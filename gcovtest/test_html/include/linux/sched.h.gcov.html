<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
  <title>LCOV - test.info - include/linux/sched.h</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">include/linux</a> - sched.h<span style="font-size: 80%;"> (source / <a href="sched.h.func.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">test.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">3</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2011-05-12</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntryHi">-</td>
          </tr>
          <tr>
            <td></td>
            <td></td>
            <td></td>
            <td class="headerItem">Branches:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntryHi">-</td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">           Branch data     Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>                :            : #ifndef _LINUX_SCHED_H</a>
<span class="lineNum">       2 </span>                :            : #define _LINUX_SCHED_H
<span class="lineNum">       3 </span>                :            : 
<span class="lineNum">       4 </span>                :            : /*
<span class="lineNum">       5 </span>                :            :  * cloning flags:
<span class="lineNum">       6 </span>                :            :  */
<span class="lineNum">       7 </span>                :            : #define CSIGNAL         0x000000ff      /* signal mask to be sent at exit */
<span class="lineNum">       8 </span>                :            : #define CLONE_VM        0x00000100      /* set if VM shared between processes */
<span class="lineNum">       9 </span>                :            : #define CLONE_FS        0x00000200      /* set if fs info shared between processes */
<span class="lineNum">      10 </span>                :            : #define CLONE_FILES     0x00000400      /* set if open files shared between processes */
<span class="lineNum">      11 </span>                :            : #define CLONE_SIGHAND   0x00000800      /* set if signal handlers and blocked signals shared */
<span class="lineNum">      12 </span>                :            : #define CLONE_PTRACE    0x00002000      /* set if we want to let tracing continue on the child too */
<span class="lineNum">      13 </span>                :            : #define CLONE_VFORK     0x00004000      /* set if the parent wants the child to wake it up on mm_release */
<span class="lineNum">      14 </span>                :            : #define CLONE_PARENT    0x00008000      /* set if we want to have the same parent as the cloner */
<span class="lineNum">      15 </span>                :            : #define CLONE_THREAD    0x00010000      /* Same thread group? */
<span class="lineNum">      16 </span>                :            : #define CLONE_NEWNS     0x00020000      /* New namespace group? */
<span class="lineNum">      17 </span>                :            : #define CLONE_SYSVSEM   0x00040000      /* share system V SEM_UNDO semantics */
<span class="lineNum">      18 </span>                :            : #define CLONE_SETTLS    0x00080000      /* create a new TLS for the child */
<span class="lineNum">      19 </span>                :            : #define CLONE_PARENT_SETTID     0x00100000      /* set the TID in the parent */
<span class="lineNum">      20 </span>                :            : #define CLONE_CHILD_CLEARTID    0x00200000      /* clear the TID in the child */
<span class="lineNum">      21 </span>                :            : #define CLONE_DETACHED          0x00400000      /* Unused, ignored */
<span class="lineNum">      22 </span>                :            : #define CLONE_UNTRACED          0x00800000      /* set if the tracing process can't force CLONE_PTRACE on this clone */
<span class="lineNum">      23 </span>                :            : #define CLONE_CHILD_SETTID      0x01000000      /* set the TID in the child */
<span class="lineNum">      24 </span>                :            : #define CLONE_STOPPED           0x02000000      /* Start in stopped state */
<span class="lineNum">      25 </span>                :            : #define CLONE_NEWUTS            0x04000000      /* New utsname group? */
<span class="lineNum">      26 </span>                :            : #define CLONE_NEWIPC            0x08000000      /* New ipcs */
<span class="lineNum">      27 </span>                :            : #define CLONE_NEWUSER           0x10000000      /* New user namespace */
<span class="lineNum">      28 </span>                :            : #define CLONE_NEWPID            0x20000000      /* New pid namespace */
<span class="lineNum">      29 </span>                :            : #define CLONE_NEWNET            0x40000000      /* New network namespace */
<span class="lineNum">      30 </span>                :            : #define CLONE_IO                0x80000000      /* Clone io context */
<span class="lineNum">      31 </span>                :            : 
<span class="lineNum">      32 </span>                :            : /*
<span class="lineNum">      33 </span>                :            :  * Scheduling policies
<span class="lineNum">      34 </span>                :            :  */
<span class="lineNum">      35 </span>                :            : #define SCHED_NORMAL            0
<span class="lineNum">      36 </span>                :            : #define SCHED_FIFO              1
<span class="lineNum">      37 </span>                :            : #define SCHED_RR                2
<span class="lineNum">      38 </span>                :            : #define SCHED_BATCH             3
<span class="lineNum">      39 </span>                :            : /* SCHED_ISO: reserved but not implemented yet */
<span class="lineNum">      40 </span>                :            : #define SCHED_IDLE              5
<span class="lineNum">      41 </span>                :            : /* Can be ORed in to make sure the process is reverted back to SCHED_NORMAL on fork */
<span class="lineNum">      42 </span>                :            : #define SCHED_RESET_ON_FORK     0x40000000
<span class="lineNum">      43 </span>                :            : 
<span class="lineNum">      44 </span>                :            : #ifdef __KERNEL__
<span class="lineNum">      45 </span>                :            : 
<span class="lineNum">      46 </span>                :            : struct sched_param {
<span class="lineNum">      47 </span>                :            :         int sched_priority;
<span class="lineNum">      48 </span>                :            : };
<span class="lineNum">      49 </span>                :            : 
<span class="lineNum">      50 </span>                :            : #include &lt;asm/param.h&gt;    /* for HZ */
<span class="lineNum">      51 </span>                :            : 
<span class="lineNum">      52 </span>                :            : #include &lt;linux/capability.h&gt;
<span class="lineNum">      53 </span>                :            : #include &lt;linux/threads.h&gt;
<span class="lineNum">      54 </span>                :            : #include &lt;linux/kernel.h&gt;
<span class="lineNum">      55 </span>                :            : #include &lt;linux/types.h&gt;
<span class="lineNum">      56 </span>                :            : #include &lt;linux/timex.h&gt;
<span class="lineNum">      57 </span>                :            : #include &lt;linux/jiffies.h&gt;
<span class="lineNum">      58 </span>                :            : #include &lt;linux/rbtree.h&gt;
<span class="lineNum">      59 </span>                :            : #include &lt;linux/thread_info.h&gt;
<span class="lineNum">      60 </span>                :            : #include &lt;linux/cpumask.h&gt;
<span class="lineNum">      61 </span>                :            : #include &lt;linux/errno.h&gt;
<span class="lineNum">      62 </span>                :            : #include &lt;linux/nodemask.h&gt;
<span class="lineNum">      63 </span>                :            : #include &lt;linux/mm_types.h&gt;
<span class="lineNum">      64 </span>                :            : 
<span class="lineNum">      65 </span>                :            : #include &lt;asm/system.h&gt;
<span class="lineNum">      66 </span>                :            : #include &lt;asm/page.h&gt;
<span class="lineNum">      67 </span>                :            : #include &lt;asm/ptrace.h&gt;
<span class="lineNum">      68 </span>                :            : #include &lt;asm/cputime.h&gt;
<span class="lineNum">      69 </span>                :            : 
<span class="lineNum">      70 </span>                :            : #include &lt;linux/smp.h&gt;
<span class="lineNum">      71 </span>                :            : #include &lt;linux/sem.h&gt;
<span class="lineNum">      72 </span>                :            : #include &lt;linux/signal.h&gt;
<span class="lineNum">      73 </span>                :            : #include &lt;linux/path.h&gt;
<span class="lineNum">      74 </span>                :            : #include &lt;linux/compiler.h&gt;
<span class="lineNum">      75 </span>                :            : #include &lt;linux/completion.h&gt;
<span class="lineNum">      76 </span>                :            : #include &lt;linux/pid.h&gt;
<span class="lineNum">      77 </span>                :            : #include &lt;linux/percpu.h&gt;
<span class="lineNum">      78 </span>                :            : #include &lt;linux/topology.h&gt;
<span class="lineNum">      79 </span>                :            : #include &lt;linux/proportions.h&gt;
<span class="lineNum">      80 </span>                :            : #include &lt;linux/seccomp.h&gt;
<span class="lineNum">      81 </span>                :            : #include &lt;linux/rcupdate.h&gt;
<span class="lineNum">      82 </span>                :            : #include &lt;linux/rculist.h&gt;
<span class="lineNum">      83 </span>                :            : #include &lt;linux/rtmutex.h&gt;
<span class="lineNum">      84 </span>                :            : 
<span class="lineNum">      85 </span>                :            : #include &lt;linux/time.h&gt;
<span class="lineNum">      86 </span>                :            : #include &lt;linux/param.h&gt;
<span class="lineNum">      87 </span>                :            : #include &lt;linux/resource.h&gt;
<span class="lineNum">      88 </span>                :            : #include &lt;linux/timer.h&gt;
<span class="lineNum">      89 </span>                :            : #include &lt;linux/hrtimer.h&gt;
<span class="lineNum">      90 </span>                :            : #include &lt;linux/task_io_accounting.h&gt;
<span class="lineNum">      91 </span>                :            : #include &lt;linux/kobject.h&gt;
<span class="lineNum">      92 </span>                :            : #include &lt;linux/latencytop.h&gt;
<span class="lineNum">      93 </span>                :            : #include &lt;linux/cred.h&gt;
<span class="lineNum">      94 </span>                :            : 
<span class="lineNum">      95 </span>                :            : #include &lt;asm/processor.h&gt;
<span class="lineNum">      96 </span>                :            : 
<span class="lineNum">      97 </span>                :            : struct exec_domain;
<span class="lineNum">      98 </span>                :            : struct futex_pi_state;
<span class="lineNum">      99 </span>                :            : struct robust_list_head;
<span class="lineNum">     100 </span>                :            : struct bio_list;
<span class="lineNum">     101 </span>                :            : struct fs_struct;
<span class="lineNum">     102 </span>                :            : struct perf_event_context;
<span class="lineNum">     103 </span>                :            : 
<span class="lineNum">     104 </span>                :            : /*
<span class="lineNum">     105 </span>                :            :  * List of flags we want to share for kernel threads,
<span class="lineNum">     106 </span>                :            :  * if only because they are not used by them anyway.
<span class="lineNum">     107 </span>                :            :  */
<span class="lineNum">     108 </span>                :            : #define CLONE_KERNEL    (CLONE_FS | CLONE_FILES | CLONE_SIGHAND)
<span class="lineNum">     109 </span>                :            : 
<span class="lineNum">     110 </span>                :            : /*
<span class="lineNum">     111 </span>                :            :  * These are the constant used to fake the fixed-point load-average
<span class="lineNum">     112 </span>                :            :  * counting. Some notes:
<span class="lineNum">     113 </span>                :            :  *  - 11 bit fractions expand to 22 bits by the multiplies: this gives
<span class="lineNum">     114 </span>                :            :  *    a load-average precision of 10 bits integer + 11 bits fractional
<span class="lineNum">     115 </span>                :            :  *  - if you want to count load-averages more often, you need more
<span class="lineNum">     116 </span>                :            :  *    precision, or rounding will get you. With 2-second counting freq,
<span class="lineNum">     117 </span>                :            :  *    the EXP_n values would be 1981, 2034 and 2043 if still using only
<span class="lineNum">     118 </span>                :            :  *    11 bit fractions.
<span class="lineNum">     119 </span>                :            :  */
<span class="lineNum">     120 </span>                :            : extern unsigned long avenrun[];         /* Load averages */
<span class="lineNum">     121 </span>                :            : extern void get_avenrun(unsigned long *loads, unsigned long offset, int shift);
<span class="lineNum">     122 </span>                :            : 
<span class="lineNum">     123 </span>                :            : #define FSHIFT          11              /* nr of bits of precision */
<span class="lineNum">     124 </span>                :            : #define FIXED_1         (1&lt;&lt;FSHIFT)       /* 1.0 as fixed-point */
<span class="lineNum">     125 </span>                :            : #define LOAD_FREQ       (5*HZ+1)        /* 5 sec intervals */
<span class="lineNum">     126 </span>                :            : #define EXP_1           1884            /* 1/exp(5sec/1min) as fixed-point */
<span class="lineNum">     127 </span>                :            : #define EXP_5           2014            /* 1/exp(5sec/5min) */
<span class="lineNum">     128 </span>                :            : #define EXP_15          2037            /* 1/exp(5sec/15min) */
<span class="lineNum">     129 </span>                :            : 
<span class="lineNum">     130 </span>                :            : #define CALC_LOAD(load,exp,n) \
<span class="lineNum">     131 </span>                :            :         load *= exp; \
<span class="lineNum">     132 </span>                :            :         load += n*(FIXED_1-exp); \
<span class="lineNum">     133 </span>                :            :         load &gt;&gt;= FSHIFT;
<span class="lineNum">     134 </span>                :            : 
<span class="lineNum">     135 </span>                :            : extern unsigned long total_forks;
<span class="lineNum">     136 </span>                :            : extern int nr_threads;
<span class="lineNum">     137 </span>                :            : DECLARE_PER_CPU(unsigned long, process_counts);
<span class="lineNum">     138 </span>                :            : extern int nr_processes(void);
<span class="lineNum">     139 </span>                :            : extern unsigned long nr_running(void);
<span class="lineNum">     140 </span>                :            : extern unsigned long nr_uninterruptible(void);
<span class="lineNum">     141 </span>                :            : extern unsigned long nr_iowait(void);
<span class="lineNum">     142 </span>                :            : extern unsigned long nr_iowait_cpu(int cpu);
<span class="lineNum">     143 </span>                :            : extern unsigned long this_cpu_load(void);
<span class="lineNum">     144 </span>                :            : 
<span class="lineNum">     145 </span>                :            : 
<span class="lineNum">     146 </span>                :            : extern void calc_global_load(void);
<span class="lineNum">     147 </span>                :            : 
<span class="lineNum">     148 </span>                :            : extern unsigned long get_parent_ip(unsigned long addr);
<span class="lineNum">     149 </span>                :            : 
<span class="lineNum">     150 </span>                :            : struct seq_file;
<span class="lineNum">     151 </span>                :            : struct cfs_rq;
<span class="lineNum">     152 </span>                :            : struct task_group;
<span class="lineNum">     153 </span>                :            : #ifdef CONFIG_SCHED_DEBUG
<span class="lineNum">     154 </span>                :            : extern void proc_sched_show_task(struct task_struct *p, struct seq_file *m);
<span class="lineNum">     155 </span>                :            : extern void proc_sched_set_task(struct task_struct *p);
<span class="lineNum">     156 </span>                :            : extern void
<span class="lineNum">     157 </span>                :            : print_cfs_rq(struct seq_file *m, int cpu, struct cfs_rq *cfs_rq);
<span class="lineNum">     158 </span>                :            : #else
<span class="lineNum">     159 </span>                :            : static inline void
<span class="lineNum">     160 </span>                :            : proc_sched_show_task(struct task_struct *p, struct seq_file *m)
<span class="lineNum">     161 </span>                :            : {
<span class="lineNum">     162 </span>                :            : }
<span class="lineNum">     163 </span>                :            : static inline void proc_sched_set_task(struct task_struct *p)
<span class="lineNum">     164 </span>                :            : {
<span class="lineNum">     165 </span>                :            : }
<span class="lineNum">     166 </span>                :            : static inline void
<span class="lineNum">     167 </span>                :            : print_cfs_rq(struct seq_file *m, int cpu, struct cfs_rq *cfs_rq)
<span class="lineNum">     168 </span>                :            : {
<span class="lineNum">     169 </span>                :            : }
<span class="lineNum">     170 </span>                :            : #endif
<span class="lineNum">     171 </span>                :            : 
<span class="lineNum">     172 </span>                :            : /*
<span class="lineNum">     173 </span>                :            :  * Task state bitmask. NOTE! These bits are also
<span class="lineNum">     174 </span>                :            :  * encoded in fs/proc/array.c: get_task_state().
<span class="lineNum">     175 </span>                :            :  *
<span class="lineNum">     176 </span>                :            :  * We have two separate sets of flags: task-&gt;state
<span class="lineNum">     177 </span>                :            :  * is about runnability, while task-&gt;exit_state are
<span class="lineNum">     178 </span>                :            :  * about the task exiting. Confusing, but this way
<span class="lineNum">     179 </span>                :            :  * modifying one set can't modify the other one by
<span class="lineNum">     180 </span>                :            :  * mistake.
<span class="lineNum">     181 </span>                :            :  */
<span class="lineNum">     182 </span>                :            : #define TASK_RUNNING            0
<span class="lineNum">     183 </span>                :            : #define TASK_INTERRUPTIBLE      1
<span class="lineNum">     184 </span>                :            : #define TASK_UNINTERRUPTIBLE    2
<span class="lineNum">     185 </span>                :            : #define __TASK_STOPPED          4
<span class="lineNum">     186 </span>                :            : #define __TASK_TRACED           8
<span class="lineNum">     187 </span>                :            : /* in tsk-&gt;exit_state */
<span class="lineNum">     188 </span>                :            : #define EXIT_ZOMBIE             16
<span class="lineNum">     189 </span>                :            : #define EXIT_DEAD               32
<span class="lineNum">     190 </span>                :            : /* in tsk-&gt;state again */
<span class="lineNum">     191 </span>                :            : #define TASK_DEAD               64
<span class="lineNum">     192 </span>                :            : #define TASK_WAKEKILL           128
<span class="lineNum">     193 </span>                :            : #define TASK_WAKING             256
<span class="lineNum">     194 </span>                :            : #define TASK_STATE_MAX          512
<span class="lineNum">     195 </span>                :            : 
<span class="lineNum">     196 </span>                :            : #define TASK_STATE_TO_CHAR_STR &quot;RSDTtZXxKW&quot;
<span class="lineNum">     197 </span>                :            : 
<span class="lineNum">     198 </span>                :            : extern char ___assert_task_state[1 - 2*!!(
<span class="lineNum">     199 </span>                :            :                 sizeof(TASK_STATE_TO_CHAR_STR)-1 != ilog2(TASK_STATE_MAX)+1)];
<span class="lineNum">     200 </span>                :            : 
<span class="lineNum">     201 </span>                :            : /* Convenience macros for the sake of set_task_state */
<span class="lineNum">     202 </span>                :            : #define TASK_KILLABLE           (TASK_WAKEKILL | TASK_UNINTERRUPTIBLE)
<span class="lineNum">     203 </span>                :            : #define TASK_STOPPED            (TASK_WAKEKILL | __TASK_STOPPED)
<span class="lineNum">     204 </span>                :            : #define TASK_TRACED             (TASK_WAKEKILL | __TASK_TRACED)
<span class="lineNum">     205 </span>                :            : 
<span class="lineNum">     206 </span>                :            : /* Convenience macros for the sake of wake_up */
<span class="lineNum">     207 </span>                :            : #define TASK_NORMAL             (TASK_INTERRUPTIBLE | TASK_UNINTERRUPTIBLE)
<span class="lineNum">     208 </span>                :            : #define TASK_ALL                (TASK_NORMAL | __TASK_STOPPED | __TASK_TRACED)
<span class="lineNum">     209 </span>                :            : 
<span class="lineNum">     210 </span>                :            : /* get_task_state() */
<span class="lineNum">     211 </span>                :            : #define TASK_REPORT             (TASK_RUNNING | TASK_INTERRUPTIBLE | \
<span class="lineNum">     212 </span>                :            :                                  TASK_UNINTERRUPTIBLE | __TASK_STOPPED | \
<span class="lineNum">     213 </span>                :            :                                  __TASK_TRACED)
<span class="lineNum">     214 </span>                :            : 
<span class="lineNum">     215 </span>                :            : #define task_is_traced(task)    ((task-&gt;state &amp; __TASK_TRACED) != 0)
<span class="lineNum">     216 </span>                :            : #define task_is_stopped(task)   ((task-&gt;state &amp; __TASK_STOPPED) != 0)
<span class="lineNum">     217 </span>                :            : #define task_is_dead(task)      ((task)-&gt;exit_state != 0)
<span class="lineNum">     218 </span>                :            : #define task_is_stopped_or_traced(task) \
<span class="lineNum">     219 </span>                :            :                         ((task-&gt;state &amp; (__TASK_STOPPED | __TASK_TRACED)) != 0)
<span class="lineNum">     220 </span>                :            : #define task_contributes_to_load(task)  \
<span class="lineNum">     221 </span>                :            :                                 ((task-&gt;state &amp; TASK_UNINTERRUPTIBLE) != 0 &amp;&amp; \
<span class="lineNum">     222 </span>                :            :                                  (task-&gt;flags &amp; PF_FREEZING) == 0)
<span class="lineNum">     223 </span>                :            : 
<span class="lineNum">     224 </span>                :            : #define __set_task_state(tsk, state_value)              \
<span class="lineNum">     225 </span>                :            :         do { (tsk)-&gt;state = (state_value); } while (0)
<span class="lineNum">     226 </span>                :            : #define set_task_state(tsk, state_value)                \
<span class="lineNum">     227 </span>                :            :         set_mb((tsk)-&gt;state, (state_value))
<span class="lineNum">     228 </span>                :            : 
<span class="lineNum">     229 </span>                :            : /*
<span class="lineNum">     230 </span>                :            :  * set_current_state() includes a barrier so that the write of current-&gt;state
<span class="lineNum">     231 </span>                :            :  * is correctly serialised wrt the caller's subsequent test of whether to
<span class="lineNum">     232 </span>                :            :  * actually sleep:
<span class="lineNum">     233 </span>                :            :  *
<span class="lineNum">     234 </span>                :            :  *      set_current_state(TASK_UNINTERRUPTIBLE);
<span class="lineNum">     235 </span>                :            :  *      if (do_i_need_to_sleep())
<span class="lineNum">     236 </span>                :            :  *              schedule();
<span class="lineNum">     237 </span>                :            :  *
<span class="lineNum">     238 </span>                :            :  * If the caller does not need such serialisation then use __set_current_state()
<span class="lineNum">     239 </span>                :            :  */
<span class="lineNum">     240 </span>                :            : #define __set_current_state(state_value)                        \
<span class="lineNum">     241 </span>                :            :         do { current-&gt;state = (state_value); } while (0)
<span class="lineNum">     242 </span>                :            : #define set_current_state(state_value)          \
<span class="lineNum">     243 </span>                :            :         set_mb(current-&gt;state, (state_value))
<span class="lineNum">     244 </span>                :            : 
<span class="lineNum">     245 </span>                :            : /* Task command name length */
<span class="lineNum">     246 </span>                :            : #define TASK_COMM_LEN 16
<span class="lineNum">     247 </span>                :            : 
<span class="lineNum">     248 </span>                :            : #include &lt;linux/spinlock.h&gt;
<span class="lineNum">     249 </span>                :            : 
<span class="lineNum">     250 </span>                :            : /*
<span class="lineNum">     251 </span>                :            :  * This serializes &quot;schedule()&quot; and also protects
<span class="lineNum">     252 </span>                :            :  * the run-queue from deletions/modifications (but
<span class="lineNum">     253 </span>                :            :  * _adding_ to the beginning of the run-queue has
<span class="lineNum">     254 </span>                :            :  * a separate lock).
<span class="lineNum">     255 </span>                :            :  */
<span class="lineNum">     256 </span>                :            : extern rwlock_t tasklist_lock;
<span class="lineNum">     257 </span>                :            : extern spinlock_t mmlist_lock;
<span class="lineNum">     258 </span>                :            : 
<span class="lineNum">     259 </span>                :            : struct task_struct;
<span class="lineNum">     260 </span>                :            : 
<span class="lineNum">     261 </span>                :            : #ifdef CONFIG_PROVE_RCU
<span class="lineNum">     262 </span>                :            : extern int lockdep_tasklist_lock_is_held(void);
<span class="lineNum">     263 </span>                :            : #endif /* #ifdef CONFIG_PROVE_RCU */
<span class="lineNum">     264 </span>                :            : 
<span class="lineNum">     265 </span>                :            : extern void sched_init(void);
<span class="lineNum">     266 </span>                :            : extern void sched_init_smp(void);
<span class="lineNum">     267 </span>                :            : extern asmlinkage void schedule_tail(struct task_struct *prev);
<span class="lineNum">     268 </span>                :            : extern void init_idle(struct task_struct *idle, int cpu);
<span class="lineNum">     269 </span>                :            : extern void init_idle_bootup_task(struct task_struct *idle);
<span class="lineNum">     270 </span>                :            : 
<span class="lineNum">     271 </span>                :            : extern int runqueue_is_locked(int cpu);
<span class="lineNum">     272 </span>                :            : 
<span class="lineNum">     273 </span>                :            : extern cpumask_var_t nohz_cpu_mask;
<span class="lineNum">     274 </span>                :            : #if defined(CONFIG_SMP) &amp;&amp; defined(CONFIG_NO_HZ)
<span class="lineNum">     275 </span>                :            : extern int select_nohz_load_balancer(int cpu);
<span class="lineNum">     276 </span>                :            : extern int get_nohz_load_balancer(void);
<span class="lineNum">     277 </span>                :            : #else
<span class="lineNum">     278 </span>                :            : static inline int select_nohz_load_balancer(int cpu)
<span class="lineNum">     279 </span>                :            : {
<span class="lineNum">     280 </span>                :            :         return 0;
<span class="lineNum">     281 </span>                :            : }
<span class="lineNum">     282 </span>                :            : #endif
<span class="lineNum">     283 </span>                :            : 
<span class="lineNum">     284 </span>                :            : /*
<span class="lineNum">     285 </span>                :            :  * Only dump TASK_* tasks. (0 for all tasks)
<span class="lineNum">     286 </span>                :            :  */
<span class="lineNum">     287 </span>                :            : extern void show_state_filter(unsigned long state_filter);
<span class="lineNum">     288 </span>                :            : 
<span class="lineNum">     289 </span>                :            : static inline void show_state(void)
<span class="lineNum">     290 </span>                :            : {
<span class="lineNum">     291 </span>                :            :         show_state_filter(0);
<span class="lineNum">     292 </span>                :            : }
<span class="lineNum">     293 </span>                :            : 
<span class="lineNum">     294 </span>                :            : extern void show_regs(struct pt_regs *);
<span class="lineNum">     295 </span>                :            : 
<span class="lineNum">     296 </span>                :            : /*
<span class="lineNum">     297 </span>                :            :  * TASK is a pointer to the task whose backtrace we want to see (or NULL for current
<span class="lineNum">     298 </span>                :            :  * task), SP is the stack pointer of the first frame that should be shown in the back
<span class="lineNum">     299 </span>                :            :  * trace (or NULL if the entire call-chain of the task should be shown).
<span class="lineNum">     300 </span>                :            :  */
<span class="lineNum">     301 </span>                :            : extern void show_stack(struct task_struct *task, unsigned long *sp);
<span class="lineNum">     302 </span>                :            : 
<span class="lineNum">     303 </span>                :            : void io_schedule(void);
<span class="lineNum">     304 </span>                :            : long io_schedule_timeout(long timeout);
<span class="lineNum">     305 </span>                :            : 
<span class="lineNum">     306 </span>                :            : extern void cpu_init (void);
<span class="lineNum">     307 </span>                :            : extern void trap_init(void);
<span class="lineNum">     308 </span>                :            : extern void update_process_times(int user);
<span class="lineNum">     309 </span>                :            : extern void scheduler_tick(void);
<span class="lineNum">     310 </span>                :            : 
<span class="lineNum">     311 </span>                :            : extern void sched_show_task(struct task_struct *p);
<span class="lineNum">     312 </span>                :            : 
<span class="lineNum">     313 </span>                :            : #ifdef CONFIG_DETECT_SOFTLOCKUP
<span class="lineNum">     314 </span>                :            : extern void softlockup_tick(void);
<span class="lineNum">     315 </span>                :            : extern void touch_softlockup_watchdog(void);
<span class="lineNum">     316 </span>                :            : extern void touch_softlockup_watchdog_sync(void);
<span class="lineNum">     317 </span>                :            : extern void touch_all_softlockup_watchdogs(void);
<span class="lineNum">     318 </span>                :            : extern int proc_dosoftlockup_thresh(struct ctl_table *table, int write,
<span class="lineNum">     319 </span>                :            :                                     void __user *buffer,
<span class="lineNum">     320 </span>                :            :                                     size_t *lenp, loff_t *ppos);
<span class="lineNum">     321 </span>                :            : extern unsigned int  softlockup_panic;
<span class="lineNum">     322 </span>                :            : extern int softlockup_thresh;
<span class="lineNum">     323 </span>                :            : #else
<span class="lineNum">     324 </span>                :            : static inline void softlockup_tick(void)
<span class="lineNum">     325 </span>                :            : {
<span class="lineNum">     326 </span>                :            : }
<span class="lineNum">     327 </span>                :            : static inline void touch_softlockup_watchdog(void)
<span class="lineNum">     328 </span>                :            : {
<span class="lineNum">     329 </span>                :            : }
<span class="lineNum">     330 </span>                :            : static inline void touch_softlockup_watchdog_sync(void)
<span class="lineNum">     331 </span>                :            : {
<span class="lineNum">     332 </span>                :            : }
<span class="lineNum">     333 </span>                :            : static inline void touch_all_softlockup_watchdogs(void)
<span class="lineNum">     334 </span>                :            : {
<span class="lineNum">     335 </span>                :            : }
<span class="lineNum">     336 </span>                :            : #endif
<span class="lineNum">     337 </span>                :            : 
<span class="lineNum">     338 </span>                :            : #ifdef CONFIG_DETECT_HUNG_TASK
<span class="lineNum">     339 </span>                :            : extern unsigned int  sysctl_hung_task_panic;
<span class="lineNum">     340 </span>                :            : extern unsigned long sysctl_hung_task_check_count;
<span class="lineNum">     341 </span>                :            : extern unsigned long sysctl_hung_task_timeout_secs;
<span class="lineNum">     342 </span>                :            : extern unsigned long sysctl_hung_task_warnings;
<span class="lineNum">     343 </span>                :            : extern int proc_dohung_task_timeout_secs(struct ctl_table *table, int write,
<span class="lineNum">     344 </span>                :            :                                          void __user *buffer,
<span class="lineNum">     345 </span>                :            :                                          size_t *lenp, loff_t *ppos);
<span class="lineNum">     346 </span>                :            : #endif
<span class="lineNum">     347 </span>                :            : 
<span class="lineNum">     348 </span>                :            : /* Attach to any functions which should be ignored in wchan output. */
<span class="lineNum">     349 </span>                :            : #define __sched         __attribute__((__section__(&quot;.sched.text&quot;)))
<span class="lineNum">     350 </span>                :            : 
<span class="lineNum">     351 </span>                :            : /* Linker adds these: start and end of __sched functions */
<span class="lineNum">     352 </span>                :            : extern char __sched_text_start[], __sched_text_end[];
<span class="lineNum">     353 </span>                :            : 
<span class="lineNum">     354 </span>                :            : /* Is this address in the __sched functions? */
<span class="lineNum">     355 </span>                :            : extern int in_sched_functions(unsigned long addr);
<span class="lineNum">     356 </span>                :            : 
<span class="lineNum">     357 </span>                :            : #define MAX_SCHEDULE_TIMEOUT    LONG_MAX
<span class="lineNum">     358 </span>                :            : extern signed long schedule_timeout(signed long timeout);
<span class="lineNum">     359 </span>                :            : extern signed long schedule_timeout_interruptible(signed long timeout);
<span class="lineNum">     360 </span>                :            : extern signed long schedule_timeout_killable(signed long timeout);
<span class="lineNum">     361 </span>                :            : extern signed long schedule_timeout_uninterruptible(signed long timeout);
<span class="lineNum">     362 </span>                :            : asmlinkage void schedule(void);
<span class="lineNum">     363 </span>                :            : extern int mutex_spin_on_owner(struct mutex *lock, struct thread_info *owner);
<span class="lineNum">     364 </span>                :            : 
<span class="lineNum">     365 </span>                :            : struct nsproxy;
<span class="lineNum">     366 </span>                :            : struct user_namespace;
<span class="lineNum">     367 </span>                :            : 
<span class="lineNum">     368 </span>                :            : /*
<span class="lineNum">     369 </span>                :            :  * Default maximum number of active map areas, this limits the number of vmas
<span class="lineNum">     370 </span>                :            :  * per mm struct. Users can overwrite this number by sysctl but there is a
<span class="lineNum">     371 </span>                :            :  * problem.
<span class="lineNum">     372 </span>                :            :  *
<span class="lineNum">     373 </span>                :            :  * When a program's coredump is generated as ELF format, a section is created
<span class="lineNum">     374 </span>                :            :  * per a vma. In ELF, the number of sections is represented in unsigned short.
<span class="lineNum">     375 </span>                :            :  * This means the number of sections should be smaller than 65535 at coredump.
<span class="lineNum">     376 </span>                :            :  * Because the kernel adds some informative sections to a image of program at
<span class="lineNum">     377 </span>                :            :  * generating coredump, we need some margin. The number of extra sections is
<span class="lineNum">     378 </span>                :            :  * 1-3 now and depends on arch. We use &quot;5&quot; as safe margin, here.
<span class="lineNum">     379 </span>                :            :  */
<span class="lineNum">     380 </span>                :            : #define MAPCOUNT_ELF_CORE_MARGIN        (5)
<span class="lineNum">     381 </span>                :            : #define DEFAULT_MAX_MAP_COUNT   (USHRT_MAX - MAPCOUNT_ELF_CORE_MARGIN)
<span class="lineNum">     382 </span>                :            : 
<span class="lineNum">     383 </span>                :            : extern int sysctl_max_map_count;
<span class="lineNum">     384 </span>                :            : 
<span class="lineNum">     385 </span>                :            : #include &lt;linux/aio.h&gt;
<span class="lineNum">     386 </span>                :            : 
<span class="lineNum">     387 </span>                :            : #ifdef CONFIG_MMU
<span class="lineNum">     388 </span>                :            : extern void arch_pick_mmap_layout(struct mm_struct *mm);
<span class="lineNum">     389 </span>                :            : extern unsigned long
<span class="lineNum">     390 </span>                :            : arch_get_unmapped_area(struct file *, unsigned long, unsigned long,
<span class="lineNum">     391 </span>                :            :                        unsigned long, unsigned long);
<span class="lineNum">     392 </span>                :            : extern unsigned long
<span class="lineNum">     393 </span>                :            : arch_get_unmapped_area_topdown(struct file *filp, unsigned long addr,
<span class="lineNum">     394 </span>                :            :                           unsigned long len, unsigned long pgoff,
<span class="lineNum">     395 </span>                :            :                           unsigned long flags);
<span class="lineNum">     396 </span>                :            : extern void arch_unmap_area(struct mm_struct *, unsigned long);
<span class="lineNum">     397 </span>                :            : extern void arch_unmap_area_topdown(struct mm_struct *, unsigned long);
<span class="lineNum">     398 </span>                :            : #else
<span class="lineNum">     399 </span>                :            : static inline void arch_pick_mmap_layout(struct mm_struct *mm) {}
<span class="lineNum">     400 </span>                :            : #endif
<span class="lineNum">     401 </span>                :            : 
<span class="lineNum">     402 </span>                :            : 
<span class="lineNum">     403 </span>                :            : extern void set_dumpable(struct mm_struct *mm, int value);
<span class="lineNum">     404 </span>                :            : extern int get_dumpable(struct mm_struct *mm);
<span class="lineNum">     405 </span>                :            : 
<span class="lineNum">     406 </span>                :            : /* mm flags */
<span class="lineNum">     407 </span>                :            : /* dumpable bits */
<span class="lineNum">     408 </span>                :            : #define MMF_DUMPABLE      0  /* core dump is permitted */
<span class="lineNum">     409 </span>                :            : #define MMF_DUMP_SECURELY 1  /* core file is readable only by root */
<span class="lineNum">     410 </span>                :            : 
<span class="lineNum">     411 </span>                :            : #define MMF_DUMPABLE_BITS 2
<span class="lineNum">     412 </span>                :            : #define MMF_DUMPABLE_MASK ((1 &lt;&lt; MMF_DUMPABLE_BITS) - 1)
<span class="lineNum">     413 </span>                :            : 
<span class="lineNum">     414 </span>                :            : /* coredump filter bits */
<span class="lineNum">     415 </span>                :            : #define MMF_DUMP_ANON_PRIVATE   2
<span class="lineNum">     416 </span>                :            : #define MMF_DUMP_ANON_SHARED    3
<span class="lineNum">     417 </span>                :            : #define MMF_DUMP_MAPPED_PRIVATE 4
<span class="lineNum">     418 </span>                :            : #define MMF_DUMP_MAPPED_SHARED  5
<span class="lineNum">     419 </span>                :            : #define MMF_DUMP_ELF_HEADERS    6
<span class="lineNum">     420 </span>                :            : #define MMF_DUMP_HUGETLB_PRIVATE 7
<span class="lineNum">     421 </span>                :            : #define MMF_DUMP_HUGETLB_SHARED  8
<span class="lineNum">     422 </span>                :            : 
<span class="lineNum">     423 </span>                :            : #define MMF_DUMP_FILTER_SHIFT   MMF_DUMPABLE_BITS
<span class="lineNum">     424 </span>                :            : #define MMF_DUMP_FILTER_BITS    7
<span class="lineNum">     425 </span>                :            : #define MMF_DUMP_FILTER_MASK \
<span class="lineNum">     426 </span>                :            :         (((1 &lt;&lt; MMF_DUMP_FILTER_BITS) - 1) &lt;&lt; MMF_DUMP_FILTER_SHIFT)
<span class="lineNum">     427 </span>                :            : #define MMF_DUMP_FILTER_DEFAULT \
<span class="lineNum">     428 </span>                :            :         ((1 &lt;&lt; MMF_DUMP_ANON_PRIVATE) |   (1 &lt;&lt; MMF_DUMP_ANON_SHARED) |\
<span class="lineNum">     429 </span>                :            :          (1 &lt;&lt; MMF_DUMP_HUGETLB_PRIVATE) | MMF_DUMP_MASK_DEFAULT_ELF)
<span class="lineNum">     430 </span>                :            : 
<span class="lineNum">     431 </span>                :            : #ifdef CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS
<span class="lineNum">     432 </span>                :            : # define MMF_DUMP_MASK_DEFAULT_ELF      (1 &lt;&lt; MMF_DUMP_ELF_HEADERS)
<span class="lineNum">     433 </span>                :            : #else
<span class="lineNum">     434 </span>                :            : # define MMF_DUMP_MASK_DEFAULT_ELF      0
<span class="lineNum">     435 </span>                :            : #endif
<span class="lineNum">     436 </span>                :            :                                         /* leave room for more dump flags */
<span class="lineNum">     437 </span>                :            : #define MMF_VM_MERGEABLE        16      /* KSM may merge identical pages */
<span class="lineNum">     438 </span>                :            : 
<span class="lineNum">     439 </span>                :            : #define MMF_INIT_MASK           (MMF_DUMPABLE_MASK | MMF_DUMP_FILTER_MASK)
<span class="lineNum">     440 </span>                :            : 
<span class="lineNum">     441 </span>                :            : struct sighand_struct {
<span class="lineNum">     442 </span>                :            :         atomic_t                count;
<span class="lineNum">     443 </span>                :            :         struct k_sigaction      action[_NSIG];
<span class="lineNum">     444 </span>                :            :         spinlock_t              siglock;
<span class="lineNum">     445 </span>                :            :         wait_queue_head_t       signalfd_wqh;
<span class="lineNum">     446 </span>                :            : };
<span class="lineNum">     447 </span>                :            : 
<span class="lineNum">     448 </span>                :            : struct pacct_struct {
<span class="lineNum">     449 </span>                :            :         int                     ac_flag;
<span class="lineNum">     450 </span>                :            :         long                    ac_exitcode;
<span class="lineNum">     451 </span>                :            :         unsigned long           ac_mem;
<span class="lineNum">     452 </span>                :            :         cputime_t               ac_utime, ac_stime;
<span class="lineNum">     453 </span>                :            :         unsigned long           ac_minflt, ac_majflt;
<span class="lineNum">     454 </span>                :            : };
<span class="lineNum">     455 </span>                :            : 
<span class="lineNum">     456 </span>                :            : struct cpu_itimer {
<span class="lineNum">     457 </span>                :            :         cputime_t expires;
<span class="lineNum">     458 </span>                :            :         cputime_t incr;
<span class="lineNum">     459 </span>                :            :         u32 error;
<span class="lineNum">     460 </span>                :            :         u32 incr_error;
<span class="lineNum">     461 </span>                :            : };
<span class="lineNum">     462 </span>                :            : 
<span class="lineNum">     463 </span>                :            : /**
<span class="lineNum">     464 </span>                :            :  * struct task_cputime - collected CPU time counts
<span class="lineNum">     465 </span>                :            :  * @utime:              time spent in user mode, in &amp;cputime_t units
<span class="lineNum">     466 </span>                :            :  * @stime:              time spent in kernel mode, in &amp;cputime_t units
<span class="lineNum">     467 </span>                :            :  * @sum_exec_runtime:   total time spent on the CPU, in nanoseconds
<span class="lineNum">     468 </span>                :            :  *
<span class="lineNum">     469 </span>                :            :  * This structure groups together three kinds of CPU time that are
<span class="lineNum">     470 </span>                :            :  * tracked for threads and thread groups.  Most things considering
<span class="lineNum">     471 </span>                :            :  * CPU time want to group these counts together and treat all three
<span class="lineNum">     472 </span>                :            :  * of them in parallel.
<span class="lineNum">     473 </span>                :            :  */
<span class="lineNum">     474 </span>                :            : struct task_cputime {
<span class="lineNum">     475 </span>                :            :         cputime_t utime;
<span class="lineNum">     476 </span>                :            :         cputime_t stime;
<span class="lineNum">     477 </span>                :            :         unsigned long long sum_exec_runtime;
<span class="lineNum">     478 </span>                :            : };
<span class="lineNum">     479 </span>                :            : /* Alternate field names when used to cache expirations. */
<span class="lineNum">     480 </span>                :            : #define prof_exp        stime
<span class="lineNum">     481 </span>                :            : #define virt_exp        utime
<span class="lineNum">     482 </span>                :            : #define sched_exp       sum_exec_runtime
<span class="lineNum">     483 </span>                :            : 
<span class="lineNum">     484 </span>                :            : #define INIT_CPUTIME    \
<span class="lineNum">     485 </span>                :            :         (struct task_cputime) {                                 \
<span class="lineNum">     486 </span>                :            :                 .utime = cputime_zero,                          \
<span class="lineNum">     487 </span>                :            :                 .stime = cputime_zero,                          \
<span class="lineNum">     488 </span>                :            :                 .sum_exec_runtime = 0,                          \
<span class="lineNum">     489 </span>                :            :         }
<span class="lineNum">     490 </span>                :            : 
<span class="lineNum">     491 </span>                :            : /*
<span class="lineNum">     492 </span>                :            :  * Disable preemption until the scheduler is running.
<span class="lineNum">     493 </span>                :            :  * Reset by start_kernel()-&gt;sched_init()-&gt;init_idle().
<span class="lineNum">     494 </span>                :            :  *
<span class="lineNum">     495 </span>                :            :  * We include PREEMPT_ACTIVE to avoid cond_resched() from working
<span class="lineNum">     496 </span>                :            :  * before the scheduler is active -- see should_resched().
<span class="lineNum">     497 </span>                :            :  */
<span class="lineNum">     498 </span>                :            : #define INIT_PREEMPT_COUNT      (1 + PREEMPT_ACTIVE)
<span class="lineNum">     499 </span>                :            : 
<span class="lineNum">     500 </span>                :            : /**
<span class="lineNum">     501 </span>                :            :  * struct thread_group_cputimer - thread group interval timer counts
<span class="lineNum">     502 </span>                :            :  * @cputime:            thread group interval timers.
<span class="lineNum">     503 </span>                :            :  * @running:            non-zero when there are timers running and
<span class="lineNum">     504 </span>                :            :  *                      @cputime receives updates.
<span class="lineNum">     505 </span>                :            :  * @lock:               lock for fields in this struct.
<span class="lineNum">     506 </span>                :            :  *
<span class="lineNum">     507 </span>                :            :  * This structure contains the version of task_cputime, above, that is
<span class="lineNum">     508 </span>                :            :  * used for thread group CPU timer calculations.
<span class="lineNum">     509 </span>                :            :  */
<span class="lineNum">     510 </span>                :            : struct thread_group_cputimer {
<span class="lineNum">     511 </span>                :            :         struct task_cputime cputime;
<span class="lineNum">     512 </span>                :            :         int running;
<span class="lineNum">     513 </span>                :            :         spinlock_t lock;
<span class="lineNum">     514 </span>                :            : };
<span class="lineNum">     515 </span>                :            : 
<span class="lineNum">     516 </span>                :            : /*
<span class="lineNum">     517 </span>                :            :  * NOTE! &quot;signal_struct&quot; does not have it's own
<span class="lineNum">     518 </span>                :            :  * locking, because a shared signal_struct always
<span class="lineNum">     519 </span>                :            :  * implies a shared sighand_struct, so locking
<span class="lineNum">     520 </span>                :            :  * sighand_struct is always a proper superset of
<span class="lineNum">     521 </span>                :            :  * the locking of signal_struct.
<span class="lineNum">     522 </span>                :            :  */
<span class="lineNum">     523 </span>                :            : struct signal_struct {
<span class="lineNum">     524 </span>                :            :         atomic_t                sigcnt;
<span class="lineNum">     525 </span>                :            :         atomic_t                live;
<span class="lineNum">     526 </span>                :            :         int                     nr_threads;
<span class="lineNum">     527 </span>                :            : 
<span class="lineNum">     528 </span>                :            :         wait_queue_head_t       wait_chldexit;  /* for wait4() */
<span class="lineNum">     529 </span>                :            : 
<span class="lineNum">     530 </span>                :            :         /* current thread group signal load-balancing target: */
<span class="lineNum">     531 </span>                :            :         struct task_struct      *curr_target;
<span class="lineNum">     532 </span>                :            : 
<span class="lineNum">     533 </span>                :            :         /* shared signal handling: */
<span class="lineNum">     534 </span>                :            :         struct sigpending       shared_pending;
<span class="lineNum">     535 </span>                :            : 
<span class="lineNum">     536 </span>                :            :         /* thread group exit support */
<span class="lineNum">     537 </span>                :            :         int                     group_exit_code;
<span class="lineNum">     538 </span>                :            :         /* overloaded:
<span class="lineNum">     539 </span>                :            :          * - notify group_exit_task when -&gt;count is equal to notify_count
<span class="lineNum">     540 </span>                :            :          * - everyone except group_exit_task is stopped during signal delivery
<span class="lineNum">     541 </span>                :            :          *   of fatal signals, group_exit_task processes the signal.
<span class="lineNum">     542 </span>                :            :          */
<span class="lineNum">     543 </span>                :            :         int                     notify_count;
<span class="lineNum">     544 </span>                :            :         struct task_struct      *group_exit_task;
<span class="lineNum">     545 </span>                :            : 
<span class="lineNum">     546 </span>                :            :         /* thread group stop support, overloads group_exit_code too */
<span class="lineNum">     547 </span>                :            :         int                     group_stop_count;
<span class="lineNum">     548 </span>                :            :         unsigned int            flags; /* see SIGNAL_* flags below */
<span class="lineNum">     549 </span>                :            : 
<span class="lineNum">     550 </span>                :            :         /* POSIX.1b Interval Timers */
<span class="lineNum">     551 </span>                :            :         struct list_head posix_timers;
<span class="lineNum">     552 </span>                :            : 
<span class="lineNum">     553 </span>                :            :         /* ITIMER_REAL timer for the process */
<span class="lineNum">     554 </span>                :            :         struct hrtimer real_timer;
<span class="lineNum">     555 </span>                :            :         struct pid *leader_pid;
<span class="lineNum">     556 </span>                :            :         ktime_t it_real_incr;
<span class="lineNum">     557 </span>                :            : 
<span class="lineNum">     558 </span>                :            :         /*
<span class="lineNum">     559 </span>                :            :          * ITIMER_PROF and ITIMER_VIRTUAL timers for the process, we use
<span class="lineNum">     560 </span>                :            :          * CPUCLOCK_PROF and CPUCLOCK_VIRT for indexing array as these
<span class="lineNum">     561 </span>                :            :          * values are defined to 0 and 1 respectively
<span class="lineNum">     562 </span>                :            :          */
<span class="lineNum">     563 </span>                :            :         struct cpu_itimer it[2];
<span class="lineNum">     564 </span>                :            : 
<span class="lineNum">     565 </span>                :            :         /*
<span class="lineNum">     566 </span>                :            :          * Thread group totals for process CPU timers.
<span class="lineNum">     567 </span>                :            :          * See thread_group_cputimer(), et al, for details.
<span class="lineNum">     568 </span>                :            :          */
<span class="lineNum">     569 </span>                :            :         struct thread_group_cputimer cputimer;
<span class="lineNum">     570 </span>                :            : 
<span class="lineNum">     571 </span>                :            :         /* Earliest-expiration cache. */
<span class="lineNum">     572 </span>                :            :         struct task_cputime cputime_expires;
<span class="lineNum">     573 </span>                :            : 
<span class="lineNum">     574 </span>                :            :         struct list_head cpu_timers[3];
<span class="lineNum">     575 </span>                :            : 
<span class="lineNum">     576 </span>                :            :         struct pid *tty_old_pgrp;
<span class="lineNum">     577 </span>                :            : 
<span class="lineNum">     578 </span>                :            :         /* boolean value for session group leader */
<span class="lineNum">     579 </span>                :            :         int leader;
<span class="lineNum">     580 </span>                :            : 
<span class="lineNum">     581 </span>                :            :         struct tty_struct *tty; /* NULL if no tty */
<span class="lineNum">     582 </span>                :            : 
<span class="lineNum">     583 </span>                :            :         /*
<span class="lineNum">     584 </span>                :            :          * Cumulative resource counters for dead threads in the group,
<span class="lineNum">     585 </span>                :            :          * and for reaped dead child processes forked by this group.
<span class="lineNum">     586 </span>                :            :          * Live threads maintain their own counters and add to these
<span class="lineNum">     587 </span>                :            :          * in __exit_signal, except for the group leader.
<span class="lineNum">     588 </span>                :            :          */
<span class="lineNum">     589 </span>                :            :         cputime_t utime, stime, cutime, cstime;
<span class="lineNum">     590 </span>                :            :         cputime_t gtime;
<span class="lineNum">     591 </span>                :            :         cputime_t cgtime;
<span class="lineNum">     592 </span>                :            : #ifndef CONFIG_VIRT_CPU_ACCOUNTING
<span class="lineNum">     593 </span>                :            :         cputime_t prev_utime, prev_stime;
<span class="lineNum">     594 </span>                :            : #endif
<span class="lineNum">     595 </span>                :            :         unsigned long nvcsw, nivcsw, cnvcsw, cnivcsw;
<span class="lineNum">     596 </span>                :            :         unsigned long min_flt, maj_flt, cmin_flt, cmaj_flt;
<span class="lineNum">     597 </span>                :            :         unsigned long inblock, oublock, cinblock, coublock;
<span class="lineNum">     598 </span>                :            :         unsigned long maxrss, cmaxrss;
<span class="lineNum">     599 </span>                :            :         struct task_io_accounting ioac;
<span class="lineNum">     600 </span>                :            : 
<span class="lineNum">     601 </span>                :            :         /*
<span class="lineNum">     602 </span>                :            :          * Cumulative ns of schedule CPU time fo dead threads in the
<span class="lineNum">     603 </span>                :            :          * group, not including a zombie group leader, (This only differs
<span class="lineNum">     604 </span>                :            :          * from jiffies_to_ns(utime + stime) if sched_clock uses something
<span class="lineNum">     605 </span>                :            :          * other than jiffies.)
<span class="lineNum">     606 </span>                :            :          */
<span class="lineNum">     607 </span>                :            :         unsigned long long sum_sched_runtime;
<span class="lineNum">     608 </span>                :            : 
<span class="lineNum">     609 </span>                :            :         /*
<span class="lineNum">     610 </span>                :            :          * We don't bother to synchronize most readers of this at all,
<span class="lineNum">     611 </span>                :            :          * because there is no reader checking a limit that actually needs
<span class="lineNum">     612 </span>                :            :          * to get both rlim_cur and rlim_max atomically, and either one
<span class="lineNum">     613 </span>                :            :          * alone is a single word that can safely be read normally.
<span class="lineNum">     614 </span>                :            :          * getrlimit/setrlimit use task_lock(current-&gt;group_leader) to
<span class="lineNum">     615 </span>                :            :          * protect this instead of the siglock, because they really
<span class="lineNum">     616 </span>                :            :          * have no need to disable irqs.
<span class="lineNum">     617 </span>                :            :          */
<span class="lineNum">     618 </span>                :            :         struct rlimit rlim[RLIM_NLIMITS];
<span class="lineNum">     619 </span>                :            : 
<span class="lineNum">     620 </span>                :            : #ifdef CONFIG_BSD_PROCESS_ACCT
<span class="lineNum">     621 </span>                :            :         struct pacct_struct pacct;      /* per-process accounting information */
<span class="lineNum">     622 </span>                :            : #endif
<span class="lineNum">     623 </span>                :            : #ifdef CONFIG_TASKSTATS
<span class="lineNum">     624 </span>                :            :         struct taskstats *stats;
<span class="lineNum">     625 </span>                :            : #endif
<span class="lineNum">     626 </span>                :            : #ifdef CONFIG_AUDIT
<span class="lineNum">     627 </span>                :            :         unsigned audit_tty;
<span class="lineNum">     628 </span>                :            :         struct tty_audit_buf *tty_audit_buf;
<span class="lineNum">     629 </span>                :            : #endif
<span class="lineNum">     630 </span>                :            : 
<span class="lineNum">     631 </span>                :            :         int oom_adj;    /* OOM kill score adjustment (bit shift) */
<span class="lineNum">     632 </span>                :            : };
<span class="lineNum">     633 </span>                :            : 
<span class="lineNum">     634 </span>                :            : /* Context switch must be unlocked if interrupts are to be enabled */
<span class="lineNum">     635 </span>                :            : #ifdef __ARCH_WANT_INTERRUPTS_ON_CTXSW
<span class="lineNum">     636 </span>                :            : # define __ARCH_WANT_UNLOCKED_CTXSW
<span class="lineNum">     637 </span>                :            : #endif
<span class="lineNum">     638 </span>                :            : 
<span class="lineNum">     639 </span>                :            : /*
<span class="lineNum">     640 </span>                :            :  * Bits in flags field of signal_struct.
<span class="lineNum">     641 </span>                :            :  */
<span class="lineNum">     642 </span>                :            : #define SIGNAL_STOP_STOPPED     0x00000001 /* job control stop in effect */
<span class="lineNum">     643 </span>                :            : #define SIGNAL_STOP_DEQUEUED    0x00000002 /* stop signal dequeued */
<span class="lineNum">     644 </span>                :            : #define SIGNAL_STOP_CONTINUED   0x00000004 /* SIGCONT since WCONTINUED reap */
<span class="lineNum">     645 </span>                :            : #define SIGNAL_GROUP_EXIT       0x00000008 /* group exit in progress */
<span class="lineNum">     646 </span>                :            : /*
<span class="lineNum">     647 </span>                :            :  * Pending notifications to parent.
<span class="lineNum">     648 </span>                :            :  */
<span class="lineNum">     649 </span>                :            : #define SIGNAL_CLD_STOPPED      0x00000010
<span class="lineNum">     650 </span>                :            : #define SIGNAL_CLD_CONTINUED    0x00000020
<span class="lineNum">     651 </span>                :            : #define SIGNAL_CLD_MASK         (SIGNAL_CLD_STOPPED|SIGNAL_CLD_CONTINUED)
<span class="lineNum">     652 </span>                :            : 
<span class="lineNum">     653 </span>                :            : #define SIGNAL_UNKILLABLE       0x00000040 /* for init: ignore fatal signals */
<span class="lineNum">     654 </span>                :            : 
<span class="lineNum">     655 </span>                :            : /* If true, all threads except -&gt;group_exit_task have pending SIGKILL */
<span class="lineNum">     656 </span>                :            : static inline int signal_group_exit(const struct signal_struct *sig)
<span class="lineNum">     657 </span>                :            : {
<span class="lineNum">     658 </span>                :            :         return  (sig-&gt;flags &amp; SIGNAL_GROUP_EXIT) ||
<span class="lineNum">     659 </span>                :            :                 (sig-&gt;group_exit_task != NULL);
<span class="lineNum">     660 </span>                :            : }
<span class="lineNum">     661 </span>                :            : 
<span class="lineNum">     662 </span>                :            : /*
<span class="lineNum">     663 </span>                :            :  * Some day this will be a full-fledged user tracking system..
<span class="lineNum">     664 </span>                :            :  */
<span class="lineNum">     665 </span>                :            : struct user_struct {
<span class="lineNum">     666 </span>                :            :         atomic_t __count;       /* reference count */
<span class="lineNum">     667 </span>                :            :         atomic_t processes;     /* How many processes does this user have? */
<span class="lineNum">     668 </span>                :            :         atomic_t files;         /* How many open files does this user have? */
<span class="lineNum">     669 </span>                :            :         atomic_t sigpending;    /* How many pending signals does this user have? */
<span class="lineNum">     670 </span>                :            : #ifdef CONFIG_INOTIFY_USER
<span class="lineNum">     671 </span>                :            :         atomic_t inotify_watches; /* How many inotify watches does this user have? */
<span class="lineNum">     672 </span>                :            :         atomic_t inotify_devs;  /* How many inotify devs does this user have opened? */
<span class="lineNum">     673 </span>                :            : #endif
<span class="lineNum">     674 </span>                :            : #ifdef CONFIG_EPOLL
<span class="lineNum">     675 </span>                :            :         atomic_t epoll_watches; /* The number of file descriptors currently watched */
<span class="lineNum">     676 </span>                :            : #endif
<span class="lineNum">     677 </span>                :            : #ifdef CONFIG_POSIX_MQUEUE
<span class="lineNum">     678 </span>                :            :         /* protected by mq_lock */
<span class="lineNum">     679 </span>                :            :         unsigned long mq_bytes; /* How many bytes can be allocated to mqueue? */
<span class="lineNum">     680 </span>                :            : #endif
<span class="lineNum">     681 </span>                :            :         unsigned long locked_shm; /* How many pages of mlocked shm ? */
<span class="lineNum">     682 </span>                :            : 
<span class="lineNum">     683 </span>                :            : #ifdef CONFIG_KEYS
<span class="lineNum">     684 </span>                :            :         struct key *uid_keyring;        /* UID specific keyring */
<span class="lineNum">     685 </span>                :            :         struct key *session_keyring;    /* UID's default session keyring */
<span class="lineNum">     686 </span>                :            : #endif
<span class="lineNum">     687 </span>                :            : 
<span class="lineNum">     688 </span>                :            :         /* Hash table maintenance information */
<span class="lineNum">     689 </span>                :            :         struct hlist_node uidhash_node;
<span class="lineNum">     690 </span>                :            :         uid_t uid;
<span class="lineNum">     691 </span>                :            :         struct user_namespace *user_ns;
<span class="lineNum">     692 </span>                :            : 
<span class="lineNum">     693 </span>                :            : #ifdef CONFIG_PERF_EVENTS
<span class="lineNum">     694 </span>                :            :         atomic_long_t locked_vm;
<span class="lineNum">     695 </span>                :            : #endif
<span class="lineNum">     696 </span>                :            : };
<span class="lineNum">     697 </span>                :            : 
<span class="lineNum">     698 </span>                :            : extern int uids_sysfs_init(void);
<span class="lineNum">     699 </span>                :            : 
<span class="lineNum">     700 </span>                :            : extern struct user_struct *find_user(uid_t);
<span class="lineNum">     701 </span>                :            : 
<span class="lineNum">     702 </span>                :            : extern struct user_struct root_user;
<span class="lineNum">     703 </span>                :            : #define INIT_USER (&amp;root_user)
<span class="lineNum">     704 </span>                :            : 
<span class="lineNum">     705 </span>                :            : 
<span class="lineNum">     706 </span>                :            : struct backing_dev_info;
<span class="lineNum">     707 </span>                :            : struct reclaim_state;
<span class="lineNum">     708 </span>                :            : 
<span class="lineNum">     709 </span>                :            : #if defined(CONFIG_SCHEDSTATS) || defined(CONFIG_TASK_DELAY_ACCT)
<span class="lineNum">     710 </span>                :            : struct sched_info {
<span class="lineNum">     711 </span>                :            :         /* cumulative counters */
<span class="lineNum">     712 </span>                :            :         unsigned long pcount;         /* # of times run on this cpu */
<span class="lineNum">     713 </span>                :            :         unsigned long long run_delay; /* time spent waiting on a runqueue */
<span class="lineNum">     714 </span>                :            : 
<span class="lineNum">     715 </span>                :            :         /* timestamps */
<span class="lineNum">     716 </span>                :            :         unsigned long long last_arrival,/* when we last ran on a cpu */
<span class="lineNum">     717 </span>                :            :                            last_queued; /* when we were last queued to run */
<span class="lineNum">     718 </span>                :            : #ifdef CONFIG_SCHEDSTATS
<span class="lineNum">     719 </span>                :            :         /* BKL stats */
<span class="lineNum">     720 </span>                :            :         unsigned int bkl_count;
<span class="lineNum">     721 </span>                :            : #endif
<span class="lineNum">     722 </span>                :            : };
<span class="lineNum">     723 </span>                :            : #endif /* defined(CONFIG_SCHEDSTATS) || defined(CONFIG_TASK_DELAY_ACCT) */
<span class="lineNum">     724 </span>                :            : 
<span class="lineNum">     725 </span>                :            : #ifdef CONFIG_TASK_DELAY_ACCT
<span class="lineNum">     726 </span>                :            : struct task_delay_info {
<span class="lineNum">     727 </span>                :            :         spinlock_t      lock;
<span class="lineNum">     728 </span>                :            :         unsigned int    flags;  /* Private per-task flags */
<span class="lineNum">     729 </span>                :            : 
<span class="lineNum">     730 </span>                :            :         /* For each stat XXX, add following, aligned appropriately
<span class="lineNum">     731 </span>                :            :          *
<span class="lineNum">     732 </span>                :            :          * struct timespec XXX_start, XXX_end;
<span class="lineNum">     733 </span>                :            :          * u64 XXX_delay;
<span class="lineNum">     734 </span>                :            :          * u32 XXX_count;
<span class="lineNum">     735 </span>                :            :          *
<span class="lineNum">     736 </span>                :            :          * Atomicity of updates to XXX_delay, XXX_count protected by
<span class="lineNum">     737 </span>                :            :          * single lock above (split into XXX_lock if contention is an issue).
<span class="lineNum">     738 </span>                :            :          */
<span class="lineNum">     739 </span>                :            : 
<span class="lineNum">     740 </span>                :            :         /*
<span class="lineNum">     741 </span>                :            :          * XXX_count is incremented on every XXX operation, the delay
<span class="lineNum">     742 </span>                :            :          * associated with the operation is added to XXX_delay.
<span class="lineNum">     743 </span>                :            :          * XXX_delay contains the accumulated delay time in nanoseconds.
<span class="lineNum">     744 </span>                :            :          */
<span class="lineNum">     745 </span>                :            :         struct timespec blkio_start, blkio_end; /* Shared by blkio, swapin */
<span class="lineNum">     746 </span>                :            :         u64 blkio_delay;        /* wait for sync block io completion */
<span class="lineNum">     747 </span>                :            :         u64 swapin_delay;       /* wait for swapin block io completion */
<span class="lineNum">     748 </span>                :            :         u32 blkio_count;        /* total count of the number of sync block */
<span class="lineNum">     749 </span>                :            :                                 /* io operations performed */
<span class="lineNum">     750 </span>                :            :         u32 swapin_count;       /* total count of the number of swapin block */
<span class="lineNum">     751 </span>                :            :                                 /* io operations performed */
<span class="lineNum">     752 </span>                :            : 
<span class="lineNum">     753 </span>                :            :         struct timespec freepages_start, freepages_end;
<span class="lineNum">     754 </span>                :            :         u64 freepages_delay;    /* wait for memory reclaim */
<span class="lineNum">     755 </span>                :            :         u32 freepages_count;    /* total count of memory reclaim */
<span class="lineNum">     756 </span>                :            : };
<span class="lineNum">     757 </span>                :            : #endif  /* CONFIG_TASK_DELAY_ACCT */
<span class="lineNum">     758 </span>                :            : 
<span class="lineNum">     759 </span>                :            : static inline int sched_info_on(void)
<span class="lineNum">     760 </span>                :            : {
<span class="lineNum">     761 </span>                :            : #ifdef CONFIG_SCHEDSTATS
<span class="lineNum">     762 </span>                :            :         return 1;
<span class="lineNum">     763 </span>                :            : #elif defined(CONFIG_TASK_DELAY_ACCT)
<span class="lineNum">     764 </span>                :            :         extern int delayacct_on;
<span class="lineNum">     765 </span>                :            :         return delayacct_on;
<span class="lineNum">     766 </span>                :            : #else
<span class="lineNum">     767 </span>                :            :         return 0;
<span class="lineNum">     768 </span>                :            : #endif
<span class="lineNum">     769 </span>                :            : }
<span class="lineNum">     770 </span>                :            : 
<span class="lineNum">     771 </span>                :            : enum cpu_idle_type {
<span class="lineNum">     772 </span>                :            :         CPU_IDLE,
<span class="lineNum">     773 </span>                :            :         CPU_NOT_IDLE,
<span class="lineNum">     774 </span>                :            :         CPU_NEWLY_IDLE,
<span class="lineNum">     775 </span>                :            :         CPU_MAX_IDLE_TYPES
<span class="lineNum">     776 </span>                :            : };
<span class="lineNum">     777 </span>                :            : 
<span class="lineNum">     778 </span>                :            : /*
<span class="lineNum">     779 </span>                :            :  * sched-domains (multiprocessor balancing) declarations:
<span class="lineNum">     780 </span>                :            :  */
<span class="lineNum">     781 </span>                :            : 
<span class="lineNum">     782 </span>                :            : /*
<span class="lineNum">     783 </span>                :            :  * Increase resolution of nice-level calculations:
<span class="lineNum">     784 </span>                :            :  */
<span class="lineNum">     785 </span>                :            : #define SCHED_LOAD_SHIFT        10
<span class="lineNum">     786 </span>                :            : #define SCHED_LOAD_SCALE        (1L &lt;&lt; SCHED_LOAD_SHIFT)
<span class="lineNum">     787 </span>                :            : 
<span class="lineNum">     788 </span>                :            : #define SCHED_LOAD_SCALE_FUZZ   SCHED_LOAD_SCALE
<span class="lineNum">     789 </span>                :            : 
<span class="lineNum">     790 </span>                :            : #ifdef CONFIG_SMP
<span class="lineNum">     791 </span>                :            : #define SD_LOAD_BALANCE         0x0001  /* Do load balancing on this domain. */
<span class="lineNum">     792 </span>                :            : #define SD_BALANCE_NEWIDLE      0x0002  /* Balance when about to become idle */
<span class="lineNum">     793 </span>                :            : #define SD_BALANCE_EXEC         0x0004  /* Balance on exec */
<span class="lineNum">     794 </span>                :            : #define SD_BALANCE_FORK         0x0008  /* Balance on fork, clone */
<span class="lineNum">     795 </span>                :            : #define SD_BALANCE_WAKE         0x0010  /* Balance on wakeup */
<span class="lineNum">     796 </span>                :            : #define SD_WAKE_AFFINE          0x0020  /* Wake task to waking CPU */
<span class="lineNum">     797 </span>                :            : #define SD_PREFER_LOCAL         0x0040  /* Prefer to keep tasks local to this domain */
<span class="lineNum">     798 </span>                :            : #define SD_SHARE_CPUPOWER       0x0080  /* Domain members share cpu power */
<span class="lineNum">     799 </span>                :            : #define SD_POWERSAVINGS_BALANCE 0x0100  /* Balance for power savings */
<span class="lineNum">     800 </span>                :            : #define SD_SHARE_PKG_RESOURCES  0x0200  /* Domain members share cpu pkg resources */
<span class="lineNum">     801 </span>                :            : #define SD_SERIALIZE            0x0400  /* Only a single load balancing instance */
<span class="lineNum">     802 </span>                :            : 
<span class="lineNum">     803 </span>                :            : #define SD_PREFER_SIBLING       0x1000  /* Prefer to place tasks in a sibling domain */
<span class="lineNum">     804 </span>                :            : 
<span class="lineNum">     805 </span>                :            : enum powersavings_balance_level {
<span class="lineNum">     806 </span>                :            :         POWERSAVINGS_BALANCE_NONE = 0,  /* No power saving load balance */
<span class="lineNum">     807 </span>                :            :         POWERSAVINGS_BALANCE_BASIC,     /* Fill one thread/core/package
<span class="lineNum">     808 </span>                :            :                                          * first for long running threads
<span class="lineNum">     809 </span>                :            :                                          */
<span class="lineNum">     810 </span>                :            :         POWERSAVINGS_BALANCE_WAKEUP,    /* Also bias task wakeups to semi-idle
<span class="lineNum">     811 </span>                :            :                                          * cpu package for power savings
<span class="lineNum">     812 </span>                :            :                                          */
<span class="lineNum">     813 </span>                :            :         MAX_POWERSAVINGS_BALANCE_LEVELS
<span class="lineNum">     814 </span>                :            : };
<span class="lineNum">     815 </span>                :            : 
<span class="lineNum">     816 </span>                :            : extern int sched_mc_power_savings, sched_smt_power_savings;
<span class="lineNum">     817 </span>                :            : 
<span class="lineNum">     818 </span>                :            : static inline int sd_balance_for_mc_power(void)
<span class="lineNum">     819 </span>                :            : {
<span class="lineNum">     820 </span>                :            :         if (sched_smt_power_savings)
<span class="lineNum">     821 </span>                :            :                 return SD_POWERSAVINGS_BALANCE;
<span class="lineNum">     822 </span>                :            : 
<span class="lineNum">     823 </span>                :            :         if (!sched_mc_power_savings)
<span class="lineNum">     824 </span>                :            :                 return SD_PREFER_SIBLING;
<span class="lineNum">     825 </span>                :            : 
<span class="lineNum">     826 </span>                :            :         return 0;
<span class="lineNum">     827 </span>                :            : }
<span class="lineNum">     828 </span>                :            : 
<span class="lineNum">     829 </span>                :            : static inline int sd_balance_for_package_power(void)
<span class="lineNum">     830 </span>                :            : {
<span class="lineNum">     831 </span>                :            :         if (sched_mc_power_savings | sched_smt_power_savings)
<span class="lineNum">     832 </span>                :            :                 return SD_POWERSAVINGS_BALANCE;
<span class="lineNum">     833 </span>                :            : 
<span class="lineNum">     834 </span>                :            :         return SD_PREFER_SIBLING;
<span class="lineNum">     835 </span>                :            : }
<span class="lineNum">     836 </span>                :            : 
<span class="lineNum">     837 </span>                :            : /*
<span class="lineNum">     838 </span>                :            :  * Optimise SD flags for power savings:
<span class="lineNum">     839 </span>                :            :  * SD_BALANCE_NEWIDLE helps agressive task consolidation and power savings.
<span class="lineNum">     840 </span>                :            :  * Keep default SD flags if sched_{smt,mc}_power_saving=0
<span class="lineNum">     841 </span>                :            :  */
<span class="lineNum">     842 </span>                :            : 
<span class="lineNum">     843 </span>                :            : static inline int sd_power_saving_flags(void)
<span class="lineNum">     844 </span>                :            : {
<span class="lineNum">     845 </span>                :            :         if (sched_mc_power_savings | sched_smt_power_savings)
<span class="lineNum">     846 </span>                :            :                 return SD_BALANCE_NEWIDLE;
<span class="lineNum">     847 </span>                :            : 
<span class="lineNum">     848 </span>                :            :         return 0;
<span class="lineNum">     849 </span>                :            : }
<span class="lineNum">     850 </span>                :            : 
<span class="lineNum">     851 </span>                :            : struct sched_group {
<span class="lineNum">     852 </span>                :            :         struct sched_group *next;       /* Must be a circular list */
<span class="lineNum">     853 </span>                :            : 
<span class="lineNum">     854 </span>                :            :         /*
<span class="lineNum">     855 </span>                :            :          * CPU power of this group, SCHED_LOAD_SCALE being max power for a
<span class="lineNum">     856 </span>                :            :          * single CPU.
<span class="lineNum">     857 </span>                :            :          */
<span class="lineNum">     858 </span>                :            :         unsigned int cpu_power;
<span class="lineNum">     859 </span>                :            : 
<span class="lineNum">     860 </span>                :            :         /*
<span class="lineNum">     861 </span>                :            :          * The CPUs this group covers.
<span class="lineNum">     862 </span>                :            :          *
<span class="lineNum">     863 </span>                :            :          * NOTE: this field is variable length. (Allocated dynamically
<span class="lineNum">     864 </span>                :            :          * by attaching extra space to the end of the structure,
<span class="lineNum">     865 </span>                :            :          * depending on how many CPUs the kernel has booted up with)
<span class="lineNum">     866 </span>                :            :          *
<span class="lineNum">     867 </span>                :            :          * It is also be embedded into static data structures at build
<span class="lineNum">     868 </span>                :            :          * time. (See 'struct static_sched_group' in kernel/sched.c)
<span class="lineNum">     869 </span>                :            :          */
<span class="lineNum">     870 </span>                :            :         unsigned long cpumask[0];
<span class="lineNum">     871 </span>                :            : };
<span class="lineNum">     872 </span>                :            : 
<span class="lineNum">     873 </span>                :            : static inline struct cpumask *sched_group_cpus(struct sched_group *sg)
<span class="lineNum">     874 </span>                :            : {
<span class="lineNum">     875 </span>                :            :         return to_cpumask(sg-&gt;cpumask);
<span class="lineNum">     876 </span>                :            : }
<span class="lineNum">     877 </span>                :            : 
<span class="lineNum">     878 </span>                :            : enum sched_domain_level {
<span class="lineNum">     879 </span>                :            :         SD_LV_NONE = 0,
<span class="lineNum">     880 </span>                :            :         SD_LV_SIBLING,
<span class="lineNum">     881 </span>                :            :         SD_LV_MC,
<span class="lineNum">     882 </span>                :            :         SD_LV_CPU,
<span class="lineNum">     883 </span>                :            :         SD_LV_NODE,
<span class="lineNum">     884 </span>                :            :         SD_LV_ALLNODES,
<span class="lineNum">     885 </span>                :            :         SD_LV_MAX
<span class="lineNum">     886 </span>                :            : };
<span class="lineNum">     887 </span>                :            : 
<span class="lineNum">     888 </span>                :            : struct sched_domain_attr {
<span class="lineNum">     889 </span>                :            :         int relax_domain_level;
<span class="lineNum">     890 </span>                :            : };
<span class="lineNum">     891 </span>                :            : 
<span class="lineNum">     892 </span>                :            : #define SD_ATTR_INIT    (struct sched_domain_attr) {    \
<span class="lineNum">     893 </span>                :            :         .relax_domain_level = -1,                       \
<span class="lineNum">     894 </span>                :            : }
<span class="lineNum">     895 </span>                :            : 
<span class="lineNum">     896 </span>                :            : struct sched_domain {
<span class="lineNum">     897 </span>                :            :         /* These fields must be setup */
<span class="lineNum">     898 </span>                :            :         struct sched_domain *parent;    /* top domain must be null terminated */
<span class="lineNum">     899 </span>                :            :         struct sched_domain *child;     /* bottom domain must be null terminated */
<span class="lineNum">     900 </span>                :            :         struct sched_group *groups;     /* the balancing groups of the domain */
<span class="lineNum">     901 </span>                :            :         unsigned long min_interval;     /* Minimum balance interval ms */
<span class="lineNum">     902 </span>                :            :         unsigned long max_interval;     /* Maximum balance interval ms */
<span class="lineNum">     903 </span>                :            :         unsigned int busy_factor;       /* less balancing by factor if busy */
<span class="lineNum">     904 </span>                :            :         unsigned int imbalance_pct;     /* No balance until over watermark */
<span class="lineNum">     905 </span>                :            :         unsigned int cache_nice_tries;  /* Leave cache hot tasks for # tries */
<span class="lineNum">     906 </span>                :            :         unsigned int busy_idx;
<span class="lineNum">     907 </span>                :            :         unsigned int idle_idx;
<span class="lineNum">     908 </span>                :            :         unsigned int newidle_idx;
<span class="lineNum">     909 </span>                :            :         unsigned int wake_idx;
<span class="lineNum">     910 </span>                :            :         unsigned int forkexec_idx;
<span class="lineNum">     911 </span>                :            :         unsigned int smt_gain;
<span class="lineNum">     912 </span>                :            :         int flags;                      /* See SD_* */
<span class="lineNum">     913 </span>                :            :         enum sched_domain_level level;
<span class="lineNum">     914 </span>                :            : 
<span class="lineNum">     915 </span>                :            :         /* Runtime fields. */
<span class="lineNum">     916 </span>                :            :         unsigned long last_balance;     /* init to jiffies. units in jiffies */
<span class="lineNum">     917 </span>                :            :         unsigned int balance_interval;  /* initialise to 1. units in ms. */
<span class="lineNum">     918 </span>                :            :         unsigned int nr_balance_failed; /* initialise to 0 */
<span class="lineNum">     919 </span>                :            : 
<span class="lineNum">     920 </span>                :            :         u64 last_update;
<span class="lineNum">     921 </span>                :            : 
<span class="lineNum">     922 </span>                :            : #ifdef CONFIG_SCHEDSTATS
<span class="lineNum">     923 </span>                :            :         /* load_balance() stats */
<span class="lineNum">     924 </span>                :            :         unsigned int lb_count[CPU_MAX_IDLE_TYPES];
<span class="lineNum">     925 </span>                :            :         unsigned int lb_failed[CPU_MAX_IDLE_TYPES];
<span class="lineNum">     926 </span>                :            :         unsigned int lb_balanced[CPU_MAX_IDLE_TYPES];
<span class="lineNum">     927 </span>                :            :         unsigned int lb_imbalance[CPU_MAX_IDLE_TYPES];
<span class="lineNum">     928 </span>                :            :         unsigned int lb_gained[CPU_MAX_IDLE_TYPES];
<span class="lineNum">     929 </span>                :            :         unsigned int lb_hot_gained[CPU_MAX_IDLE_TYPES];
<span class="lineNum">     930 </span>                :            :         unsigned int lb_nobusyg[CPU_MAX_IDLE_TYPES];
<span class="lineNum">     931 </span>                :            :         unsigned int lb_nobusyq[CPU_MAX_IDLE_TYPES];
<span class="lineNum">     932 </span>                :            : 
<span class="lineNum">     933 </span>                :            :         /* Active load balancing */
<span class="lineNum">     934 </span>                :            :         unsigned int alb_count;
<span class="lineNum">     935 </span>                :            :         unsigned int alb_failed;
<span class="lineNum">     936 </span>                :            :         unsigned int alb_pushed;
<span class="lineNum">     937 </span>                :            : 
<span class="lineNum">     938 </span>                :            :         /* SD_BALANCE_EXEC stats */
<span class="lineNum">     939 </span>                :            :         unsigned int sbe_count;
<span class="lineNum">     940 </span>                :            :         unsigned int sbe_balanced;
<span class="lineNum">     941 </span>                :            :         unsigned int sbe_pushed;
<span class="lineNum">     942 </span>                :            : 
<span class="lineNum">     943 </span>                :            :         /* SD_BALANCE_FORK stats */
<span class="lineNum">     944 </span>                :            :         unsigned int sbf_count;
<span class="lineNum">     945 </span>                :            :         unsigned int sbf_balanced;
<span class="lineNum">     946 </span>                :            :         unsigned int sbf_pushed;
<span class="lineNum">     947 </span>                :            : 
<span class="lineNum">     948 </span>                :            :         /* try_to_wake_up() stats */
<span class="lineNum">     949 </span>                :            :         unsigned int ttwu_wake_remote;
<span class="lineNum">     950 </span>                :            :         unsigned int ttwu_move_affine;
<span class="lineNum">     951 </span>                :            :         unsigned int ttwu_move_balance;
<span class="lineNum">     952 </span>                :            : #endif
<span class="lineNum">     953 </span>                :            : #ifdef CONFIG_SCHED_DEBUG
<span class="lineNum">     954 </span>                :            :         char *name;
<span class="lineNum">     955 </span>                :            : #endif
<span class="lineNum">     956 </span>                :            : 
<span class="lineNum">     957 </span>                :            :         unsigned int span_weight;
<span class="lineNum">     958 </span>                :            :         /*
<span class="lineNum">     959 </span>                :            :          * Span of all CPUs in this domain.
<span class="lineNum">     960 </span>                :            :          *
<span class="lineNum">     961 </span>                :            :          * NOTE: this field is variable length. (Allocated dynamically
<span class="lineNum">     962 </span>                :            :          * by attaching extra space to the end of the structure,
<span class="lineNum">     963 </span>                :            :          * depending on how many CPUs the kernel has booted up with)
<span class="lineNum">     964 </span>                :            :          *
<span class="lineNum">     965 </span>                :            :          * It is also be embedded into static data structures at build
<span class="lineNum">     966 </span>                :            :          * time. (See 'struct static_sched_domain' in kernel/sched.c)
<span class="lineNum">     967 </span>                :            :          */
<span class="lineNum">     968 </span>                :            :         unsigned long span[0];
<span class="lineNum">     969 </span>                :            : };
<span class="lineNum">     970 </span>                :            : 
<span class="lineNum">     971 </span>                :            : static inline struct cpumask *sched_domain_span(struct sched_domain *sd)
<span class="lineNum">     972 </span>                :            : {
<span class="lineNum">     973 </span>                :            :         return to_cpumask(sd-&gt;span);
<span class="lineNum">     974 </span>                :            : }
<span class="lineNum">     975 </span>                :            : 
<span class="lineNum">     976 </span>                :            : extern void partition_sched_domains(int ndoms_new, cpumask_var_t doms_new[],
<span class="lineNum">     977 </span>                :            :                                     struct sched_domain_attr *dattr_new);
<span class="lineNum">     978 </span>                :            : 
<span class="lineNum">     979 </span>                :            : /* Allocate an array of sched domains, for partition_sched_domains(). */
<span class="lineNum">     980 </span>                :            : cpumask_var_t *alloc_sched_domains(unsigned int ndoms);
<span class="lineNum">     981 </span>                :            : void free_sched_domains(cpumask_var_t doms[], unsigned int ndoms);
<span class="lineNum">     982 </span>                :            : 
<span class="lineNum">     983 </span>                :            : /* Test a flag in parent sched domain */
<span class="lineNum">     984 </span>                :            : static inline int test_sd_parent(struct sched_domain *sd, int flag)
<span class="lineNum">     985 </span>                :            : {
<span class="lineNum">     986 </span>                :            :         if (sd-&gt;parent &amp;&amp; (sd-&gt;parent-&gt;flags &amp; flag))
<span class="lineNum">     987 </span>                :            :                 return 1;
<span class="lineNum">     988 </span>                :            : 
<span class="lineNum">     989 </span>                :            :         return 0;
<span class="lineNum">     990 </span>                :            : }
<span class="lineNum">     991 </span>                :            : 
<span class="lineNum">     992 </span>                :            : unsigned long default_scale_freq_power(struct sched_domain *sd, int cpu);
<span class="lineNum">     993 </span>                :            : unsigned long default_scale_smt_power(struct sched_domain *sd, int cpu);
<span class="lineNum">     994 </span>                :            : 
<span class="lineNum">     995 </span>                :            : #else /* CONFIG_SMP */
<span class="lineNum">     996 </span>                :            : 
<span class="lineNum">     997 </span>                :            : struct sched_domain_attr;
<span class="lineNum">     998 </span>                :            : 
<span class="lineNum">     999 </span>                :            : static inline void
<span class="lineNum">    1000 </span>                :            : partition_sched_domains(int ndoms_new, cpumask_var_t doms_new[],
<span class="lineNum">    1001 </span>                :            :                         struct sched_domain_attr *dattr_new)
<span class="lineNum">    1002 </span>                :            : {
<span class="lineNum">    1003 </span>                :            : }
<span class="lineNum">    1004 </span>                :            : #endif  /* !CONFIG_SMP */
<span class="lineNum">    1005 </span>                :            : 
<span class="lineNum">    1006 </span>                :            : 
<span class="lineNum">    1007 </span>                :            : struct io_context;                      /* See blkdev.h */
<span class="lineNum">    1008 </span>                :            : 
<span class="lineNum">    1009 </span>                :            : 
<span class="lineNum">    1010 </span>                :            : #ifdef ARCH_HAS_PREFETCH_SWITCH_STACK
<span class="lineNum">    1011 </span>                :            : extern void prefetch_stack(struct task_struct *t);
<span class="lineNum">    1012 </span>                :            : #else
<span class="lineNum">    1013 </span>                :            : static inline void prefetch_stack(struct task_struct *t) { }
<span class="lineNum">    1014 </span>                :            : #endif
<span class="lineNum">    1015 </span>                :            : 
<span class="lineNum">    1016 </span>                :            : struct audit_context;           /* See audit.c */
<span class="lineNum">    1017 </span>                :            : struct mempolicy;
<span class="lineNum">    1018 </span>                :            : struct pipe_inode_info;
<span class="lineNum">    1019 </span>                :            : struct uts_namespace;
<span class="lineNum">    1020 </span>                :            : 
<span class="lineNum">    1021 </span>                :            : struct rq;
<span class="lineNum">    1022 </span>                :            : struct sched_domain;
<span class="lineNum">    1023 </span>                :            : 
<span class="lineNum">    1024 </span>                :            : /*
<span class="lineNum">    1025 </span>                :            :  * wake flags
<span class="lineNum">    1026 </span>                :            :  */
<span class="lineNum">    1027 </span>                :            : #define WF_SYNC         0x01            /* waker goes to sleep after wakup */
<span class="lineNum">    1028 </span>                :            : #define WF_FORK         0x02            /* child wakeup after fork */
<span class="lineNum">    1029 </span>                :            : 
<span class="lineNum">    1030 </span>                :            : #define ENQUEUE_WAKEUP          1
<span class="lineNum">    1031 </span>                :            : #define ENQUEUE_WAKING          2
<span class="lineNum">    1032 </span>                :            : #define ENQUEUE_HEAD            4
<span class="lineNum">    1033 </span>                :            : 
<span class="lineNum">    1034 </span>                :            : #define DEQUEUE_SLEEP           1
<span class="lineNum">    1035 </span>                :            : 
<span class="lineNum">    1036 </span>                :            : struct sched_class {
<span class="lineNum">    1037 </span>                :            :         const struct sched_class *next;
<span class="lineNum">    1038 </span>                :            : 
<span class="lineNum">    1039 </span>                :            :         void (*enqueue_task) (struct rq *rq, struct task_struct *p, int flags);
<span class="lineNum">    1040 </span>                :            :         void (*dequeue_task) (struct rq *rq, struct task_struct *p, int flags);
<span class="lineNum">    1041 </span>                :            :         void (*yield_task) (struct rq *rq);
<span class="lineNum">    1042 </span>                :            : 
<span class="lineNum">    1043 </span>                :            :         void (*check_preempt_curr) (struct rq *rq, struct task_struct *p, int flags);
<span class="lineNum">    1044 </span>                :            : 
<span class="lineNum">    1045 </span>                :            :         struct task_struct * (*pick_next_task) (struct rq *rq);
<span class="lineNum">    1046 </span>                :            :         void (*put_prev_task) (struct rq *rq, struct task_struct *p);
<span class="lineNum">    1047 </span>                :            : 
<span class="lineNum">    1048 </span>                :            : #ifdef CONFIG_SMP
<span class="lineNum">    1049 </span>                :            :         int  (*select_task_rq)(struct rq *rq, struct task_struct *p,
<span class="lineNum">    1050 </span>                :            :                                int sd_flag, int flags);
<span class="lineNum">    1051 </span>                :            : 
<span class="lineNum">    1052 </span>                :            :         void (*pre_schedule) (struct rq *this_rq, struct task_struct *task);
<span class="lineNum">    1053 </span>                :            :         void (*post_schedule) (struct rq *this_rq);
<span class="lineNum">    1054 </span>                :            :         void (*task_waking) (struct rq *this_rq, struct task_struct *task);
<span class="lineNum">    1055 </span>                :            :         void (*task_woken) (struct rq *this_rq, struct task_struct *task);
<span class="lineNum">    1056 </span>                :            : 
<span class="lineNum">    1057 </span>                :            :         void (*set_cpus_allowed)(struct task_struct *p,
<span class="lineNum">    1058 </span>                :            :                                  const struct cpumask *newmask);
<span class="lineNum">    1059 </span>                :            : 
<span class="lineNum">    1060 </span>                :            :         void (*rq_online)(struct rq *rq);
<span class="lineNum">    1061 </span>                :            :         void (*rq_offline)(struct rq *rq);
<span class="lineNum">    1062 </span>                :            : #endif
<span class="lineNum">    1063 </span>                :            : 
<span class="lineNum">    1064 </span>                :            :         void (*set_curr_task) (struct rq *rq);
<span class="lineNum">    1065 </span>                :            :         void (*task_tick) (struct rq *rq, struct task_struct *p, int queued);
<span class="lineNum">    1066 </span>                :            :         void (*task_fork) (struct task_struct *p);
<span class="lineNum">    1067 </span>                :            : 
<span class="lineNum">    1068 </span>                :            :         void (*switched_from) (struct rq *this_rq, struct task_struct *task,
<span class="lineNum">    1069 </span>                :            :                                int running);
<span class="lineNum">    1070 </span>                :            :         void (*switched_to) (struct rq *this_rq, struct task_struct *task,
<span class="lineNum">    1071 </span>                :            :                              int running);
<span class="lineNum">    1072 </span>                :            :         void (*prio_changed) (struct rq *this_rq, struct task_struct *task,
<span class="lineNum">    1073 </span>                :            :                              int oldprio, int running);
<span class="lineNum">    1074 </span>                :            : 
<span class="lineNum">    1075 </span>                :            :         unsigned int (*get_rr_interval) (struct rq *rq,
<span class="lineNum">    1076 </span>                :            :                                          struct task_struct *task);
<span class="lineNum">    1077 </span>                :            : 
<span class="lineNum">    1078 </span>                :            : #ifdef CONFIG_FAIR_GROUP_SCHED
<span class="lineNum">    1079 </span>                :            :         void (*moved_group) (struct task_struct *p, int on_rq);
<span class="lineNum">    1080 </span>                :            :         void (*prep_move_group) (struct task_struct *p, int on_rq);
<span class="lineNum">    1081 </span>                :            : #endif
<span class="lineNum">    1082 </span>                :            : };
<span class="lineNum">    1083 </span>                :            : 
<span class="lineNum">    1084 </span>                :            : struct load_weight {
<span class="lineNum">    1085 </span>                :            :         unsigned long weight, inv_weight;
<span class="lineNum">    1086 </span>                :            : };
<span class="lineNum">    1087 </span>                :            : 
<span class="lineNum">    1088 </span>                :            : #ifdef CONFIG_SCHEDSTATS
<span class="lineNum">    1089 </span>                :            : struct sched_statistics {
<span class="lineNum">    1090 </span>                :            :         u64                     wait_start;
<span class="lineNum">    1091 </span>                :            :         u64                     wait_max;
<span class="lineNum">    1092 </span>                :            :         u64                     wait_count;
<span class="lineNum">    1093 </span>                :            :         u64                     wait_sum;
<span class="lineNum">    1094 </span>                :            :         u64                     iowait_count;
<span class="lineNum">    1095 </span>                :            :         u64                     iowait_sum;
<span class="lineNum">    1096 </span>                :            : 
<span class="lineNum">    1097 </span>                :            :         u64                     sleep_start;
<span class="lineNum">    1098 </span>                :            :         u64                     sleep_max;
<span class="lineNum">    1099 </span>                :            :         s64                     sum_sleep_runtime;
<span class="lineNum">    1100 </span>                :            : 
<span class="lineNum">    1101 </span>                :            :         u64                     block_start;
<span class="lineNum">    1102 </span>                :            :         u64                     block_max;
<span class="lineNum">    1103 </span>                :            :         u64                     exec_max;
<span class="lineNum">    1104 </span>                :            :         u64                     slice_max;
<span class="lineNum">    1105 </span>                :            : 
<span class="lineNum">    1106 </span>                :            :         u64                     nr_migrations_cold;
<span class="lineNum">    1107 </span>                :            :         u64                     nr_failed_migrations_affine;
<span class="lineNum">    1108 </span>                :            :         u64                     nr_failed_migrations_running;
<span class="lineNum">    1109 </span>                :            :         u64                     nr_failed_migrations_hot;
<span class="lineNum">    1110 </span>                :            :         u64                     nr_forced_migrations;
<span class="lineNum">    1111 </span>                :            : 
<span class="lineNum">    1112 </span>                :            :         u64                     nr_wakeups;
<span class="lineNum">    1113 </span>                :            :         u64                     nr_wakeups_sync;
<span class="lineNum">    1114 </span>                :            :         u64                     nr_wakeups_migrate;
<span class="lineNum">    1115 </span>                :            :         u64                     nr_wakeups_local;
<span class="lineNum">    1116 </span>                :            :         u64                     nr_wakeups_remote;
<span class="lineNum">    1117 </span>                :            :         u64                     nr_wakeups_affine;
<span class="lineNum">    1118 </span>                :            :         u64                     nr_wakeups_affine_attempts;
<span class="lineNum">    1119 </span>                :            :         u64                     nr_wakeups_passive;
<span class="lineNum">    1120 </span>                :            :         u64                     nr_wakeups_idle;
<span class="lineNum">    1121 </span>                :            : };
<span class="lineNum">    1122 </span>                :            : #endif
<span class="lineNum">    1123 </span>                :            : 
<span class="lineNum">    1124 </span>                :            : struct sched_entity {
<span class="lineNum">    1125 </span>                :            :         struct load_weight      load;           /* for load-balancing */
<span class="lineNum">    1126 </span>                :            :         struct rb_node          run_node;
<span class="lineNum">    1127 </span>                :            :         struct list_head        group_node;
<span class="lineNum">    1128 </span>                :            :         unsigned int            on_rq;
<span class="lineNum">    1129 </span>                :            : 
<span class="lineNum">    1130 </span>                :            :         u64                     exec_start;
<span class="lineNum">    1131 </span>                :            :         u64                     sum_exec_runtime;
<span class="lineNum">    1132 </span>                :            :         u64                     vruntime;
<span class="lineNum">    1133 </span>                :            :         u64                     prev_sum_exec_runtime;
<span class="lineNum">    1134 </span>                :            : 
<span class="lineNum">    1135 </span>                :            :         u64                     nr_migrations;
<span class="lineNum">    1136 </span>                :            : 
<span class="lineNum">    1137 </span>                :            : #ifdef CONFIG_SCHEDSTATS
<span class="lineNum">    1138 </span>                :            :         struct sched_statistics statistics;
<span class="lineNum">    1139 </span>                :            : #endif
<span class="lineNum">    1140 </span>                :            : 
<span class="lineNum">    1141 </span>                :            : #ifdef CONFIG_FAIR_GROUP_SCHED
<span class="lineNum">    1142 </span>                :            :         struct sched_entity     *parent;
<span class="lineNum">    1143 </span>                :            :         /* rq on which this entity is (to be) queued: */
<span class="lineNum">    1144 </span>                :            :         struct cfs_rq           *cfs_rq;
<span class="lineNum">    1145 </span>                :            :         /* rq &quot;owned&quot; by this entity/group: */
<span class="lineNum">    1146 </span>                :            :         struct cfs_rq           *my_q;
<span class="lineNum">    1147 </span>                :            : #endif
<span class="lineNum">    1148 </span>                :            : };
<span class="lineNum">    1149 </span>                :            : 
<span class="lineNum">    1150 </span>                :            : struct sched_rt_entity {
<span class="lineNum">    1151 </span>                :            :         struct list_head run_list;
<span class="lineNum">    1152 </span>                :            :         unsigned long timeout;
<span class="lineNum">    1153 </span>                :            :         unsigned int time_slice;
<span class="lineNum">    1154 </span>                :            :         int nr_cpus_allowed;
<span class="lineNum">    1155 </span>                :            : 
<span class="lineNum">    1156 </span>                :            :         struct sched_rt_entity *back;
<span class="lineNum">    1157 </span>                :            : #ifdef CONFIG_RT_GROUP_SCHED
<span class="lineNum">    1158 </span>                :            :         struct sched_rt_entity  *parent;
<span class="lineNum">    1159 </span>                :            :         /* rq on which this entity is (to be) queued: */
<span class="lineNum">    1160 </span>                :            :         struct rt_rq            *rt_rq;
<span class="lineNum">    1161 </span>                :            :         /* rq &quot;owned&quot; by this entity/group: */
<span class="lineNum">    1162 </span>                :            :         struct rt_rq            *my_q;
<span class="lineNum">    1163 </span>                :            : #endif
<span class="lineNum">    1164 </span>                :            : };
<span class="lineNum">    1165 </span>                :            : 
<span class="lineNum">    1166 </span>                :            : struct rcu_node;
<span class="lineNum">    1167 </span>                :            : 
<span class="lineNum">    1168 </span>                :            : struct task_struct {
<span class="lineNum">    1169 </span>                :            :         volatile long state;    /* -1 unrunnable, 0 runnable, &gt;0 stopped */
<span class="lineNum">    1170 </span>                :            :         void *stack;
<span class="lineNum">    1171 </span>                :            :         atomic_t usage;
<span class="lineNum">    1172 </span>                :            :         unsigned int flags;     /* per process flags, defined below */
<span class="lineNum">    1173 </span>                :            :         unsigned int ptrace;
<span class="lineNum">    1174 </span>                :            : 
<span class="lineNum">    1175 </span>                :            :         int lock_depth;         /* BKL lock depth */
<span class="lineNum">    1176 </span>                :            : 
<span class="lineNum">    1177 </span>                :            : #ifdef CONFIG_SMP
<span class="lineNum">    1178 </span>                :            : #ifdef __ARCH_WANT_UNLOCKED_CTXSW
<span class="lineNum">    1179 </span>                :            :         int oncpu;
<span class="lineNum">    1180 </span>                :            : #endif
<span class="lineNum">    1181 </span>                :            : #endif
<span class="lineNum">    1182 </span>                :            : 
<span class="lineNum">    1183 </span>                :            :         int prio, static_prio, normal_prio;
<span class="lineNum">    1184 </span>                :            :         unsigned int rt_priority;
<span class="lineNum">    1185 </span>                :            :         const struct sched_class *sched_class;
<span class="lineNum">    1186 </span>                :            :         struct sched_entity se;
<span class="lineNum">    1187 </span>                :            :         struct sched_rt_entity rt;
<span class="lineNum">    1188 </span>                :            : 
<span class="lineNum">    1189 </span>                :            : #ifdef CONFIG_PREEMPT_NOTIFIERS
<span class="lineNum">    1190 </span>                :            :         /* list of struct preempt_notifier: */
<span class="lineNum">    1191 </span>                :            :         struct hlist_head preempt_notifiers;
<span class="lineNum">    1192 </span>                :            : #endif
<span class="lineNum">    1193 </span>                :            : 
<span class="lineNum">    1194 </span>                :            :         /*
<span class="lineNum">    1195 </span>                :            :          * fpu_counter contains the number of consecutive context switches
<span class="lineNum">    1196 </span>                :            :          * that the FPU is used. If this is over a threshold, the lazy fpu
<span class="lineNum">    1197 </span>                :            :          * saving becomes unlazy to save the trap. This is an unsigned char
<span class="lineNum">    1198 </span>                :            :          * so that after 256 times the counter wraps and the behavior turns
<span class="lineNum">    1199 </span>                :            :          * lazy again; this to deal with bursty apps that only use FPU for
<span class="lineNum">    1200 </span>                :            :          * a short time
<span class="lineNum">    1201 </span>                :            :          */
<span class="lineNum">    1202 </span>                :            :         unsigned char fpu_counter;
<span class="lineNum">    1203 </span>                :            : #ifdef CONFIG_BLK_DEV_IO_TRACE
<span class="lineNum">    1204 </span>                :            :         unsigned int btrace_seq;
<span class="lineNum">    1205 </span>                :            : #endif
<span class="lineNum">    1206 </span>                :            : 
<span class="lineNum">    1207 </span>                :            :         unsigned int policy;
<span class="lineNum">    1208 </span>                :            :         cpumask_t cpus_allowed;
<span class="lineNum">    1209 </span>                :            : 
<span class="lineNum">    1210 </span>                :            : #ifdef CONFIG_TREE_PREEMPT_RCU
<span class="lineNum">    1211 </span>                :            :         int rcu_read_lock_nesting;
<span class="lineNum">    1212 </span>                :            :         char rcu_read_unlock_special;
<span class="lineNum">    1213 </span>                :            :         struct rcu_node *rcu_blocked_node;
<span class="lineNum">    1214 </span>                :            :         struct list_head rcu_node_entry;
<span class="lineNum">    1215 </span>                :            : #endif /* #ifdef CONFIG_TREE_PREEMPT_RCU */
<span class="lineNum">    1216 </span>                :            : 
<span class="lineNum">    1217 </span>                :            : #if defined(CONFIG_SCHEDSTATS) || defined(CONFIG_TASK_DELAY_ACCT)
<span class="lineNum">    1218 </span>                :            :         struct sched_info sched_info;
<span class="lineNum">    1219 </span>                :            : #endif
<span class="lineNum">    1220 </span>                :            : 
<span class="lineNum">    1221 </span>                :            :         struct list_head tasks;
<span class="lineNum">    1222 </span>                :            :         struct plist_node pushable_tasks;
<span class="lineNum">    1223 </span>                :            : 
<span class="lineNum">    1224 </span>                :            :         struct mm_struct *mm, *active_mm;
<span class="lineNum">    1225 </span>                :            : #if defined(SPLIT_RSS_COUNTING)
<span class="lineNum">    1226 </span>                :            :         struct task_rss_stat    rss_stat;
<span class="lineNum">    1227 </span>                :            : #endif
<span class="lineNum">    1228 </span>                :            : /* task state */
<span class="lineNum">    1229 </span>                :            :         int exit_state;
<span class="lineNum">    1230 </span>                :            :         int exit_code, exit_signal;
<span class="lineNum">    1231 </span>                :            :         int pdeath_signal;  /*  The signal sent when the parent dies  */
<span class="lineNum">    1232 </span>                :            :         /* ??? */
<span class="lineNum">    1233 </span>                :            :         unsigned int personality;
<span class="lineNum">    1234 </span>                :            :         unsigned did_exec:1;
<span class="lineNum">    1235 </span>                :            :         unsigned in_execve:1;   /* Tell the LSMs that the process is doing an
<span class="lineNum">    1236 </span>                :            :                                  * execve */
<span class="lineNum">    1237 </span>                :            :         unsigned in_iowait:1;
<span class="lineNum">    1238 </span>                :            : 
<span class="lineNum">    1239 </span>                :            : 
<span class="lineNum">    1240 </span>                :            :         /* Revert to default priority/policy when forking */
<span class="lineNum">    1241 </span>                :            :         unsigned sched_reset_on_fork:1;
<span class="lineNum">    1242 </span>                :            : 
<span class="lineNum">    1243 </span>                :            :         pid_t pid;
<span class="lineNum">    1244 </span>                :            :         pid_t tgid;
<span class="lineNum">    1245 </span>                :            : 
<span class="lineNum">    1246 </span>                :            : #ifdef CONFIG_CC_STACKPROTECTOR
<span class="lineNum">    1247 </span>                :            :         /* Canary value for the -fstack-protector gcc feature */
<span class="lineNum">    1248 </span>                :            :         unsigned long stack_canary;
<span class="lineNum">    1249 </span>                :            : #endif
<span class="lineNum">    1250 </span>                :            : 
<span class="lineNum">    1251 </span>                :            :         /* 
<span class="lineNum">    1252 </span>                :            :          * pointers to (original) parent process, youngest child, younger sibling,
<span class="lineNum">    1253 </span>                :            :          * older sibling, respectively.  (p-&gt;father can be replaced with 
<span class="lineNum">    1254 </span>                :            :          * p-&gt;real_parent-&gt;pid)
<span class="lineNum">    1255 </span>                :            :          */
<span class="lineNum">    1256 </span>                :            :         struct task_struct *real_parent; /* real parent process */
<span class="lineNum">    1257 </span>                :            :         struct task_struct *parent; /* recipient of SIGCHLD, wait4() reports */
<span class="lineNum">    1258 </span>                :            :         /*
<span class="lineNum">    1259 </span>                :            :          * children/sibling forms the list of my natural children
<span class="lineNum">    1260 </span>                :            :          */
<span class="lineNum">    1261 </span>                :            :         struct list_head children;      /* list of my children */
<span class="lineNum">    1262 </span>                :            :         struct list_head sibling;       /* linkage in my parent's children list */
<span class="lineNum">    1263 </span>                :            :         struct task_struct *group_leader;       /* threadgroup leader */
<span class="lineNum">    1264 </span>                :            : 
<span class="lineNum">    1265 </span>                :            :         /*
<span class="lineNum">    1266 </span>                :            :          * ptraced is the list of tasks this task is using ptrace on.
<span class="lineNum">    1267 </span>                :            :          * This includes both natural children and PTRACE_ATTACH targets.
<span class="lineNum">    1268 </span>                :            :          * p-&gt;ptrace_entry is p's link on the p-&gt;parent-&gt;ptraced list.
<span class="lineNum">    1269 </span>                :            :          */
<span class="lineNum">    1270 </span>                :            :         struct list_head ptraced;
<span class="lineNum">    1271 </span>                :            :         struct list_head ptrace_entry;
<span class="lineNum">    1272 </span>                :            : 
<span class="lineNum">    1273 </span>                :            :         /* PID/PID hash table linkage. */
<span class="lineNum">    1274 </span>                :            :         struct pid_link pids[PIDTYPE_MAX];
<span class="lineNum">    1275 </span>                :            :         struct list_head thread_group;
<span class="lineNum">    1276 </span>                :            : 
<span class="lineNum">    1277 </span>                :            :         struct completion *vfork_done;          /* for vfork() */
<span class="lineNum">    1278 </span>                :            :         int __user *set_child_tid;              /* CLONE_CHILD_SETTID */
<span class="lineNum">    1279 </span>                :            :         int __user *clear_child_tid;            /* CLONE_CHILD_CLEARTID */
<span class="lineNum">    1280 </span>                :            : 
<span class="lineNum">    1281 </span>                :            :         cputime_t utime, stime, utimescaled, stimescaled;
<span class="lineNum">    1282 </span>                :            :         cputime_t gtime;
<span class="lineNum">    1283 </span>                :            : #ifndef CONFIG_VIRT_CPU_ACCOUNTING
<span class="lineNum">    1284 </span>                :            :         cputime_t prev_utime, prev_stime;
<span class="lineNum">    1285 </span>                :            : #endif
<span class="lineNum">    1286 </span>                :            :         unsigned long nvcsw, nivcsw; /* context switch counts */
<span class="lineNum">    1287 </span>                :            :         struct timespec start_time;             /* monotonic time */
<span class="lineNum">    1288 </span>                :            :         struct timespec real_start_time;        /* boot based time */
<span class="lineNum">    1289 </span>                :            : /* mm fault and swap info: this can arguably be seen as either mm-specific or thread-specific */
<span class="lineNum">    1290 </span>                :            :         unsigned long min_flt, maj_flt;
<span class="lineNum">    1291 </span>                :            : 
<span class="lineNum">    1292 </span>                :            :         struct task_cputime cputime_expires;
<span class="lineNum">    1293 </span>                :            :         struct list_head cpu_timers[3];
<span class="lineNum">    1294 </span>                :            : 
<span class="lineNum">    1295 </span>                :            : /* process credentials */
<span class="lineNum">    1296 </span>                :            :         const struct cred *real_cred;   /* objective and real subjective task
<span class="lineNum">    1297 </span>                :            :                                          * credentials (COW) */
<span class="lineNum">    1298 </span>                :            :         const struct cred *cred;        /* effective (overridable) subjective task
<span class="lineNum">    1299 </span>                :            :                                          * credentials (COW) */
<span class="lineNum">    1300 </span>                :            :         struct mutex cred_guard_mutex;  /* guard against foreign influences on
<span class="lineNum">    1301 </span>                :            :                                          * credential calculations
<span class="lineNum">    1302 </span>                :            :                                          * (notably. ptrace) */
<span class="lineNum">    1303 </span>                :            :         struct cred *replacement_session_keyring; /* for KEYCTL_SESSION_TO_PARENT */
<span class="lineNum">    1304 </span>                :            : 
<span class="lineNum">    1305 </span>                :            :         char comm[TASK_COMM_LEN]; /* executable name excluding path
<span class="lineNum">    1306 </span>                :            :                                      - access with [gs]et_task_comm (which lock
<span class="lineNum">    1307 </span>                :            :                                        it with task_lock())
<span class="lineNum">    1308 </span>                :            :                                      - initialized normally by setup_new_exec */
<span class="lineNum">    1309 </span>                :            : /* file system info */
<span class="lineNum">    1310 </span>                :            :         int link_count, total_link_count;
<span class="lineNum">    1311 </span>                :            : #ifdef CONFIG_SYSVIPC
<span class="lineNum">    1312 </span>                :            : /* ipc stuff */
<span class="lineNum">    1313 </span>                :            :         struct sysv_sem sysvsem;
<span class="lineNum">    1314 </span>                :            : #endif
<span class="lineNum">    1315 </span>                :            : #ifdef CONFIG_DETECT_HUNG_TASK
<span class="lineNum">    1316 </span>                :            : /* hung task detection */
<span class="lineNum">    1317 </span>                :            :         unsigned long last_switch_count;
<span class="lineNum">    1318 </span>                :            : #endif
<span class="lineNum">    1319 </span>                :            : /* CPU-specific state of this task */
<span class="lineNum">    1320 </span>                :            :         struct thread_struct thread;
<span class="lineNum">    1321 </span>                :            : /* filesystem information */
<span class="lineNum">    1322 </span>                :            :         struct fs_struct *fs;
<span class="lineNum">    1323 </span>                :            : /* open file information */
<span class="lineNum">    1324 </span>                :            :         struct files_struct *files;
<span class="lineNum">    1325 </span>                :            : /* namespaces */
<span class="lineNum">    1326 </span>                :            :         struct nsproxy *nsproxy;
<span class="lineNum">    1327 </span>                :            : /* signal handlers */
<span class="lineNum">    1328 </span>                :            :         struct signal_struct *signal;
<span class="lineNum">    1329 </span>                :            :         struct sighand_struct *sighand;
<span class="lineNum">    1330 </span>                :            : 
<span class="lineNum">    1331 </span>                :            :         sigset_t blocked, real_blocked;
<span class="lineNum">    1332 </span>                :            :         sigset_t saved_sigmask; /* restored if set_restore_sigmask() was used */
<span class="lineNum">    1333 </span>                :            :         struct sigpending pending;
<span class="lineNum">    1334 </span>                :            : 
<span class="lineNum">    1335 </span>                :            :         unsigned long sas_ss_sp;
<span class="lineNum">    1336 </span>                :            :         size_t sas_ss_size;
<span class="lineNum">    1337 </span>                :            :         int (*notifier)(void *priv);
<span class="lineNum">    1338 </span>                :            :         void *notifier_data;
<span class="lineNum">    1339 </span>                :            :         sigset_t *notifier_mask;
<span class="lineNum">    1340 </span>                :            :         struct audit_context *audit_context;
<span class="lineNum">    1341 </span>                :            : #ifdef CONFIG_AUDITSYSCALL
<span class="lineNum">    1342 </span>                :            :         uid_t loginuid;
<span class="lineNum">    1343 </span>                :            :         unsigned int sessionid;
<span class="lineNum">    1344 </span>                :            : #endif
<span class="lineNum">    1345 </span>                :            :         seccomp_t seccomp;
<span class="lineNum">    1346 </span>                :            : 
<span class="lineNum">    1347 </span>                :            : /* Thread group tracking */
<span class="lineNum">    1348 </span>                :            :         u32 parent_exec_id;
<span class="lineNum">    1349 </span>                :            :         u32 self_exec_id;
<span class="lineNum">    1350 </span>                :            : /* Protection of (de-)allocation: mm, files, fs, tty, keyrings, mems_allowed,
<span class="lineNum">    1351 </span>                :            :  * mempolicy */
<span class="lineNum">    1352 </span>                :            :         spinlock_t alloc_lock;
<span class="lineNum">    1353 </span>                :            : 
<span class="lineNum">    1354 </span>                :            : #ifdef CONFIG_GENERIC_HARDIRQS
<span class="lineNum">    1355 </span>                :            :         /* IRQ handler threads */
<span class="lineNum">    1356 </span>                :            :         struct irqaction *irqaction;
<span class="lineNum">    1357 </span>                :            : #endif
<span class="lineNum">    1358 </span>                :            : 
<span class="lineNum">    1359 </span>                :            :         /* Protection of the PI data structures: */
<span class="lineNum">    1360 </span>                :            :         raw_spinlock_t pi_lock;
<span class="lineNum">    1361 </span>                :            : 
<span class="lineNum">    1362 </span>                :            : #ifdef CONFIG_RT_MUTEXES
<span class="lineNum">    1363 </span>                :            :         /* PI waiters blocked on a rt_mutex held by this task */
<span class="lineNum">    1364 </span>                :            :         struct plist_head pi_waiters;
<span class="lineNum">    1365 </span>                :            :         /* Deadlock detection and priority inheritance handling */
<span class="lineNum">    1366 </span>                :            :         struct rt_mutex_waiter *pi_blocked_on;
<span class="lineNum">    1367 </span>                :            : #endif
<span class="lineNum">    1368 </span>                :            : 
<span class="lineNum">    1369 </span>                :            : #ifdef CONFIG_DEBUG_MUTEXES
<span class="lineNum">    1370 </span>                :            :         /* mutex deadlock detection */
<span class="lineNum">    1371 </span>                :            :         struct mutex_waiter *blocked_on;
<span class="lineNum">    1372 </span>                :            : #endif
<span class="lineNum">    1373 </span>                :            : #ifdef CONFIG_TRACE_IRQFLAGS
<span class="lineNum">    1374 </span>                :            :         unsigned int irq_events;
<span class="lineNum">    1375 </span>                :            :         unsigned long hardirq_enable_ip;
<span class="lineNum">    1376 </span>                :            :         unsigned long hardirq_disable_ip;
<span class="lineNum">    1377 </span>                :            :         unsigned int hardirq_enable_event;
<span class="lineNum">    1378 </span>                :            :         unsigned int hardirq_disable_event;
<span class="lineNum">    1379 </span>                :            :         int hardirqs_enabled;
<span class="lineNum">    1380 </span>                :            :         int hardirq_context;
<span class="lineNum">    1381 </span>                :            :         unsigned long softirq_disable_ip;
<span class="lineNum">    1382 </span>                :            :         unsigned long softirq_enable_ip;
<span class="lineNum">    1383 </span>                :            :         unsigned int softirq_disable_event;
<span class="lineNum">    1384 </span>                :            :         unsigned int softirq_enable_event;
<span class="lineNum">    1385 </span>                :            :         int softirqs_enabled;
<span class="lineNum">    1386 </span>                :            :         int softirq_context;
<span class="lineNum">    1387 </span>                :            : #endif
<span class="lineNum">    1388 </span>                :            : #ifdef CONFIG_LOCKDEP
<span class="lineNum">    1389 </span>                :            : # define MAX_LOCK_DEPTH 48UL
<span class="lineNum">    1390 </span>                :            :         u64 curr_chain_key;
<span class="lineNum">    1391 </span>                :            :         int lockdep_depth;
<span class="lineNum">    1392 </span>                :            :         unsigned int lockdep_recursion;
<span class="lineNum">    1393 </span>                :            :         struct held_lock held_locks[MAX_LOCK_DEPTH];
<span class="lineNum">    1394 </span>                :            :         gfp_t lockdep_reclaim_gfp;
<span class="lineNum">    1395 </span>                :            : #endif
<span class="lineNum">    1396 </span>                :            : 
<span class="lineNum">    1397 </span>                :            : /* journalling filesystem info */
<span class="lineNum">    1398 </span>                :            :         void *journal_info;
<span class="lineNum">    1399 </span>                :            : 
<span class="lineNum">    1400 </span>                :            : /* stacked block device info */
<span class="lineNum">    1401 </span>                :            :         struct bio_list *bio_list;
<span class="lineNum">    1402 </span>                :            : 
<span class="lineNum">    1403 </span>                :            : /* VM state */
<span class="lineNum">    1404 </span>                :            :         struct reclaim_state *reclaim_state;
<span class="lineNum">    1405 </span>                :            : 
<span class="lineNum">    1406 </span>                :            :         struct backing_dev_info *backing_dev_info;
<span class="lineNum">    1407 </span>                :            : 
<span class="lineNum">    1408 </span>                :            :         struct io_context *io_context;
<span class="lineNum">    1409 </span>                :            : 
<span class="lineNum">    1410 </span>                :            :         unsigned long ptrace_message;
<span class="lineNum">    1411 </span>                :            :         siginfo_t *last_siginfo; /* For ptrace use.  */
<span class="lineNum">    1412 </span>                :            :         struct task_io_accounting ioac;
<span class="lineNum">    1413 </span>                :            : #if defined(CONFIG_TASK_XACCT)
<span class="lineNum">    1414 </span>                :            :         u64 acct_rss_mem1;      /* accumulated rss usage */
<span class="lineNum">    1415 </span>                :            :         u64 acct_vm_mem1;       /* accumulated virtual memory usage */
<span class="lineNum">    1416 </span>                :            :         cputime_t acct_timexpd; /* stime + utime since last update */
<span class="lineNum">    1417 </span>                :            : #endif
<span class="lineNum">    1418 </span>                :            : #ifdef CONFIG_CPUSETS
<span class="lineNum">    1419 </span>                :            :         nodemask_t mems_allowed;        /* Protected by alloc_lock */
<span class="lineNum">    1420 </span>                :            :         int mems_allowed_change_disable;
<span class="lineNum">    1421 </span>                :            :         int cpuset_mem_spread_rotor;
<span class="lineNum">    1422 </span>                :            :         int cpuset_slab_spread_rotor;
<span class="lineNum">    1423 </span>                :            : #endif
<span class="lineNum">    1424 </span>                :            : #ifdef CONFIG_CGROUPS
<span class="lineNum">    1425 </span>                :            :         /* Control Group info protected by css_set_lock */
<span class="lineNum">    1426 </span>                :            :         struct css_set *cgroups;
<span class="lineNum">    1427 </span>                :            :         /* cg_list protected by css_set_lock and tsk-&gt;alloc_lock */
<span class="lineNum">    1428 </span>                :            :         struct list_head cg_list;
<span class="lineNum">    1429 </span>                :            : #endif
<span class="lineNum">    1430 </span>                :            : #ifdef CONFIG_FUTEX
<span class="lineNum">    1431 </span>                :            :         struct robust_list_head __user *robust_list;
<span class="lineNum">    1432 </span>                :            : #ifdef CONFIG_COMPAT
<span class="lineNum">    1433 </span>                :            :         struct compat_robust_list_head __user *compat_robust_list;
<span class="lineNum">    1434 </span>                :            : #endif
<span class="lineNum">    1435 </span>                :            :         struct list_head pi_state_list;
<span class="lineNum">    1436 </span>                :            :         struct futex_pi_state *pi_state_cache;
<span class="lineNum">    1437 </span>                :            : #endif
<span class="lineNum">    1438 </span>                :            : #ifdef CONFIG_PERF_EVENTS
<span class="lineNum">    1439 </span>                :            :         struct perf_event_context *perf_event_ctxp;
<span class="lineNum">    1440 </span>                :            :         struct mutex perf_event_mutex;
<span class="lineNum">    1441 </span>                :            :         struct list_head perf_event_list;
<span class="lineNum">    1442 </span>                :            : #endif
<span class="lineNum">    1443 </span>                :            : #ifdef CONFIG_NUMA
<span class="lineNum">    1444 </span>                :            :         struct mempolicy *mempolicy;    /* Protected by alloc_lock */
<span class="lineNum">    1445 </span>                :            :         short il_next;
<span class="lineNum">    1446 </span>                :            : #endif
<span class="lineNum">    1447 </span>                :            :         atomic_t fs_excl;       /* holding fs exclusive resources */
<span class="lineNum">    1448 </span>                :            :         struct rcu_head rcu;
<span class="lineNum">    1449 </span>                :            : 
<span class="lineNum">    1450 </span>                :            :         /*
<span class="lineNum">    1451 </span>                :            :          * cache last used pipe for splice
<span class="lineNum">    1452 </span>                :            :          */
<span class="lineNum">    1453 </span>                :            :         struct pipe_inode_info *splice_pipe;
<span class="lineNum">    1454 </span>                :            : #ifdef  CONFIG_TASK_DELAY_ACCT
<span class="lineNum">    1455 </span>                :            :         struct task_delay_info *delays;
<span class="lineNum">    1456 </span>                :            : #endif
<span class="lineNum">    1457 </span>                :            : #ifdef CONFIG_FAULT_INJECTION
<span class="lineNum">    1458 </span>                :            :         int make_it_fail;
<span class="lineNum">    1459 </span>                :            : #endif
<span class="lineNum">    1460 </span>                :            :         struct prop_local_single dirties;
<span class="lineNum">    1461 </span>                :            : #ifdef CONFIG_LATENCYTOP
<span class="lineNum">    1462 </span>                :            :         int latency_record_count;
<span class="lineNum">    1463 </span>                :            :         struct latency_record latency_record[LT_SAVECOUNT];
<span class="lineNum">    1464 </span>                :            : #endif
<span class="lineNum">    1465 </span>                :            :         /*
<span class="lineNum">    1466 </span>                :            :          * time slack values; these are used to round up poll() and
<span class="lineNum">    1467 </span>                :            :          * select() etc timeout values. These are in nanoseconds.
<span class="lineNum">    1468 </span>                :            :          */
<span class="lineNum">    1469 </span>                :            :         unsigned long timer_slack_ns;
<span class="lineNum">    1470 </span>                :            :         unsigned long default_timer_slack_ns;
<span class="lineNum">    1471 </span>                :            : 
<span class="lineNum">    1472 </span>                :            :         struct list_head        *scm_work_list;
<span class="lineNum">    1473 </span>                :            : #ifdef CONFIG_FUNCTION_GRAPH_TRACER
<span class="lineNum">    1474 </span>                :            :         /* Index of current stored address in ret_stack */
<span class="lineNum">    1475 </span>                :            :         int curr_ret_stack;
<span class="lineNum">    1476 </span>                :            :         /* Stack of return addresses for return function tracing */
<span class="lineNum">    1477 </span>                :            :         struct ftrace_ret_stack *ret_stack;
<span class="lineNum">    1478 </span>                :            :         /* time stamp for last schedule */
<span class="lineNum">    1479 </span>                :            :         unsigned long long ftrace_timestamp;
<span class="lineNum">    1480 </span>                :            :         /*
<span class="lineNum">    1481 </span>                :            :          * Number of functions that haven't been traced
<span class="lineNum">    1482 </span>                :            :          * because of depth overrun.
<span class="lineNum">    1483 </span>                :            :          */
<span class="lineNum">    1484 </span>                :            :         atomic_t trace_overrun;
<span class="lineNum">    1485 </span>                :            :         /* Pause for the tracing */
<span class="lineNum">    1486 </span>                :            :         atomic_t tracing_graph_pause;
<span class="lineNum">    1487 </span>                :            : #endif
<span class="lineNum">    1488 </span>                :            : #ifdef CONFIG_TRACING
<span class="lineNum">    1489 </span>                :            :         /* state flags for use by tracers */
<span class="lineNum">    1490 </span>                :            :         unsigned long trace;
<span class="lineNum">    1491 </span>                :            :         /* bitmask of trace recursion */
<span class="lineNum">    1492 </span>                :            :         unsigned long trace_recursion;
<span class="lineNum">    1493 </span>                :            : #endif /* CONFIG_TRACING */
<span class="lineNum">    1494 </span>                :            : #ifdef CONFIG_CGROUP_MEM_RES_CTLR /* memcg uses this to do batch job */
<span class="lineNum">    1495 </span>                :            :         struct memcg_batch_info {
<span class="lineNum">    1496 </span>                :            :                 int do_batch;   /* incremented when batch uncharge started */
<span class="lineNum">    1497 </span>                :            :                 struct mem_cgroup *memcg; /* target memcg of uncharge */
<span class="lineNum">    1498 </span>                :            :                 unsigned long bytes;            /* uncharged usage */
<span class="lineNum">    1499 </span>                :            :                 unsigned long memsw_bytes; /* uncharged mem+swap usage */
<span class="lineNum">    1500 </span>                :            :         } memcg_batch;
<span class="lineNum">    1501 </span>                :            : #endif
<span class="lineNum">    1502 </span>                :            : };
<span class="lineNum">    1503 </span>                :            : 
<span class="lineNum">    1504 </span>                :            : /* Future-safe accessor for struct task_struct's cpus_allowed. */
<span class="lineNum">    1505 </span>                :            : #define tsk_cpus_allowed(tsk) (&amp;(tsk)-&gt;cpus_allowed)
<span class="lineNum">    1506 </span>                :            : 
<span class="lineNum">    1507 </span>                :            : /*
<span class="lineNum">    1508 </span>                :            :  * Priority of a process goes from 0..MAX_PRIO-1, valid RT
<span class="lineNum">    1509 </span>                :            :  * priority is 0..MAX_RT_PRIO-1, and SCHED_NORMAL/SCHED_BATCH
<span class="lineNum">    1510 </span>                :            :  * tasks are in the range MAX_RT_PRIO..MAX_PRIO-1. Priority
<span class="lineNum">    1511 </span>                :            :  * values are inverted: lower p-&gt;prio value means higher priority.
<span class="lineNum">    1512 </span>                :            :  *
<span class="lineNum">    1513 </span>                :            :  * The MAX_USER_RT_PRIO value allows the actual maximum
<span class="lineNum">    1514 </span>                :            :  * RT priority to be separate from the value exported to
<span class="lineNum">    1515 </span>                :            :  * user-space.  This allows kernel threads to set their
<span class="lineNum">    1516 </span>                :            :  * priority to a value higher than any user task. Note:
<span class="lineNum">    1517 </span>                :            :  * MAX_RT_PRIO must not be smaller than MAX_USER_RT_PRIO.
<span class="lineNum">    1518 </span>                :            :  */
<span class="lineNum">    1519 </span>                :            : 
<span class="lineNum">    1520 </span>                :            : #define MAX_USER_RT_PRIO        100
<span class="lineNum">    1521 </span>                :            : #define MAX_RT_PRIO             MAX_USER_RT_PRIO
<span class="lineNum">    1522 </span>                :            : 
<span class="lineNum">    1523 </span>                :            : #define MAX_PRIO                (MAX_RT_PRIO + 40)
<span class="lineNum">    1524 </span>                :            : #define DEFAULT_PRIO            (MAX_RT_PRIO + 20)
<span class="lineNum">    1525 </span>                :            : 
<span class="lineNum">    1526 </span>                :            : static inline int rt_prio(int prio)
<span class="lineNum">    1527 </span>                :            : {
<span class="lineNum">    1528 </span>                :            :         if (unlikely(prio &lt; MAX_RT_PRIO))
<span class="lineNum">    1529 </span>                :            :                 return 1;
<span class="lineNum">    1530 </span>                :            :         return 0;
<span class="lineNum">    1531 </span>                :            : }
<span class="lineNum">    1532 </span>                :            : 
<span class="lineNum">    1533 </span>                :            : static inline int rt_task(struct task_struct *p)
<span class="lineNum">    1534 </span>                :            : {
<span class="lineNum">    1535 </span>                :            :         return rt_prio(p-&gt;prio);
<span class="lineNum">    1536 </span>                :            : }
<span class="lineNum">    1537 </span>                :            : 
<span class="lineNum">    1538 </span>                :            : static inline struct pid *task_pid(struct task_struct *task)
<span class="lineNum">    1539 </span>                :            : {
<span class="lineNum">    1540 </span>                :            :         return task-&gt;pids[PIDTYPE_PID].pid;
<span class="lineNum">    1541 </span>                :            : }
<span class="lineNum">    1542 </span>                :            : 
<span class="lineNum">    1543 </span>                :            : static inline struct pid *task_tgid(struct task_struct *task)
<span class="lineNum">    1544 </span>                :            : {
<span class="lineNum">    1545 </span>                :            :         return task-&gt;group_leader-&gt;pids[PIDTYPE_PID].pid;
<span class="lineNum">    1546 </span>                :            : }
<span class="lineNum">    1547 </span>                :            : 
<span class="lineNum">    1548 </span>                :            : /*
<span class="lineNum">    1549 </span>                :            :  * Without tasklist or rcu lock it is not safe to dereference
<span class="lineNum">    1550 </span>                :            :  * the result of task_pgrp/task_session even if task == current,
<span class="lineNum">    1551 </span>                :            :  * we can race with another thread doing sys_setsid/sys_setpgid.
<span class="lineNum">    1552 </span>                :            :  */
<span class="lineNum">    1553 </span>                :            : static inline struct pid *task_pgrp(struct task_struct *task)
<span class="lineNum">    1554 </span>                :            : {
<span class="lineNum">    1555 </span>                :            :         return task-&gt;group_leader-&gt;pids[PIDTYPE_PGID].pid;
<span class="lineNum">    1556 </span>                :            : }
<span class="lineNum">    1557 </span>                :            : 
<span class="lineNum">    1558 </span>                :            : static inline struct pid *task_session(struct task_struct *task)
<span class="lineNum">    1559 </span>                :            : {
<span class="lineNum">    1560 </span>                :            :         return task-&gt;group_leader-&gt;pids[PIDTYPE_SID].pid;
<span class="lineNum">    1561 </span>                :            : }
<span class="lineNum">    1562 </span>                :            : 
<span class="lineNum">    1563 </span>                :            : struct pid_namespace;
<span class="lineNum">    1564 </span>                :            : 
<span class="lineNum">    1565 </span>                :            : /*
<span class="lineNum">    1566 </span>                :            :  * the helpers to get the task's different pids as they are seen
<span class="lineNum">    1567 </span>                :            :  * from various namespaces
<span class="lineNum">    1568 </span>                :            :  *
<span class="lineNum">    1569 </span>                :            :  * task_xid_nr()     : global id, i.e. the id seen from the init namespace;
<span class="lineNum">    1570 </span>                :            :  * task_xid_vnr()    : virtual id, i.e. the id seen from the pid namespace of
<span class="lineNum">    1571 </span>                :            :  *                     current.
<span class="lineNum">    1572 </span>                :            :  * task_xid_nr_ns()  : id seen from the ns specified;
<span class="lineNum">    1573 </span>                :            :  *
<span class="lineNum">    1574 </span>                :            :  * set_task_vxid()   : assigns a virtual id to a task;
<span class="lineNum">    1575 </span>                :            :  *
<span class="lineNum">    1576 </span>                :            :  * see also pid_nr() etc in include/linux/pid.h
<span class="lineNum">    1577 </span>                :            :  */
<span class="lineNum">    1578 </span>                :            : pid_t __task_pid_nr_ns(struct task_struct *task, enum pid_type type,
<span class="lineNum">    1579 </span>                :            :                         struct pid_namespace *ns);
<span class="lineNum">    1580 </span>                :            : 
<span class="lineNum">    1581 </span>                :            : static inline pid_t task_pid_nr(struct task_struct *tsk)
<span class="lineNum">    1582 </span>                :            : {
<span class="lineNum">    1583 </span>                :            :         return tsk-&gt;pid;
<span class="lineNum">    1584 </span>                :            : }
<span class="lineNum">    1585 </span>                :            : 
<span class="lineNum">    1586 </span>                :            : static inline pid_t task_pid_nr_ns(struct task_struct *tsk,
<span class="lineNum">    1587 </span>                :            :                                         struct pid_namespace *ns)
<span class="lineNum">    1588 </span>                :            : {
<span class="lineNum">    1589 </span>                :            :         return __task_pid_nr_ns(tsk, PIDTYPE_PID, ns);
<span class="lineNum">    1590 </span>                :            : }
<span class="lineNum">    1591 </span>                :            : 
<span class="lineNum">    1592 </span>                :            : static inline pid_t task_pid_vnr(struct task_struct *tsk)
<span class="lineNum">    1593 </span>                :            : {
<span class="lineNum">    1594 </span>                :            :         return __task_pid_nr_ns(tsk, PIDTYPE_PID, NULL);
<span class="lineNum">    1595 </span>                :            : }
<span class="lineNum">    1596 </span>                :            : 
<span class="lineNum">    1597 </span>                :            : 
<span class="lineNum">    1598 </span>                :            : static inline pid_t task_tgid_nr(struct task_struct *tsk)
<span class="lineNum">    1599 </span>                :            : {
<span class="lineNum">    1600 </span>                :            :         return tsk-&gt;tgid;
<span class="lineNum">    1601 </span>                :            : }
<span class="lineNum">    1602 </span>                :            : 
<span class="lineNum">    1603 </span>                :            : pid_t task_tgid_nr_ns(struct task_struct *tsk, struct pid_namespace *ns);
<span class="lineNum">    1604 </span>                :            : 
<span class="lineNum">    1605 </span>                :            : static inline pid_t task_tgid_vnr(struct task_struct *tsk)
<span class="lineNum">    1606 </span>                :            : {
<span class="lineNum">    1607 </span>                :            :         return pid_vnr(task_tgid(tsk));
<span class="lineNum">    1608 </span>                :            : }
<span class="lineNum">    1609 </span>                :            : 
<span class="lineNum">    1610 </span>                :            : 
<span class="lineNum">    1611 </span>                :            : static inline pid_t task_pgrp_nr_ns(struct task_struct *tsk,
<span class="lineNum">    1612 </span>                :            :                                         struct pid_namespace *ns)
<span class="lineNum">    1613 </span>                :            : {
<span class="lineNum">    1614 </span>                :            :         return __task_pid_nr_ns(tsk, PIDTYPE_PGID, ns);
<span class="lineNum">    1615 </span>                :            : }
<span class="lineNum">    1616 </span>                :            : 
<span class="lineNum">    1617 </span>                :            : static inline pid_t task_pgrp_vnr(struct task_struct *tsk)
<span class="lineNum">    1618 </span>                :            : {
<span class="lineNum">    1619 </span>                :            :         return __task_pid_nr_ns(tsk, PIDTYPE_PGID, NULL);
<span class="lineNum">    1620 </span>                :            : }
<span class="lineNum">    1621 </span>                :            : 
<span class="lineNum">    1622 </span>                :            : 
<span class="lineNum">    1623 </span>                :            : static inline pid_t task_session_nr_ns(struct task_struct *tsk,
<span class="lineNum">    1624 </span>                :            :                                         struct pid_namespace *ns)
<span class="lineNum">    1625 </span>                :            : {
<span class="lineNum">    1626 </span>                :            :         return __task_pid_nr_ns(tsk, PIDTYPE_SID, ns);
<span class="lineNum">    1627 </span>                :            : }
<span class="lineNum">    1628 </span>                :            : 
<span class="lineNum">    1629 </span>                :            : static inline pid_t task_session_vnr(struct task_struct *tsk)
<span class="lineNum">    1630 </span>                :            : {
<span class="lineNum">    1631 </span>                :            :         return __task_pid_nr_ns(tsk, PIDTYPE_SID, NULL);
<span class="lineNum">    1632 </span>                :            : }
<span class="lineNum">    1633 </span>                :            : 
<span class="lineNum">    1634 </span>                :            : /* obsolete, do not use */
<span class="lineNum">    1635 </span>                :            : static inline pid_t task_pgrp_nr(struct task_struct *tsk)
<span class="lineNum">    1636 </span>                :            : {
<span class="lineNum">    1637 </span>                :            :         return task_pgrp_nr_ns(tsk, &amp;init_pid_ns);
<span class="lineNum">    1638 </span>                :            : }
<span class="lineNum">    1639 </span>                :            : 
<span class="lineNum">    1640 </span>                :            : /**
<span class="lineNum">    1641 </span>                :            :  * pid_alive - check that a task structure is not stale
<span class="lineNum">    1642 </span>                :            :  * @p: Task structure to be checked.
<span class="lineNum">    1643 </span>                :            :  *
<span class="lineNum">    1644 </span>                :            :  * Test if a process is not yet dead (at most zombie state)
<span class="lineNum">    1645 </span>                :            :  * If pid_alive fails, then pointers within the task structure
<span class="lineNum">    1646 </span>                :            :  * can be stale and must not be dereferenced.
<span class="lineNum">    1647 </span>                :            :  */
<span class="lineNum">    1648 </span>                :            : static inline int pid_alive(struct task_struct *p)
<span class="lineNum">    1649 </span>                :            : {
<span class="lineNum">    1650 </span>                :            :         return p-&gt;pids[PIDTYPE_PID].pid != NULL;
<span class="lineNum">    1651 </span>                :            : }
<span class="lineNum">    1652 </span>                :            : 
<span class="lineNum">    1653 </span>                :            : /**
<span class="lineNum">    1654 </span>                :            :  * is_global_init - check if a task structure is init
<span class="lineNum">    1655 </span>                :            :  * @tsk: Task structure to be checked.
<span class="lineNum">    1656 </span>                :            :  *
<span class="lineNum">    1657 </span>                :            :  * Check if a task structure is the first user space task the kernel created.
<span class="lineNum">    1658 </span>                :            :  */
<span class="lineNum">    1659 </span>                :            : static inline int is_global_init(struct task_struct *tsk)
<span class="lineNum">    1660 </span>                :            : {
<span class="lineNum">    1661 </span>                :            :         return tsk-&gt;pid == 1;
<span class="lineNum">    1662 </span>                :            : }
<span class="lineNum">    1663 </span>                :            : 
<span class="lineNum">    1664 </span>                :            : /*
<span class="lineNum">    1665 </span>                :            :  * is_container_init:
<span class="lineNum">    1666 </span>                :            :  * check whether in the task is init in its own pid namespace.
<span class="lineNum">    1667 </span>                :            :  */
<span class="lineNum">    1668 </span>                :            : extern int is_container_init(struct task_struct *tsk);
<span class="lineNum">    1669 </span>                :            : 
<span class="lineNum">    1670 </span>                :            : extern struct pid *cad_pid;
<span class="lineNum">    1671 </span>                :            : 
<span class="lineNum">    1672 </span>                :            : extern void free_task(struct task_struct *tsk);
<span class="lineNum">    1673 </span>                :            : #define get_task_struct(tsk) do { atomic_inc(&amp;(tsk)-&gt;usage); } while(0)
<span class="lineNum">    1674 </span>                :            : 
<span class="lineNum">    1675 </span>                :            : extern void __put_task_struct(struct task_struct *t);
<span class="lineNum">    1676 </span>                :            : 
<span class="lineNum">    1677 </span>                :            : static inline void put_task_struct(struct task_struct *t)
<span class="lineNum">    1678 </span>                :            : {
<span class="lineNum">    1679 </span>                :            :         if (atomic_dec_and_test(&amp;t-&gt;usage))
<span class="lineNum">    1680 </span>                :            :                 __put_task_struct(t);
<span class="lineNum">    1681 </span>                :            : }
<span class="lineNum">    1682 </span>                :            : 
<span class="lineNum">    1683 </span>                :            : extern void task_times(struct task_struct *p, cputime_t *ut, cputime_t *st);
<span class="lineNum">    1684 </span>                :            : extern void thread_group_times(struct task_struct *p, cputime_t *ut, cputime_t *st);
<span class="lineNum">    1685 </span>                :            : 
<span class="lineNum">    1686 </span>                :            : extern int task_free_register(struct notifier_block *n);
<span class="lineNum">    1687 </span>                :            : extern int task_free_unregister(struct notifier_block *n);
<span class="lineNum">    1688 </span>                :            : 
<span class="lineNum">    1689 </span>                :            : /*
<span class="lineNum">    1690 </span>                :            :  * Per process flags
<span class="lineNum">    1691 </span>                :            :  */
<span class="lineNum">    1692 </span>                :            : #define PF_ALIGNWARN    0x00000001      /* Print alignment warning msgs */
<span class="lineNum">    1693 </span>                :            :                                         /* Not implemented yet, only for 486*/
<span class="lineNum">    1694 </span>                :            : #define PF_STARTING     0x00000002      /* being created */
<span class="lineNum">    1695 </span>                :            : #define PF_EXITING      0x00000004      /* getting shut down */
<span class="lineNum">    1696 </span>                :            : #define PF_EXITPIDONE   0x00000008      /* pi exit done on shut down */
<span class="lineNum">    1697 </span>                :            : #define PF_VCPU         0x00000010      /* I'm a virtual CPU */
<span class="lineNum">    1698 </span>                :            : #define PF_FORKNOEXEC   0x00000040      /* forked but didn't exec */
<span class="lineNum">    1699 </span>                :            : #define PF_MCE_PROCESS  0x00000080      /* process policy on mce errors */
<span class="lineNum">    1700 </span>                :            : #define PF_SUPERPRIV    0x00000100      /* used super-user privileges */
<span class="lineNum">    1701 </span>                :            : #define PF_DUMPCORE     0x00000200      /* dumped core */
<span class="lineNum">    1702 </span>                :            : #define PF_SIGNALED     0x00000400      /* killed by a signal */
<span class="lineNum">    1703 </span>                :            : #define PF_MEMALLOC     0x00000800      /* Allocating memory */
<span class="lineNum">    1704 </span>                :            : #define PF_FLUSHER      0x00001000      /* responsible for disk writeback */
<span class="lineNum">    1705 </span>                :            : #define PF_USED_MATH    0x00002000      /* if unset the fpu must be initialized before use */
<span class="lineNum">    1706 </span>                :            : #define PF_FREEZING     0x00004000      /* freeze in progress. do not account to load */
<span class="lineNum">    1707 </span>                :            : #define PF_NOFREEZE     0x00008000      /* this thread should not be frozen */
<span class="lineNum">    1708 </span>                :            : #define PF_FROZEN       0x00010000      /* frozen for system suspend */
<span class="lineNum">    1709 </span>                :            : #define PF_FSTRANS      0x00020000      /* inside a filesystem transaction */
<span class="lineNum">    1710 </span>                :            : #define PF_KSWAPD       0x00040000      /* I am kswapd */
<span class="lineNum">    1711 </span>                :            : #define PF_OOM_ORIGIN   0x00080000      /* Allocating much memory to others */
<span class="lineNum">    1712 </span>                :            : #define PF_LESS_THROTTLE 0x00100000     /* Throttle me less: I clean memory */
<span class="lineNum">    1713 </span>                :            : #define PF_KTHREAD      0x00200000      /* I am a kernel thread */
<span class="lineNum">    1714 </span>                :            : #define PF_RANDOMIZE    0x00400000      /* randomize virtual address space */
<span class="lineNum">    1715 </span>                :            : #define PF_SWAPWRITE    0x00800000      /* Allowed to write to swap */
<span class="lineNum">    1716 </span>                :            : #define PF_SPREAD_PAGE  0x01000000      /* Spread page cache over cpuset */
<span class="lineNum">    1717 </span>                :            : #define PF_SPREAD_SLAB  0x02000000      /* Spread some slab caches over cpuset */
<span class="lineNum">    1718 </span>                :            : #define PF_THREAD_BOUND 0x04000000      /* Thread bound to specific cpu */
<span class="lineNum">    1719 </span>                :            : #define PF_MCE_EARLY    0x08000000      /* Early kill for mce process policy */
<span class="lineNum">    1720 </span>                :            : #define PF_MEMPOLICY    0x10000000      /* Non-default NUMA mempolicy */
<span class="lineNum">    1721 </span>                :            : #define PF_MUTEX_TESTER 0x20000000      /* Thread belongs to the rt mutex tester */
<span class="lineNum">    1722 </span>                :            : #define PF_FREEZER_SKIP 0x40000000      /* Freezer should not count it as freezeable */
<span class="lineNum">    1723 </span>                :            : #define PF_FREEZER_NOSIG 0x80000000     /* Freezer won't send signals to it */
<span class="lineNum">    1724 </span>                :            : 
<span class="lineNum">    1725 </span>                :            : /*
<span class="lineNum">    1726 </span>                :            :  * Only the _current_ task can read/write to tsk-&gt;flags, but other
<span class="lineNum">    1727 </span>                :            :  * tasks can access tsk-&gt;flags in readonly mode for example
<span class="lineNum">    1728 </span>                :            :  * with tsk_used_math (like during threaded core dumping).
<span class="lineNum">    1729 </span>                :            :  * There is however an exception to this rule during ptrace
<span class="lineNum">    1730 </span>                :            :  * or during fork: the ptracer task is allowed to write to the
<span class="lineNum">    1731 </span>                :            :  * child-&gt;flags of its traced child (same goes for fork, the parent
<span class="lineNum">    1732 </span>                :            :  * can write to the child-&gt;flags), because we're guaranteed the
<span class="lineNum">    1733 </span>                :            :  * child is not running and in turn not changing child-&gt;flags
<span class="lineNum">    1734 </span>                :            :  * at the same time the parent does it.
<span class="lineNum">    1735 </span>                :            :  */
<span class="lineNum">    1736 </span>                :            : #define clear_stopped_child_used_math(child) do { (child)-&gt;flags &amp;= ~PF_USED_MATH; } while (0)
<span class="lineNum">    1737 </span>                :            : #define set_stopped_child_used_math(child) do { (child)-&gt;flags |= PF_USED_MATH; } while (0)
<span class="lineNum">    1738 </span>                :            : #define clear_used_math() clear_stopped_child_used_math(current)
<span class="lineNum">    1739 </span>                :            : #define set_used_math() set_stopped_child_used_math(current)
<span class="lineNum">    1740 </span>                :            : #define conditional_stopped_child_used_math(condition, child) \
<span class="lineNum">    1741 </span>                :            :         do { (child)-&gt;flags &amp;= ~PF_USED_MATH, (child)-&gt;flags |= (condition) ? PF_USED_MATH : 0; } while (0)
<span class="lineNum">    1742 </span>                :            : #define conditional_used_math(condition) \
<span class="lineNum">    1743 </span>                :            :         conditional_stopped_child_used_math(condition, current)
<span class="lineNum">    1744 </span>                :            : #define copy_to_stopped_child_used_math(child) \
<span class="lineNum">    1745 </span>                :            :         do { (child)-&gt;flags &amp;= ~PF_USED_MATH, (child)-&gt;flags |= current-&gt;flags &amp; PF_USED_MATH; } while (0)
<span class="lineNum">    1746 </span>                :            : /* NOTE: this will return 0 or PF_USED_MATH, it will never return 1 */
<span class="lineNum">    1747 </span>                :            : #define tsk_used_math(p) ((p)-&gt;flags &amp; PF_USED_MATH)
<span class="lineNum">    1748 </span>                :            : #define used_math() tsk_used_math(current)
<span class="lineNum">    1749 </span>                :            : 
<span class="lineNum">    1750 </span>                :            : #ifdef CONFIG_TREE_PREEMPT_RCU
<span class="lineNum">    1751 </span>                :            : 
<span class="lineNum">    1752 </span>                :            : #define RCU_READ_UNLOCK_BLOCKED (1 &lt;&lt; 0) /* blocked while in RCU read-side. */
<span class="lineNum">    1753 </span>                :            : #define RCU_READ_UNLOCK_NEED_QS (1 &lt;&lt; 1) /* RCU core needs CPU response. */
<span class="lineNum">    1754 </span>                :            : 
<span class="lineNum">    1755 </span>                :            : static inline void rcu_copy_process(struct task_struct *p)
<span class="lineNum">    1756 </span>                :            : {
<span class="lineNum">    1757 </span>                :            :         p-&gt;rcu_read_lock_nesting = 0;
<span class="lineNum">    1758 </span>                :            :         p-&gt;rcu_read_unlock_special = 0;
<span class="lineNum">    1759 </span>                :            :         p-&gt;rcu_blocked_node = NULL;
<span class="lineNum">    1760 </span>                :            :         INIT_LIST_HEAD(&amp;p-&gt;rcu_node_entry);
<span class="lineNum">    1761 </span>                :            : }
<span class="lineNum">    1762 </span>                :            : 
<span class="lineNum">    1763 </span>                :            : #else
<span class="lineNum">    1764 </span>                :            : 
<span class="lineNum">    1765 </span>                :            : static inline void rcu_copy_process(struct task_struct *p)
<span class="lineNum">    1766 </span>                :            : {
<span class="lineNum">    1767 </span>                :            : }
<span class="lineNum">    1768 </span>                :            : 
<span class="lineNum">    1769 </span>                :            : #endif
<span class="lineNum">    1770 </span>                :            : 
<span class="lineNum">    1771 </span>                :            : #ifdef CONFIG_SMP
<span class="lineNum">    1772 </span>                :            : extern int set_cpus_allowed_ptr(struct task_struct *p,
<span class="lineNum">    1773 </span>                :            :                                 const struct cpumask *new_mask);
<span class="lineNum">    1774 </span>                :            : #else
<span class="lineNum">    1775 </span>                :            : static inline int set_cpus_allowed_ptr(struct task_struct *p,
<span class="lineNum">    1776 </span>                :            :                                        const struct cpumask *new_mask)
<span class="lineNum">    1777 </span>                :            : {
<span class="lineNum">    1778 </span>                :            :         if (!cpumask_test_cpu(0, new_mask))
<span class="lineNum">    1779 </span>                :            :                 return -EINVAL;
<span class="lineNum">    1780 </span>                :            :         return 0;
<span class="lineNum">    1781 </span>                :            : }
<span class="lineNum">    1782 </span>                :            : #endif
<span class="lineNum">    1783 </span>                :            : 
<span class="lineNum">    1784 </span>                :            : #ifndef CONFIG_CPUMASK_OFFSTACK
<span class="lineNum">    1785 </span>                :            : static inline int set_cpus_allowed(struct task_struct *p, cpumask_t new_mask)
<span class="lineNum">    1786 </span>                :            : {
<span class="lineNum">    1787 </span>                :            :         return set_cpus_allowed_ptr(p, &amp;new_mask);
<span class="lineNum">    1788 </span>                :            : }
<span class="lineNum">    1789 </span>                :            : #endif
<span class="lineNum">    1790 </span>                :            : 
<span class="lineNum">    1791 </span>                :            : /*
<span class="lineNum">    1792 </span>                :            :  * Architectures can set this to 1 if they have specified
<span class="lineNum">    1793 </span>                :            :  * CONFIG_HAVE_UNSTABLE_SCHED_CLOCK in their arch Kconfig,
<span class="lineNum">    1794 </span>                :            :  * but then during bootup it turns out that sched_clock()
<span class="lineNum">    1795 </span>                :            :  * is reliable after all:
<span class="lineNum">    1796 </span>                :            :  */
<span class="lineNum">    1797 </span>                :            : #ifdef CONFIG_HAVE_UNSTABLE_SCHED_CLOCK
<span class="lineNum">    1798 </span>                :            : extern int sched_clock_stable;
<span class="lineNum">    1799 </span>                :            : #endif
<span class="lineNum">    1800 </span>                :            : 
<span class="lineNum">    1801 </span>                :            : /* ftrace calls sched_clock() directly */
<span class="lineNum">    1802 </span>                :            : extern unsigned long long notrace sched_clock(void);
<span class="lineNum">    1803 </span>                :            : 
<span class="lineNum">    1804 </span>                :            : extern void sched_clock_init(void);
<span class="lineNum">    1805 </span>                :            : extern u64 sched_clock_cpu(int cpu);
<span class="lineNum">    1806 </span>                :            : 
<span class="lineNum">    1807 </span>                :            : #ifndef CONFIG_HAVE_UNSTABLE_SCHED_CLOCK
<span class="lineNum">    1808 </span>                :            : static inline void sched_clock_tick(void)
<span class="lineNum">    1809 </span>                :            : {
<span class="lineNum">    1810 </span>                :            : }
<span class="lineNum">    1811 </span>                :            : 
<span class="lineNum">    1812 </span>                :            : static inline void sched_clock_idle_sleep_event(void)
<span class="lineNum">    1813 </span>                :            : {
<span class="lineNum">    1814 </span>                :            : }
<span class="lineNum">    1815 </span>                :            : 
<span class="lineNum">    1816 </span>                :            : static inline void sched_clock_idle_wakeup_event(u64 delta_ns)
<span class="lineNum">    1817 </span>                :            : {
<span class="lineNum">    1818 </span>                :            : }
<span class="lineNum">    1819 </span>                :            : #else
<span class="lineNum">    1820 </span>                :            : extern void sched_clock_tick(void);
<span class="lineNum">    1821 </span>                :            : extern void sched_clock_idle_sleep_event(void);
<span class="lineNum">    1822 </span>                :            : extern void sched_clock_idle_wakeup_event(u64 delta_ns);
<span class="lineNum">    1823 </span>                :            : #endif
<span class="lineNum">    1824 </span>                :            : 
<span class="lineNum">    1825 </span>                :            : /*
<span class="lineNum">    1826 </span>                :            :  * For kernel-internal use: high-speed (but slightly incorrect) per-cpu
<span class="lineNum">    1827 </span>                :            :  * clock constructed from sched_clock():
<span class="lineNum">    1828 </span>                :            :  */
<span class="lineNum">    1829 </span>                :            : extern unsigned long long cpu_clock(int cpu);
<span class="lineNum">    1830 </span>                :            : 
<span class="lineNum">    1831 </span>                :            : extern unsigned long long
<span class="lineNum">    1832 </span>                :            : task_sched_runtime(struct task_struct *task);
<span class="lineNum">    1833 </span>                :            : extern unsigned long long thread_group_sched_runtime(struct task_struct *task);
<span class="lineNum">    1834 </span>                :            : 
<span class="lineNum">    1835 </span>                :            : /* sched_exec is called by processes performing an exec */
<span class="lineNum">    1836 </span>                :            : #ifdef CONFIG_SMP
<span class="lineNum">    1837 </span>                :            : extern void sched_exec(void);
<span class="lineNum">    1838 </span>                :            : #else
<span class="lineNum">    1839 </span>                :            : #define sched_exec()   {}
<span class="lineNum">    1840 </span>                :            : #endif
<span class="lineNum">    1841 </span>                :            : 
<span class="lineNum">    1842 </span>                :            : extern void sched_clock_idle_sleep_event(void);
<span class="lineNum">    1843 </span>                :            : extern void sched_clock_idle_wakeup_event(u64 delta_ns);
<span class="lineNum">    1844 </span>                :            : 
<span class="lineNum">    1845 </span>                :            : #ifdef CONFIG_HOTPLUG_CPU
<span class="lineNum">    1846 </span>                :            : extern void move_task_off_dead_cpu(int dead_cpu, struct task_struct *p);
<span class="lineNum">    1847 </span>                :            : extern void idle_task_exit(void);
<span class="lineNum">    1848 </span>                :            : #else
<span class="lineNum">    1849 </span>                :            : static inline void idle_task_exit(void) {}
<span class="lineNum">    1850 </span>                :            : #endif
<span class="lineNum">    1851 </span>                :            : 
<span class="lineNum">    1852 </span>                :            : extern void sched_idle_next(void);
<span class="lineNum">    1853 </span>                :            : 
<span class="lineNum">    1854 </span>                :            : #if defined(CONFIG_NO_HZ) &amp;&amp; defined(CONFIG_SMP)
<span class="lineNum">    1855 </span>                :            : extern void wake_up_idle_cpu(int cpu);
<span class="lineNum">    1856 </span>                :            : #else
<span class="lineNum">    1857 </span>                :            : static inline void wake_up_idle_cpu(int cpu) { }
<span class="lineNum">    1858 </span>                :            : #endif
<span class="lineNum">    1859 </span>                :            : 
<span class="lineNum">    1860 </span>                :            : extern unsigned int sysctl_sched_latency;
<span class="lineNum">    1861 </span>                :            : extern unsigned int sysctl_sched_min_granularity;
<span class="lineNum">    1862 </span>                :            : extern unsigned int sysctl_sched_wakeup_granularity;
<span class="lineNum">    1863 </span>                :            : extern unsigned int sysctl_sched_shares_ratelimit;
<span class="lineNum">    1864 </span>                :            : extern unsigned int sysctl_sched_shares_thresh;
<span class="lineNum">    1865 </span>                :            : extern unsigned int sysctl_sched_child_runs_first;
<span class="lineNum">    1866 </span>                :            : 
<span class="lineNum">    1867 </span>                :            : enum sched_tunable_scaling {
<span class="lineNum">    1868 </span>                :            :         SCHED_TUNABLESCALING_NONE,
<span class="lineNum">    1869 </span>                :            :         SCHED_TUNABLESCALING_LOG,
<span class="lineNum">    1870 </span>                :            :         SCHED_TUNABLESCALING_LINEAR,
<span class="lineNum">    1871 </span>                :            :         SCHED_TUNABLESCALING_END,
<span class="lineNum">    1872 </span>                :            : };
<span class="lineNum">    1873 </span>                :            : extern enum sched_tunable_scaling sysctl_sched_tunable_scaling;
<span class="lineNum">    1874 </span>                :            : 
<span class="lineNum">    1875 </span>                :            : #ifdef CONFIG_SCHED_DEBUG
<span class="lineNum">    1876 </span>                :            : extern unsigned int sysctl_sched_migration_cost;
<span class="lineNum">    1877 </span>                :            : extern unsigned int sysctl_sched_nr_migrate;
<span class="lineNum">    1878 </span>                :            : extern unsigned int sysctl_sched_time_avg;
<span class="lineNum">    1879 </span>                :            : extern unsigned int sysctl_timer_migration;
<span class="lineNum">    1880 </span>                :            : 
<span class="lineNum">    1881 </span>                :            : int sched_proc_update_handler(struct ctl_table *table, int write,
<span class="lineNum">    1882 </span>                :            :                 void __user *buffer, size_t *length,
<span class="lineNum">    1883 </span>                :            :                 loff_t *ppos);
<span class="lineNum">    1884 </span>                :            : #endif
<span class="lineNum">    1885 </span>                :            : #ifdef CONFIG_SCHED_DEBUG
<span class="lineNum">    1886 </span>                :            : static inline unsigned int get_sysctl_timer_migration(void)
<span class="lineNum">    1887 </span>                :            : {
<span class="lineNum">    1888 </span>                :            :         return sysctl_timer_migration;
<span class="lineNum">    1889 </span>                :            : }
<span class="lineNum">    1890 </span>                :            : #else
<span class="lineNum">    1891 </span>                :            : static inline unsigned int get_sysctl_timer_migration(void)
<span class="lineNum">    1892 </span>                :            : {
<span class="lineNum">    1893 </span>                :            :         return 1;
<span class="lineNum">    1894 </span>                :            : }
<span class="lineNum">    1895 </span>                :            : #endif
<span class="lineNum">    1896 </span>                :            : extern unsigned int sysctl_sched_rt_period;
<span class="lineNum">    1897 </span>                :            : extern int sysctl_sched_rt_runtime;
<span class="lineNum">    1898 </span>                :            : 
<span class="lineNum">    1899 </span>                :            : int sched_rt_handler(struct ctl_table *table, int write,
<span class="lineNum">    1900 </span>                :            :                 void __user *buffer, size_t *lenp,
<span class="lineNum">    1901 </span>                :            :                 loff_t *ppos);
<span class="lineNum">    1902 </span>                :            : 
<span class="lineNum">    1903 </span>                :            : extern unsigned int sysctl_sched_compat_yield;
<span class="lineNum">    1904 </span>                :            : 
<span class="lineNum">    1905 </span>                :            : #ifdef CONFIG_RT_MUTEXES
<span class="lineNum">    1906 </span>                :            : extern int rt_mutex_getprio(struct task_struct *p);
<span class="lineNum">    1907 </span>                :            : extern void rt_mutex_setprio(struct task_struct *p, int prio);
<span class="lineNum">    1908 </span>                :            : extern void rt_mutex_adjust_pi(struct task_struct *p);
<span class="lineNum">    1909 </span>                :            : #else
<span class="lineNum">    1910 </span>                :            : static inline int rt_mutex_getprio(struct task_struct *p)
<span class="lineNum">    1911 </span>                :            : {
<span class="lineNum">    1912 </span>                :            :         return p-&gt;normal_prio;
<span class="lineNum">    1913 </span>                :            : }
<span class="lineNum">    1914 </span>                :            : # define rt_mutex_adjust_pi(p)          do { } while (0)
<span class="lineNum">    1915 </span>                :            : #endif
<span class="lineNum">    1916 </span>                :            : 
<span class="lineNum">    1917 </span>                :            : extern void set_user_nice(struct task_struct *p, long nice);
<span class="lineNum">    1918 </span>                :            : extern int task_prio(const struct task_struct *p);
<span class="lineNum">    1919 </span>                :            : extern int task_nice(const struct task_struct *p);
<span class="lineNum">    1920 </span>                :            : extern int can_nice(const struct task_struct *p, const int nice);
<span class="lineNum">    1921 </span>                :            : extern int task_curr(const struct task_struct *p);
<span class="lineNum">    1922 </span>                :            : extern int idle_cpu(int cpu);
<span class="lineNum">    1923 </span>                :            : extern int sched_setscheduler(struct task_struct *, int, struct sched_param *);
<span class="lineNum">    1924 </span>                :            : extern int sched_setscheduler_nocheck(struct task_struct *, int,
<span class="lineNum">    1925 </span>                :            :                                       struct sched_param *);
<span class="lineNum">    1926 </span>                :            : extern struct task_struct *idle_task(int cpu);
<span class="lineNum">    1927 </span>                :            : extern struct task_struct *curr_task(int cpu);
<span class="lineNum">    1928 </span>                :            : extern void set_curr_task(int cpu, struct task_struct *p);
<span class="lineNum">    1929 </span>                :            : 
<span class="lineNum">    1930 </span>                :            : void yield(void);
<span class="lineNum">    1931 </span>                :            : 
<span class="lineNum">    1932 </span>                :            : /*
<span class="lineNum">    1933 </span>                :            :  * The default (Linux) execution domain.
<span class="lineNum">    1934 </span>                :            :  */
<span class="lineNum">    1935 </span>                :            : extern struct exec_domain       default_exec_domain;
<span class="lineNum">    1936 </span>                :            : 
<span class="lineNum">    1937 </span>                :            : union thread_union {
<span class="lineNum">    1938 </span>                :            :         struct thread_info thread_info;
<span class="lineNum">    1939 </span>                :            :         unsigned long stack[THREAD_SIZE/sizeof(long)];
<span class="lineNum">    1940 </span>                :            : };
<span class="lineNum">    1941 </span>                :            : 
<span class="lineNum">    1942 </span>                :            : #ifndef __HAVE_ARCH_KSTACK_END
<span class="lineNum">    1943 </span>                :            : static inline int kstack_end(void *addr)
<span class="lineNum">    1944 </span>                :            : {
<span class="lineNum">    1945 </span>                :            :         /* Reliable end of stack detection:
<span class="lineNum">    1946 </span>                :            :          * Some APM bios versions misalign the stack
<span class="lineNum">    1947 </span>                :            :          */
<span class="lineNum">    1948 </span>                :            :         return !(((unsigned long)addr+sizeof(void*)-1) &amp; (THREAD_SIZE-sizeof(void*)));
<span class="lineNum">    1949 </span>                :            : }
<span class="lineNum">    1950 </span>                :            : #endif
<span class="lineNum">    1951 </span>                :            : 
<span class="lineNum">    1952 </span>                :            : extern union thread_union init_thread_union;
<span class="lineNum">    1953 </span>                :            : extern struct task_struct init_task;
<span class="lineNum">    1954 </span>                :            : 
<span class="lineNum">    1955 </span>                :            : extern struct   mm_struct init_mm;
<span class="lineNum">    1956 </span>                :            : 
<span class="lineNum">    1957 </span>                :            : extern struct pid_namespace init_pid_ns;
<span class="lineNum">    1958 </span>                :            : 
<span class="lineNum">    1959 </span>                :            : /*
<span class="lineNum">    1960 </span>                :            :  * find a task by one of its numerical ids
<span class="lineNum">    1961 </span>                :            :  *
<span class="lineNum">    1962 </span>                :            :  * find_task_by_pid_ns():
<span class="lineNum">    1963 </span>                :            :  *      finds a task by its pid in the specified namespace
<span class="lineNum">    1964 </span>                :            :  * find_task_by_vpid():
<span class="lineNum">    1965 </span>                :            :  *      finds a task by its virtual pid
<span class="lineNum">    1966 </span>                :            :  *
<span class="lineNum">    1967 </span>                :            :  * see also find_vpid() etc in include/linux/pid.h
<span class="lineNum">    1968 </span>                :            :  */
<span class="lineNum">    1969 </span>                :            : 
<span class="lineNum">    1970 </span>                :            : extern struct task_struct *find_task_by_vpid(pid_t nr);
<span class="lineNum">    1971 </span>                :            : extern struct task_struct *find_task_by_pid_ns(pid_t nr,
<span class="lineNum">    1972 </span>                :            :                 struct pid_namespace *ns);
<span class="lineNum">    1973 </span>                :            : 
<span class="lineNum">    1974 </span>                :            : extern void __set_special_pids(struct pid *pid);
<span class="lineNum">    1975 </span>                :            : 
<span class="lineNum">    1976 </span>                :            : /* per-UID process charging. */
<span class="lineNum">    1977 </span>                :            : extern struct user_struct * alloc_uid(struct user_namespace *, uid_t);
<span class="lineNum">    1978 </span>                :            : static inline struct user_struct *get_uid(struct user_struct *u)
<span class="lineNum">    1979 </span>                :            : {
<span class="lineNum">    1980 </span>                :            :         atomic_inc(&amp;u-&gt;__count);
<span class="lineNum">    1981 </span>                :            :         return u;
<span class="lineNum">    1982 </span>                :            : }
<span class="lineNum">    1983 </span>                :            : extern void free_uid(struct user_struct *);
<span class="lineNum">    1984 </span>                :            : extern void release_uids(struct user_namespace *ns);
<span class="lineNum">    1985 </span>                :            : 
<span class="lineNum">    1986 </span>                :            : #include &lt;asm/current.h&gt;
<span class="lineNum">    1987 </span>                :            : 
<span class="lineNum">    1988 </span>                :            : extern void do_timer(unsigned long ticks);
<span class="lineNum">    1989 </span>                :            : 
<span class="lineNum">    1990 </span>                :            : extern int wake_up_state(struct task_struct *tsk, unsigned int state);
<span class="lineNum">    1991 </span>                :            : extern int wake_up_process(struct task_struct *tsk);
<span class="lineNum">    1992 </span>                :            : extern void wake_up_new_task(struct task_struct *tsk,
<span class="lineNum">    1993 </span>                :            :                                 unsigned long clone_flags);
<span class="lineNum">    1994 </span>                :            : #ifdef CONFIG_SMP
<span class="lineNum">    1995 </span>                :            :  extern void kick_process(struct task_struct *tsk);
<span class="lineNum">    1996 </span>                :            : #else
<span class="lineNum">    1997 </span>                :            :  static inline void kick_process(struct task_struct *tsk) { }
<span class="lineNum">    1998 </span>                :            : #endif
<span class="lineNum">    1999 </span>                :            : extern void sched_fork(struct task_struct *p, int clone_flags);
<span class="lineNum">    2000 </span>                :            : extern void sched_dead(struct task_struct *p);
<span class="lineNum">    2001 </span>                :            : 
<span class="lineNum">    2002 </span>                :            : extern void proc_caches_init(void);
<span class="lineNum">    2003 </span>                :            : extern void flush_signals(struct task_struct *);
<span class="lineNum">    2004 </span>                :            : extern void __flush_signals(struct task_struct *);
<span class="lineNum">    2005 </span>                :            : extern void ignore_signals(struct task_struct *);
<span class="lineNum">    2006 </span>                :            : extern void flush_signal_handlers(struct task_struct *, int force_default);
<span class="lineNum">    2007 </span>                :            : extern int dequeue_signal(struct task_struct *tsk, sigset_t *mask, siginfo_t *info);
<span class="lineNum">    2008 </span>                :            : 
<span class="lineNum">    2009 </span>                :            : static inline int dequeue_signal_lock(struct task_struct *tsk, sigset_t *mask, siginfo_t *info)
<span class="lineNum">    2010 </span>                :            : {
<span class="lineNum">    2011 </span>                :            :         unsigned long flags;
<span class="lineNum">    2012 </span>                :            :         int ret;
<span class="lineNum">    2013 </span>                :            : 
<span class="lineNum">    2014 </span>                :            :         spin_lock_irqsave(&amp;tsk-&gt;sighand-&gt;siglock, flags);
<span class="lineNum">    2015 </span>                :            :         ret = dequeue_signal(tsk, mask, info);
<span class="lineNum">    2016 </span>                :            :         spin_unlock_irqrestore(&amp;tsk-&gt;sighand-&gt;siglock, flags);
<span class="lineNum">    2017 </span>                :            : 
<span class="lineNum">    2018 </span>                :            :         return ret;
<span class="lineNum">    2019 </span>                :            : }       
<span class="lineNum">    2020 </span>                :            : 
<span class="lineNum">    2021 </span>                :            : extern void block_all_signals(int (*notifier)(void *priv), void *priv,
<span class="lineNum">    2022 </span>                :            :                               sigset_t *mask);
<span class="lineNum">    2023 </span>                :            : extern void unblock_all_signals(void);
<span class="lineNum">    2024 </span>                :            : extern void release_task(struct task_struct * p);
<span class="lineNum">    2025 </span>                :            : extern int send_sig_info(int, struct siginfo *, struct task_struct *);
<span class="lineNum">    2026 </span>                :            : extern int force_sigsegv(int, struct task_struct *);
<span class="lineNum">    2027 </span>                :            : extern int force_sig_info(int, struct siginfo *, struct task_struct *);
<span class="lineNum">    2028 </span>                :            : extern int __kill_pgrp_info(int sig, struct siginfo *info, struct pid *pgrp);
<span class="lineNum">    2029 </span>                :            : extern int kill_pid_info(int sig, struct siginfo *info, struct pid *pid);
<span class="lineNum">    2030 </span>                :            : extern int kill_pid_info_as_uid(int, struct siginfo *, struct pid *, uid_t, uid_t, u32);
<span class="lineNum">    2031 </span>                :            : extern int kill_pgrp(struct pid *pid, int sig, int priv);
<span class="lineNum">    2032 </span>                :            : extern int kill_pid(struct pid *pid, int sig, int priv);
<span class="lineNum">    2033 </span>                :            : extern int kill_proc_info(int, struct siginfo *, pid_t);
<span class="lineNum">    2034 </span>                :            : extern int do_notify_parent(struct task_struct *, int);
<span class="lineNum">    2035 </span>                :            : extern void __wake_up_parent(struct task_struct *p, struct task_struct *parent);
<span class="lineNum">    2036 </span>                :            : extern void force_sig(int, struct task_struct *);
<span class="lineNum">    2037 </span>                :            : extern int send_sig(int, struct task_struct *, int);
<span class="lineNum">    2038 </span>                :            : extern int zap_other_threads(struct task_struct *p);
<span class="lineNum">    2039 </span>                :            : extern struct sigqueue *sigqueue_alloc(void);
<span class="lineNum">    2040 </span>                :            : extern void sigqueue_free(struct sigqueue *);
<span class="lineNum">    2041 </span>                :            : extern int send_sigqueue(struct sigqueue *,  struct task_struct *, int group);
<span class="lineNum">    2042 </span>                :            : extern int do_sigaction(int, struct k_sigaction *, struct k_sigaction *);
<span class="lineNum">    2043 </span>                :            : extern int do_sigaltstack(const stack_t __user *, stack_t __user *, unsigned long);
<span class="lineNum">    2044 </span>                :            : 
<span class="lineNum">    2045 </span>                :            : static inline int kill_cad_pid(int sig, int priv)
<span class="lineNum">    2046 </span>                :            : {
<span class="lineNum">    2047 </span>                :            :         return kill_pid(cad_pid, sig, priv);
<span class="lineNum">    2048 </span>                :            : }
<span class="lineNum">    2049 </span>                :            : 
<span class="lineNum">    2050 </span>                :            : /* These can be the second arg to send_sig_info/send_group_sig_info.  */
<span class="lineNum">    2051 </span>                :            : #define SEND_SIG_NOINFO ((struct siginfo *) 0)
<span class="lineNum">    2052 </span>                :            : #define SEND_SIG_PRIV   ((struct siginfo *) 1)
<span class="lineNum">    2053 </span>                :            : #define SEND_SIG_FORCED ((struct siginfo *) 2)
<span class="lineNum">    2054 </span>                :            : 
<span class="lineNum">    2055 </span>                :            : /*
<span class="lineNum">    2056 </span>                :            :  * True if we are on the alternate signal stack.
<span class="lineNum">    2057 </span>                :            :  */
<span class="lineNum">    2058 </span>                :            : static inline int on_sig_stack(unsigned long sp)
<span class="lineNum">    2059 </span>                :            : {
<span class="lineNum">    2060 </span>                :            : #ifdef CONFIG_STACK_GROWSUP
<span class="lineNum">    2061 </span>                :            :         return sp &gt;= current-&gt;sas_ss_sp &amp;&amp;
<span class="lineNum">    2062 </span>                :            :                 sp - current-&gt;sas_ss_sp &lt; current-&gt;sas_ss_size;
<span class="lineNum">    2063 </span>                :            : #else
<span class="lineNum">    2064 </span>                :            :         return sp &gt; current-&gt;sas_ss_sp &amp;&amp;
<span class="lineNum">    2065 </span>                :            :                 sp - current-&gt;sas_ss_sp &lt;= current-&gt;sas_ss_size;
<span class="lineNum">    2066 </span>                :            : #endif
<span class="lineNum">    2067 </span>                :            : }
<span class="lineNum">    2068 </span>                :            : 
<span class="lineNum">    2069 </span>                :            : static inline int sas_ss_flags(unsigned long sp)
<span class="lineNum">    2070 </span>                :            : {
<span class="lineNum">    2071 </span>                :            :         return (current-&gt;sas_ss_size == 0 ? SS_DISABLE
<span class="lineNum">    2072 </span>                :            :                 : on_sig_stack(sp) ? SS_ONSTACK : 0);
<span class="lineNum">    2073 </span>                :            : }
<span class="lineNum">    2074 </span>                :            : 
<span class="lineNum">    2075 </span>                :            : /*
<span class="lineNum">    2076 </span>                :            :  * Routines for handling mm_structs
<span class="lineNum">    2077 </span>                :            :  */
<span class="lineNum">    2078 </span>                :            : extern struct mm_struct * mm_alloc(void);
<span class="lineNum">    2079 </span>                :            : 
<span class="lineNum">    2080 </span>                :            : /* mmdrop drops the mm and the page tables */
<span class="lineNum">    2081 </span>                :            : extern void __mmdrop(struct mm_struct *);
<span class="lineNum">    2082 </span>                :            : static inline void mmdrop(struct mm_struct * mm)
<span class="lineNum">    2083 </span>                :            : {
<span class="lineNum">    2084 </span>                :            :         if (unlikely(atomic_dec_and_test(&amp;mm-&gt;mm_count)))
<span class="lineNum">    2085 </span>                :            :                 __mmdrop(mm);
<span class="lineNum">    2086 </span>                :            : }
<span class="lineNum">    2087 </span>                :            : 
<span class="lineNum">    2088 </span>                :            : /* mmput gets rid of the mappings and all user-space */
<span class="lineNum">    2089 </span>                :            : extern void mmput(struct mm_struct *);
<span class="lineNum">    2090 </span>                :            : /* Grab a reference to a task's mm, if it is not already going away */
<span class="lineNum">    2091 </span>                :            : extern struct mm_struct *get_task_mm(struct task_struct *task);
<span class="lineNum">    2092 </span>                :            : /* Remove the current tasks stale references to the old mm_struct */
<span class="lineNum">    2093 </span>                :            : extern void mm_release(struct task_struct *, struct mm_struct *);
<span class="lineNum">    2094 </span>                :            : /* Allocate a new mm structure and copy contents from tsk-&gt;mm */
<span class="lineNum">    2095 </span>                :            : extern struct mm_struct *dup_mm(struct task_struct *tsk);
<span class="lineNum">    2096 </span>                :            : 
<span class="lineNum">    2097 </span>                :            : extern int copy_thread(unsigned long, unsigned long, unsigned long,
<span class="lineNum">    2098 </span>                :            :                         struct task_struct *, struct pt_regs *);
<span class="lineNum">    2099 </span>                :            : extern void flush_thread(void);
<span class="lineNum">    2100 </span>                :            : extern void exit_thread(void);
<span class="lineNum">    2101 </span>                :            : 
<span class="lineNum">    2102 </span>                :            : extern void exit_files(struct task_struct *);
<span class="lineNum">    2103 </span>                :            : extern void __cleanup_sighand(struct sighand_struct *);
<span class="lineNum">    2104 </span>                :            : 
<span class="lineNum">    2105 </span>                :            : extern void exit_itimers(struct signal_struct *);
<span class="lineNum">    2106 </span>                :            : extern void flush_itimer_signals(void);
<span class="lineNum">    2107 </span>                :            : 
<span class="lineNum">    2108 </span>                :            : extern NORET_TYPE void do_group_exit(int);
<span class="lineNum">    2109 </span>                :            : 
<span class="lineNum">    2110 </span>                :            : extern void daemonize(const char *, ...);
<span class="lineNum">    2111 </span>                :            : extern int allow_signal(int);
<span class="lineNum">    2112 </span>                :            : extern int disallow_signal(int);
<span class="lineNum">    2113 </span>                :            : 
<span class="lineNum">    2114 </span>                :            : extern int do_execve(char *, char __user * __user *, char __user * __user *, struct pt_regs *);
<span class="lineNum">    2115 </span>                :            : extern long do_fork(unsigned long, unsigned long, struct pt_regs *, unsigned long, int __user *, int __user *);
<span class="lineNum">    2116 </span>                :            : struct task_struct *fork_idle(int);
<span class="lineNum">    2117 </span>                :            : 
<span class="lineNum">    2118 </span>                :            : extern void set_task_comm(struct task_struct *tsk, char *from);
<span class="lineNum">    2119 </span>                :            : extern char *get_task_comm(char *to, struct task_struct *tsk);
<span class="lineNum">    2120 </span>                :            : 
<span class="lineNum">    2121 </span>                :            : #ifdef CONFIG_SMP
<span class="lineNum">    2122 </span>                :            : extern unsigned long wait_task_inactive(struct task_struct *, long match_state);
<span class="lineNum">    2123 </span>                :            : #else
<span class="lineNum">    2124 </span>                :            : static inline unsigned long wait_task_inactive(struct task_struct *p,
<span class="lineNum">    2125 </span>                :            :                                                long match_state)
<span class="lineNum">    2126 </span>                :            : {
<span class="lineNum">    2127 </span>                :            :         return 1;
<span class="lineNum">    2128 </span>                :            : }
<span class="lineNum">    2129 </span>                :            : #endif
<span class="lineNum">    2130 </span>                :            : 
<span class="lineNum">    2131 </span>                :            : #define next_task(p) \
<span class="lineNum">    2132 </span>                :            :         list_entry_rcu((p)-&gt;tasks.next, struct task_struct, tasks)
<span class="lineNum">    2133 </span>                :            : 
<span class="lineNum">    2134 </span>                :            : #define for_each_process(p) \
<span class="lineNum">    2135 </span>                :            :         for (p = &amp;init_task ; (p = next_task(p)) != &amp;init_task ; )
<span class="lineNum">    2136 </span>                :            : 
<span class="lineNum">    2137 </span>                :            : extern bool current_is_single_threaded(void);
<span class="lineNum">    2138 </span>                :            : 
<span class="lineNum">    2139 </span>                :            : /*
<span class="lineNum">    2140 </span>                :            :  * Careful: do_each_thread/while_each_thread is a double loop so
<span class="lineNum">    2141 </span>                :            :  *          'break' will not work as expected - use goto instead.
<span class="lineNum">    2142 </span>                :            :  */
<span class="lineNum">    2143 </span>                :            : #define do_each_thread(g, t) \
<span class="lineNum">    2144 </span>                :            :         for (g = t = &amp;init_task ; (g = t = next_task(g)) != &amp;init_task ; ) do
<span class="lineNum">    2145 </span>                :            : 
<span class="lineNum">    2146 </span>                :            : #define while_each_thread(g, t) \
<span class="lineNum">    2147 </span>                :            :         while ((t = next_thread(t)) != g)
<span class="lineNum">    2148 </span>                :            : 
<span class="lineNum">    2149 </span>                :            : static inline int get_nr_threads(struct task_struct *tsk)
<span class="lineNum">    2150 </span>                :            : {
<span class="lineNum">    2151 </span>                :            :         return tsk-&gt;signal-&gt;nr_threads;
<span class="lineNum">    2152 </span>                :            : }
<span class="lineNum">    2153 </span>                :            : 
<span class="lineNum">    2154 </span>                :            : /* de_thread depends on thread_group_leader not being a pid based check */
<span class="lineNum">    2155 </span>                :            : #define thread_group_leader(p)  (p == p-&gt;group_leader)
<span class="lineNum">    2156 </span>                :            : 
<span class="lineNum">    2157 </span>                :            : /* Do to the insanities of de_thread it is possible for a process
<span class="lineNum">    2158 </span>                :            :  * to have the pid of the thread group leader without actually being
<span class="lineNum">    2159 </span>                :            :  * the thread group leader.  For iteration through the pids in proc
<span class="lineNum">    2160 </span>                :            :  * all we care about is that we have a task with the appropriate
<span class="lineNum">    2161 </span>                :            :  * pid, we don't actually care if we have the right task.
<span class="lineNum">    2162 </span>                :            :  */
<span class="lineNum">    2163 </span>                :            : static inline int has_group_leader_pid(struct task_struct *p)
<span class="lineNum">    2164 </span>                :            : {
<span class="lineNum">    2165 </span>                :            :         return p-&gt;pid == p-&gt;tgid;
<span class="lineNum">    2166 </span>                :            : }
<span class="lineNum">    2167 </span>                :            : 
<span class="lineNum">    2168 </span>                :            : static inline
<span class="lineNum">    2169 </span>                :            : int same_thread_group(struct task_struct *p1, struct task_struct *p2)
<span class="lineNum">    2170 </span>                :            : {
<span class="lineNum">    2171 </span>                :            :         return p1-&gt;tgid == p2-&gt;tgid;
<span class="lineNum">    2172 </span>                :            : }
<span class="lineNum">    2173 </span>                :            : 
<span class="lineNum">    2174 </span>                :            : static inline struct task_struct *next_thread(const struct task_struct *p)
<span class="lineNum">    2175 </span>                :            : {
<span class="lineNum">    2176 </span>                :<span class="lineNoCov">          0 :         return list_entry_rcu(p-&gt;thread_group.next,</span>
<span class="lineNum">    2177 </span>                :            :                               struct task_struct, thread_group);
<span class="lineNum">    2178 </span>                :            : }
<span class="lineNum">    2179 </span>                :            : 
<span class="lineNum">    2180 </span>                :            : static inline int thread_group_empty(struct task_struct *p)
<span class="lineNum">    2181 </span>                :            : {
<span class="lineNum">    2182 </span>                :            :         return list_empty(&amp;p-&gt;thread_group);
<span class="lineNum">    2183 </span>                :            : }
<span class="lineNum">    2184 </span>                :            : 
<span class="lineNum">    2185 </span>                :            : #define delay_group_leader(p) \
<span class="lineNum">    2186 </span>                :            :                 (thread_group_leader(p) &amp;&amp; !thread_group_empty(p))
<span class="lineNum">    2187 </span>                :            : 
<span class="lineNum">    2188 </span>                :            : static inline int task_detached(struct task_struct *p)
<span class="lineNum">    2189 </span>                :            : {
<span class="lineNum">    2190 </span>                :            :         return p-&gt;exit_signal == -1;
<span class="lineNum">    2191 </span>                :            : }
<span class="lineNum">    2192 </span>                :            : 
<span class="lineNum">    2193 </span>                :            : /*
<span class="lineNum">    2194 </span>                :            :  * Protects -&gt;fs, -&gt;files, -&gt;mm, -&gt;group_info, -&gt;comm, keyring
<span class="lineNum">    2195 </span>                :            :  * subscriptions and synchronises with wait4().  Also used in procfs.  Also
<span class="lineNum">    2196 </span>                :            :  * pins the final release of task.io_context.  Also protects -&gt;cpuset and
<span class="lineNum">    2197 </span>                :            :  * -&gt;cgroup.subsys[].
<span class="lineNum">    2198 </span>                :            :  *
<span class="lineNum">    2199 </span>                :            :  * Nests both inside and outside of read_lock(&amp;tasklist_lock).
<span class="lineNum">    2200 </span>                :            :  * It must not be nested with write_lock_irq(&amp;tasklist_lock),
<span class="lineNum">    2201 </span>                :            :  * neither inside nor outside.
<span class="lineNum">    2202 </span>                :            :  */
<span class="lineNum">    2203 </span>                :            : static inline void task_lock(struct task_struct *p)
<span class="lineNum">    2204 </span>                :            : {
<span class="lineNum">    2205 </span>                :            :         spin_lock(&amp;p-&gt;alloc_lock);
<span class="lineNum">    2206 </span>                :            : }
<span class="lineNum">    2207 </span>                :            : 
<span class="lineNum">    2208 </span>                :            : static inline void task_unlock(struct task_struct *p)
<span class="lineNum">    2209 </span>                :            : {
<span class="lineNum">    2210 </span>                :            :         spin_unlock(&amp;p-&gt;alloc_lock);
<span class="lineNum">    2211 </span>                :            : }
<span class="lineNum">    2212 </span>                :            : 
<span class="lineNum">    2213 </span>                :            : extern struct sighand_struct *lock_task_sighand(struct task_struct *tsk,
<span class="lineNum">    2214 </span>                :            :                                                         unsigned long *flags);
<span class="lineNum">    2215 </span>                :            : 
<span class="lineNum">    2216 </span>                :            : static inline void unlock_task_sighand(struct task_struct *tsk,
<span class="lineNum">    2217 </span>                :            :                                                 unsigned long *flags)
<span class="lineNum">    2218 </span>                :            : {
<span class="lineNum">    2219 </span>                :            :         spin_unlock_irqrestore(&amp;tsk-&gt;sighand-&gt;siglock, *flags);
<span class="lineNum">    2220 </span>                :            : }
<span class="lineNum">    2221 </span>                :            : 
<span class="lineNum">    2222 </span>                :            : #ifndef __HAVE_THREAD_FUNCTIONS
<span class="lineNum">    2223 </span>                :            : 
<span class="lineNum">    2224 </span>                :            : #define task_thread_info(task)  ((struct thread_info *)(task)-&gt;stack)
<span class="lineNum">    2225 </span>                :            : #define task_stack_page(task)   ((task)-&gt;stack)
<span class="lineNum">    2226 </span>                :            : 
<span class="lineNum">    2227 </span>                :            : static inline void setup_thread_stack(struct task_struct *p, struct task_struct *org)
<span class="lineNum">    2228 </span>                :            : {
<span class="lineNum">    2229 </span>                :            :         *task_thread_info(p) = *task_thread_info(org);
<span class="lineNum">    2230 </span>                :            :         task_thread_info(p)-&gt;task = p;
<span class="lineNum">    2231 </span>                :            : }
<span class="lineNum">    2232 </span>                :            : 
<span class="lineNum">    2233 </span>                :            : static inline unsigned long *end_of_stack(struct task_struct *p)
<span class="lineNum">    2234 </span>                :            : {
<span class="lineNum">    2235 </span>                :            :         return (unsigned long *)(task_thread_info(p) + 1);
<span class="lineNum">    2236 </span>                :            : }
<span class="lineNum">    2237 </span>                :            : 
<span class="lineNum">    2238 </span>                :            : #endif
<span class="lineNum">    2239 </span>                :            : 
<span class="lineNum">    2240 </span>                :            : static inline int object_is_on_stack(void *obj)
<span class="lineNum">    2241 </span>                :            : {
<span class="lineNum">    2242 </span>                :            :         void *stack = task_stack_page(current);
<span class="lineNum">    2243 </span>                :            : 
<span class="lineNum">    2244 </span>                :            :         return (obj &gt;= stack) &amp;&amp; (obj &lt; (stack + THREAD_SIZE));
<span class="lineNum">    2245 </span>                :            : }
<span class="lineNum">    2246 </span>                :            : 
<span class="lineNum">    2247 </span>                :            : extern void thread_info_cache_init(void);
<span class="lineNum">    2248 </span>                :            : 
<span class="lineNum">    2249 </span>                :            : #ifdef CONFIG_DEBUG_STACK_USAGE
<span class="lineNum">    2250 </span>                :            : static inline unsigned long stack_not_used(struct task_struct *p)
<span class="lineNum">    2251 </span>                :            : {
<span class="lineNum">    2252 </span>                :            :         unsigned long *n = end_of_stack(p);
<span class="lineNum">    2253 </span>                :            : 
<span class="lineNum">    2254 </span>                :            :         do {    /* Skip over canary */
<span class="lineNum">    2255 </span>                :            :                 n++;
<span class="lineNum">    2256 </span>                :            :         } while (!*n);
<span class="lineNum">    2257 </span>                :            : 
<span class="lineNum">    2258 </span>                :            :         return (unsigned long)n - (unsigned long)end_of_stack(p);
<span class="lineNum">    2259 </span>                :            : }
<span class="lineNum">    2260 </span>                :            : #endif
<span class="lineNum">    2261 </span>                :            : 
<span class="lineNum">    2262 </span>                :            : /* set thread flags in other task's structures
<span class="lineNum">    2263 </span>                :            :  * - see asm/thread_info.h for TIF_xxxx flags available
<span class="lineNum">    2264 </span>                :            :  */
<span class="lineNum">    2265 </span>                :            : static inline void set_tsk_thread_flag(struct task_struct *tsk, int flag)
<span class="lineNum">    2266 </span>                :            : {
<span class="lineNum">    2267 </span>                :            :         set_ti_thread_flag(task_thread_info(tsk), flag);
<span class="lineNum">    2268 </span>                :            : }
<span class="lineNum">    2269 </span>                :            : 
<span class="lineNum">    2270 </span>                :            : static inline void clear_tsk_thread_flag(struct task_struct *tsk, int flag)
<span class="lineNum">    2271 </span>                :            : {
<span class="lineNum">    2272 </span>                :            :         clear_ti_thread_flag(task_thread_info(tsk), flag);
<span class="lineNum">    2273 </span>                :            : }
<span class="lineNum">    2274 </span>                :            : 
<span class="lineNum">    2275 </span>                :            : static inline int test_and_set_tsk_thread_flag(struct task_struct *tsk, int flag)
<span class="lineNum">    2276 </span>                :            : {
<span class="lineNum">    2277 </span>                :            :         return test_and_set_ti_thread_flag(task_thread_info(tsk), flag);
<span class="lineNum">    2278 </span>                :            : }
<span class="lineNum">    2279 </span>                :            : 
<span class="lineNum">    2280 </span>                :            : static inline int test_and_clear_tsk_thread_flag(struct task_struct *tsk, int flag)
<span class="lineNum">    2281 </span>                :            : {
<span class="lineNum">    2282 </span>                :            :         return test_and_clear_ti_thread_flag(task_thread_info(tsk), flag);
<span class="lineNum">    2283 </span>                :            : }
<span class="lineNum">    2284 </span>                :            : 
<span class="lineNum">    2285 </span>                :            : static inline int test_tsk_thread_flag(struct task_struct *tsk, int flag)
<span class="lineNum">    2286 </span>                :            : {
<span class="lineNum">    2287 </span>                :<span class="lineNoCov">          0 :         return test_ti_thread_flag(task_thread_info(tsk), flag);</span>
<span class="lineNum">    2288 </span>                :            : }
<span class="lineNum">    2289 </span>                :            : 
<span class="lineNum">    2290 </span>                :            : static inline void set_tsk_need_resched(struct task_struct *tsk)
<span class="lineNum">    2291 </span>                :            : {
<span class="lineNum">    2292 </span>                :            :         set_tsk_thread_flag(tsk,TIF_NEED_RESCHED);
<span class="lineNum">    2293 </span>                :            : }
<span class="lineNum">    2294 </span>                :            : 
<span class="lineNum">    2295 </span>                :            : static inline void clear_tsk_need_resched(struct task_struct *tsk)
<span class="lineNum">    2296 </span>                :            : {
<span class="lineNum">    2297 </span>                :            :         clear_tsk_thread_flag(tsk,TIF_NEED_RESCHED);
<span class="lineNum">    2298 </span>                :            : }
<span class="lineNum">    2299 </span>                :            : 
<span class="lineNum">    2300 </span>                :            : static inline int test_tsk_need_resched(struct task_struct *tsk)
<span class="lineNum">    2301 </span>                :            : {
<span class="lineNum">    2302 </span>                :            :         return unlikely(test_tsk_thread_flag(tsk,TIF_NEED_RESCHED));
<span class="lineNum">    2303 </span>                :            : }
<span class="lineNum">    2304 </span>                :            : 
<span class="lineNum">    2305 </span>                :            : static inline int restart_syscall(void)
<span class="lineNum">    2306 </span>                :            : {
<span class="lineNum">    2307 </span>                :            :         set_tsk_thread_flag(current, TIF_SIGPENDING);
<span class="lineNum">    2308 </span>                :            :         return -ERESTARTNOINTR;
<span class="lineNum">    2309 </span>                :            : }
<span class="lineNum">    2310 </span>                :            : 
<span class="lineNum">    2311 </span>                :            : static inline int signal_pending(struct task_struct *p)
<span class="lineNum">    2312 </span>                :            : {
<span class="lineNum">    2313 </span>                :<span class="lineNoCov">          0 :         return unlikely(test_tsk_thread_flag(p,TIF_SIGPENDING));</span>
<span class="lineNum">    2314 </span>                :            : }
<span class="lineNum">    2315 </span>                :            : 
<span class="lineNum">    2316 </span>                :            : static inline int __fatal_signal_pending(struct task_struct *p)
<span class="lineNum">    2317 </span>                :            : {
<span class="lineNum">    2318 </span>                :            :         return unlikely(sigismember(&amp;p-&gt;pending.signal, SIGKILL));
<span class="lineNum">    2319 </span>                :            : }
<span class="lineNum">    2320 </span>                :            : 
<span class="lineNum">    2321 </span>                :            : static inline int fatal_signal_pending(struct task_struct *p)
<span class="lineNum">    2322 </span>                :            : {
<span class="lineNum">    2323 </span>                :            :         return signal_pending(p) &amp;&amp; __fatal_signal_pending(p);
<span class="lineNum">    2324 </span>                :            : }
<span class="lineNum">    2325 </span>                :            : 
<span class="lineNum">    2326 </span>                :            : static inline int signal_pending_state(long state, struct task_struct *p)
<span class="lineNum">    2327 </span>                :            : {
<span class="lineNum">    2328 </span>                :            :         if (!(state &amp; (TASK_INTERRUPTIBLE | TASK_WAKEKILL)))
<span class="lineNum">    2329 </span>                :            :                 return 0;
<span class="lineNum">    2330 </span>                :            :         if (!signal_pending(p))
<span class="lineNum">    2331 </span>                :            :                 return 0;
<span class="lineNum">    2332 </span>                :            : 
<span class="lineNum">    2333 </span>                :            :         return (state &amp; TASK_INTERRUPTIBLE) || __fatal_signal_pending(p);
<span class="lineNum">    2334 </span>                :            : }
<span class="lineNum">    2335 </span>                :            : 
<span class="lineNum">    2336 </span>                :            : static inline int need_resched(void)
<span class="lineNum">    2337 </span>                :            : {
<span class="lineNum">    2338 </span>                :            :         return unlikely(test_thread_flag(TIF_NEED_RESCHED));
<span class="lineNum">    2339 </span>                :            : }
<span class="lineNum">    2340 </span>                :            : 
<span class="lineNum">    2341 </span>                :            : /*
<span class="lineNum">    2342 </span>                :            :  * cond_resched() and cond_resched_lock(): latency reduction via
<span class="lineNum">    2343 </span>                :            :  * explicit rescheduling in places that are safe. The return
<span class="lineNum">    2344 </span>                :            :  * value indicates whether a reschedule was done in fact.
<span class="lineNum">    2345 </span>                :            :  * cond_resched_lock() will drop the spinlock before scheduling,
<span class="lineNum">    2346 </span>                :            :  * cond_resched_softirq() will enable bhs before scheduling.
<span class="lineNum">    2347 </span>                :            :  */
<span class="lineNum">    2348 </span>                :            : extern int _cond_resched(void);
<span class="lineNum">    2349 </span>                :            : 
<span class="lineNum">    2350 </span>                :            : #define cond_resched() ({                       \
<span class="lineNum">    2351 </span>                :            :         __might_sleep(__FILE__, __LINE__, 0);   \
<span class="lineNum">    2352 </span>                :            :         _cond_resched();                        \
<span class="lineNum">    2353 </span>                :            : })
<span class="lineNum">    2354 </span>                :            : 
<span class="lineNum">    2355 </span>                :            : extern int __cond_resched_lock(spinlock_t *lock);
<span class="lineNum">    2356 </span>                :            : 
<span class="lineNum">    2357 </span>                :            : #ifdef CONFIG_PREEMPT
<span class="lineNum">    2358 </span>                :            : #define PREEMPT_LOCK_OFFSET     PREEMPT_OFFSET
<span class="lineNum">    2359 </span>                :            : #else
<span class="lineNum">    2360 </span>                :            : #define PREEMPT_LOCK_OFFSET     0
<span class="lineNum">    2361 </span>                :            : #endif
<span class="lineNum">    2362 </span>                :            : 
<span class="lineNum">    2363 </span>                :            : #define cond_resched_lock(lock) ({                              \
<span class="lineNum">    2364 </span>                :            :         __might_sleep(__FILE__, __LINE__, PREEMPT_LOCK_OFFSET); \
<span class="lineNum">    2365 </span>                :            :         __cond_resched_lock(lock);                              \
<span class="lineNum">    2366 </span>                :            : })
<span class="lineNum">    2367 </span>                :            : 
<span class="lineNum">    2368 </span>                :            : extern int __cond_resched_softirq(void);
<span class="lineNum">    2369 </span>                :            : 
<span class="lineNum">    2370 </span>                :            : #define cond_resched_softirq() ({                               \
<span class="lineNum">    2371 </span>                :            :         __might_sleep(__FILE__, __LINE__, SOFTIRQ_OFFSET);      \
<span class="lineNum">    2372 </span>                :            :         __cond_resched_softirq();                               \
<span class="lineNum">    2373 </span>                :            : })
<span class="lineNum">    2374 </span>                :            : 
<span class="lineNum">    2375 </span>                :            : /*
<span class="lineNum">    2376 </span>                :            :  * Does a critical section need to be broken due to another
<span class="lineNum">    2377 </span>                :            :  * task waiting?: (technically does not depend on CONFIG_PREEMPT,
<span class="lineNum">    2378 </span>                :            :  * but a general need for low latency)
<span class="lineNum">    2379 </span>                :            :  */
<span class="lineNum">    2380 </span>                :            : static inline int spin_needbreak(spinlock_t *lock)
<span class="lineNum">    2381 </span>                :            : {
<span class="lineNum">    2382 </span>                :            : #ifdef CONFIG_PREEMPT
<span class="lineNum">    2383 </span>                :            :         return spin_is_contended(lock);
<span class="lineNum">    2384 </span>                :            : #else
<span class="lineNum">    2385 </span>                :            :         return 0;
<span class="lineNum">    2386 </span>                :            : #endif
<span class="lineNum">    2387 </span>                :            : }
<span class="lineNum">    2388 </span>                :            : 
<span class="lineNum">    2389 </span>                :            : /*
<span class="lineNum">    2390 </span>                :            :  * Thread group CPU time accounting.
<span class="lineNum">    2391 </span>                :            :  */
<span class="lineNum">    2392 </span>                :            : void thread_group_cputime(struct task_struct *tsk, struct task_cputime *times);
<span class="lineNum">    2393 </span>                :            : void thread_group_cputimer(struct task_struct *tsk, struct task_cputime *times);
<span class="lineNum">    2394 </span>                :            : 
<span class="lineNum">    2395 </span>                :            : static inline void thread_group_cputime_init(struct signal_struct *sig)
<span class="lineNum">    2396 </span>                :            : {
<span class="lineNum">    2397 </span>                :            :         spin_lock_init(&amp;sig-&gt;cputimer.lock);
<span class="lineNum">    2398 </span>                :            : }
<span class="lineNum">    2399 </span>                :            : 
<span class="lineNum">    2400 </span>                :            : /*
<span class="lineNum">    2401 </span>                :            :  * Reevaluate whether the task has signals pending delivery.
<span class="lineNum">    2402 </span>                :            :  * Wake the task if so.
<span class="lineNum">    2403 </span>                :            :  * This is required every time the blocked sigset_t changes.
<span class="lineNum">    2404 </span>                :            :  * callers must hold sighand-&gt;siglock.
<span class="lineNum">    2405 </span>                :            :  */
<span class="lineNum">    2406 </span>                :            : extern void recalc_sigpending_and_wake(struct task_struct *t);
<span class="lineNum">    2407 </span>                :            : extern void recalc_sigpending(void);
<span class="lineNum">    2408 </span>                :            : 
<span class="lineNum">    2409 </span>                :            : extern void signal_wake_up(struct task_struct *t, int resume_stopped);
<span class="lineNum">    2410 </span>                :            : 
<span class="lineNum">    2411 </span>                :            : /*
<span class="lineNum">    2412 </span>                :            :  * Wrappers for p-&gt;thread_info-&gt;cpu access. No-op on UP.
<span class="lineNum">    2413 </span>                :            :  */
<span class="lineNum">    2414 </span>                :            : #ifdef CONFIG_SMP
<span class="lineNum">    2415 </span>                :            : 
<span class="lineNum">    2416 </span>                :            : static inline unsigned int task_cpu(const struct task_struct *p)
<span class="lineNum">    2417 </span>                :            : {
<span class="lineNum">    2418 </span>                :            :         return task_thread_info(p)-&gt;cpu;
<span class="lineNum">    2419 </span>                :            : }
<span class="lineNum">    2420 </span>                :            : 
<span class="lineNum">    2421 </span>                :            : extern void set_task_cpu(struct task_struct *p, unsigned int cpu);
<span class="lineNum">    2422 </span>                :            : 
<span class="lineNum">    2423 </span>                :            : #else
<span class="lineNum">    2424 </span>                :            : 
<span class="lineNum">    2425 </span>                :            : static inline unsigned int task_cpu(const struct task_struct *p)
<span class="lineNum">    2426 </span>                :            : {
<span class="lineNum">    2427 </span>                :            :         return 0;
<span class="lineNum">    2428 </span>                :            : }
<span class="lineNum">    2429 </span>                :            : 
<span class="lineNum">    2430 </span>                :            : static inline void set_task_cpu(struct task_struct *p, unsigned int cpu)
<span class="lineNum">    2431 </span>                :            : {
<span class="lineNum">    2432 </span>                :            : }
<span class="lineNum">    2433 </span>                :            : 
<span class="lineNum">    2434 </span>                :            : #endif /* CONFIG_SMP */
<span class="lineNum">    2435 </span>                :            : 
<span class="lineNum">    2436 </span>                :            : #ifdef CONFIG_TRACING
<span class="lineNum">    2437 </span>                :            : extern void
<span class="lineNum">    2438 </span>                :            : __trace_special(void *__tr, void *__data,
<span class="lineNum">    2439 </span>                :            :                 unsigned long arg1, unsigned long arg2, unsigned long arg3);
<span class="lineNum">    2440 </span>                :            : #else
<span class="lineNum">    2441 </span>                :            : static inline void
<span class="lineNum">    2442 </span>                :            : __trace_special(void *__tr, void *__data,
<span class="lineNum">    2443 </span>                :            :                 unsigned long arg1, unsigned long arg2, unsigned long arg3)
<span class="lineNum">    2444 </span>                :            : {
<span class="lineNum">    2445 </span>                :            : }
<span class="lineNum">    2446 </span>                :            : #endif
<span class="lineNum">    2447 </span>                :            : 
<span class="lineNum">    2448 </span>                :            : extern long sched_setaffinity(pid_t pid, const struct cpumask *new_mask);
<span class="lineNum">    2449 </span>                :            : extern long sched_getaffinity(pid_t pid, struct cpumask *mask);
<span class="lineNum">    2450 </span>                :            : 
<span class="lineNum">    2451 </span>                :            : extern void normalize_rt_tasks(void);
<span class="lineNum">    2452 </span>                :            : 
<span class="lineNum">    2453 </span>                :            : #ifdef CONFIG_CGROUP_SCHED
<span class="lineNum">    2454 </span>                :            : 
<span class="lineNum">    2455 </span>                :            : extern struct task_group init_task_group;
<span class="lineNum">    2456 </span>                :            : 
<span class="lineNum">    2457 </span>                :            : extern struct task_group *sched_create_group(struct task_group *parent);
<span class="lineNum">    2458 </span>                :            : extern void sched_destroy_group(struct task_group *tg);
<span class="lineNum">    2459 </span>                :            : extern void sched_move_task(struct task_struct *tsk);
<span class="lineNum">    2460 </span>                :            : #ifdef CONFIG_FAIR_GROUP_SCHED
<span class="lineNum">    2461 </span>                :            : extern int sched_group_set_shares(struct task_group *tg, unsigned long shares);
<span class="lineNum">    2462 </span>                :            : extern unsigned long sched_group_shares(struct task_group *tg);
<span class="lineNum">    2463 </span>                :            : #endif
<span class="lineNum">    2464 </span>                :            : #ifdef CONFIG_RT_GROUP_SCHED
<span class="lineNum">    2465 </span>                :            : extern int sched_group_set_rt_runtime(struct task_group *tg,
<span class="lineNum">    2466 </span>                :            :                                       long rt_runtime_us);
<span class="lineNum">    2467 </span>                :            : extern long sched_group_rt_runtime(struct task_group *tg);
<span class="lineNum">    2468 </span>                :            : extern int sched_group_set_rt_period(struct task_group *tg,
<span class="lineNum">    2469 </span>                :            :                                       long rt_period_us);
<span class="lineNum">    2470 </span>                :            : extern long sched_group_rt_period(struct task_group *tg);
<span class="lineNum">    2471 </span>                :            : extern int sched_rt_can_attach(struct task_group *tg, struct task_struct *tsk);
<span class="lineNum">    2472 </span>                :            : #endif
<span class="lineNum">    2473 </span>                :            : #endif
<span class="lineNum">    2474 </span>                :            : 
<span class="lineNum">    2475 </span>                :            : extern int task_can_switch_user(struct user_struct *up,
<span class="lineNum">    2476 </span>                :            :                                         struct task_struct *tsk);
<span class="lineNum">    2477 </span>                :            : 
<span class="lineNum">    2478 </span>                :            : #ifdef CONFIG_TASK_XACCT
<span class="lineNum">    2479 </span>                :            : static inline void add_rchar(struct task_struct *tsk, ssize_t amt)
<span class="lineNum">    2480 </span>                :            : {
<span class="lineNum">    2481 </span>                :            :         tsk-&gt;ioac.rchar += amt;
<span class="lineNum">    2482 </span>                :            : }
<span class="lineNum">    2483 </span>                :            : 
<span class="lineNum">    2484 </span>                :            : static inline void add_wchar(struct task_struct *tsk, ssize_t amt)
<span class="lineNum">    2485 </span>                :            : {
<span class="lineNum">    2486 </span>                :            :         tsk-&gt;ioac.wchar += amt;
<span class="lineNum">    2487 </span>                :            : }
<span class="lineNum">    2488 </span>                :            : 
<span class="lineNum">    2489 </span>                :            : static inline void inc_syscr(struct task_struct *tsk)
<span class="lineNum">    2490 </span>                :            : {
<span class="lineNum">    2491 </span>                :            :         tsk-&gt;ioac.syscr++;
<span class="lineNum">    2492 </span>                :            : }
<span class="lineNum">    2493 </span>                :            : 
<span class="lineNum">    2494 </span>                :            : static inline void inc_syscw(struct task_struct *tsk)
<span class="lineNum">    2495 </span>                :            : {
<span class="lineNum">    2496 </span>                :            :         tsk-&gt;ioac.syscw++;
<span class="lineNum">    2497 </span>                :            : }
<span class="lineNum">    2498 </span>                :            : #else
<span class="lineNum">    2499 </span>                :            : static inline void add_rchar(struct task_struct *tsk, ssize_t amt)
<span class="lineNum">    2500 </span>                :            : {
<span class="lineNum">    2501 </span>                :            : }
<span class="lineNum">    2502 </span>                :            : 
<span class="lineNum">    2503 </span>                :            : static inline void add_wchar(struct task_struct *tsk, ssize_t amt)
<span class="lineNum">    2504 </span>                :            : {
<span class="lineNum">    2505 </span>                :            : }
<span class="lineNum">    2506 </span>                :            : 
<span class="lineNum">    2507 </span>                :            : static inline void inc_syscr(struct task_struct *tsk)
<span class="lineNum">    2508 </span>                :            : {
<span class="lineNum">    2509 </span>                :            : }
<span class="lineNum">    2510 </span>                :            : 
<span class="lineNum">    2511 </span>                :            : static inline void inc_syscw(struct task_struct *tsk)
<span class="lineNum">    2512 </span>                :            : {
<span class="lineNum">    2513 </span>                :            : }
<span class="lineNum">    2514 </span>                :            : #endif
<span class="lineNum">    2515 </span>                :            : 
<span class="lineNum">    2516 </span>                :            : #ifndef TASK_SIZE_OF
<span class="lineNum">    2517 </span>                :            : #define TASK_SIZE_OF(tsk)       TASK_SIZE
<span class="lineNum">    2518 </span>                :            : #endif
<span class="lineNum">    2519 </span>                :            : 
<span class="lineNum">    2520 </span>                :            : /*
<span class="lineNum">    2521 </span>                :            :  * Call the function if the target task is executing on a CPU right now:
<span class="lineNum">    2522 </span>                :            :  */
<span class="lineNum">    2523 </span>                :            : extern void task_oncpu_function_call(struct task_struct *p,
<span class="lineNum">    2524 </span>                :            :                                      void (*func) (void *info), void *info);
<span class="lineNum">    2525 </span>                :            : 
<span class="lineNum">    2526 </span>                :            : 
<span class="lineNum">    2527 </span>                :            : #ifdef CONFIG_MM_OWNER
<span class="lineNum">    2528 </span>                :            : extern void mm_update_next_owner(struct mm_struct *mm);
<span class="lineNum">    2529 </span>                :            : extern void mm_init_owner(struct mm_struct *mm, struct task_struct *p);
<span class="lineNum">    2530 </span>                :            : #else
<span class="lineNum">    2531 </span>                :            : static inline void mm_update_next_owner(struct mm_struct *mm)
<span class="lineNum">    2532 </span>                :            : {
<span class="lineNum">    2533 </span>                :            : }
<span class="lineNum">    2534 </span>                :            : 
<span class="lineNum">    2535 </span>                :            : static inline void mm_init_owner(struct mm_struct *mm, struct task_struct *p)
<span class="lineNum">    2536 </span>                :            : {
<span class="lineNum">    2537 </span>                :            : }
<span class="lineNum">    2538 </span>                :            : #endif /* CONFIG_MM_OWNER */
<span class="lineNum">    2539 </span>                :            : 
<span class="lineNum">    2540 </span>                :            : static inline unsigned long task_rlimit(const struct task_struct *tsk,
<span class="lineNum">    2541 </span>                :            :                 unsigned int limit)
<span class="lineNum">    2542 </span>                :            : {
<span class="lineNum">    2543 </span>                :            :         return ACCESS_ONCE(tsk-&gt;signal-&gt;rlim[limit].rlim_cur);
<span class="lineNum">    2544 </span>                :            : }
<span class="lineNum">    2545 </span>                :            : 
<span class="lineNum">    2546 </span>                :            : static inline unsigned long task_rlimit_max(const struct task_struct *tsk,
<span class="lineNum">    2547 </span>                :            :                 unsigned int limit)
<span class="lineNum">    2548 </span>                :            : {
<span class="lineNum">    2549 </span>                :            :         return ACCESS_ONCE(tsk-&gt;signal-&gt;rlim[limit].rlim_max);
<span class="lineNum">    2550 </span>                :            : }
<span class="lineNum">    2551 </span>                :            : 
<span class="lineNum">    2552 </span>                :            : static inline unsigned long rlimit(unsigned int limit)
<span class="lineNum">    2553 </span>                :            : {
<span class="lineNum">    2554 </span>                :            :         return task_rlimit(current, limit);
<span class="lineNum">    2555 </span>                :            : }
<span class="lineNum">    2556 </span>                :            : 
<span class="lineNum">    2557 </span>                :            : static inline unsigned long rlimit_max(unsigned int limit)
<span class="lineNum">    2558 </span>                :            : {
<span class="lineNum">    2559 </span>                :            :         return task_rlimit_max(current, limit);
<span class="lineNum">    2560 </span>                :            : }
<span class="lineNum">    2561 </span>                :            : 
<span class="lineNum">    2562 </span>                :            : #endif /* __KERNEL__ */
<span class="lineNum">    2563 </span>                :            : 
<span class="lineNum">    2564 </span>                :            : #endif
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.8</a></td></tr>
  </table>
  <br>

</body>
</html>
