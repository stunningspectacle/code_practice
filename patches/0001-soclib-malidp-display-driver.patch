From 5e1c6379d4ddfa63adc3ea99205ebade43ab06c3 Mon Sep 17 00:00:00 2001
From: Leo Yan <leo.yan@intel.com>
Date: Fri, 22 Apr 2016 15:16:14 +0800
Subject: [PATCH] soclib malidp display driver

Change-Id: Ie7ec0dbb97c70a0710444f47872f1f87c1df1425
Signed-off-by: Leo Yan <leo.yan@intel.com>
Tracked-On:
---
 devices/malidp/Makefile                            |   18 +
 devices/malidp/src/bl_disp.c                       |   57 +
 devices/malidp/src/bl_malidp.c                     |  170 ++
 devices/malidp/src/include/bl_display.h            |   74 +
 devices/malidp/src/include/bl_display_if_config.h  |  234 +++
 devices/malidp/src/include/bl_malidp.h             |   76 +
 devices/malidp/src/include/bl_malidp_kernel_fake.h |   33 +
 devices/malidp/src/include/malidp_adf.h            |  285 +++
 devices/malidp/src/include/malidp_de_device.h      |  374 ++++
 devices/malidp/src/include/malidp_disp_config.h    |   74 +
 devices/malidp/src/include/malidp_hw.h             |  309 ++++
 devices/malidp/src/include/malidp_hw_types.h       |  169 ++
 devices/malidp/src/include/malidp_product_api.h    |  179 ++
 devices/malidp/src/include/malidp_se_device.h      |  295 +++
 devices/malidp/src/malidp_config_blob_parser.c     |  192 ++
 devices/malidp/src/malidp_de_device.c              | 1119 ++++++++++++
 devices/malidp/src/malidp_hw.c                     | 1902 ++++++++++++++++++++
 devices/malidp/src/malidp_product_dp550.c          |  931 ++++++++++
 devices/malidp/src/malidp_se_device.c              |  503 ++++++
 devices/malidp/src/sofia3gx/dsi_display.c          |  849 +++++++++
 devices/malidp/src/sofia3gx/dsi_hwregs.c           |  349 ++++
 devices/malidp/src/sofia3gx/dsi_hwregs.h           |  260 +++
 22 files changed, 8452 insertions(+)
 create mode 100644 devices/malidp/Makefile
 create mode 100644 devices/malidp/src/bl_disp.c
 create mode 100644 devices/malidp/src/bl_malidp.c
 create mode 100644 devices/malidp/src/include/bl_display.h
 create mode 100644 devices/malidp/src/include/bl_display_if_config.h
 create mode 100644 devices/malidp/src/include/bl_malidp.h
 create mode 100644 devices/malidp/src/include/bl_malidp_kernel_fake.h
 create mode 100644 devices/malidp/src/include/malidp_adf.h
 create mode 100644 devices/malidp/src/include/malidp_de_device.h
 create mode 100644 devices/malidp/src/include/malidp_disp_config.h
 create mode 100644 devices/malidp/src/include/malidp_hw.h
 create mode 100644 devices/malidp/src/include/malidp_hw_types.h
 create mode 100644 devices/malidp/src/include/malidp_product_api.h
 create mode 100644 devices/malidp/src/include/malidp_se_device.h
 create mode 100644 devices/malidp/src/malidp_config_blob_parser.c
 create mode 100644 devices/malidp/src/malidp_de_device.c
 create mode 100644 devices/malidp/src/malidp_hw.c
 create mode 100644 devices/malidp/src/malidp_product_dp550.c
 create mode 100644 devices/malidp/src/malidp_se_device.c
 create mode 100644 devices/malidp/src/sofia3gx/dsi_display.c
 create mode 100644 devices/malidp/src/sofia3gx/dsi_hwregs.c
 create mode 100644 devices/malidp/src/sofia3gx/dsi_hwregs.h

diff --git a/devices/malidp/Makefile b/devices/malidp/Makefile
new file mode 100644
index 0000000..07fcae8
--- /dev/null
+++ b/devices/malidp/Makefile
@@ -0,0 +1,18 @@
+C_DEFINES +=
+
+ASM_LIST +=
+
+C_LIST += bl_disp.c \
+	bl_malidp.c \
+	malidp_config_blob_parser.c \
+	malidp_product_dp550.c \
+	malidp_hw.c \
+	malidp_de_device.c \
+	malidp_se_device.c \
+	dsi_display.c \
+	dsi_hwregs.c
+
+SOURCEDIR += $(SOCDIR)/devices/malidp/src
+SOURCEDIR += $(SOCDIR)/devices/malidp/src/sofia3gx
+
+INCLUDEDIR += $(SOCDIR)/devices/malidp/include
diff --git a/devices/malidp/src/bl_disp.c b/devices/malidp/src/bl_disp.c
new file mode 100644
index 0000000..808e5fa
--- /dev/null
+++ b/devices/malidp/src/bl_disp.c
@@ -0,0 +1,57 @@
+/* ----------------------------------------------------------------------------
+   Copyright (C) 2013-2014 Intel Mobile Communications GmbH
+
+   Sec Class: Intel Confidential (IC)
+
+   All rights reserved.
+   ----------------------------------------------------------------------------
+   This document contains proprietary information belonging to IMC.
+   Passing on and copying of this document, use
+   and communication of its contents is not permitted without prior written
+   authorisation.
+  ---------------------------------------------------------------------------*/
+
+#include "bastypes.h"
+
+#include "bl-dcc.h"
+#include "bl_display_if_config.h"
+#include "bl_malidp.h"
+
+struct bl_display *lcd = NULL;
+
+bl_dcc_result_type bl_dcc_show_image(unsigned int width,
+				     unsigned int height,
+				     unsigned int bpp,
+				     unsigned char *data,
+				     bl_display_cbs_t *pbl_disp_cb,
+				     bl_lcd_config_t *pbl_lcd_conf,
+				     bl_dcc_platform hw_id)
+{
+	struct malidp_panel_info *panel;
+	int xpos = 0, ypos = 0;
+
+	if (hw_id >= BL_DCC_PLATFORM_INVALID)
+		return BL_DCC_RESULT_INCORRECT_HWID;
+
+	if (NULL == lcd) {
+		lcd = bl_malidp_init_config((unsigned int *)pbl_lcd_conf);
+		if (bl_malidp_probe(pbl_disp_cb, (void *)lcd))
+			return BL_DCC_RESULT_INIT_FAILED;
+	}
+
+	panel = bl_malidp_get_panel_info();
+	if (width > panel->timing.xres || height > panel->timing.yres)
+		return BL_DCC_RESULT_INCORRECT_SIZE;
+
+	xpos = (panel->timing.xres - width) >> 1;
+	ypos = (panel->timing.yres - height) >> 1;
+
+	return malidp_update_windows(xpos, ypos, width, height, bpp, data);
+}
+
+/*
+__attribute__((weak))int usif_dbg_printf(const char * format, ...)
+{
+  return 0;
+}
+*/
diff --git a/devices/malidp/src/bl_malidp.c b/devices/malidp/src/bl_malidp.c
new file mode 100644
index 0000000..43585f4
--- /dev/null
+++ b/devices/malidp/src/bl_malidp.c
@@ -0,0 +1,170 @@
+/*
+* (C) Copyright 2014-2015 Rockchip Electronics
+*
+* All rights reserved.
+*
+* Contents: This header file contains the definitions and types
+* for the malidp display platform driver.
+*/
+
+#include "bl_display.h"
+#include "bl_malidp.h"
+
+static struct bl_malidp malidp_dev = {
+	.preinit = 0,
+};
+
+extern unsigned int g_cgu_dcc_clk_rate;
+
+static int malidp_setup(struct bl_malidp *malidp)
+{
+	struct drm_mode_modeinfo *mode = &malidp->mode;
+	struct fb_videomode *timging = &malidp->panel.timing;
+
+	/* power on lcd and enable clock*/
+	if (malidp->ctrl_ops) {
+		//TODO
+		*((volatile int *)0xe4700a3c) = 0x1c;
+		TRACE_BL_DISPLAY_PRINTF("Enable lcd clk: %d", malidp->disp_clk_rate);
+		malidp->ctrl_ops->bl_lcd_power_on();
+		g_cgu_dcc_clk_rate = malidp->disp_clk_rate;
+		malidp->ctrl_ops->bl_dcc_power_on();
+		*((volatile int *)0xe4700a3c) = 0x10;
+	}
+
+	mode->clock = g_cgu_dcc_clk_rate;
+	mode->vrefresh = timing->refresh;
+
+	mode->hdisplay = timing->xres;
+	mode->hsync_start = mode->hdisplay + timing->right_margin;
+	mode->hsync_end = mode->hsync_start + timing->hsync_len;
+	mode->htotal = mode->hsync_end + timing->left_margin;
+
+	mode->vdisplay = timing->yres;
+	mode->vsync_start = mode->vdisplay + timing->lower_margin;
+	mode->vsync_end = mode->vsync_start + timing->vsync_len;
+	mode->vtotal = mode->vsync_end + timing->upper_margin;
+
+	malidp_hw_update_gamma_settings(&malidp->hw_dev, false, NULL);
+	malidp_hw_modeset(&malidp->hw_dev, mode);
+
+	if (malidp->trsm_ops && malidp->trsm_ops->enable)
+		malidp->trsm_ops->enable(malidp);
+
+	return DISP_NO_ERR;
+}
+
+static int malidp_dev_init(struct bl_malidp *malidp,
+			       bl_display_cbs_t *pbl_disp_ops,
+			       void *disp_par)
+{
+	struct bl_display *bl_disp = (struct bl_display *)disp_par;
+	if (!malidp)
+		return DISP_ERR_NODEV;
+
+	if (SCREEN_MIPI == malidp->panel->screen_type) {
+		//TODO: clk rate
+		if (bl_disp->dif.u.dsi.dc_clk_rate == 0)
+			bl_disp->dif.u.dsi.dc_clk_rate = 297000000;
+		malidp->disp_clk_rate = bl_disp->dif.u.dsi.dc_clk_rate;
+	} else
+		malidp->disp_clk_rate = 2 * malidp->panel->timing.pixclock;
+
+	TRACE_BL_DISPLAY_PRINTF("screen_type %d, disp_clk_rate %d",
+			malidp->panel->screen_type, malidp->disp_clk_rate);
+	malidp->ctrl_ops = pbl_disp_ops;
+	malidp->disp_par = disp_par;
+
+	malidp_hw_init(&malidp->hw_dev, &malidp->hw_desc);
+
+	switch (malidp->panel->screen_type) {
+	case SCREEN_RGB:
+	case SCREEN_LVDS:
+		//nano_lvds_probe(display);
+		break;
+	case SCREEN_MIPI:
+		dsi_probe(malidp);
+		break;
+	default:
+		break;
+	}
+
+	return DISP_NO_ERR;
+}
+
+int bl_malidp_probe(bl_malidp_cbs_t *pbl_disp_ops, void *disp_par)
+{
+	struct bl_malidp *malidp = &malidp_dev;
+
+	if (malidp->preinit)
+		return DISP_NO_ERR;
+
+	memset(malidp, 0, sizeof(*malidp));
+
+	malidp->panel = bl_malidp_get_panel_info();
+
+	malidp_hw_enumerate(&malidp->hw_desc, MALI_DP550, &malidp->hw_pdata);
+
+	malidp_dev_init(malidp, pbl_disp_ops, disp_par);
+
+	malidp_setup(malidp);
+
+	malidp->preinit = 1;
+	return DISP_NO_ERR;
+}
+
+int malidp_update_windows(unsigned int xpos, unsigned int ypos,
+			      unsigned short xact, unsigned short yact,
+			      unsigned short bpp, unsigned char *data)
+{
+	struct bl_malidp *malidp = &malidp_dev;
+
+	struct malidp_hw_state *hw_state = &malidp->hw_state;
+	struct malidp_hw_buffer *hw_buffer = &malidp->hw_buffer;
+        struct malidp_hw_device *hw_dev = &malidp->hw_dev;
+	struct malidp_panel_info *panel = malidp->panel;
+
+	struct malidp_layer_hw_info *layer = hw_dev->topology->layers[0];
+
+	//int n_hw_layers = hw_dev->topology->n_layers;
+
+	if (xact == 0 || yact == 0 ||
+	    xact > panel->timing.xres || yact > panel->timing.yres ||
+	    bpp == 0)
+		return DISP_ERR_INVALID_SIZE;
+
+	if (!data)
+		return DISP_ERR_INVALID_DATA;
+
+
+	hw_state->n_bufs = 1;
+	hw_state->bufs = hw_buffer;
+
+	hw_buffer->natural_w = xact;
+	hw_buffer->natural_h = yact;
+	hw_buffer->n_planes = 1;
+	hw_buffer->flags = MALIDP_FLAG_BUFFER_INPUT;
+	hw_buffer->hw_layer = layer;
+
+	switch (bpp) {	/* byte per pixel */
+	case 4:
+		hw_buffer->format = layer->supported_formats[DRM_FORMAT_ABGR8888];
+		hw_buffer->alpha_mode = MALIDP_ALPHA_MODE_PIXEL;
+
+		break;
+	case 3:
+		hw_buffer->format = layer->supported_formats[DRM_FORMAT_RGB888];
+		break;
+	case 2:
+		hw_buffer->format = layer->supported_formats[DRM_FORMAT_RGB565];
+		break;
+	default:
+		break;
+	}
+
+	hw_buffer->addr[0] = (unsigned long)data;
+
+	malidp_hw_commit(hw_dev, hw_state);
+
+	return DISP_NO_ERR;
+}
diff --git a/devices/malidp/src/include/bl_display.h b/devices/malidp/src/include/bl_display.h
new file mode 100644
index 0000000..2ebc0bd
--- /dev/null
+++ b/devices/malidp/src/include/bl_display.h
@@ -0,0 +1,74 @@
+/* ----------------------------------------------------------------------------
+   Copyright (C) 2013-2014 Intel Mobile Communications GmbH
+
+   Sec Class: Intel Confidential (IC)
+
+   All rights reserved.
+   ----------------------------------------------------------------------------
+   This document contains proprietary information belonging to IMC.
+   Passing on and copying of this document, use
+   and communication of its contents is not permitted without prior written
+   authorisation.
+  ---------------------------------------------------------------------------*/
+
+#ifndef _BL_DISPLAY_H_
+#define _BL_DISPLAY_H_
+
+#include "bl-dcc.h"
+#include "bl_display_if_config.h"
+
+struct bl_display {
+	int type;
+	int fps;	/* framerate */
+	int xres;	/* pixel width */
+	int yres;	/* pixel heigth */
+	int xdpi;	/* pixel density per inch in x direction */
+	int ydpi;	/* pixel density per inch in y direction */
+	int bpp;
+	unsigned char cs;
+	struct display_reset reset;
+	/*struct display_msg *msgs_power_on;
+	struct display_msg *msgs_power_off;
+	struct display_msg *msgs_sleep_in;
+	struct display_msg *msgs_sleep_out;
+	struct display_msg *msgs_init;*/
+	struct display_msg *msgs_update;
+	int (*dif_init) (struct bl_display *lcd);
+	int (*dif_config) (struct bl_display *lcd, int type);
+	int (*dif_stop) (struct bl_display *lcd);
+	void (*panel_reset) (int gpio, struct bl_display *lcd);
+	int (*panel_init) (struct bl_display *lcd, bl_display_cbs_t *pbl_disp_cb);
+	int (*power_on) (struct bl_display *lcd);
+	int (*sleep_in) (struct bl_display *lcd);
+	int (*sleep_out) (struct bl_display *lcd);
+	int (*power_off) (struct bl_display *lcd);
+	void (*send_cmd) (struct bl_display *lcd,
+					struct display_msg *msg,
+					bl_display_cbs_t *pbl_disp_cb);
+	void (*frame_prepare) (struct bl_display *lcd,
+					int stride, int nlines);
+	int (*frame_wfe) (struct bl_display *lcd);
+	int (*set_rate) (struct bl_display *lcd, int val);
+	int (*get_rate) (struct bl_display *lcd);
+	struct bl_display_if dif;
+	unsigned int clk_rate;
+	struct display_msg **msgs_init;
+	struct display_msg **msgs_sleep_out;
+};
+
+typedef struct bl_display BL_DISPLAY;
+
+/*****
+*
+* Function Declaration
+*
+********************************************/
+bl_display* bl_display_init_config(unsigned int *blob);
+
+int bl_dsi_set_phy_lock(struct bl_display *lcd);
+void bl_dsi_start_video(struct bl_display *lcd);
+
+#define TRACE_BL_DISPLAY_PRINTF(format, s...) usif_dbg_printf(format, ## s)
+
+#endif
+
diff --git a/devices/malidp/src/include/bl_display_if_config.h b/devices/malidp/src/include/bl_display_if_config.h
new file mode 100644
index 0000000..b815f4b
--- /dev/null
+++ b/devices/malidp/src/include/bl_display_if_config.h
@@ -0,0 +1,234 @@
+/* ----------------------------------------------------------------------------
+   Copyright (C) 2013-2014 Intel Mobile Communications GmbH
+
+   Sec Class: Intel Confidential (IC)
+
+   All rights reserved.
+   ----------------------------------------------------------------------------
+   This document contains proprietary information belonging to IMC.
+   Passing on and copying of this document, use
+   and communication of its contents is not permitted without prior written
+   authorisation.
+  ---------------------------------------------------------------------------*/
+
+#ifndef BL_DISPLAY_IF_CONFIG_H_
+#define BL_DISPLAY_IF_CONFIG_H_
+
+/*
+ * The blob tool, identifies the interface definition through ,
+ * the definition of  BL_DISPLAY_IF_CONFIG_VER.
+ * If any of the following structure needs to be changed,
+ * the version number shall be increased by 1
+ */
+#define BL_DISPLAY_IF_CONFIG_VER   0x02
+
+struct xgold_lcd_periph_parameters {
+    unsigned char cs_polarity;
+    unsigned char cd_polarity;
+    unsigned char wr_polarity;
+    unsigned char rd_polarity;
+    unsigned char hd_polarity;
+    unsigned char vd_polarity;
+};
+
+struct xgold_lcd_timing_parameters {
+    unsigned addr_delay_ns;
+    unsigned cs_act_ns;
+    unsigned data_delay_ns;
+    unsigned wr_rd_act_ns;
+    unsigned wr_rd_deact_ns;
+    unsigned cs_deact_ns;
+    unsigned access_cycle_ns;
+};
+
+enum {
+    DIF_TX_DATA = 1,
+    DIF_TX_PIXELS = 2,
+};
+
+#define LCD_MSG_CMD     0
+#define LCD_MSG_DAT     1
+
+
+typedef struct {
+            int type;
+            int fps;    /* framerate */
+            int xres;   /* pixel width */
+            int yres;   /* pixel heigth */
+            int xdpi;   /* pixel density per inch in x direction */
+            int ydpi;   /* pixel density per inch in y direction */
+} PANEL_RES;
+
+struct display_msg {
+    /*const char *name;*/
+    unsigned char header;
+    unsigned char type;
+    int length;
+    int delay;		/*in ms */
+    unsigned int flags;
+    unsigned char *datas;
+};
+
+
+#define LCD_MSG_LP  1
+
+
+enum {
+    BL_IF_MIPI_DBI = 1,
+    BL_IF_MIPI_DSI = 2,
+};
+
+#define DISPLAY_IS_MIPI_DBI_IF(_t_) \
+    (_t_ == BL_IF_MIPI_DBI)
+#define DISPLAY_IS_MIPI_DSI_IF(_t_) \
+        (_t_ == BL_IF_MIPI_DSI)
+
+enum dsi_mode_t {
+    DSI_VIDEO = 0,
+    DSI_CMD = 1,
+};
+
+enum dsi_pix_stream_t {
+    DSI_PIX_BIT16P = 0,
+    DSI_PIX_BIT18P = 1,
+    DSI_PIX_BIT18L = 2,
+    DSI_PIX_BIT24P = 3,
+    DSI_PIX_UNKNOWN = 0xFF
+};
+
+enum dsi_video_mode_t {
+    DSI_ACTIVE = 0,
+    DSI_PULSES = 1,
+    DSI_EVENTS = 2,
+    DSI_BURST = 3,
+    DSI_UNKNOWN = 0xFF
+};
+
+struct bl_display_if_mipi_dsi {
+    int dc_clk_rate;
+    int mode;
+    int brmin;
+    int brdef;
+    int brmax;
+    int nblanes;
+    int id;
+/* phy0 */
+    int share;
+    int m;
+    int n;
+    int pwup;
+    int calib;
+    int to_lp_hs_req;
+/* phy1 */
+    int to_lp_hs_dis;
+    int to_lp_hs_eot;
+    int to_hs_zero;
+    int to_hs_flip;
+    int lp_clk_div;
+/* phy2 */
+    int to_hs_clk_pre;
+    int to_hs_clk_post;
+    int data_delay;
+    int clock_delay;
+    int lp_tx_tfall;
+/* phy3 */
+    int en;
+    int lp_tx_trise;
+    int lp_tx_vref;
+
+/* video mode settings*/
+    /* Timing: All values in pixclocks, except pixclock (of course) */
+    int hfp; /* horizontal front porch (cycles/bytes) */
+    int hfp_lp; /* LP / HS */
+    int hbp; /* horizontal back porch (bytes) */
+    int hbp_lp;
+    int hsa; /* horizontal sync active (bytes) */
+    int hsa_lp;
+    int vfp; /* vertical front porch (line) */
+    int vbp; /* vertical back porch (line) */
+    int vsa; /* vertical sync active (line) */
+    int video_mode;
+    int video_pixel;
+    int bllp_time;
+    int line_time;
+
+    int fps;
+    int eot;
+    int gate;
+};
+
+struct bl_display_if_mipi_dbi {
+    /* data on bus */
+    int segments_per_pix;
+    int bits_per_segment;
+    /* timing */
+    unsigned addr_delay_ns;
+    unsigned cs_act_ns;
+    unsigned data_delay_ns;
+    unsigned wr_rd_act_ns;
+    unsigned wr_rd_deact_ns;
+    unsigned cs_deact_ns;
+    unsigned access_cycle_ns;
+    unsigned int mux_params[32];
+    struct xgold_lcd_periph_parameters periph_params;
+};
+
+struct bl_display_if {
+    int type;
+    int ncfg;
+    union {
+        struct bl_display_if_mipi_dbi dbi;
+        struct bl_display_if_mipi_dsi dsi;
+    } u;
+};
+
+struct display_reset {
+    int value1;
+    int mdelay1;
+    int value2;
+    int mdelay2;
+    int value3;
+    int mdelay3;
+};
+
+typedef enum e_dcs_cmd_type
+{
+
+    DCS_CMD_START       = 0x100,
+    DCS_CMD_RESET       = 0x101,
+    DCS_CMD_INIT_START  = 0x102,
+    DCS_CMD_GENERIC     = 0x103,
+    DCS_CMD_INIT_END    = 0x104,
+    DCS_CMD_DELAY       = 0x105,
+    DCS_CMD_LP          = 0x106,
+    DCS_CMD_RESOLUTION   = 0x107,
+    DCS_CMD_DISPLAY_IF   = 0x108,
+    DCS_CMD_PANEL_INFO	= 0x109,
+    DCS_CMD_POWER_LIST	= 0x110,
+    DCS_CMD_SLEEP_OUT_START = 0x111,
+    DCS_CMD_SLEEP_OUT_END	= 0x112,
+    DCS_CMD_END         = 0x1FF
+
+} dcs_cmd_type;
+
+/*
+ * If any of the following structure needs to be changed,
+ * the version number definiton, VBT_VERSION, shall be increased by 1
+ */
+
+#define VBT_VERSION    0x2
+#define VBT_MAGIC_WORD 0xC001C0DE
+
+typedef struct {
+    unsigned int magic_word;
+    unsigned int version;
+    unsigned int vbt_size;
+    unsigned int bl_if_config_version;
+    unsigned char reserved[52]; //total: 64 bytes- Reserved for future use
+} VBT_HEADER;
+
+#define DISPLAY_CONFIG_DATA_SIZE_IN_BYTES	(7 * 1024)
+#define BL_DISP_MAX_NUMBER_OF_MSGS  1024
+#define BL_DISP_MAX_LENGTH_OF_DATA  512
+
+#endif
diff --git a/devices/malidp/src/include/bl_malidp.h b/devices/malidp/src/include/bl_malidp.h
new file mode 100644
index 0000000..9f49ee6
--- /dev/null
+++ b/devices/malidp/src/include/bl_malidp.h
@@ -0,0 +1,76 @@
+/*
+* (C) Copyright 2014-2015 Rockchip Electronics
+*
+* All rights reserved.
+*
+* Contents: This header file contains the definitions and types
+* for the malidp display platform driver.
+*/
+
+#ifndef _MALIDP_DISP_H_
+#define _MALIDP_DISP_H_
+
+#include "bl-dcc.h"
+#include "malidp_disp_config.h"
+
+#ifndef BITS
+#define BITS(x, bit)            ((x) << (bit))
+#endif
+
+#ifndef BITS_MASK
+#define BITS_MASK(x, mask, bit) BITS((x) & (mask), bit)
+#endif
+
+#ifndef bool
+#define bool	unsigned char
+#endif
+
+#define FB_VMODE_INTERLACED	1	/* interlaced	*/
+
+enum disp_result_type {
+	DISP_NO_ERR = 0,
+	DISP_ERR_NODEV,
+	DISP_ERR_INVALID_SIZE,
+	DISP_ERR_INVALID_DATA,
+	DISP_ERR_INVALID_WINID,
+	DISP_ERR_INIT_FAILED,
+	DISP_ERR_POWER_FAILED,
+	DISP_ERR_UPDATE_FAILED,
+	DISP_ERR_UNKNOWN,
+};
+
+struct bl_malidp;
+
+struct bl_malidp_trsm_drv_ops {
+	int (*enable)(struct bl_malidp *display);
+	int (*disable)(struct bl_malidp *display);
+};
+
+struct bl_malidp {
+	bool preinit;
+	unsigned int disp_clk_rate;
+
+	struct drm_mode_modeinfo mode;
+	struct bl_malidp_panel_info *panel;
+
+	struct malidp_hw_buffer hw_buffer;
+	struct malidp_layer_hw_info layer;
+
+        struct malidp_hw_description hw_desc;
+        struct malidp_hw_pdata hw_pdata;
+        struct malidp_hw_device hw_dev;
+        struct malidp_hw_state hw_state;
+	struct malidp_hw_state_priv hw_priv;
+
+	struct bl_malidp_trsm_drv_ops *trsm_ops;	/* Transmitter ops */
+	bl_display_cbs_t *ctrl_ops;
+	void *disp_par;
+};
+
+struct bl_malidp_panel_info *bl_malidp_get_panel_info(void);
+int bl_malidp_probe(bl_display_cbs_t *pbl_disp_ops, void *disp_par);
+int bl_malidp_update_windows(unsigned int xpos, unsigned int ypos,
+			      unsigned short xact, unsigned short yact,
+			      unsigned short bpp, unsigned char *data);
+
+#endif	/* _MALIDP_DISP_H_ */
diff --git a/devices/malidp/src/include/bl_malidp_kernel_fake.h b/devices/malidp/src/include/bl_malidp_kernel_fake.h
new file mode 100644
index 0000000..2be5b51
--- /dev/null
+++ b/devices/malidp/src/include/bl_malidp_kernel_fake.h
@@ -0,0 +1,33 @@
+#ifndef _BL_MALIDP_KERNEL_FAKE_H_
+#define _BL_MALIDP_KERNEL_FAKE_H_
+
+struct device {
+    int device;
+};
+
+struct mutex {
+    int mutex;
+};
+
+typedef struct spinlock {
+    int lock;
+} spinlock_t;
+
+#define spin_lock_irqsave(lock, flags) 
+#define spin_unlock_irqrestore(lock, flags)
+
+#define mutex_lock(m)
+#define mutex_unlock(m)
+
+#define kfree(m) TRACE_BL_DISPLAY_PRINTF("%s: %d: kfree called", __func__, __LINE__)
+
+#define dev_err(dev, format, s...) TRACE_BL_DISPLAY_PRINTF(format, ## s)
+#define dev_info(dev, format, s...) TRACE_BL_DISPLAY_PRINTF(format, ## s)
+#define dev_dbg(dev, format, s...) TRACE_BL_DISPLAY_PRINTF(format, ## s)
+
+#define clk_get_rate(clk) (1080*1920*4*60)   //TODO
+#define clk_set_rate(clk, rate) //TODO
+
+#define kzalloc(size, flags)
+
+#endif
diff --git a/devices/malidp/src/include/malidp_adf.h b/devices/malidp/src/include/malidp_adf.h
new file mode 100644
index 0000000..f694bda
--- /dev/null
+++ b/devices/malidp/src/include/malidp_adf.h
@@ -0,0 +1,285 @@
+/*
+ *
+ * (C) COPYRIGHT 2013-2015 ARM Limited. All rights reserved.
+ *
+ * This program is free software and is provided to you under the terms of the
+ * GNU General Public License version 2 as published by the Free Software
+ * Foundation, and any use by you of this program is subject to the terms
+ * of such GNU licence.
+ *
+ * A copy of the licence is included with the program, and can also be obtained
+ * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA  02110-1301, USA.
+ *
+ */
+
+
+
+#ifndef _UAPI_MALIDP_ADF_H_
+#define _UAPI_MALIDP_ADF_H_
+
+/* Product identification */
+#define MALIDP_CORE_ID(__product, __major, __minor, __status) \
+	((((__product) & 0xFFFF) << 16) | (((__major) & 0xF) << 12) | \
+	(((__minor) & 0xF) << 8) | ((__status) & 0xFF))
+#define MALIDP_CORE_ID_PRODUCT_ID(__core_id) ((u32)(__core_id) >> 16)
+#define MALIDP_CORE_ID_MAJOR(__core_id)      (((u32)(__core_id) >> 12) & 0xF)
+#define MALIDP_CORE_ID_MINOR(__core_id)      (((u32)(__core_id) >> 8) & 0xF)
+#define MALIDP_CORE_ID_STATUS(__core_id)     (((u32)(__core_id)) & 0xFF)
+
+#define MALIDP_DP500_PRODUCT_ID 0x0500
+#define MALIDP_DP550_PRODUCT_ID 0x0550
+
+/* Custom pixel formats */
+#define MALIDP_FORMAT_XYUV	fourcc_code('M', 'X', 'Y', 'V') /* [31:0] X:Y:Cb:Cr 8:8:8:8 little endian */
+#define MALIDP_FORMAT_VYU30	fourcc_code('M', 'V', '3', '0') /* [31:0] X:Cr:Y:Cb 2:10:10:10 little endian */
+#define MALIDP_FORMAT_NV12AFBC	fourcc_code('M', '1', '2', 'A') /* AFBC compressed YUV 4:2:0, 8 bits per component */
+#define MALIDP_FORMAT_NV16AFBC	fourcc_code('M', '1', '6', 'A') /* AFBC compressed YUV 4:2:2, 8 bits per component */
+#define MALIDP_FORMAT_YUV10_420AFBC	fourcc_code('M', '3', '0', 'A') /* AFBC compressed YUV 4:2:0, 10 bits per component */
+#define MALIDP_FORMAT_Y0L2	fourcc_code('Y', '0', 'L', '2') /* YUV 4:2:0, ARM linear 10-bit packed format */
+/* YUV 4:2:0, 10-bit per component, 2 plane.
+ * Each sample packed into the top 10 bits of a 16-bit word.
+ * Plane 0: [63:0] Y3:x:Y2:x:Y1:x:Y0, 10:6:10:6:10:6:10:6
+ * Plane 1: [63:0] V02:x:U02:x:V00:x:U00, 10:6:10:6:10:6:10:6
+ */
+#define MALIDP_FORMAT_P010	fourcc_code('P', '0', '1', '0')
+
+/* Custom interface types */
+#define MALIDP_INTF_LVDS    (ADF_INTF_TYPE_DEVICE_CUSTOM + 1)
+#define MALIDP_INTF_VIRTUAL (ADF_INTF_TYPE_DEVICE_CUSTOM + 2)
+#define MALIDP_INTF_MEMORY  (ADF_INTF_TYPE_DEVICE_CUSTOM + 3)
+#define MALIDP_INTF_UNKNOWN (ADF_INTF_TYPE_DEVICE_CUSTOM + 4)
+
+/* Flags to describe blending mode */
+#define MALIDP_ALPHA_MODE_NONE    (1 << 0)
+#define MALIDP_ALPHA_MODE_LAYER   (0 << 1)
+#define MALIDP_ALPHA_MODE_PIXEL   (1 << 1)
+#define MALIDP_ALPHA_MODE_NO_BG   (0 << 2)
+#define MALIDP_ALPHA_MODE_W_BG    (1 << 2)
+#define MALIDP_ALPHA_MODE_PREMULT (1 << 3)
+
+/* Flags to describe transformation
+ * Rotations are in a counter-clockwise direction */
+#define MALIDP_TRANSFORM_SET_R(X) (((X) & 0x3) << 0)
+#define MALIDP_TRANSFORM_GET_R(X) (((X) >> 0) & 0x3)
+#define MALIDP_TRANSFORM_R0       0
+#define MALIDP_TRANSFORM_R90      1
+#define MALIDP_TRANSFORM_R180     2
+#define MALIDP_TRANSFORM_R270     3
+#define MALIDP_TRANSFORM_HFLIP    (1 << 2)
+#define MALIDP_TRANSFORM_VFLIP    (1 << 3)
+
+/* Flags for other things */
+#define MALIDP_FLAG_BUFFER_INPUT    (0 << 0)
+#define MALIDP_FLAG_BUFFER_OUTPUT   (1 << 0)
+#define MALIDP_FLAG_YUV_MASK        (3 << 1)
+#define MALIDP_FLAG_YUV_BT601       (0 << 1)
+#define MALIDP_FLAG_YUV_BT709       (1 << 1)
+#define MALIDP_FLAG_YUV_NARROW      (0 << 2)
+#define MALIDP_FLAG_YUV_WIDE        (1 << 2)
+#define MALIDP_FLAG_AFBC            (1 << 3)
+#define MALIDP_FLAG_AFBC_YTR        (1 << 4)
+/*
+ * This forces inverse-gamma-correction to be disabled, which is enabled by
+ * default for YUV buffers and always disabled for RGB buffers
+ */
+#define MALIDP_FLAG_FORCE_NO_IGAMMA (1 << 5)
+#define MALIDP_FLAG_SRGB	    (1 << 6)
+#define MALIDP_FLAG_AFBC_SPLITBLK   (1 << 7)
+#define MALIDP_FLAG_SMART_BBOX      (1 << 8)
+
+/* Layer feature descriptors */
+#define MALIDP_LAYER_FEATURE_SCALING   (1 << 0)
+#define MALIDP_LAYER_FEATURE_TRANSFORM (1 << 1)
+#define MALIDP_LAYER_FEATURE_AFBC      (1 << 2)
+#define MALIDP_LAYER_FEATURE_SRGB      (1 << 3)
+
+/* Flags to describe the strategy used for partitioning
+ * rotation memory
+ */
+
+/*
+ * MALIDP_ROTMEM_PARTITION_FIXED
+ * The hardware paritions memory in a fixed pattern based on the number of
+ * layers using the rotation memory. Rotation memory is used by buffers
+ * that meet one or more of the following criteria:
+ *  * Are rotated by 90 or 270 degrees
+ *  * Are compressed with AFBC (with or without rotation)
+ *
+ * The fixed partitions use the following pattern:
+ * | Number of buffers in rotation memory | Buffer 1 | Buffer 2 | Buffer 3 |
+ * |                  1                   |   100%   |   N/A    |    N/A   |
+ * |                  2                   |    50%   |   50%    |    N/A   |
+ * |                  3                   |    50%   |   25%    |    25%   |
+ */
+#define MALIDP_ROTMEM_PARTITION_FIXED (1 << 0)
+
+#define MALIDP_MAX_N_FORMATS 64
+
+#define MALIDP_N_GAMMA_COEFFS 64
+
+struct malidp_buffer_config {
+	/* The index of the adf_buffer_config which this malidp config relates
+	 * to */
+	__u32 adf_buffer_index;
+
+	/* The ID of the interface which this config relates to */
+	__u32 adf_intf_id;
+
+	/* The on-screen size/position of the buffer (per interface) */
+	__u16 display_top;
+	__u16 reserved1;
+	__u16 display_left;
+	__u16 reserved2;
+
+	/* The display dimensions are given after any scaling has been
+	 * applied (but before any rotate operation) */
+	__u16 display_width;
+	__u16 reserved3;
+	__u16 display_height;
+	__u16 reserved4;
+
+	/* The transformation to be applied. The application must ensure that
+	 * this field is consistent for all malidp_buffer_configs which target
+	 * a particular adf_buffer_config */
+	__u32 transform;
+
+	/* Special purpose flags. Bitwise-or of MALIDP_FLAG_XX */
+	__u32 flags;
+
+	/* Alpha blending parameters in case of composition */
+	__u32 alpha_mode; /* Bitwise OR of MALIDP_ALPHA_MODE_XX */
+	__u8 layer_alpha; /* 0xFF is opaque */
+	__u8 pad[3];
+
+	/* AFBC-specific fields */
+	__u16 afbc_crop_l;
+	__u16 afbc_crop_r;
+	__u16 afbc_crop_t;
+	__u16 afbc_crop_b;
+
+};
+
+struct malidp_post_data_hdr {
+	__u32 type;
+	__u32 size;
+};
+
+struct malidp_custom_data {
+	struct malidp_post_data_hdr reserved;
+
+	/* This is the total number of custom buffer descriptions included.
+	 * It can be up to n_bufs * n_interfaces (one config per interface per
+	 * buffer)
+	 */
+	__u32 n_malidp_buffer_configs;
+
+	/* The size of each buffer config, allows for future expansion, and for
+	 * user/kernel space to have mismatched struct descriptions */
+	__u32 sizeof_malidp_buffer_config;
+
+	/* Everything past this point is an array of malidp_buffer_configs */
+	struct malidp_buffer_config buffers[];
+};
+
+struct malidp_adf_overlay_custom_data {
+	/* Non-zero if this overlay engine can be scaled. Should not be used
+	 * by new software, use the features field instead.
+	 */
+	__u32 supports_scaling;
+	/* Bitwise-OR of MALIDP_LAYER_FEATURE_xxx supported by this overlay */
+	__u32 features;
+	/* The number of layers supported by this overlay engine */
+	__u32 n_supported_layers;
+	__u32 pad;
+};
+
+struct malidp_adf_intf_custom_data {
+	__u8 gamma; /* gamma value as returned by the EDID standard */
+	/* (u16, u16) binary fixed point.
+	 * (h_input*v_input)/v_output should be less than threshold.
+	 */
+	__u32 downscaling_threshold;
+};
+
+struct malidp_adf_device_custom_data {
+	/* Information about the available rotation memory*/
+	__u32 rotation_memory_size; /* Size of available memory in bytes */
+	__u32 rotation_memory_strategy; /* Bitwise-or of MALIDP_ROTMEM_* */
+
+	__u32 n_scalers; /* The number of scaling blocks available */
+
+	/* Minimum and maximum supported dimensions for a layer (in pixels) */
+	__u32 min_width;
+	__u32 min_height;
+	__u32 max_width;
+	__u32 max_height;
+
+	/* The number of AFBC pixel formats supported by this device */
+	__u32 n_supported_afbc_formats;
+	/* List of AFBC pixel formats supported by this device */
+	__u32 supported_afbc_formats[MALIDP_MAX_N_FORMATS];
+
+	/* The number of write-back pixel formats supported by this device */
+	__u32 n_supported_mw_formats;
+	/* List of write-back pixel formats supported by this device */
+	__u32 supported_mw_formats[MALIDP_MAX_N_FORMATS];
+	/* The number of unsupported transform formats */
+	__u32 n_xform_invalid_formats;
+	/* The bitfield AFBC formats which support split block */
+	__u64 supported_afbc_splitblk;
+	/* List of unsupported transform formats */
+	__u32 xform_invalid_formats[MALIDP_MAX_N_FORMATS];
+};
+
+#define MALIDP_ADF_EVENT_FLIP (ADF_EVENT_DEVICE_CUSTOM + 1)
+
+/**
+ * struct adf_flip_event - a new scene was posted on the screen
+ *
+ * A flip event always occurrs at the same time than an standard vsync event.
+ * So they will have exactly the same timestamp.
+ *
+ * @base: event header
+ * @timestamp: time of flip event, in nanoseconds
+ */
+struct malidp_adf_flip_event {
+	struct adf_event base;
+	__aligned_u64 timestamp;
+};
+
+/**
+ * struct malidp_adf_get_output_fence - retrieve an output fence from kernel
+ * space. This can only be used on interfaces of type ADF_INTF_MEMORY.
+ *
+ * @output_fence: sync_fence fd which will clear when the output buffer has
+ * been written out.
+ *
+ */
+struct malidp_adf_get_output_fence {
+	__s32 output_fence;
+};
+
+/**
+ * struct malidp_adf_set_gamma - enable/disable the gamma correction and
+ * program the HW gamma coef. table.
+ * This can only be used on the primary interface.
+ *
+ * @enable: enable/disable the gamma correction.
+ * @coefficient: the gamma coeff. table for HW.
+ *
+ */
+struct malidp_adf_set_gamma {
+	__u32 enable;
+	__u32 pad;	/* align to 64bit */
+
+	__u32 coefficient[MALIDP_N_GAMMA_COEFFS];
+};
+
+#define MALIDP_ADF_IOCTL_GET_OUTPUT_FENCE _IOR('D', 128, \
+					struct malidp_adf_get_output_fence)
+
+#define MALIDP_ADF_IOCTL_SET_GAMMA		  _IOW('D', 129, \
+					struct malidp_adf_set_gamma)
+
+#endif /* _UAPI_MALIDP_ADF_H_ */
diff --git a/devices/malidp/src/include/malidp_de_device.h b/devices/malidp/src/include/malidp_de_device.h
new file mode 100644
index 0000000..f0f5c1e
--- /dev/null
+++ b/devices/malidp/src/include/malidp_de_device.h
@@ -0,0 +1,374 @@
+/*
+ *
+ * (C) COPYRIGHT 2013-2015 ARM Limited. All rights reserved.
+ *
+ * This program is free software and is provided to you under the terms of the
+ * GNU General Public License version 2 as published by the Free Software
+ * Foundation, and any use by you of this program is subject to the terms
+ * of such GNU licence.
+ *
+ * A copy of the licence is included with the program, and can also be obtained
+ * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA  02110-1301, USA.
+ *
+ */
+
+
+
+#ifndef _MALIDP_DE_DEVICE_H_
+#define _MALIDP_DE_DEVICE_H_
+
+#include "malidp_hw_types.h"
+#include "malidp_sysfs.h"
+
+#define DE_H_FRONTPORCH(x)	(((x) & 0xfff) << 0)
+#define DE_H_BACKPORCH(x)	(((x) & 0x3ff) << 16)
+#define DE_V_FRONTPORCH(x)	(((x) & 0xff) << 0)
+#define DE_V_BACKPORCH(x)	(((x) & 0xff) << 16)
+#define DE_H_SYNCWIDTH(x)	(((x) & 0x3ff) << 0)
+#define DE_V_SYNCWIDTH(x)	(((x) & 0xff) << 16)
+#define DE_H_ACTIVE(x)	(((x) & 0x1fff) << 0)
+#define DE_V_ACTIVE(x)	(((x) & 0x1fff) << 16)
+
+#define DE_LINE_INT_1(x)	((x) & 0x3fff)
+#define DE_LINE_INT_2(x)	(((x) & 0x3fff) << 16)
+
+
+#define	DE_AXI_OUTSTDCAPB_MASK	0xff
+#define	DE_AXI_OUTSTDCAPB(x)	(((x) & DE_AXI_OUTSTDCAPB_MASK) << 0)
+#define	DE_AXI_POUTSTDCAB_MASK	0x3f
+#define	DE_AXI_POUTSTDCAB(x)	(((x) & DE_AXI_POUTSTDCAB_MASK) << 8)
+#define	DE_AXI_BURSTLEN_MASK	0xff
+#define	DE_AXI_BURSTLEN(x)	(((x) & DE_AXI_BURSTLEN_MASK) << 16)
+
+#define DE_SET_FLOWCFG_MASK	0x3
+#define DE_SET_FLOWCFG(x)	(((x) & DE_SET_FLOWCFG_MASK) << 16)
+#define DE_GAMMA_EN		0x1
+#define DE_CADJ_EN		(1 << 4)
+#define DE_DITH_EN		(1 << 12)
+
+#define DE_OUT_DEPTH_MASK		0xf
+#define DE_OUT_DEPTH_R_SHIFT		16
+#define DE_OUT_DEPTH_R(x)		(((x) & DE_OUT_DEPTH_MASK) << DE_OUT_DEPTH_R_SHIFT)
+#define DE_OUT_DEPTH_G_SHIFT		8
+#define DE_OUT_DEPTH_G(x)		(((x) & DE_OUT_DEPTH_MASK) << DE_OUT_DEPTH_G_SHIFT)
+#define DE_OUT_DEPTH_B_SHIFT		0
+#define DE_OUT_DEPTH_B(x)		(((x) & DE_OUT_DEPTH_MASK) << DE_OUT_DEPTH_B_SHIFT)
+
+#define DE_REG_COEFTAB_ADDR		0x30
+#define		DE_COEFTAB_ADDR_MASK		0x3f
+#define		DE_COEFTAB_TABLE_MASK		0x7
+#define		DE_COEFTAB_ADDR_SHIFT		0
+#define		DE_COEFTAB_GAMMA_SHIFT		16
+#define		DE_COEFTAB_LV_DEGAMMA_SHIFT	19
+#define		DE_COEFTAB_GAMMA		(DE_COEFTAB_TABLE_MASK << DE_COEFTAB_GAMMA_SHIFT)
+#define		DE_COEFTAB_LV_DEGAMMA		(DE_COEFTAB_TABLE_MASK << DE_COEFTAB_LV_DEGAMMA_SHIFT)
+#define		DE_COEFTAB_INTAB_ADDR(x)	(((x) & DE_COEFTAB_ADDR_MASK) << DE_COEFTAB_ADDR_SHIFT)
+#define DE_REG_COEFTAB_DATA		0x34
+#define		DE_COEFTAB_DATA(a, b)		((((a) & 0xfff) << 16) | (((b) & 0xfff) << 0))
+#define DE_N_COEFTAB_COEFS		64
+#define DE_N_COLORADJ_COEFS		12
+
+/* Layer Common Registers */
+#define DE_REG_L_FORMAT			0x0
+#define		DE_L_FMT_MASK			0x3f
+#define		DE_L_SET_FMT(x)			(((x) & DE_L_FMT_MASK) << 0)
+#define DE_REG_L_CONTROL		0x4
+#define		DE_L_EN				(1 << 0)
+#define		DE_L_FCFG_MASK		0x7
+#define		DE_L_FCFG(x)			(((x) & DE_L_FCFG_MASK) << 1)
+#define		DE_GET_L_FCFG(x)		((x >> 1) & DE_L_FCFG_MASK)
+#define		DE_L_IGEN			(1 << 4)
+#define		DE_L_VALID			(1 << 5)
+#define		DE_L_IGSEL_MASK			(0x3 << 6)
+#define		DE_L_IGSEL_IG			(0 << 6)
+#define		DE_L_IGSEL_SRGB			(1 << 6)
+#define		DE_L_IGSEL_LINEAR		(2 << 6)
+#define		DE_L_ROT_90			(1 << 8)
+#define		DE_L_ROT_180			(2 << 8)
+#define		DE_L_HFLIP			(1 << 10)
+#define		DE_L_VFLIP			(1 << 11)
+#define		DE_L_TRANS_MASK			(DE_L_ROT_90 | DE_L_ROT_180 | DE_L_HFLIP | DE_L_VFLIP)
+#define		DE_L_SET_TRANS(x)		(((x) << 8) & DE_L_TRANS_MASK)
+#define		DE_L_COMPOSE_PIXEL		(1 << 12)
+#define		DE_L_COMPOSE_BG			(2 << 12)
+#define		DE_L_PREMULT			(1 << 14)
+#define		DE_L_ALPHA(x)			(((x) & 0xff) << 16)
+#define DE_REG_L_COMPOSE		0x8
+#define		DE_L_ALPHA0(x)			((x) & 0xff)
+#define		DE_L_ALPHA1(x)			(((x) & 0xff) << 8)
+#define		DE_L_ALPHA2(x)			(((x) & 0xff) << 16)
+#define		DE_L_ALPHA3(x)			(((x) & 0xff) << 24)
+#define DE_REG_L_SIZE			0xC
+#define DE_REG_L_SIZE_CMP		0x10
+#define		DE_L_SIZE_H(x)			(((x) & 0x1fff) << 0)
+#define		DE_L_SIZE_V(x)			(((x) & 0x1fff) << 16)
+#define DE_REG_L_OFFSET			0x14
+#define		DE_L_OFFSET_H(x)		(((x) & 0x1fff) << 0)
+#define		DE_L_OFFSET_V(x)		(((x) & 0x1fff) << 16)
+
+/* Video Layer Specific Registers */
+#define DE_REG_LV1_STRIDE		0x18
+#define DE_REG_LV2_STRIDE		0x1C
+#define DE_REG_LV3_STRIDE		0x20
+#define DE_REG_LV1_PTR0_LOW		0x24
+#define DE_REG_LV1_PTR0_HIGH		0x28
+#define DE_REG_LV1_PTR1_LOW		0x2C
+#define DE_REG_LV1_PTR1_HIGH		0x30
+#define DE_REG_LV2_PTR0_LOW		0x34
+#define DE_REG_LV2_PTR0_HIGH		0x38
+#define DE_REG_LV2_PTR1_LOW		0x3C
+#define DE_REG_LV2_PTR1_HIGH		0x40
+#define DE_REG_LV3_PTR0_LOW		0x44
+#define DE_REG_LV3_PTR0_HIGH		0x48
+#define DE_REG_LV3_PTR1_LOW		0x4C
+#define DE_REG_LV3_PTR1_HIGH		0x50
+#define DE_REG_LV1I_PTR0_LOW		0x54
+#define DE_REG_LV1I_PTR0_HIGH		0x58
+#define DE_REG_LV1I_PTR1_LOW		0x5C
+#define DE_REG_LV1I_PTR1_HIGH		0x60
+#define DE_REG_LV2I_PTR0_LOW		0x64
+#define DE_REG_LV2I_PTR0_HIGH		0x68
+#define DE_REG_LV2I_PTR1_LOW		0x6C
+#define DE_REG_LV2I_PTR1_HIGH		0x70
+#define DE_REG_LV3I_PTR0_LOW		0x74
+#define DE_REG_LV3I_PTR0_HIGH		0x78
+#define DE_REG_LV3I_PTR1_LOW		0x7C
+#define DE_REG_LV3I_PTR1_HIGH		0x80
+#define DE_REG_LV1_PTR0_R_LOW		0x84
+#define DE_REG_LV1_PTR0_R_HIGH		0x88
+#define DE_REG_LV1_PTR1_R_LOW		0x8C
+#define DE_REG_LV1_PTR1_R_HIGH		0x90
+#define DE_REG_LV2_PTR0_R_LOW		0x94
+#define DE_REG_LV2_PTR0_R_HIGH		0x98
+#define DE_REG_LV2_PTR1_R_LOW		0x9C
+#define DE_REG_LV2_PTR1_R_HIGH		0xA0
+#define DE_REG_LV3_PTR0_R_LOW		0xA4
+#define DE_REG_LV3_PTR0_R_HIGH		0xA8
+#define DE_REG_LV3_PTR1_R_LOW		0xAC
+#define DE_REG_LV3_PTR1_R_HIGH		0xB0
+
+/* Graphics Layer Specific Registers */
+#define DE_REG_LG_STRIDE		0x18
+#define DE_REG_LG_PTR0_LOW		0x1C
+#define DE_REG_LG_PTR0_HIGH		0x20
+#define DE_REG_LG_PTR1_LOW		0x24
+#define DE_REG_LG_PTR1_HIGH		0x28
+
+/* Smart Layer Specific Registers */
+#define DE_REG_LS_BBOX_ARGB		0x18
+#define DE_REG_LS_ENABLE		0x1C
+#define		DE_LS_EN_NUM(x)		(((x) & 0x7) << 0)
+#define DE_REG_LS_R1_IN_SIZE		0x20
+#define DE_REG_LS_R1_OFFSET		0x24
+#define DE_REG_LS_R1_STRIDE		0x28
+#define DE_REG_LS_R1_PTR_LOW		0x2C
+#define DE_REG_LS_R1_PTR_HIGH		0x30
+
+#define DE_REG_LS_R2_IN_SIZE		0x34
+
+#define DE_REG_LS_Rn_ADDR_DELTA	(DE_REG_LS_R2_IN_SIZE - DE_REG_LS_R1_IN_SIZE)
+
+/* AFBC Decoder Registers */
+#define DE_AD_EN			(1 << 0)
+#define DE_AD_YTR			(1 << 4)
+#define DE_AD_BS			(1 << 8)
+#define DE_AD_CROP_LEFT(x)		(((x) & 0x1FFF) << 0)
+#define DE_AD_CROP_RIGHT(x)		(((x) & 0x1FFF) << 16)
+#define DE_AD_CROP_TOP(x)		(((x) & 0x1FFF) << 0)
+#define DE_AD_CROP_BOTTOM(x)		(((x) & 0x1FFF) << 16)
+
+/* RQOS Register */
+#define		DE_RQOS_LOW(x)		(((x) & 0xFFF) << 0)
+#define		DE_RQOS_RED(x)		(((x) & 0xF) << 12)
+#define		DE_RQOS_HIGH(x)		(((x) & 0xFFF) << 16)
+#define		DE_RQOS_GREEN(x)	(((x) & 0xF) << 28)
+
+#define DE_DEFAULT_AXI_OUTSTRAN		16
+#define DE_DEFAULT_AXI_POUTSTDCAB	16
+#define DE_DEFAULT_AXI_BURSTLEN		16
+#define DE_DEFAULT_AXI_ARQOS_LOW	112
+#define DE_DEFAULT_AXI_ARQOS_HIGH	128
+#define DE_DEFAULT_AXI_ARQOS_RED	1
+#define DE_DEFAULT_AXI_ARQOS_GREEN	0
+
+/* Background is always set to black color */
+#define DE_FIXED_BG_R   0
+#define DE_FIXED_BG_G   0
+#define DE_FIXED_BG_B   0
+
+#define DE_DEFAULT_PREFETCH_LINE	5
+
+enum malidp_de_flow_cmp_cfg {
+	MALIDP_DE_CMP_FLOW_INTERNAL,
+	MALIDP_DE_CMP_FLOW_SE0,
+	/* Other configurations are currently reserved */
+};
+
+enum malidp_de_flow_layer_cfg {
+	MALIDP_DE_LAYER_FLOW_LOCAL = 0,
+	MALIDP_DE_LAYER_FLOW_SIMULT_SE0 = 1,
+	MALIDP_DE_LAYER_FLOW_SCALE_SE0 = 3,
+	/* Other values are currently reserved */
+};
+
+/*
+ * This structure contains all the relevant HW parameters we need to change
+ * the mode in the DE:
+ * - clock: frequency of the pixclk in Hz
+ * Horizontal sync parameters:
+ * - h_active: size of the horizontal active area in pixels
+ * - hbp: horizontal backporch in pixels
+ * - hfp: horizontal front porch in pixels
+ * - hsw: horizontal sync pulse width
+ * - hsync_pol_pos: horizontal sync polarity (true=positive, false=negative)
+ * Vertical sync parameters:
+ * - v_active: size of the vertical active area in pixels
+ * - vbp: vertical backporch in pixels
+ * - vfp: vertical front porch in pixels
+ * - vsw: vertical sync pulse width
+ * - vsync_pol_pos: vertical sync polarity (true=positive, false=negative)
+ */
+struct malidp_de_hwmode {
+	u32 clock;
+	u32 h_active, hbp, hfp, hsw;
+	bool hsync_pol_pos;
+	u32 v_active, vbp, vfp, vsw;
+	bool vsync_pol_pos;
+};
+
+struct malidp_de_device {
+	void __iomem *regs;
+	enum malidp_op_mode op_mode;
+	struct drm_mode_modeinfo current_mode;
+	struct device *device;
+	struct malidp_hw_device *hwdev;
+	void (*flip_callback)(struct device *, void *, struct malidp_hw_event_queue *);
+	void *callback_opaque;
+	const s32 *yuv2rgb_coeffs[MALIDP_MAX_LAYERS];
+	/*
+	 * Used to indicate that the next PTR_UPDATE IRQ is due to a
+	 * content change as opposed to a mode change or disabling the memory
+	 * interface. Access must be protected by the hwdev hw_lock.
+	 */
+	bool scene_changing;
+	struct malidp_hw_event_queue *ev_queue;
+	/*
+	 * This spinlock protects accesses to registers and clocks.
+	 * Also protects the shared variables in this structure:
+	 * "event", "op_mode" and "flip_callback".
+	 */
+	spinlock_t *hw_lock;
+
+	/*
+	 * Gamma-related settings
+	 */
+	bool gamma_enabled;
+	u32 gamma_coeffs[DE_N_COEFTAB_COEFS];
+
+	/* Color adjustment settings */
+	u16 color_adjustment_coeffs[DE_N_COLORADJ_COEFS];
+
+	/* Output depth for dithering */
+	u8 red_bits, green_bits, blue_bits;
+
+	/* Attributes accessible through sysfs */
+	u16 burstlen;
+	u8 outstran;
+	u8 poutstdcab;
+
+	u16 arqos_threshold_low;
+	u16 arqos_threshold_high;
+	u8 arqos_red;
+	u8 arqos_green;
+
+	const struct malidp_de_regmap *de_regmap;
+	/* Stored after entering PSM to handle any residual IRQs */
+	u32 pending_status;
+};
+
+int malidp_dt_parse_de(struct platform_device *pdev,
+			       struct device_node *nproot,
+			       struct malidp_hw_pdata *pdata);
+
+int malidp_de_fmt_drm2hw(struct malidp_de_device *dev,
+	struct malidp_hw_buffer *buf);
+
+struct malidp_de_device *malidp_de_hw_init(struct malidp_hw_device *hwdev,
+			     struct platform_device *pdev,
+			     struct malidp_hw_pdata *pdata,
+			     spinlock_t *hw_lock);
+
+void malidp_de_set_axi_cfg(struct malidp_de_device *dev, u32 outstran,
+				u32 poutstdcab, u32 burstlen);
+bool malidp_de_attr_valid(struct malidp_de_device *dev,
+		u32 attr, u32 val);
+void malidp_de_init_axi_qos(struct malidp_de_device *dev,
+		u32 low, u32 high, u32 red_code, u32 green_code);
+void malidp_de_write_alpha_lookup(struct malidp_de_device *dev);
+void malidp_de_hw_exit(struct malidp_de_device *dev);
+
+void malidp_de_write(struct malidp_de_device *dev,
+				u32 value, u32 reg);
+u32 malidp_de_read(struct malidp_de_device *dev, u32 reg);
+void malidp_de_setbits(struct malidp_de_device *dev, u32 mask,
+		u32 reg);
+void malidp_de_clearbits(struct malidp_de_device *dev,
+		u32 mask, u32 reg);
+irqreturn_t malidp_de_irq_thread_handler(int irq, void *data);
+
+int malidp_de_modeset(struct malidp_de_device *dev,
+		struct drm_mode_modeinfo *mode);
+
+void malidp_de_set_coeftab(struct malidp_de_device *dev,
+	u32 table, const u32 *coeffs);
+/*
+ * The following functions need to be called while holding the HW spinlock
+ * unless they are used at initialization or exit time.
+ *
+ */
+void malidp_de_cfg_cmp_flow(struct malidp_de_device *dev,
+			enum malidp_de_flow_cmp_cfg);
+
+void malidp_de_cfg_layer_flow(struct malidp_de_device *dev,
+			const struct malidp_layer_hw_info *hw_layer,
+			enum malidp_de_flow_layer_cfg cfg);
+
+enum malidp_de_flow_layer_cfg malidp_de_get_layer_flow(struct malidp_de_device *dev,
+			const struct malidp_layer_hw_info *hw_layer);
+
+void malidp_de_cfg_smart_state(struct malidp_de_device *dev,
+			const struct malidp_hw_smart_layer_state *ls_state);
+
+int malidp_de_cfg_layer(struct malidp_de_device *dev,
+			struct malidp_hw_buffer *buf);
+
+void malidp_de_disable_all_layers(struct malidp_de_device *dev);
+
+void malidp_de_set_flip_callback(struct malidp_de_device *dev,
+		void (*callback)(struct device *, void *, struct malidp_hw_event_queue *),
+		void *opaque);
+
+void malidp_de_modeget(struct malidp_de_device *dev,
+		       struct drm_mode_modeinfo *mode);
+
+enum malidp_op_mode malidp_de_get_op_mode(struct malidp_de_device *dev);
+
+int malidp_de_get_attr(struct malidp_de_device *dev, u32 attr, u32 *val);
+int malidp_de_set_attr(struct malidp_de_device *dev, u32 attr, u32 val);
+int malidp_de_save_attr(struct malidp_de_device *dev, u32 attr, u32 val);
+
+void malidp_de_update_gamma_settings(struct malidp_de_device *dev,
+			bool enable, u32 *coeffs);
+void malidp_de_store_output_depth(struct malidp_de_device *dev,
+		u8 red, u8 green, u8 blue);
+
+int malidp_de_update_cadj_coeffs(struct malidp_de_device *dev,
+	u16 red_x, u16 red_y, u16 green_x, u16 green_y,
+	u16 blue_x, u16 blue_y, u16 white_x, u16 white_y);
+
+void malidp_de_debugfs_init(struct malidp_de_device *dev,
+		struct dentry *folder);
+
+void malidp_de_cleanup_yuv2rgb_coeffs(struct malidp_de_device *dev);
+#endif /* _MALIDP_DE_DEVICE_H_ */
diff --git a/devices/malidp/src/include/malidp_disp_config.h b/devices/malidp/src/include/malidp_disp_config.h
new file mode 100644
index 0000000..9e4712b
--- /dev/null
+++ b/devices/malidp/src/include/malidp_disp_config.h
@@ -0,0 +1,74 @@
+#ifndef _MALIDP_DISP_CONFIG_H_
+#define _MALIDP_DISP_CONFIG_H_
+
+#define OUT_P888	0	/* 24bit screen,connect to lcdc D0~D23 */
+#define OUT_P666	1	/* 18bit screen,connect to lcdc D0~D17 */
+#define OUT_P565	2
+#define OUT_S888x	4
+#define OUT_CCIR656	6
+#define OUT_S888	8
+#define OUT_S888DUMY	12
+#define OUT_RGB_AAA	15
+#define OUT_P16BPP4	24
+#define OUT_D888_P666	0x21	/* connect to lcdc D2~D7, D10~D15, D18~D23 */
+#define OUT_D888_P565	0x22
+
+#define SCREEN_NULL		0
+#define SCREEN_RGB		1
+#define SCREEN_LVDS		2
+#define SCREEN_DUAL_LVDS	3
+#define SCREEN_MCU		4
+#define SCREEN_TVOUT		5
+#define SCREEN_HDMI		6
+#define SCREEN_MIPI		7
+#define SCREEN_DUAL_MIPI	8
+#define SCREEN_EDP		9
+
+#define LVDS_8BIT_1	0
+#define LVDS_8BIT_2	1
+#define LVDS_8BIT_3	2
+#define LVDS_6BIT	3
+
+#define PRMRY		1	/* primary display device */
+#define EXTEND		2	/* extend display device */
+
+#define FB_VMODE_INTERLACED	1	/* interlaced	*/
+
+struct fb_videomode {
+	/* const char *name; */
+	unsigned int refresh;
+	unsigned int xres;
+	unsigned int yres;
+	unsigned int pixclock;
+	unsigned int left_margin;
+	unsigned int right_margin;
+	unsigned int upper_margin;
+	unsigned int lower_margin;
+	unsigned int hsync_len;		/* Horz sync pulse width */
+	unsigned int vsync_len;		/* Vertical sync pulse width */
+	unsigned int sync;
+	unsigned int vmode;
+	unsigned int flag;
+};
+
+/**
+ * A structure for lcd panel information.
+ */
+struct malidp_panel_info {
+	unsigned int lcd_face;	/* lcd rgb tye (i.e. RGB888) */
+	unsigned int screen_type;	/* LVDS/MIPI/RGB/HDMI */
+	unsigned int lvds_format;
+
+	struct fb_videomode timing;	/* screen display timing*/
+	unsigned int width;	/* physical size of lcd width */
+	unsigned int height;	/* physical size of lcd height */
+	unsigned char pin_dclk;	/* Clock polarity */
+	unsigned char pin_den;	/* Output Enable polarity */
+	unsigned char pin_hsync;	/* Horizontal Sync polarity */
+	unsigned char pin_vsync;	/* Vertical Sync polarity */
+	unsigned char swap_rb;
+	unsigned char swap_rg;
+	unsigned char swap_gb;
+};
+
+#endif	/* _BL_DISP_CONFIG_H_ */
diff --git a/devices/malidp/src/include/malidp_hw.h b/devices/malidp/src/include/malidp_hw.h
new file mode 100644
index 0000000..b885ed5
--- /dev/null
+++ b/devices/malidp/src/include/malidp_hw.h
@@ -0,0 +1,309 @@
+/*
+ *
+ * (C) COPYRIGHT 2013-2015 ARM Limited. All rights reserved.
+ *
+ * This program is free software and is provided to you under the terms of the
+ * GNU General Public License version 2 as published by the Free Software
+ * Foundation, and any use by you of this program is subject to the terms
+ * of such GNU licence.
+ *
+ * A copy of the licence is included with the program, and can also be obtained
+ * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA  02110-1301, USA.
+ *
+ */
+
+#ifndef _MALIDP_HW_H_
+#define _MALIDP_HW_H_
+
+#include "malidp_hw_types.h"
+
+#define MALIDP_MAX_EVENT_STRING 100
+#define MALIDP_MAX_LAYERS 4
+#define MALIDP_MAX_SMART_LAYERS 4
+
+enum malidp_hw_product {
+	MALI_DP500 = 0,
+	MALI_DP550
+};
+
+enum malidp_op_mode {
+	MALIDP_OP_MODE_NORMAL = 0,
+	MALIDP_OP_MODE_CONFIG,
+	MALIDP_OP_MODE_POWERSAVE,
+	MALIDP_OP_MODE_TEST,
+	/* Must only be used at driver init */
+	MALIDP_OP_MODE_UNKNOWN,
+};
+
+enum malidp_hw_intf_type {
+	MALIDP_HW_INTF_PRIMARY,
+	MALIDP_HW_INTF_MEMORY,
+};
+
+struct malidp_intf_hw_info {
+	char name[MALIDP_NAME_LEN];
+	enum malidp_hw_intf_type type;
+	u32 idx;
+};
+
+enum malidp_hw_layer_type {
+	MALIDP_HW_LAYER_VIDEO,
+	MALIDP_HW_LAYER_GRAPHICS,
+	MALIDP_HW_LAYER_SMART,
+};
+
+struct malidp_layer_hw_info {
+	int index;
+	char name[MALIDP_NAME_LEN];
+	enum malidp_hw_layer_type type;
+	/* Bitwise-OR of MALIDP_LAYER_FEATURE_xxx supported by this layer */
+	u32 features;
+	unsigned int n_supported_formats;
+	int n_max_planes;
+	const u32 *supported_formats;
+	/* The HW id of the format at the same index in the supported_formats list
+	 * Can be null if the index itself should be used (e.g. in DP550)
+	 */
+	const u32 *format_ids;
+	const u32 n_supported_layers;
+	const u32 regs_base;
+	const u32 ad_ctrl_reg;
+	const u32 ad_crop_h_reg;
+	const u32 ad_crop_v_reg;
+	union {
+		struct {
+			const u32 stride_offset;
+			const u32 ptr0_low_offset;
+			const u32 ptr0_high_offset;
+			const u32 p3_stride_offset;
+		};
+
+		struct {
+			const u32 ls_r1_in_size;
+			const u32 ls_r1_offset;
+			const u32 ls_r1_stride;
+			const u32 ls_r1_ptr_low;
+			const u32 ls_r1_ptr_high;
+		};
+	};
+	const u32 yuv2rgb_reg_offset;
+};
+
+struct malidp_hw_regmap;
+struct malidp_product_api;
+
+struct malidp_hw_topology {
+	u32 product_id;
+	const struct malidp_intf_hw_info *interfaces;
+	int n_interfaces;
+	const struct malidp_layer_hw_info *layers;
+	int n_layers;
+	u32 n_scalers;
+	u32 n_supported_afbc_formats;
+	const u32 *supported_afbc_formats;
+	u64 supported_afbc_splitblk;
+	u32 n_mw_formats;
+	const u32 *mw_formats;
+	const u32 *mw_format_ids;
+	u32 n_xform_invalid_formats;
+	const u32 *xform_invalid_formats;
+	const struct malidp_product_api *dp_api;
+	const struct malidp_hw_regmap *regmap;
+};
+
+struct malidp_line_size_hw_info {
+	u32 max_line_size;
+	u32 min_line_size;
+	u32 input_fifo_size;
+	u32 default_rotmem_size;
+};
+
+struct malidp_hw_device {
+	void __iomem *regs;
+	const struct malidp_hw_topology *topology;
+	const struct malidp_line_size_hw_info *ls_info;
+	/*
+	 * Protects access to the HW features, needs to be taken by the DE and
+	 * SE IRQ handlers to avoid races.
+	 */
+	spinlock_t hw_lock;
+	/*
+	 * Must be held when calling malidp_hw_change_op_mode() to
+	 * serialise operating mode changes and ensure the reported operating
+	 * mode is consistent.
+	 */
+	struct mutex power_mutex;
+	struct device device;
+	struct malidp_de_device de_dev;
+	struct malidp_se_device se_dev;
+	struct clk *pxclk, *mclk, *aclk, *pclk;
+	u32 rotmem_size;
+	/* clock_ratio=mclk/pclk, it is fix point data (16.16)*/
+	u32 clock_ratio;
+	/* Threshold for downscaling. Fix point data (16.16) */
+	u32 downscaling_threshold;
+
+	char hw_event_mask[MALIDP_MAX_EVENT_STRING];
+	enum malidp_hw_partition_type partition_type;
+
+	const struct malidp_product_api *dp_api;
+	const struct malidp_hw_regmap *hw_regmap;
+
+	//struct dentry *dbg_folder;
+	u32 core_id;
+	/* Only used in debugfs and not available for dp500 */
+	bool cproc_en;
+};
+
+struct malidp_hw_configuration {
+	const struct malidp_line_size_hw_info *ls_configs;
+	int n_configs;
+	enum malidp_hw_partition_type partition_type;
+};
+
+/* Description of the hardware, in order of increasing specificity */
+struct malidp_hw_description {
+	/* Things defined by the HW version */
+	const struct malidp_hw_topology *topology;
+	/* Things defined by this configuration of the HW version */
+	struct malidp_hw_configuration *config;
+	/* Things defined by this platform */
+	struct malidp_hw_pdata *pdata;
+};
+
+struct malidp_hw_smart_layer_state {
+	const struct malidp_layer_hw_info *ls_hw_layer;
+	/* The size of smart layer bounding box */
+	u16 ls_bbox_top;
+	u16 ls_bbox_left;
+	u16 ls_bbox_bottom;
+	u16 ls_bbox_right;
+	/* The smart layer bounding box background color in ARGB8888 format */
+	u32 ls_bbox_argb;
+	/* The number of active smart layers */
+	u8 n_smart_layers;
+	/* The array of indexes of the smart layer HW buffers */
+	u8 ls_hw_buf_idx[MALIDP_MAX_SMART_LAYERS];
+	/* Indicate the bbox is from user space */
+	bool ls_bbox_from_user;
+};
+
+struct malidp_hw_state_priv;
+
+struct malidp_hw_state {
+	u32 n_bufs;
+	struct malidp_hw_buffer *bufs;
+	struct malidp_hw_state_priv hw_priv;
+	struct malidp_hw_smart_layer_state ls_state;
+};
+
+/*
+ * This function should find out what hardware is available and populate
+ * hw_desc appropriately.
+ *
+ * @hw_desc[out] The hardware description
+ * @product[in] The product code for this device.
+ * @pdata[in] The platform-specific information for this device.
+ */
+void malidp_hw_enumerate(struct malidp_hw_description *hw_desc,
+		enum malidp_hw_product product, struct malidp_hw_pdata *pdata);
+
+int malidp_hw_validate(struct malidp_hw_device *hwdev,
+		struct malidp_hw_state *hw_state);
+
+void malidp_hw_state_free(struct malidp_hw_device *hwdev,
+		struct malidp_hw_state *hw_state);
+
+int malidp_hw_commit(struct malidp_hw_device *hwdev,
+		struct malidp_hw_state *hw_state);
+
+int malidp_hw_set_callback(struct malidp_hw_device *dev,
+		const struct malidp_intf_hw_info *hw_intf,
+		void (*callback)(struct device *, void *, struct malidp_hw_event_queue *),
+		void *opaque);
+
+int malidp_hw_modeset(struct malidp_hw_device *dev, struct drm_mode_modeinfo *mode);
+
+char *malidp_hw_get_event_string(char *string, int max, struct malidp_hw_event *event);
+
+struct malidp_hw_device *malidp_hw_init(struct platform_device *pdev,
+			       struct malidp_hw_description *hw_desc);
+
+void malidp_hw_exit(struct malidp_hw_device *hwdev);
+
+u32 malidp_hw_get_core_id(struct malidp_hw_device *hwdev);
+
+int malidp_hw_get_resources(struct platform_device *pdev,
+			       struct device_node *nproot,
+			       struct malidp_hw_pdata *pdata);
+
+void malidp_hw_update_gamma_settings(struct malidp_hw_device *hwdev,
+				     bool enable,
+				     u32 *coeffs);
+
+bool malidp_hw_format_is_yuv(u32 format);
+bool malidp_hw_format_has_alpha(u32 format);
+u32 malidp_hw_format_bpp(u32 format);
+
+uint32_t malidp_hw_rotmem_size_get(struct malidp_hw_device *hwdev);
+void malidp_hw_supported_dimensions_get(struct malidp_hw_device *hwdev,
+					u32 *min_width, u32 *min_height,
+					u32 *max_width, u32 *max_height);
+enum malidp_hw_partition_type
+		malidp_hw_rotmem_type_get(struct malidp_hw_device *hwdev);
+const struct malidp_hw_topology
+		*malidp_hw_get_topology(struct malidp_hw_device *hwdev);
+u32 malidp_hw_clock_ratio_get(struct malidp_hw_device *hwdev);
+int malidp_hw_clock_ratio_set(struct malidp_hw_device *hwdev,
+		u32 new_clock_ratio);
+u32 malidp_hw_downscaling_threshold(struct malidp_hw_device *hwdev);
+u32 malidp_hw_get_fifo_size(struct malidp_hw_device *hwdev);
+int malidp_hw_set_mclk(struct malidp_hw_device *hwdev, u32 pxclk);
+
+int malidp_hw_get_attr(struct malidp_hw_device *hwdev, u32 attr, u32 *val);
+int malidp_hw_set_attr(struct malidp_hw_device *hwdev, u32 attr, u32 val);
+
+void malidp_hw_set_de_output_depth(struct malidp_hw_device *hwdev, u8 red,
+		u8 green, u8 blue);
+
+int malidp_hw_update_color_adjustment(struct malidp_hw_device *hwdev,
+	u16 red_x, u16 red_y, u16 green_x, u16 green_y, u16 blue_x, u16 blue_y,
+	u16 white_x, u16 white_y);
+
+int malidp_hw_debugfs_init(struct malidp_hw_device *hwdev,
+	struct dentry *parent);
+
+struct malidp_hw_event_queue *malidp_hw_event_queue_create(size_t n_events);
+void malidp_hw_event_queue_destroy(struct malidp_hw_event_queue *queue);
+void malidp_hw_event_queue_enqueue(struct malidp_hw_event_queue *queue,
+		struct malidp_hw_event *event);
+void malidp_hw_event_queue_dequeue(struct malidp_hw_event_queue *queue,
+		struct malidp_hw_event *event);
+
+void malidp_hw_disable_all_layers_and_mw(struct malidp_hw_device *hwdev);
+void malidp_hw_clear_mw(struct malidp_hw_state *hw_state);
+
+u32 malidp_hw_read(struct malidp_hw_device *hwdev, u32 reg);
+void malidp_hw_write(struct malidp_hw_device *hwdev, u32 value, u32 reg);
+void malidp_hw_setbits(struct malidp_hw_device *dev, u32 mask,
+			u32 reg);
+void malidp_hw_clearbits(struct malidp_hw_device *dev, u32 mask,
+			u32 reg);
+bool malidp_hw_buf_support_srgb(struct malidp_hw_buffer *hw_buf);
+bool malidp_hw_pxclk_ok(struct malidp_hw_device *dev, long rate);
+attr_visible_t malidp_hw_get_attr_visible_func(struct malidp_hw_device *hwdev);
+
+int malidp_hw_runtime_resume(struct malidp_hw_device *hwdev);
+int malidp_hw_runtime_suspend(struct malidp_hw_device *hwdev);
+int malidp_hw_display_switch(struct malidp_hw_device *hwdev, bool power_on);
+/*
+ * To be used only by the DE/SE HW code. As indicated by the "atomic" suffix
+ * these calls are not thread safe, hence they need to be called with the
+ * HW spinlock taken.
+ *
+ */
+void malidp_hw_commit_scene_atomic(struct malidp_hw_device *hwdev, bool set);
+void malidp_hw_cfg_de_disable_mw_flows_atomic(struct malidp_hw_device *hwdev);
+
+#endif /* _MALIDP_HW_H_ */
diff --git a/devices/malidp/src/include/malidp_hw_types.h b/devices/malidp/src/include/malidp_hw_types.h
new file mode 100644
index 0000000..e97c9b5
--- /dev/null
+++ b/devices/malidp/src/include/malidp_hw_types.h
@@ -0,0 +1,169 @@
+/*
+ *
+ * (C) COPYRIGHT 2013-2015 ARM Limited. All rights reserved.
+ *
+ * This program is free software and is provided to you under the terms of the
+ * GNU General Public License version 2 as published by the Free Software
+ * Foundation, and any use by you of this program is subject to the terms
+ * of such GNU licence.
+ *
+ * A copy of the licence is included with the program, and can also be obtained
+ * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA  02110-1301, USA.
+ *
+ */
+
+
+
+#ifndef _MALIDP_HW_TYPES_H_
+#define _MALIDP_HW_TYPES_H_
+
+#define MALIDP_NAME_LEN 30
+
+#define MALIDP_HW_EVENT_NONE	0
+#define MALIDP_HW_EVENT_FLIP	(1 << 0)
+#define MALIDP_HW_EVENT_ERROR	(1 << 1)
+#define		MALIDP_HW_ERROR_URUN	(1 << 6)
+#define		MALIDP_HW_ERROR_ORUN	(1 << 7)
+#define		MALIDP_HW_ERROR_AXI	(1 << 8)
+#define		MALIDP_HW_ERROR_QFULL	(1 << 9)
+#define		MALIDP_HW_ERROR_IBUSY	(1 << 10)
+#define MALIDP_HW_EVENT_VSYNC	(1 << 2)
+#define MALIDP_HW_EVENT_START	(1 << 3)
+#define MALIDP_HW_EVENT_NEWCFG	(1 << 4)
+#define MALIDP_HW_EVENT_STOP	(1 << 5)
+
+/* Attributes which are exposed via sysfs */
+#define MALIDP_ATTR_FLAG_CM	(1 << 0)
+#define MALIDP_ATTR_FLAG_DE	(1 << 1)
+#define MALIDP_ATTR_FLAG_SE	(1 << 2)
+#define MALIDP_ATTR_BURSTLEN	((1 << 3) | MALIDP_ATTR_FLAG_CM)
+#define MALIDP_ATTR_OUTSTRAN	((2 << 3) | MALIDP_ATTR_FLAG_CM)
+#define MALIDP_ATTR_CACHE	((3 << 3) | MALIDP_ATTR_FLAG_CM)
+#define MALIDP_ATTR_QOS		((4 << 3) | MALIDP_ATTR_FLAG_CM)
+#define MALIDP_ATTR_RQOS_LOW	(5 << 3)
+#define MALIDP_ATTR_RQOS_HIGH	(6 << 3)
+#define MALIDP_ATTR_RQOS_RED	(7 << 3)
+#define MALIDP_ATTR_RQOS_GREEN	(8 << 3)
+#define MALIDP_ATTR_FIFO_SIZE	(9 << 3)
+#define MALIDP_ATTR_POUTSTDCAB  ((10 << 3) | MALIDP_ATTR_FLAG_CM)
+#define MALIDP_ATTR_DE_BURSTLEN	(MALIDP_ATTR_BURSTLEN | MALIDP_ATTR_FLAG_DE)
+#define MALIDP_ATTR_DE_POUTSTDCAB (MALIDP_ATTR_POUTSTDCAB | MALIDP_ATTR_FLAG_DE)
+#define MALIDP_ATTR_DE_OUTSTRAN	(MALIDP_ATTR_OUTSTRAN | MALIDP_ATTR_FLAG_DE)
+#define MALIDP_ATTR_DE_RQOS_LOW	(MALIDP_ATTR_RQOS_LOW | MALIDP_ATTR_FLAG_DE)
+#define MALIDP_ATTR_DE_RQOS_HIGH (MALIDP_ATTR_RQOS_HIGH | MALIDP_ATTR_FLAG_DE)
+#define MALIDP_ATTR_DE_RQOS_RED	(MALIDP_ATTR_RQOS_RED | MALIDP_ATTR_FLAG_DE)
+#define MALIDP_ATTR_DE_RQOS_GREEN (MALIDP_ATTR_RQOS_GREEN | MALIDP_ATTR_FLAG_DE)
+#define MALIDP_ATTR_DE_FIFO_SIZE (MALIDP_ATTR_FIFO_SIZE | MALIDP_ATTR_FLAG_DE)
+#define MALIDP_ATTR_SE_BURSTLEN	(MALIDP_ATTR_BURSTLEN | MALIDP_ATTR_FLAG_SE)
+#define MALIDP_ATTR_SE_OUTSTRAN	(MALIDP_ATTR_OUTSTRAN | MALIDP_ATTR_FLAG_SE)
+#define MALIDP_ATTR_SE_WQOS	(MALIDP_ATTR_QOS | MALIDP_ATTR_FLAG_SE)
+#define MALIDP_ATTR_SE_WCACHE	(MALIDP_ATTR_CACHE | MALIDP_ATTR_FLAG_SE)
+
+enum malidp_hw_partition_type {
+	MALIDP_HW_PARTITION_FIXED,
+};
+
+struct malidp_hw_event {
+	u32 type;
+	ktime_t timestamp;
+};
+
+struct malidp_hw_event_queue;
+
+struct malidp_hw_scale_rect {
+	u16 src_w, src_h;
+	u16 dest_w, dest_h;
+};
+
+/** struct malidp_hw_buffer - HW specific buffer structure
+  *
+  * The following parameters allow to specify source cropping
+  * when the target is the Display Engine. For the Scaling Engine
+  * only "w" and "h" are used as the output size for the memory
+  * write-out interface:
+  * @natural_w:	active width of the buffer in pixels, as it is in memory
+  * @natural_h:	active height of the buffer in pixels, as it is in memory
+  * @h_offset:	horizontal offset of the buffer in pixels
+  * @v_offset:	vertical offset of the buffer in pixels
+  *
+  * @fmt:	fourcc pixel format of the buffer
+  * @hw_fmt:	hardware-specific pixel format of the buffer
+  * @addr[3]:	DMA enabled address for each plane in the buffer
+  * @pitch[3]:	stride of the DMA transfer in bytes for every plane
+  * @n_planes:	number of planes used for this buffer
+  * @flags:	malidp specific flags
+  * @mw_scaling_enable: this buffer will be scaled, and the scaling result
+  * will be used in memory write-out.
+  * @mw_rect:	source and destination sizes for memory-write buffer
+  * @cmp_scaling_enable: this buffer will be scaled, and the scaling result
+  * will be used in the composition.
+  * @cmp_rect:	source and destination sizes for composition, after any
+  * rotation has been applied. For an output buffer, src and dest must be the
+  * same, which will also match the "natural" dimensions.
+  * @write_out_enable:	this buffer will be written-out to memory,
+  * if all the DE (input) buffers have this set and the output buffer too
+  * this means we want to write-out the result of the composition.
+  *
+  * The following parameters are specific to the DE only:
+  * @alpha_mode: MALIDP_ALPHA_MODE_xxx flags to set the kind of blending
+  * @layer_alpha: this is the alpha value that will be used if layer level
+  * blending is selected.
+  * @afbc_crop_l: left AFBC cropping.
+  * @afbc_crop_r: right AFBC cropping.
+  * @afbc_crop_t: top AFBC cropping.
+  * @afbc_crop_b: bottom AFBC cropping.
+  * @ls_rect_idx: smart layer rectangle register index.
+  * @hw_layer: HW specific layer information that provides information on
+  * what DE layer this buffer is aiming for. This will be NULL for buffers
+  * aiming the SE write-out interface.
+  * @requirements: the hardware features required for this buffer
+  * Bitwise OR of MALIDP_LAYER_FEATURE_xxx
+  */
+struct malidp_hw_buffer {
+	u16 natural_w, natural_h;
+	u16 h_offset, v_offset;
+	u32 fmt;
+	u32 hw_fmt;
+	dma_addr_t addr[3];
+	u32 pitch[3];
+	u32 n_planes;
+	u32 flags;
+	u32 transform;
+	bool mw_scaling_enable;
+	struct malidp_hw_scale_rect mw_rect;
+	bool cmp_scaling_enable;
+	struct malidp_hw_scale_rect cmp_rect;
+	/* DE specific */
+	bool write_out_enable;
+	u32 alpha_mode;
+	u8 layer_alpha;
+	u16 afbc_crop_l, afbc_crop_r;
+	u16 afbc_crop_t, afbc_crop_b;
+	u8 ls_rect_idx;
+	const struct malidp_layer_hw_info *hw_layer;
+	u32 requirements;
+};
+
+struct malidp_hw_pdata {
+#if 0
+	void __iomem *regs;
+	int se_irq, de_irq;
+	struct clk *pxclk, *mclk, *aclk, *pclk;
+#endif
+	u32 de_axi_burstlen;
+	u32 de_axi_poutstdcab;
+	u32 de_axi_outstran;
+	u32 de_axi_arqos_low;
+	u32 de_axi_arqos_high;
+	u32 de_axi_arqos_red;
+	u32 de_axi_arqos_green;
+	u32 se_axi_burstlen;
+	u32 se_axi_outstran;
+	u32 se_axi_awcache;
+	u32 se_axi_awqos;
+	u32 rotmem_size;
+	u32 dp_id;
+};
+
+#endif /* _MALIDP_HW_TYPES_H_ */
diff --git a/devices/malidp/src/include/malidp_product_api.h b/devices/malidp/src/include/malidp_product_api.h
new file mode 100644
index 0000000..0631064
--- /dev/null
+++ b/devices/malidp/src/include/malidp_product_api.h
@@ -0,0 +1,179 @@
+/*
+ *
+ * (C) COPYRIGHT 2014-2015 ARM Limited. All rights reserved.
+ *
+ * This program is free software and is provided to you under the terms of the
+ * GNU General Public License version 2 as published by the Free Software
+ * Foundation, and any use by you of this program is subject to the terms
+ * of such GNU licence.
+ *
+ * A copy of the licence is included with the program, and can also be obtained
+ * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA  02110-1301, USA.
+ *
+ */
+
+
+#ifndef _MALIDP_PRODUCT_API_H_
+#define _MALIDP_PRODUCT_API_H_
+
+#include "malidp_hw.h"
+#include "malidp_de_device.h"
+#include "malidp_se_device.h"
+#include "malidp_sysfs.h"
+
+#define DRM_DISPLAY_MODE_LEN    32
+
+struct drm_mode_modeinfo {
+	__u32 clock;
+	__u16 hdisplay, hsync_start, hsync_end, htotal, hskew;
+	__u16 vdisplay, vsync_start, vsync_end, vtotal, vscan;
+
+	__u32 vrefresh;
+
+	__u32 flags;
+	__u32 type;
+	char name[DRM_DISPLAY_MODE_LEN];
+};
+
+
+/* HW description accessors for the different products.
+ * Could live in separate files, but that would cause lots of
+ * file-bloat
+ */
+void malidp_dp500_get_hw_description(struct malidp_hw_description *);
+void malidp_dp550_get_hw_description(struct malidp_hw_description *);
+
+enum malidp_scaling_coeff_set;
+
+struct malidp_de_product_api {
+	/* Must be called with the DE in Config Mode
+	 * Analogous to the current malidp_de_hw_cfg implementation
+	 *  - Register interrupt handler (use common "soft" handler)
+	 *  - Set AXI config
+	 *  - Set background color
+	 *  - Set interrupts
+	 *  - Set alpha lookup tables
+	 *  - Write coefficients if necessary
+	 */
+	int (*hw_cfg)(struct malidp_de_device *);
+	/* Must be called with the DE in Config Mode
+	 * Write the display mode to the HW registers
+	 * Can't be common due to HSP and VSP moving
+	 */
+	void (*modeset)(struct malidp_de_device *, struct malidp_de_hwmode *);
+	/* Called from malidp_de_cfg_layer and at modeset
+	 * Set the gamma/inverse gamma lookup table, writing coefficients if
+	 * needed. For inverse gamma, coeffs should be NULL.
+	 */
+	void (*set_gamma_coeff)(struct malidp_de_device *, u32 *coeffs);
+	/* Fixup a DRM format according to buffer flags, if necessary.
+	 * Returns the fixed-up format, to be converted to a hardware ID.
+	 */
+	u32 (*fmt_fixup)(u32 drm_format, u32 flags);
+	/* Call from malidp_de_attr_valid
+	 * Validate AXI setting for DE:
+	 * Three attributes: BURSTLEN, POUTSTDCAB and OUTSTRAN
+	 */
+	bool (*axi_valid)(u32 attr, u32 val);
+	/* Shouldn't be called directly. It is used for requestig IRQ */
+	irqreturn_t (*irq_handler)(int irq, void *data);
+};
+
+struct malidp_se_product_api {
+	/* Must be called with the SE in Config Mode
+	 * Analogous to the current malidp_de_hw_cfg implementation
+	 *  - Register interrupt handler (use common "soft" handler)
+	 *  - Set AXI config
+	 *  - Set image enhancer state
+	 *  - Set interrupts
+	 */
+	int (*hw_cfg)(struct malidp_se_device *);
+	/* Called from malidp_se_cfg_processing
+	 * Select the scaler coefficients, writing the table if necessary
+	 */
+	void (*set_scaler_coeff)(struct malidp_se_device *,
+		enum malidp_scaling_coeff_set hcoeff,
+		enum malidp_scaling_coeff_set vcoeff);
+	/* Checking the scaling limitation
+	 */
+	bool (*limitation_check)(struct malidp_se_device *,
+			struct malidp_se_scaler_conf *);
+	/* Calculate the downscaling threshold
+	 */
+	u32 (*calc_downscaling_threshold)(u32, u32, struct drm_mode_modeinfo *);
+	/* Call from malidp_se_attr_valid
+	 * Validate AXI setting for SE:
+	 * Tow attributes: BURSTLEN and OUTSTRAN
+	 */
+	bool (*axi_valid)(u32 attr, u32 val);
+	/* Shouldn't be called directly. It is used for requestig IRQ */
+	irqreturn_t (*irq_handler)(int irq, void *data);
+};
+
+struct malidp_product_api {
+	/* Change the operating mode of the DP
+	 * This must put both the DE and SE in the given mode (or its closest
+	 * equivalent), returning the old mode
+	 */
+	enum malidp_op_mode (*change_op_mode)(struct malidp_hw_device *,
+		enum malidp_op_mode);
+	/* Called from hw_init and hw_exit
+	 * Disable device interrupt.
+	 */
+	void (*disable_irq)(struct malidp_hw_device *);
+	/* Called by sysfs to check the condition of every attributes
+	 */
+	attr_visible_t attr_visible;
+	/* Called from hw_debugfs_init.
+	 * This API is used for the elements specific to the product.
+	 */
+	void (*debugfs_func)(struct malidp_hw_device *);
+	/* Calculate rotation memory size */
+	u32 (*rotmem_size_required)(const struct malidp_hw_buffer *);
+	/* The APIs for the DE and SE of this product */
+	struct malidp_de_product_api de_api;
+	struct malidp_se_product_api se_api;
+};
+
+/* Register offsets for use by the generic de/se/hw layer */
+struct malidp_de_regmap {
+	u16 axi_control;
+	u16 disp_func;
+	u16 output_depth;
+	/* Offset of the first color adjustment coefficient register */
+	u16 coloradj_coeff;
+	u16 qos_control;
+};
+
+struct malidp_se_regmap {
+	/* Offset of the SE_CONTROL register */
+	u16 control;
+	u16 axi_control;
+	/* Offset of the Layers Control register block */
+	u16 layers_control;
+	/* Offset of the Scaling Control register block */
+	u16 scaling_control;
+	/* Offset of the Image Enhancement register block */
+	u16 enhancer_control;
+	/* Offset of the RGB_YUV_CONTROL register */
+	u16 conv_control;
+	/* Offset of the Memory Write register block */
+	u16 mw_control;
+};
+
+struct malidp_hw_regmap {
+	/* Offset of the PERIPHERAL_ID 4 register */
+	u16 id_registers;
+	/* Offset of the Configuration Valid register */
+	u16 config_valid;
+	/* Base address offset of the DE registers */
+	u16 de_base;
+	/* Base address offset of the SE registers */
+	u16 se_base;
+	/* Regmap descriptors for the DE and SE */
+	struct malidp_de_regmap de_regmap;
+	struct malidp_se_regmap se_regmap;
+};
+
+#endif /* _MALIDP_PRODUCT_API_H_ */
diff --git a/devices/malidp/src/include/malidp_se_device.h b/devices/malidp/src/include/malidp_se_device.h
new file mode 100644
index 0000000..be8faf2
--- /dev/null
+++ b/devices/malidp/src/include/malidp_se_device.h
@@ -0,0 +1,295 @@
+/*
+ *
+ * (C) COPYRIGHT 2013-2015 ARM Limited. All rights reserved.
+ *
+ * This program is free software and is provided to you under the terms of the
+ * GNU General Public License version 2 as published by the Free Software
+ * Foundation, and any use by you of this program is subject to the terms
+ * of such GNU licence.
+ *
+ * A copy of the licence is included with the program, and can also be obtained
+ * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA  02110-1301, USA.
+ *
+ */
+
+
+
+#ifndef _MALIDP_SE_DEVICE_H_
+#define _MALIDP_SE_DEVICE_H_
+
+#include "malidp_hw_types.h"
+#include "malidp_hw.h"
+
+#define SE_REG_STATUS			0x000
+#define		SE_ST_CONFIG		(1 << 0)
+#define		SE_ST_PTR_UPDATE	(1 << 4)
+#define		SE_ST_INIT_BUSY		(1 << 5)
+#define		SE_ST_AXIERR		(1 << 8)
+#define		SE_ST_OVERRUN		(1 << 9)
+#define		SE_ST_PROGLINE1		(1 << 12)
+#define		SE_ST_PROGLINE2		(1 << 13)
+#define		SE_ST_CONFIG_ACTIVE	(1 << 17)
+#define		SE_ST_PSM_ACTIVE	(1 << 18)
+#define		SE_ST_AXI_BUSY		(1 << 28)
+#define		SE_ST_IRQ		(1 << 31)
+#define SE_REG_SETIRQ			0x004
+#define SE_REG_MASKIRQ			0x008
+#define		SE_IRQ_CONFIG			(1 << 0)
+#define		SE_IRQ_PTR_UPDATE		(1 << 4)
+#define		SE_IRQ_INIT_BUSY		(1 << 5)
+#define		SE_IRQ_AXI_ERR			(1 << 8)
+#define		SE_IRQ_OVERRUN			(1 << 9)
+#define		SE_IRQ_PROGLINE1		(1 << 12)
+#define		SE_IRQ_PROGLINE2		(1 << 13)
+#define		SE_IRQ_ENABLE			(1 << 31)
+
+/* Control register bits and mask */
+#define		SE_SCALING_EN			(1 << 0)
+#define		SE_ALPHA_EN			(1 << 1)
+#define		SE_ENH_H_EN			(1 << 2)
+#define		SE_ENH_V_EN			(1 << 3)
+#define		SE_RGBO_IF_EN			(1 << 4)
+#define		SE_MW_IF_MASK			0x3
+#define		SE_MW_IF_SET(x)			(((x) & SE_MW_IF_MASK) << 5)
+#define		SE_RGB_MTH_SEL			(1 << 8)
+#define		SE_ALPHA_MTH_SEL		(1 << 9)
+#define		SE_ARGB_MTH_SET(x)		((x << 8) & (SE_RGB_MTH_SEL | SE_ALPHA_MTH_SEL))
+#define		SE_PTR_VALID			(1 << 12)
+#define		SE_SOFTRESET_REQ		(1 << 16)
+#define		SE_CONFIG_REQ			(1 << 17)
+#define		SE_MMU_PROT			(1 << 25)
+#define		SE_ENDIAN			(1 << 28)
+
+#define SE_REG_LINE_INT_CTRL		0x010
+#define		SE_LINE_INT_MASK		0x3fff
+#define		SE_LINE_INT_1(x)		(((x) & SE_LINE_INT_MASK) << 0)
+#define		SE_LINE_INT_2(x)		(((x) & SE_LINE_INT_MASK) << 16)
+
+/* AXI register bits and mask */
+#define		SE_AXI_OUTSTDCAPB_MASK		0xff
+#define		SE_AXI_OUTSTDCAPB(x)		(((x) & SE_AXI_OUTSTDCAPB_MASK) << 0)
+#define		SE_AXI_WCACHE_MASK		0xf
+#define		SE_AXI_WCACHE(x)		(((x) & SE_AXI_WCACHE_MASK) << 8)
+#define		SE_AXI_BURSTLEN_MASK		0xff
+#define		SE_AXI_BURSTLEN(x)		(((x) & SE_AXI_BURSTLEN_MASK) << 16)
+#define		SE_AXI_WQOS_MASK		0xf
+#define		SE_AXI_WQOS(x)			(((x) & SE_AXI_WQOS_MASK) << 28)
+
+#define SE_REG_SECURE_CTRL		0x01c
+
+/* Layer control register offset */
+#define SE_REG_L0_IN_SIZE		0x00
+#define SE_REG_L0_OUT_SIZE		0x04
+#define SE_REG_L0_3DSTRUCT		0x08
+#define SE_REG_L1_SIZE			0x0C
+#define		SE_SET_V_SIZE(x)		(((x) & 0x1fff) << 16)
+#define		SE_SET_H_SIZE(x)		(((x) & 0x1fff) << 0)
+
+/* Scaling control registers offset */
+#define SE_REG_H_INIT_PH		0x00
+#define SE_REG_H_DELTA_PH		0x04
+#define SE_REG_V_INIT_PH		0x08
+#define SE_REG_V_DELTA_PH		0x0c
+#define SE_REG_COEFFTAB_ADDR	0x10
+#define		SE_COEFFTAB_ADDR_MASK	0x7f
+#define		SE_V_COEFFTAB		(1 << 8)
+#define		SE_H_COEFFTAB		(1 << 9)
+#define		SE_SET_V_COEFFTAB_ADDR(x) \
+				(SE_V_COEFFTAB | ((x) & SE_COEFFTAB_ADDR_MASK))
+#define		SE_SET_H_COEFFTAB_ADDR(x) \
+				(SE_H_COEFFTAB | ((x) & SE_COEFFTAB_ADDR_MASK))
+#define SE_REG_COEFFTAB_DATA	0x14
+#define		SE_COEFFTAB_DATA_MASK	0x3fff
+#define		SE_SET_COEFFTAB_DATA(x)	((x) & SE_COEFFTAB_DATA_MASK)
+
+/* Enhance coeffents reigster offset */
+#define	SE_REG_ENH_COEFF1	0x04
+#define		SE_ENH_LIMIT_MASK		0xfff
+#define		SE_ENH_LIMIT_LOW_SHIFT		0
+#define		SE_ENH_LIMIT_HIGH_SHIFT		16
+#define		SE_SET_ENH_LIMIT_LOW(x)		(((x) & SE_ENH_LIMIT_MASK) << SE_ENH_LIMIT_LOW_SHIFT)
+#define		SE_SET_ENH_LIMIT_HIGH(x)	(((x) & SE_ENH_LIMIT_MASK) << SE_ENH_LIMIT_HIGH_SHIFT)
+#define		SE_SET_ENH_COEFF(x)		(((x) & 0x7ff) << 0)
+
+#define SE_ENH_LOW_LEVEL 24
+#define SE_ENH_HIGH_LEVEL 63
+
+/* Color space conversion register offset */
+#define SE_REG_CONV_COEFF1	0x04
+
+#define SE_REG_CONV_GAMMA_ADDR		0x0A4
+#define SE_REG_CONV_GAMMA_DATA		0x0A8
+
+/* Memory write out */
+#define SE_REG_FORMAT		0x00
+#define		SE_WFORMAT_MASK		0x3F
+#define		SE_SET_WFORMAT(x)	(((x) & SE_WFORMAT_MASK) << 0)
+#define SE_REG_WP1_STRIDE	0x04
+#define SE_REG_WP2_STRIDE	0x08
+#define SE_REG_WP1_PTR0_LOW	0x0C
+#define SE_REG_WP1_PTR0_HIGH	0x10
+#define SE_REG_WP1_PTR1_LOW		0x14
+#define SE_REG_WP1_PTR1_HIGH	0x18
+#define SE_REG_WP1_PTR0_R_LOW	0x1C
+#define SE_REG_WP1_PTR0_R_HIGH	0x20
+#define SE_REG_WP1_PTR1_R_LOW	0x24
+#define SE_REG_WP1_PTR1_R_HIGH	0x28
+#define SE_REG_WP2_PTR0_LOW		0x2C
+#define SE_REG_WP2_PTR0_HIGH	0x30
+#define SE_REG_WP2_PTR1_LOW		0x34
+#define SE_REG_WP2_PTR1_HIGH	0x38
+#define SE_REG_WP2_PTR0_R_LOW	0x3C
+#define SE_REG_WP2_PTR0_R_HIGH	0x40
+#define SE_REG_WP2_PTR1_R_LOW	0x44
+#define SE_REG_WP2_PTR1_R_HIGH	0x48
+
+#define SE_DEFAULT_AXI_BURSTLEN	16
+#define SE_DEFAULT_AXI_OUTSTRAN	16
+#define SE_DEFAULT_AXI_AWCACHE	0x0 /* Device non-bufferable */
+#define SE_DEFAULT_AXI_AWQOS	0x0 /* Not performing any QoS scheme */
+
+
+enum malidp_se_mw_mode {
+	MALIDP_SE_MW_DISABLE = 0,
+	MALIDP_SE_MW_L0,
+	MALIDP_SE_MW_L1,
+};
+
+enum malidp_se_scaling_algorithms {
+	MALIDP_SE_ARGB_PP = 0,		/* PolyPhase algorithm for both Alpha and RGB */
+	MALIDP_SE_RGB_NN = 1,		/* Nearest Neighbor algorithm for RGB, and PolyPhase for Alpha */
+	MALIDP_SE_A_PP = 1,			/* Same as MALIDP_SE_RGB_NN */
+	MALIDP_SE_RGB_PP = 2,		/* PolyPhase algorithm for RGB, and Nearest Neighbor algorithm for Alpha */
+	MALIDP_SE_A_NN = 2,			/* Same as MALIDP_SE_RGB_PP */
+	MALIDP_SE_ARGB_NN = 3,		/* Nearest Neighbor algorithm for both Alpha and RGB */
+};
+
+enum malidp_se_enhancer_cfg {
+	MALIDP_SE_ENHANCER_HORZ = 0,
+	MALIDP_SE_ENHANCER_VERT = 1,
+	MALIDP_SE_ENHANCER_BOTH = 2,
+	MALIDP_SE_ENHANCER_OFF  = 3,
+};
+
+enum malidp_scaling_coeff_set {
+	/* For upscaling */
+	MALIDP_UPSCALING_COEFFS = 0,
+	/* For noscaling or 1.5x downscaling */
+	MALIDP_DOWNSCALING_1_5_COEFFS = 1,
+	/* For 1.5x to 2x downscaling */
+	MALIDP_DOWNSCALING_2_COEFFS = 2,
+	/* For 2x to 2.75x downscaling */
+	MALIDP_DOWNSCALING_2_75_COEFFS = 3,
+	/* For 2.75x to 4x downscaling */
+	MALIDP_DOWNSCALING_4_COEFFS = 4,
+};
+
+struct malidp_se_mw_conf {
+	enum malidp_se_mw_mode mode;
+	struct malidp_hw_buffer *buf;
+};
+
+struct malidp_se_scaler_conf {
+	bool rgbo_enable;
+	bool scaling_enable;
+	u16 input_w, input_h;
+	u16 output_w, output_h;
+	enum malidp_scaling_coeff_set v_coeffs_set;
+	enum malidp_scaling_coeff_set h_coeffs_set;
+	enum malidp_se_scaling_algorithms al;
+	u32 v_init_phase, v_delta_phase;
+	u32 h_init_phase, h_delta_phase;
+	bool scale_alpha;
+	enum malidp_se_enhancer_cfg enh_cfg;
+};
+
+struct malidp_se_device {
+	void __iomem *regs;
+	enum malidp_op_mode op_mode;
+	struct device *device;
+	struct malidp_hw_device *hwdev;
+	void (*flip_callback)(struct device *, void *, struct malidp_hw_event_queue *);
+	void *callback_opaque;
+	const s32 *rgb2yuv_coeffs;
+	u16 v_coeffstab, h_coeffstab;
+	enum malidp_se_enhancer_cfg enh_cfg;
+	/*
+	 * Used to indicate that the next LINE1 IRQ is due to a
+	 * content change as opposed to re-writing the previous
+	 * scene to memory again.
+	 */
+	bool scene_changing;
+	struct malidp_hw_event_queue *ev_queue;
+	/*
+	 * This spinlock protects accesses to registers and clocks.
+	 * Also protects the shared variables in this structure:
+	 * "event".
+	 */
+	spinlock_t *hw_lock;
+
+	/* Attributes accessible through sysfs */
+	u16 burstlen;
+	u8 outstran;
+	u8 wqos;
+	u8 wcache;
+
+	const struct malidp_se_regmap *se_regmap;
+	/* Stored after entering PSM to handle any residual IRQs */
+	u32 pending_status;
+
+	u32 n_mw_formats;
+	const u32 *mw_formats;
+	/*
+	 * The HW id of the format at the same index in the supported_format
+	 * list
+	 */
+	const u32 *mw_format_ids;
+};
+
+struct malidp_se_device *malidp_se_hw_init(struct malidp_hw_device *hwdev,
+			     struct platform_device *pdev,
+			     struct malidp_hw_pdata *pdata,
+			     spinlock_t *hw_lock);
+
+int malidp_se_hw_cfg(struct malidp_se_device *dev,
+		struct malidp_hw_pdata *pdata);
+
+void malidp_se_hw_exit(struct malidp_se_device *dev);
+
+int malidp_dt_parse_se(struct platform_device *pdev,
+			       struct device_node *nproot,
+			       struct malidp_hw_pdata *pdata);
+
+int malidp_se_fmt_drm2mw(struct malidp_se_device *dev, u32 drm_fmt);
+
+void malidp_se_write(struct malidp_se_device *dev,
+				u32 value, u32 reg);
+u32 malidp_se_read(struct malidp_se_device *dev, u32 reg);
+void malidp_se_setbits(struct malidp_se_device *dev, u32 mask,
+				u32 reg);
+void malidp_se_clearbits(struct malidp_se_device *dev,
+			u32 mask, u32 reg);
+irqreturn_t malidp_se_irq_thread_handler(int irq, void *data);
+bool malidp_se_attr_valid(struct malidp_se_device *dev, u32 attr, u32 val);
+void malidp_se_set_axi_cfg(struct malidp_se_device *dev, u32 outstran,
+		u32 burstlen, u32 wcache, u32 wqos);
+/*
+ * The following functions need to be called while holding the HW spinlock
+ * unless they are used at initialization or exit time.
+ */
+void malidp_se_set_flip_callback(struct malidp_se_device *dev,
+		void (*callback)(struct device *, void *, struct malidp_hw_event_queue *),
+		void *opaque);
+
+void malidp_se_cfg_processing(struct malidp_se_device *dev,
+				struct malidp_se_mw_conf *mw_cfg,
+				struct malidp_se_scaler_conf *s0);
+
+void malidp_se_set_scaling_dependent_state(struct malidp_se_device *dev,
+				struct malidp_se_scaler_conf *s0);
+
+int malidp_se_get_attr(struct malidp_se_device *dev, u32 attr, u32 *val);
+int malidp_se_set_attr(struct malidp_se_device *dev, u32 attr, u32 val);
+int malidp_se_save_attr(struct malidp_se_device *dev, u32 attr, u32 val);
+#endif /* _MALIDP_SE_DEVICE_H_ */
diff --git a/devices/malidp/src/malidp_config_blob_parser.c b/devices/malidp/src/malidp_config_blob_parser.c
new file mode 100644
index 0000000..fc9a275
--- /dev/null
+++ b/devices/malidp/src/malidp_config_blob_parser.c
@@ -0,0 +1,192 @@
+/* ----------------------------------------------------------------------------
+   Copyright (C) 2013-2014 Intel Mobile Communications GmbH
+
+   Sec Class: Intel Confidential (IC)
+
+   All rights reserved.
+   ----------------------------------------------------------------------------
+   This document contains proprietary information belonging to IMC.
+   Passing on and copying of this document, use
+   and communication of its contents is not permitted without prior written
+   authorisation.
+  ---------------------------------------------------------------------------*/
+
+#include "bl_display.h"
+#include "bl_malidp.h"
+
+BL_DISPLAY disp_config_blob;
+struct malidp_panel_info lcd_panel_info;
+__attribute__((section("DISPLAY_BUFFER"))) struct display_msg *blob_msgs_init[BL_DISP_MAX_NUMBER_OF_MSGS];
+__attribute__((section("DISPLAY_BUFFER"))) struct display_msg *blob_msgs_sleep_out[BL_DISP_MAX_NUMBER_OF_MSGS];
+__attribute__((section("DISPLAY_BUFFER"))) struct display_msg blob_msg[BL_DISP_MAX_NUMBER_OF_MSGS];
+__attribute__((section("DISPLAY_BUFFER"))) struct display_msg blob_msg_sleep_out[BL_DISP_MAX_NUMBER_OF_MSGS];
+__attribute__((section("DISPLAY_BUFFER"))) unsigned char blob_datas[BL_DISP_MAX_NUMBER_OF_MSGS][BL_DISP_MAX_LENGTH_OF_DATA];
+
+static void parse_blob(unsigned int *blob, struct display_msg *t_msgs_init[],
+		       struct display_msg *t_msgs_sleep_out[],
+		       struct display_reset *t_reset,
+		       PANEL_RES * t_panel_res,
+		       struct bl_display_if *t_dif,
+		       struct malidp_panel_info *t_panel_info,
+		       struct display_msg t_msg[],
+		       struct display_msg t_msg_sleepout[],
+		       unsigned char t_datas[][BL_DISP_MAX_LENGTH_OF_DATA])
+{
+	int i = -1, cmd = -1,  length = 0, j = 0x0;
+	VBT_HEADER vbt_hdr;
+	int init_seq = 0;
+	int sleepout_seq = 0, cmd_so = -1;
+
+	vbt_hdr = *((VBT_HEADER *)&blob[0]);
+#ifdef HOST_DEBUG
+	printf("vbt_hdr.magic_word = 0x%x\n", vbt_hdr.magic_word);
+	printf("vbt_hdr.version = 0x%x\n", vbt_hdr.version);
+	printf("vbt_hdr.vbt_size = 0x%x\n", vbt_hdr.vbt_size);
+	printf("vbt_hdr.bl_if_config_version = 0x%x\n",
+	       vbt_hdr.bl_if_config_version);
+#endif
+
+	while (blob[++i] != DCS_CMD_END) {
+		if (blob[i] == DCS_CMD_INIT_START)
+			init_seq = 0x01;
+
+		if (blob[i] == DCS_CMD_INIT_END)
+			init_seq = 0x0;
+		if (blob[i] == DCS_CMD_SLEEP_OUT_START)
+			sleepout_seq = 0x01;
+		if (blob[i] == DCS_CMD_SLEEP_OUT_END)
+			sleepout_seq = 0x0;
+
+		if (blob[i] == DCS_CMD_GENERIC && init_seq) {
+			cmd++;
+			t_msg[cmd].type = blob[i + 1];
+			t_msg[cmd].header = blob[i + 2];
+			length = 0;
+			i += 3;
+			while (blob[i] < DCS_CMD_START)
+				t_datas[cmd][length++] = blob[i++];
+
+			t_msg[cmd].length = length;
+			t_msg[cmd].datas = t_datas[cmd];
+			t_msgs_init[cmd] = &t_msg[cmd];
+
+			/* check for delay or LP */
+			t_msg[cmd].flags = 0x0;
+			t_msg[cmd].delay = 0x0;
+
+			for (j = 0; j < 2; j++) {
+				if (blob[i] == DCS_CMD_DELAY) {
+					t_msg[cmd].delay = blob[i + 1];
+					i += 2;
+				}
+
+				if (blob[i] == DCS_CMD_LP) {
+					t_msg[cmd].flags = blob[i + 1];
+					i += 2;
+				}
+			}
+
+			/* rewind 1 */
+			i--;
+		}
+
+		if (blob[i] == DCS_CMD_GENERIC && sleepout_seq) {
+			cmd_so++;
+			t_msg_sleepout[cmd_so].type = blob[i + 1];
+			t_msg_sleepout[cmd_so].header = blob[i + 2];
+			length = 0;
+			i += 3;
+
+			while (blob[i] < DCS_CMD_START)
+				t_datas[cmd_so][length++] = blob[i++];
+
+			t_msg_sleepout[cmd_so].length = length;
+			t_msg_sleepout[cmd_so].datas = t_datas[cmd_so];
+			t_msgs_sleep_out[cmd_so] = &t_msg_sleepout[cmd_so];
+
+			/* check for delay or LP */
+			t_msg_sleepout[cmd_so].flags = 0x0;
+			t_msg_sleepout[cmd_so].delay = 0x0;
+
+			for (j = 0; j < 2; j++) {
+				if (blob[i] == DCS_CMD_DELAY) {
+					t_msg_sleepout[cmd_so].delay = blob[i+1];
+					i += 2;
+				}
+
+				if (blob[i] == DCS_CMD_LP) {
+					t_msg_sleepout[cmd_so].flags = blob[i+1];
+					i += 2;
+				}
+			}
+			/* rewind 1 */
+			i--;
+		}
+
+		if (blob[i] == DCS_CMD_RESET) {
+			t_reset->value1 = blob[i + 1];
+			t_reset->mdelay1 = blob[i + 2];
+
+			t_reset->value2 = blob[i + 3];
+			t_reset->mdelay2 = blob[i + 4];
+
+			t_reset->value3 = blob[i + 5];
+			t_reset->mdelay3 = blob[i + 6];
+
+			i += 7;
+		}
+
+		if (blob[i] == DCS_CMD_RESOLUTION){
+			i++;
+			*t_panel_res = *((PANEL_RES *)&blob[i]);
+		}
+
+		if (blob[i] == DCS_CMD_DISPLAY_IF) {
+			i++;
+			*t_dif = *((struct bl_display_if *)&blob[i]);
+		}
+
+		if (blob[i] == DCS_CMD_PANEL_INFO) {
+			i++;
+			*t_panel_info = *((struct malidp_panel_info *)&blob[i]);
+		}
+	}
+
+	t_msgs_init[cmd + 1] = 0x0;
+	t_msgs_sleep_out[cmd_so+1] = 0x0;
+}
+
+
+BL_DISPLAY *bl_malidp_init_config(unsigned int *blob)
+{
+	struct display_msg **dcs_seq;
+	struct display_msg **dcs_seq_sleep_out;
+	struct display_reset *reset_ptr;
+	PANEL_RES  *panel_res;
+	struct bl_display_if *dif;
+	struct malidp_panel_info *panel_info;
+
+	disp_config_blob.msgs_init = blob_msgs_init;
+	disp_config_blob.msgs_sleep_out = blob_msgs_sleep_out;
+
+	dcs_seq = disp_config_blob.msgs_init;
+	dcs_seq_sleep_out = disp_config_blob.msgs_sleep_out;
+	reset_ptr = &disp_config_blob.reset;
+	panel_res = (PANEL_RES *)&disp_config_blob.type;
+	dif = &disp_config_blob.dif;
+	panel_info = &lcd_panel_info;
+
+	parse_blob(blob, dcs_seq, dcs_seq_sleep_out, reset_ptr, panel_res,
+		   dif, panel_info, blob_msg, blob_msg_sleep_out, blob_datas);
+
+	/* the clk_rate should be moved to the blob. TBD */
+	/* disp_config_blob.clk_rate = 416000000; */
+
+	return &disp_config_blob;
+}
+
+struct malidp_panel_info *bl_malidp_get_panel_info(void)
+{
+	return &lcd_panel_info;
+}
+
diff --git a/devices/malidp/src/malidp_de_device.c b/devices/malidp/src/malidp_de_device.c
new file mode 100644
index 0000000..dd19648
--- /dev/null
+++ b/devices/malidp/src/malidp_de_device.c
@@ -0,0 +1,1119 @@
+/*
+ *
+ * (C) COPYRIGHT 2013-2015 ARM Limited. All rights reserved.
+ *
+ * This program is free software and is provided to you under the terms of the
+ * GNU General Public License version 2 as published by the Free Software
+ * Foundation, and any use by you of this program is subject to the terms
+ * of such GNU licence.
+ *
+ * A copy of the licence is included with the program, and can also be obtained
+ * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA  02110-1301, USA.
+ *
+ */
+
+
+
+#include "malidp_adf.h"
+#include "malidp_hw_types.h"
+#include "malidp_product_api.h"
+#include "malidp_de_device.h"
+
+#define DE_N_QUEUE_EVENTS 24
+
+#define DE_N_YUV2RGB_COEFFS 12
+#define DE_MAX_OUT_DEPTH 12
+#define DE_MIN_OUT_DEPTH 5
+
+const char *const op_mode_name[] = {
+	"MODE_NORMAL",
+	"MODE_CONFIG",
+	"MODE_POWERSAVE",
+	"MODE_TEST",
+	"MODE_UNKNOWN",
+};
+
+static const s32 malidp_de_bt601_narrow_coeffs[DE_N_YUV2RGB_COEFFS] = {
+	1192,    0, 1634,
+	1192, -401, -832,
+	1192, 2066,    0,
+
+	  64,  512,  512
+};
+
+static const s32 malidp_de_bt601_wide_coeffs[DE_N_YUV2RGB_COEFFS] = {
+	1024,    0, 1436,
+	1024, -352, -731,
+	1024, 1815,    0,
+
+	   0,  512,  512
+};
+
+static const s32 malidp_de_bt709_narrow_coeffs[DE_N_YUV2RGB_COEFFS] = {
+	1192,    0, 1836,
+	1192, -218, -546,
+	1192, 2163,    0,
+
+	  64,  512,  512
+};
+
+static const s32 malidp_de_bt709_wide_coeffs[DE_N_YUV2RGB_COEFFS] = {
+	1024,    0, 1613,
+	1024, -192, -479,
+	1024, 1900,    0,
+
+	   0,  512,  512
+};
+
+
+void malidp_de_write(struct malidp_de_device *dev,
+					  u32 value, u32 reg)
+{
+	*((volatile unsigned int *)(dev->regs + reg)) = value;
+}
+
+u32 malidp_de_read(struct malidp_de_device *dev, u32 reg)
+{
+	return *((volatile unsigned int *)(dev->regs + reg));
+}
+
+void malidp_de_setbits(struct malidp_de_device *dev, u32 mask,
+				     u32 reg)
+{
+	u32 data = malidp_de_read(dev, reg);
+	data |= mask;
+	malidp_de_write(dev, data, reg);
+}
+
+void malidp_de_clearbits(struct malidp_de_device *dev,
+				       u32 mask, u32 reg)
+{
+	u32 data = malidp_de_read(dev, reg);
+	data &= ~mask;
+	malidp_de_write(dev, data, reg);
+}
+
+static const struct malidp_layer_hw_info *
+malidp_de_get_layers(struct malidp_de_device *dev, int *n_layer)
+{
+	if (n_layer != NULL)
+		*n_layer = dev->hwdev->topology->n_layers;
+
+	return dev->hwdev->topology->layers;
+}
+
+/* Write the alpha lookup tables providing a linear interpolation */
+void malidp_de_write_alpha_lookup(struct malidp_de_device *dev)
+{
+	/* Write the alpha lookup table for all the layers */
+	const struct malidp_layer_hw_info *hw_layers;
+	int n_layers, i;
+
+	hw_layers = malidp_de_get_layers(dev, &n_layers);
+	for (i = 0; i < n_layers; i++) {
+		if (hw_layers[i].type != MALIDP_HW_LAYER_SMART) {
+			malidp_de_write(dev, DE_L_ALPHA3(255) | DE_L_ALPHA2(170) |
+					DE_L_ALPHA1(85) | DE_L_ALPHA0(0),
+					hw_layers[i].regs_base + DE_REG_L_COMPOSE);
+		}
+	}
+}
+
+
+static int malidp_de_mode_drm2hw(struct malidp_de_device *dev,
+					 struct drm_mode_modeinfo *mode,
+					 struct malidp_de_hwmode *hwmode)
+{
+	/* Initialize the structure */
+	memset(hwmode, 0, sizeof(*hwmode));
+
+	/* Sanity checks */
+	if (mode->flags & DRM_MODE_FLAG_INTERLACE) {
+		dev_err(dev->device, "interlace mode not supported\n");
+		return -1;
+	}
+
+	/* drm_mode_modeinfo clocks are specified in kHz */
+	hwmode->clock = mode->clock * 1000;
+
+	hwmode->h_active = mode->hdisplay;
+	hwmode->hfp = mode->hsync_start - mode->hdisplay;
+	hwmode->hsw = mode->hsync_end - mode->hsync_start;
+	hwmode->hbp = mode->htotal - mode->hsync_end;
+
+	hwmode->v_active = mode->vdisplay;
+	hwmode->vfp = mode->vsync_start - mode->vdisplay;
+	hwmode->vsw = mode->vsync_end - mode->vsync_start;
+	hwmode->vbp = mode->vtotal - mode->vsync_end;
+
+	if (mode->flags & DRM_MODE_FLAG_PHSYNC)
+		hwmode->hsync_pol_pos = 1;
+
+	if (mode->flags & DRM_MODE_FLAG_PVSYNC)
+		hwmode->vsync_pol_pos = 1;
+
+	return 0;
+}
+
+int malidp_de_fmt_drm2hw(struct malidp_de_device *dev,
+		struct malidp_hw_buffer *buf)
+{
+	int i, idx;
+	int n_fmts = buf->hw_layer->n_supported_formats;
+	const u32 *fmts = buf->hw_layer->supported_formats;
+	const u32 *ids = buf->hw_layer->format_ids;
+	u32 drm_fmt = dev->hwdev->dp_api->de_api.fmt_fixup(buf->fmt, buf->flags);
+
+	for (i = 0; i < n_fmts; i++) {
+		if (ids)
+			idx = ids[i];
+		else
+			idx = i;
+
+		if (fmts[i] == drm_fmt)
+			return idx;
+	}
+
+	return -1;
+}
+
+void malidp_de_set_flip_callback(struct malidp_de_device *dev,
+		void (*callback)(struct device *, void *, struct malidp_hw_event_queue *),
+		void *opaque)
+{
+	dev->flip_callback = callback;
+	dev->callback_opaque = opaque;
+}
+
+void malidp_de_set_coeftab(struct malidp_de_device *dev,
+		u32 table, const u32 *coeffs)
+{
+	u32 i;
+	u16 coloradj = dev->de_regmap->coloradj_coeff;
+
+	malidp_de_write(dev, table | DE_COEFTAB_INTAB_ADDR(0),
+			coloradj + DE_REG_COEFTAB_ADDR);
+
+	for (i = 0; i < DE_N_COEFTAB_COEFS; i++)
+		malidp_de_write(dev, coeffs[i], coloradj + DE_REG_COEFTAB_DATA);
+}
+
+static void malidp_de_set_yuv2rgb_coeffs(struct malidp_de_device *dev,
+		struct malidp_hw_buffer *buf)
+{
+	int i;
+	u32 coeff_off = 0;
+	const s32 *coeffs;
+	const struct malidp_layer_hw_info *layer = buf->hw_layer;
+
+	dev_dbg(dev->device, "%s", __func__);
+
+	switch (buf->flags & MALIDP_FLAG_YUV_MASK) {
+	case (MALIDP_FLAG_YUV_BT601 | MALIDP_FLAG_YUV_NARROW):
+		coeffs = malidp_de_bt601_narrow_coeffs;
+		break;
+	case (MALIDP_FLAG_YUV_BT601 | MALIDP_FLAG_YUV_WIDE):
+		coeffs = malidp_de_bt601_wide_coeffs;
+		break;
+	case (MALIDP_FLAG_YUV_BT709 | MALIDP_FLAG_YUV_NARROW):
+		coeffs = malidp_de_bt709_narrow_coeffs;
+		break;
+	case (MALIDP_FLAG_YUV_BT709 | MALIDP_FLAG_YUV_WIDE):
+		coeffs = malidp_de_bt709_wide_coeffs;
+		break;
+	default:
+		BUG();
+	}
+
+	coeff_off = layer->yuv2rgb_reg_offset;
+	BUG_ON(coeff_off == 0);
+
+	if (coeffs != dev->yuv2rgb_coeffs[layer->index]) {
+		dev->yuv2rgb_coeffs[layer->index] = coeffs;
+		dev_dbg(dev->device, "%s : changing coefficients", __func__);
+		/*
+		 * This assumes the coefficient registers are adjacent in the
+		 * register map
+		 */
+		for (i = 0; i < DE_N_YUV2RGB_COEFFS; i++) {
+			malidp_de_write(dev, coeffs[i],
+					coeff_off + (i * 4));
+		}
+	}
+}
+
+void malidp_de_cfg_cmp_flow(struct malidp_de_device *dev,
+			enum malidp_de_flow_cmp_cfg cfg)
+{
+	const struct malidp_de_regmap *reg = dev->de_regmap;
+
+	malidp_de_clearbits(dev, DE_SET_FLOWCFG(DE_SET_FLOWCFG_MASK),
+			    reg->disp_func);
+	malidp_de_setbits(dev, DE_SET_FLOWCFG(cfg), reg->disp_func);
+}
+
+void malidp_de_cfg_layer_flow(struct malidp_de_device *dev,
+			const struct malidp_layer_hw_info *hw_layer,
+			enum malidp_de_flow_layer_cfg cfg)
+{
+	int loff = hw_layer->regs_base;
+
+	if (!(hw_layer->features & MALIDP_LAYER_FEATURE_SCALING))
+		return;
+
+	malidp_de_clearbits(dev, DE_L_FCFG(DE_L_FCFG_MASK),
+			    loff + DE_REG_L_CONTROL);
+	malidp_de_setbits(dev, DE_L_FCFG(cfg), loff + DE_REG_L_CONTROL);
+}
+
+enum malidp_de_flow_layer_cfg malidp_de_get_layer_flow(struct malidp_de_device *dev,
+							const struct malidp_layer_hw_info *hw_layer)
+{
+	int loff = hw_layer->regs_base;
+	u32 data;
+
+	if (!(hw_layer->features & MALIDP_LAYER_FEATURE_SCALING))
+		return MALIDP_DE_LAYER_FLOW_LOCAL;
+
+	data = malidp_de_read(dev, loff + DE_REG_L_CONTROL);
+
+	return DE_GET_L_FCFG(data);
+}
+
+static int malidp_de_set_alpha(struct malidp_de_device *dev,
+		struct malidp_hw_buffer *buf)
+{
+	int loff = buf->hw_layer->regs_base;
+	uint32_t mask = DE_L_PREMULT | DE_L_COMPOSE_BG | DE_L_COMPOSE_PIXEL | DE_L_ALPHA(0xFF);
+	uint32_t value = DE_L_ALPHA(buf->layer_alpha);
+
+	if (buf->alpha_mode & MALIDP_ALPHA_MODE_NONE) {
+		value = DE_L_COMPOSE_BG | DE_L_ALPHA(0xFF);
+	} else {
+		if (buf->alpha_mode & MALIDP_ALPHA_MODE_PIXEL)
+			value |= DE_L_COMPOSE_PIXEL;
+		if (buf->alpha_mode & MALIDP_ALPHA_MODE_W_BG)
+			value |= DE_L_COMPOSE_BG;
+		if (buf->alpha_mode & MALIDP_ALPHA_MODE_PREMULT)
+			value |= DE_L_PREMULT;
+	}
+
+	malidp_de_clearbits(dev, mask, loff + DE_REG_L_CONTROL);
+	dev_dbg(dev->device, "%s : Setting alpha bits: 0x%08x", __func__, value);
+	malidp_de_setbits(dev, value, loff + DE_REG_L_CONTROL);
+
+	return 0;
+}
+
+void malidp_de_cfg_smart_state(struct malidp_de_device *dev,
+			const struct malidp_hw_smart_layer_state *ls_state)
+{
+	int loff = ls_state->ls_hw_layer->regs_base;
+	u16 bbox_width, bbox_height;
+
+	bbox_width = ls_state->ls_bbox_right - ls_state->ls_bbox_left;
+	bbox_height = ls_state->ls_bbox_bottom - ls_state->ls_bbox_top;
+
+	malidp_de_write(dev, (DE_L_SIZE_V(bbox_height) | DE_L_SIZE_H(bbox_width)),
+			loff + DE_REG_L_SIZE);
+	malidp_de_write(dev, (DE_L_SIZE_V(bbox_height) | DE_L_SIZE_H(bbox_width)),
+			loff + DE_REG_L_SIZE_CMP);
+	malidp_de_write(dev, (DE_L_OFFSET_V(ls_state->ls_bbox_top) | DE_L_OFFSET_H(ls_state->ls_bbox_left)),
+			loff + DE_REG_L_OFFSET);
+	malidp_de_write(dev, ls_state->ls_bbox_argb, loff + DE_REG_LS_BBOX_ARGB);
+
+	/* Enable layer */
+	malidp_de_write(dev, DE_LS_EN_NUM(ls_state->n_smart_layers),
+			  loff + DE_REG_LS_ENABLE);
+	malidp_de_setbits(dev, DE_L_EN, loff + DE_REG_L_CONTROL);
+
+	dev->scene_changing = true;
+}
+
+static int malidp_de_cfg_smart_layer(struct malidp_de_device *dev,
+				     struct malidp_hw_buffer *buf)
+{
+	const struct malidp_layer_hw_info *hw_layer = buf->hw_layer;
+	const u32 ls_rect_reg_offset = buf->ls_rect_idx * DE_REG_LS_Rn_ADDR_DELTA;
+	const u32 ls_rn_in_size = hw_layer->ls_r1_in_size + ls_rect_reg_offset;
+	const u32 ls_rn_offset  = hw_layer->ls_r1_offset + ls_rect_reg_offset;
+	const u32 ls_rn_stride  = hw_layer->ls_r1_stride + ls_rect_reg_offset;
+	const u32 ls_rn_ptr_low = hw_layer->ls_r1_ptr_low + ls_rect_reg_offset;
+	const u32 ls_rn_ptr_high = hw_layer->ls_r1_ptr_high + ls_rect_reg_offset;
+	int loff = hw_layer->regs_base;
+
+	/* Sizes and offset */
+	malidp_de_write(dev, (DE_L_SIZE_V(buf->natural_h) | DE_L_SIZE_H(buf->natural_w)),
+			loff + ls_rn_in_size);
+	malidp_de_write(dev, (DE_L_OFFSET_V(buf->v_offset) | DE_L_OFFSET_H(buf->h_offset)),
+			loff + ls_rn_offset);
+
+	/* Only need set format and alpha of the first buffer because all the smart
+	 * layers are sharing a same format and alpha. */
+	if (buf->ls_rect_idx == 0) {
+		malidp_de_set_alpha(dev, buf);
+		malidp_de_clearbits(dev, DE_L_IGEN, loff + DE_REG_L_CONTROL);
+		if (buf->flags & MALIDP_FLAG_SRGB) {
+			malidp_de_clearbits(dev, DE_L_IGSEL_MASK,
+				loff + DE_REG_L_CONTROL);
+			malidp_de_setbits(dev, DE_L_IGEN | DE_L_IGSEL_SRGB,
+				loff + DE_REG_L_CONTROL);
+		}
+		malidp_de_clearbits(dev, DE_L_SET_FMT(DE_L_FMT_MASK),
+				    loff + DE_REG_L_FORMAT);
+		malidp_de_setbits(dev, DE_L_SET_FMT(buf->hw_fmt),
+				  loff + DE_REG_L_FORMAT);
+	}
+
+	/* Set HW pointers */
+	if (buf->n_planes > buf->hw_layer->n_max_planes)
+		return -EINVAL;
+
+	malidp_de_write(dev, buf->pitch[0], loff + ls_rn_stride);
+	malidp_de_write(dev, lower_32_bits(buf->addr[0]), loff + ls_rn_ptr_low);
+	malidp_de_write(dev, upper_32_bits(buf->addr[0]), loff + ls_rn_ptr_high);
+
+	return 0;
+}
+
+int malidp_de_cfg_layer(struct malidp_de_device *dev,
+			struct malidp_hw_buffer *buf)
+{
+	int loff = buf->hw_layer->regs_base;
+	bool fmt_is_yuv;
+	u32 w, h;
+	u32 comp_w, comp_h;
+
+	if (buf->hw_layer->type == MALIDP_HW_LAYER_SMART) {
+		return malidp_de_cfg_smart_layer(dev, buf);
+	}
+
+	comp_w = buf->cmp_rect.dest_w;
+	comp_h = buf->cmp_rect.dest_h;
+	w = buf->natural_w;
+	h = buf->natural_h;
+
+	malidp_de_clearbits(dev, DE_AD_EN | DE_AD_YTR | DE_AD_BS, buf->hw_layer->ad_ctrl_reg);
+	if (buf->flags & MALIDP_FLAG_AFBC) {
+		u32 ytr = buf->flags & MALIDP_FLAG_AFBC_YTR ? DE_AD_YTR : 0;
+		u32 bs = buf->flags & MALIDP_FLAG_AFBC_SPLITBLK ? DE_AD_BS : 0;
+		u32 crop_h, crop_v;
+
+		w = buf->natural_w + buf->afbc_crop_l + buf->afbc_crop_r;
+		h = buf->natural_h + buf->afbc_crop_t + buf->afbc_crop_b;
+
+		dev_dbg(dev->device, "%s : configuring for AFBC buffer", __func__);
+
+		crop_h = DE_AD_CROP_RIGHT(buf->afbc_crop_r) | DE_AD_CROP_LEFT(buf->afbc_crop_l);
+		crop_v = DE_AD_CROP_BOTTOM(buf->afbc_crop_b) | DE_AD_CROP_TOP(buf->afbc_crop_t);
+
+		malidp_de_write(dev, crop_h, buf->hw_layer->ad_crop_h_reg);
+		malidp_de_write(dev, crop_v, buf->hw_layer->ad_crop_v_reg);
+		malidp_de_setbits(dev, DE_AD_EN | ytr | bs, buf->hw_layer->ad_ctrl_reg);
+
+		dev_dbg(dev->device, "%s : dimensions: %ix%i, crop: 0x%08x, 0x%08x",
+				__func__, w, h, crop_h, crop_v);
+	}
+
+	/* Transform */
+	malidp_de_clearbits(dev, DE_L_TRANS_MASK, loff + DE_REG_L_CONTROL);
+	malidp_de_setbits(dev, DE_L_SET_TRANS(buf->transform), loff + DE_REG_L_CONTROL);
+
+	/* Sizes and offset */
+	malidp_de_write(dev, (DE_L_SIZE_V(h) | DE_L_SIZE_H(w)),
+			loff + DE_REG_L_SIZE);
+	malidp_de_write(dev, (DE_L_SIZE_V(comp_h) | DE_L_SIZE_H(comp_w)),
+			loff + DE_REG_L_SIZE_CMP);
+	malidp_de_write(dev, (DE_L_OFFSET_V(buf->v_offset) | DE_L_OFFSET_H(buf->h_offset)),
+			loff + DE_REG_L_OFFSET);
+
+	/* Set format of the buffer */
+	malidp_de_clearbits(dev, DE_L_SET_FMT(DE_L_FMT_MASK),
+			    loff + DE_REG_L_FORMAT);
+	malidp_de_setbits(dev, DE_L_SET_FMT(buf->hw_fmt),
+			  loff + DE_REG_L_FORMAT);
+
+	/* Set up alpha blending */
+	if (malidp_de_set_alpha(dev, buf) < 0)
+		return -EINVAL;
+
+	/* Set YUV coefficients if necessary */
+	fmt_is_yuv = malidp_hw_format_is_yuv(buf->fmt);
+	if (fmt_is_yuv)
+		malidp_de_set_yuv2rgb_coeffs(dev, buf);
+
+	/* Set inverse gamma/sRGB */
+	if (buf->flags & MALIDP_FLAG_SRGB) {
+		malidp_de_clearbits(dev, DE_L_IGSEL_MASK,
+			loff + DE_REG_L_CONTROL);
+		malidp_de_setbits(dev, DE_L_IGEN | DE_L_IGSEL_SRGB,
+			loff + DE_REG_L_CONTROL);
+	} else if (fmt_is_yuv && !(buf->flags & MALIDP_FLAG_FORCE_NO_IGAMMA)) {
+		dev_dbg(dev->device, "%s : enabling inverse gamma\n",
+			__func__);
+		if (malidp_hw_buf_support_srgb(buf) == true)
+			malidp_de_clearbits(dev, DE_L_IGSEL_MASK,
+				loff + DE_REG_L_CONTROL);
+		malidp_de_setbits(dev, DE_L_IGEN, loff + DE_REG_L_CONTROL);
+	} else {
+		dev_dbg(dev->device, "%s : disabling inverse gamma\n",
+			__func__);
+		malidp_de_clearbits(dev, DE_L_IGEN, loff + DE_REG_L_CONTROL);
+	}
+
+	/* Set HW pointers */
+	if (buf->n_planes > buf->hw_layer->n_max_planes)
+		return -EINVAL;
+
+	switch (buf->n_planes) {
+	case 3:
+		if (buf->hw_layer->p3_stride_offset)
+			malidp_de_write(dev, buf->pitch[2], loff + buf->hw_layer->p3_stride_offset);
+		malidp_de_write(dev, lower_32_bits(buf->addr[2]), loff + DE_REG_LV3_PTR0_LOW);
+		malidp_de_write(dev, upper_32_bits(buf->addr[2]), loff + DE_REG_LV3_PTR0_HIGH);
+		/* Fallthrough */
+	case 2:
+		malidp_de_write(dev, buf->pitch[1], loff + DE_REG_LV2_STRIDE);
+		malidp_de_write(dev, lower_32_bits(buf->addr[1]), loff + DE_REG_LV2_PTR0_LOW);
+		malidp_de_write(dev, upper_32_bits(buf->addr[1]), loff + DE_REG_LV2_PTR0_HIGH);
+		/* Fallthrough */
+	case 1:
+		malidp_de_write(dev, buf->pitch[0],
+				loff + buf->hw_layer->stride_offset);
+		malidp_de_write(dev, lower_32_bits(buf->addr[0]),
+				loff + buf->hw_layer->ptr0_low_offset);
+		malidp_de_write(dev, upper_32_bits(buf->addr[0]),
+				loff + buf->hw_layer->ptr0_high_offset);
+	}
+
+	/* Enable layer */
+	malidp_de_setbits(dev, DE_L_EN, loff + DE_REG_L_CONTROL);
+
+	dev->scene_changing = true;
+
+	return 0;
+}
+
+void malidp_de_disable_all_layers(struct malidp_de_device *dev)
+{
+	const struct malidp_layer_hw_info *hw_layers;
+	int n_layers, i;
+
+	hw_layers = malidp_de_get_layers(dev, &n_layers);
+	for (i = 0; i < n_layers; i++)
+		malidp_de_clearbits(dev, DE_L_EN,
+			hw_layers[i].regs_base + DE_REG_L_CONTROL);
+}
+
+void malidp_de_cleanup_yuv2rgb_coeffs(struct malidp_de_device *dev)
+{
+	int i;
+
+	for (i = 0; i < MALIDP_MAX_LAYERS; i++)
+		dev->yuv2rgb_coeffs[i] = NULL;
+}
+
+void malidp_de_store_output_depth(struct malidp_de_device *dev,
+	u8 red, u8 green, u8 blue)
+{
+	if ((red > DE_MAX_OUT_DEPTH) || (green > DE_MAX_OUT_DEPTH) ||
+	    (blue > DE_MAX_OUT_DEPTH)) {
+		dev_warn(dev->device, "%s : depth exceeds maximum (%d), values will be truncated\n",
+			 __func__, DE_MAX_OUT_DEPTH);
+		if (red > DE_MAX_OUT_DEPTH)
+			red = DE_MAX_OUT_DEPTH;
+		if (green > DE_MAX_OUT_DEPTH)
+			green = DE_MAX_OUT_DEPTH;
+		if (blue > DE_MAX_OUT_DEPTH)
+			blue = DE_MAX_OUT_DEPTH;
+	}
+	if ((red < DE_MIN_OUT_DEPTH) || (green < DE_MIN_OUT_DEPTH) ||
+	    (blue < DE_MIN_OUT_DEPTH)) {
+		dev_warn(dev->device, "%s : depth is less than minimum (%d), values will be increased\n",
+			 __func__, DE_MIN_OUT_DEPTH);
+		if (red < DE_MIN_OUT_DEPTH)
+			red = DE_MIN_OUT_DEPTH;
+		if (green < DE_MIN_OUT_DEPTH)
+			green = DE_MIN_OUT_DEPTH;
+		if (blue < DE_MIN_OUT_DEPTH)
+			blue = DE_MIN_OUT_DEPTH;
+	}
+
+	dev->red_bits = red;
+	dev->green_bits = green;
+	dev->blue_bits = blue;
+}
+
+static void malidp_de_set_output_depth(struct malidp_de_device *dev)
+{
+	const struct malidp_de_regmap *reg = dev->de_regmap;
+
+	malidp_de_write(dev, DE_OUT_DEPTH_R(dev->red_bits) |
+			DE_OUT_DEPTH_G(dev->green_bits) |
+			DE_OUT_DEPTH_B(dev->blue_bits),
+			reg->output_depth);
+}
+
+int malidp_de_modeset(struct malidp_de_device *dev,
+			     struct drm_mode_modeinfo *mode)
+{
+	struct malidp_de_hwmode hwmode;
+	int ret;
+	u32 reg_addr;
+	const struct malidp_de_regmap *reg = dev->de_regmap;
+	const struct malidp_de_product_api *de_api =
+				&dev->hwdev->dp_api->de_api;
+
+	ret = malidp_de_mode_drm2hw(dev, mode, &hwmode);
+	if (ret < 0)
+		return ret;
+
+	de_api->modeset(dev, &hwmode);
+	memcpy(&dev->current_mode, mode, sizeof(struct drm_mode_modeinfo));
+
+	/* Set up dithering */
+	malidp_de_set_output_depth(dev);
+
+	/* Program the gamma coefficients table */
+	if (dev->gamma_enabled) {
+		malidp_de_clearbits(dev, DE_GAMMA_EN, reg->disp_func);
+		de_api->set_gamma_coeff(dev, dev->gamma_coeffs);
+		malidp_de_setbits(dev, DE_GAMMA_EN, reg->disp_func);
+	} else {
+		malidp_de_clearbits(dev, DE_GAMMA_EN, reg->disp_func);
+	}
+
+	/* Writing color adjustments coefficients */
+	malidp_de_clearbits(dev, DE_CADJ_EN, reg->disp_func);
+	reg_addr = reg->coloradj_coeff;
+	for (ret = 0; ret < DE_N_COLORADJ_COEFS; ret++) {
+		malidp_de_write(dev, dev->color_adjustment_coeffs[ret],
+			reg_addr);
+		reg_addr += 4;
+	}
+	malidp_de_setbits(dev, DE_CADJ_EN, reg->disp_func);
+
+	/* Disable the layers to make sure we don't try to show a bad scene */
+	malidp_de_disable_all_layers(dev);
+
+	return 0;
+}
+
+void malidp_de_modeget(struct malidp_de_device *dev,
+		       struct drm_mode_modeinfo *mode)
+{
+	memcpy(mode, &dev->current_mode, sizeof(struct drm_mode_modeinfo));
+}
+
+enum malidp_op_mode malidp_de_get_op_mode(struct malidp_de_device *dev)
+{
+	return dev->op_mode;
+}
+
+bool malidp_de_attr_valid(struct malidp_de_device *dev,
+				 u32 attr, u32 val)
+{
+	u32 fifo_size = malidp_hw_get_fifo_size(dev->hwdev);
+
+	switch (attr) {
+	case MALIDP_ATTR_DE_RQOS_LOW:
+		if ((val < 1) || (val > dev->arqos_threshold_high))
+			return false;
+		break;
+	case MALIDP_ATTR_DE_RQOS_HIGH:
+		if ((val < dev->arqos_threshold_low) || (val > (fifo_size - 1)))
+			return false;
+		break;
+	case MALIDP_ATTR_DE_RQOS_RED:
+	case MALIDP_ATTR_DE_RQOS_GREEN:
+		if (val > 0xF)
+			return false;
+		break;
+	default:
+		return dev->hwdev->dp_api->de_api.axi_valid(attr, val);
+	}
+
+	return true;
+}
+
+void malidp_de_set_axi_cfg(struct malidp_de_device *dev, u32 outstran,
+				  u32 poutstdcab, u32 burstlen)
+{
+	/*TODO (LEOSW-312): need new object to handle AXI stuff */
+	const struct malidp_de_regmap *reg = dev->de_regmap;
+
+	dev_dbg(dev->device, "%s: outstran: %i, burstlen: %i\n",
+		__func__, outstran, burstlen);
+
+	dev->outstran = outstran;
+	dev->burstlen = burstlen;
+	dev->poutstdcab = poutstdcab;
+	malidp_de_write(dev, DE_AXI_OUTSTDCAPB(dev->outstran) |
+			DE_AXI_POUTSTDCAB(poutstdcab) |
+			DE_AXI_BURSTLEN(dev->burstlen - 1),
+			reg->axi_control);
+}
+
+void malidp_de_init_axi_qos(struct malidp_de_device *dev,
+				   u32 low, u32 high,
+				   u32 red_code, u32 green_code)
+{
+	u32 fifo_size = malidp_hw_get_fifo_size(dev->hwdev);
+	u32 qos_reg_val = 0;
+
+	dev_dbg(dev->device,
+		"%s: low: 0x%X, high: 0x%X, red: 0x%X, green: 0x%X\n",
+		__func__, low, high, red_code, green_code);
+
+	/* trim the threshold values */
+	low = low > 0 ? low : DE_DEFAULT_AXI_ARQOS_LOW;
+	high = high > 0 ? high : DE_DEFAULT_AXI_ARQOS_HIGH;
+	high = high < fifo_size ? high : fifo_size;
+	low = low < high ? low : high;
+
+	/* program the qos register */
+	qos_reg_val |= DE_RQOS_LOW(low);
+	qos_reg_val |= DE_RQOS_HIGH(high);
+	qos_reg_val |= DE_RQOS_RED(red_code);
+	qos_reg_val |= DE_RQOS_GREEN(green_code);
+	malidp_de_write(dev, qos_reg_val, dev->de_regmap->qos_control);
+
+	/* save the rqos settings for sysfs */
+	dev->arqos_threshold_low = low;
+	dev->arqos_threshold_high = high;
+	dev->arqos_red = red_code;
+	dev->arqos_green = green_code;
+}
+
+struct malidp_de_device  *malidp_de_hw_init(struct malidp_hw_device *hwdev,
+			     struct platform_device *pdev,
+			     struct malidp_hw_pdata *pdata,
+			     spinlock_t *hw_lock)
+{
+	int res;
+	struct malidp_de_device *dev = &hwdev->de_dev;
+
+	dev->hw_lock = hw_lock;
+	dev->hwdev = hwdev;
+	dev->regs = pdata->regs + hwdev->hw_regmap->de_base;
+	dev->de_regmap = &hwdev->hw_regmap->de_regmap;
+	dev->scene_changing = false;
+	dev->gamma_enabled = false;
+
+	dev->device = &pdev->dev;
+
+	dev->ev_queue = malidp_hw_event_queue_create(DE_N_QUEUE_EVENTS);
+	if (!dev->ev_queue)
+		return NULL;
+
+	/* Set identity matrix to coefficients,
+	* no conversion as default.
+	*/
+	dev->color_adjustment_coeffs[0] = 4096;
+	dev->color_adjustment_coeffs[4] = 4096;
+	dev->color_adjustment_coeffs[8] = 4096;
+
+	dev->op_mode = MALIDP_OP_MODE_UNKNOWN;
+
+	dev->outstran = pdata->de_axi_outstran;
+	dev->poutstdcab = pdata->de_axi_poutstdcab;
+	dev->burstlen = pdata->de_axi_burstlen;
+
+	dev->arqos_threshold_low = pdata->de_axi_arqos_low;
+	dev->arqos_threshold_high = pdata->de_axi_arqos_high;
+	dev->arqos_red = pdata->de_axi_arqos_red;
+	dev->arqos_green = pdata->de_axi_arqos_green;
+
+	dev_dbg(dev->device, "%s : success!\n", __func__);
+
+	return dev;
+}
+
+int malidp_de_get_attr(struct malidp_de_device *dev, u32 attr, u32 *val)
+{
+	u32 fifo_size = malidp_hw_get_fifo_size(dev->hwdev);
+
+	switch (attr) {
+	case MALIDP_ATTR_DE_BURSTLEN:
+		*val = dev->burstlen;
+		break;
+	case MALIDP_ATTR_DE_POUTSTDCAB:
+		*val = dev->poutstdcab;
+		break;
+	case MALIDP_ATTR_DE_OUTSTRAN:
+		*val = dev->outstran;
+		break;
+	case MALIDP_ATTR_DE_RQOS_LOW:
+		*val = dev->arqos_threshold_low;
+		break;
+	case MALIDP_ATTR_DE_RQOS_HIGH:
+		*val = dev->arqos_threshold_high;
+		break;
+	case MALIDP_ATTR_DE_RQOS_RED:
+		*val = dev->arqos_red;
+		break;
+	case MALIDP_ATTR_DE_RQOS_GREEN:
+		*val = dev->arqos_green;
+		break;
+	case MALIDP_ATTR_DE_FIFO_SIZE:
+		*val = fifo_size;
+		break;
+	default:
+		dev_err(dev->device, "%s: unkown DE attribute %i\n",
+			__func__, attr);
+		return -EINVAL;
+	}
+
+	dev_dbg(dev->device, "%s: attr: %i, val: %u\n",
+		__func__, attr, *val);
+
+	return 0;
+}
+
+int malidp_de_set_attr(struct malidp_de_device *dev, u32 attr, u32 val)
+{
+	int ret = 0;
+
+	dev_dbg(dev->device, "%s: attr: %i, val: %u\n", __func__, attr, val);
+
+	if (!malidp_de_attr_valid(dev, attr, val)) {
+		dev_dbg(dev->device, "%s: invalid value %u for attr %u\n",
+			__func__, val, attr);
+		return -EINVAL;
+	}
+
+	switch (attr) {
+	case MALIDP_ATTR_DE_BURSTLEN:
+		malidp_de_set_axi_cfg(dev, dev->outstran,
+					dev->poutstdcab, val);
+		break;
+	case MALIDP_ATTR_DE_POUTSTDCAB:
+		malidp_de_set_axi_cfg(dev, dev->outstran, val,
+					dev->burstlen);
+		break;
+	case MALIDP_ATTR_DE_OUTSTRAN:
+		malidp_de_set_axi_cfg(dev, val, dev->poutstdcab,
+					dev->burstlen);
+		break;
+	case MALIDP_ATTR_DE_RQOS_LOW:
+		malidp_de_init_axi_qos(dev, val, dev->arqos_threshold_high,
+				       dev->arqos_red, dev->arqos_green);
+		break;
+	case MALIDP_ATTR_DE_RQOS_HIGH:
+		malidp_de_init_axi_qos(dev, dev->arqos_threshold_low, val,
+				       dev->arqos_red, dev->arqos_green);
+		break;
+	case MALIDP_ATTR_DE_RQOS_RED:
+		malidp_de_init_axi_qos(dev, dev->arqos_threshold_low,
+				       dev->arqos_threshold_high,
+				       val, dev->arqos_green);
+		break;
+	case MALIDP_ATTR_DE_RQOS_GREEN:
+		malidp_de_init_axi_qos(dev, dev->arqos_threshold_low,
+				       dev->arqos_threshold_high,
+				       dev->arqos_red, val);
+		break;
+	default:
+		dev_err(dev->device, "%s: unkown DE attribute %i\n",
+			__func__, attr);
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+int malidp_de_save_attr(struct malidp_de_device *dev, u32 attr, u32 val)
+{
+	int ret = 0;
+
+	dev_dbg(dev->device, "%s: attr: %i, val: %u\n", __func__, attr, val);
+
+	if (!malidp_de_attr_valid(dev, attr, val)) {
+		dev_dbg(dev->device, "%s: invalid value %u for attr %u\n",
+			__func__, val, attr);
+		return -EINVAL;
+	}
+
+	switch (attr) {
+	case MALIDP_ATTR_DE_BURSTLEN:
+		dev->burstlen = val;
+		break;
+	case MALIDP_ATTR_DE_POUTSTDCAB:
+		dev->poutstdcab = val;
+		break;
+	case MALIDP_ATTR_DE_OUTSTRAN:
+		dev->outstran = val;
+		break;
+	case MALIDP_ATTR_DE_RQOS_LOW:
+		dev->arqos_threshold_low = val;
+		break;
+	case MALIDP_ATTR_DE_RQOS_HIGH:
+		dev->arqos_threshold_high = val;
+		break;
+	case MALIDP_ATTR_DE_RQOS_RED:
+		dev->arqos_red = val;
+		break;
+	case MALIDP_ATTR_DE_RQOS_GREEN:
+		dev->arqos_green = val;
+		break;
+	default:
+		dev_err(dev->device, "%s: unkown DE attribute %i\n",
+			__func__, attr);
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+/*
+ * Update the gamma settings
+ *
+ * @enable: enable/disable the gamma correction.
+ * @coeffs: the gamma coeffs table, it is omitted if @enable = false.
+ */
+void malidp_de_update_gamma_settings(struct malidp_de_device *dev,
+			bool enable, u32 *coeffs)
+{
+	dev_dbg(dev->device, "%s: gamma enabled: %d\n", __func__, enable);
+
+	dev->gamma_enabled = enable;
+	if (dev->gamma_enabled) {
+		if (coeffs != NULL) {
+			memcpy(dev->gamma_coeffs, coeffs,
+			       sizeof(u32) * DE_N_COEFTAB_COEFS);
+		} else {
+			dev_warn(dev->device, "%s: the gamma coeffs table is null\n",
+				 __func__);
+		}
+	}
+}
+
+#define MANTISSA	12
+#define FP12_1_0	(1 << MANTISSA)
+
+static s32 fp_div(s32 dividend, s32 divisor)
+{
+	u64 a, b;
+	int sign = 0;
+
+	WARN_ON(divisor == 0);
+
+	if (dividend < 0) {
+		a = -dividend;
+		sign = !sign;
+	} else {
+		a = dividend;
+	}
+
+	if (divisor < 0) {
+		b = -divisor;
+		sign = !sign;
+	} else {
+		b = divisor;
+	}
+
+	a <<= MANTISSA;
+	do_div(a, b);
+	dividend = a;
+
+	return (sign == 0) ? dividend : -dividend;
+}
+
+static s32 fp_mul(s32 faciend, s32 multiplier)
+{
+	s64 t = faciend;
+
+	t *= multiplier;
+	faciend = (t >> MANTISSA);
+	return faciend;
+}
+
+/*
+*	Calculation of the inverse matrix
+*		| a00 a01 a02 |
+*		| a10 a11 a12 |
+*		| a20 a21 a22 |
+*	The result is stored into inverse[3][3]
+*/
+static int matrix_inverse(s32 inverse[3][3],
+		s32 a00, s32 a01, s32 a02,
+		s32 a10, s32 a11, s32 a12,
+		s32 a20, s32 a21, s32 a22)
+{
+	s32 a_1 = fp_mul(a11, a22) - fp_mul(a12, a21);
+	s32 a_2 = fp_mul(a12, a20) - fp_mul(a10, a22);
+	s32 a_3 = fp_mul(a10, a21) - fp_mul(a11, a20);
+
+	s32 determinant = fp_mul(a00, a_1) + fp_mul(a01, a_2) + fp_mul(a02, a_3);
+	if (determinant == 0)
+		return -EINVAL;
+
+	inverse[0][0] = fp_div(a_1, determinant);
+	inverse[1][0] = fp_div(a_2, determinant);
+	inverse[2][0] = fp_div(a_3, determinant);
+
+	a_1 = fp_mul(a02, a21) - fp_mul(a01, a22);
+	a_2 = fp_mul(a00, a22) - fp_mul(a02, a20);
+	a_3 = fp_mul(a01, a20) - fp_mul(a00, a21);
+
+	inverse[0][1] = fp_div(a_1, determinant);
+	inverse[1][1] = fp_div(a_2, determinant);
+	inverse[2][1] = fp_div(a_3, determinant);
+
+	a_1 = fp_mul(a01, a12) - fp_mul(a02, a11);
+	a_2 = fp_mul(a02, a10) - fp_mul(a00, a12);
+	a_3 = fp_mul(a00, a11) - fp_mul(a01, a10);
+
+	inverse[0][2] = fp_div(a_1, determinant);
+	inverse[1][2] = fp_div(a_2, determinant);
+	inverse[2][2] = fp_div(a_3, determinant);
+	return 0;
+}
+
+/* This routing makes the sum of every row in matrix not bigger than 1 */
+static void normalize_matrix(s32 m[3][3])
+{
+	s32 sum_line[3], max_sum;
+	int i, j;
+
+	for (i = 0; i < 3; i++) {
+		sum_line[i] = 0;
+		for (j = 0; j < 3; j++)
+			sum_line[i] += m[i][j];
+	}
+
+	max_sum = sum_line[0];
+	for (i = 1; i < 3; i++) {
+		if (max_sum < sum_line[i])
+			max_sum = sum_line[i];
+	}
+
+	if (max_sum <= FP12_1_0)
+		return;
+	/* If max_sum is larger than 4096, we need get 4096/max_sum,
+	* then, every element in the matrix multiple 4096/max_sum
+	*/
+	max_sum = fp_div(FP12_1_0, max_sum);
+	for (i = 0; i < 3; i++) {
+		for (j = 0; j < 3; j++)
+			m[i][j] = fp_mul(m[i][j], max_sum);
+	}
+}
+
+/*
+* This matrix is used for transforming from Rec. 709 RGB
+* into CIE XYZ.
+*/
+static const s32 matrix709[3][3] = {
+	{1689, 1465,  739},
+	{ 871, 2929,  296},
+	{  79,  488, 3892}
+};
+
+/*
+ * Update color adjustment coefficients
+ *	All the calculation is base on fix point number which format is
+ *	S19.12 (32bit, signed)
+ *	So, integer 4096 is actually for fix pointer number 1.0
+ *	The xy coordinates should be in 10bits representing values
+ *	from 0 to 1023/1024 as reported by the EDID standard.
+ * For result:
+ *	Coefficients are 15bit two's complement code.
+ */
+int malidp_de_update_cadj_coeffs(struct malidp_de_device *dev,
+	u16 red_x, u16 red_y, u16 green_x, u16 green_y,
+	u16 blue_x, u16 blue_y, u16 white_x, u16 white_y)
+{
+	s32 w_x, w_y, w_z;
+	s32 r_x, r_y, r_z;
+	s32 g_x, g_y, g_z;
+	s32 b_x, b_y, b_z;
+	s32 inverse[3][3], coeffs[3][3];
+	s32 r_xyz, g_xyz, b_xyz;
+	unsigned long flags;
+
+	r_x = red_x << 2;
+	r_y = red_y << 2;
+	g_x = green_x << 2;
+	g_y = green_y << 2;
+	b_x = blue_x << 2;
+	b_y = blue_y << 2;
+
+	/*
+	*	Algorithm for calculating M:
+	*	    | r_x  g_x b_x |   |r_xyz   0     0   |
+	*	M = | r_y  g_y b_y | * |  0   g_xyz   0   |
+	*	    | r_z  g_z b_z |   |  0     0   b_xyz |
+	*
+	*	|r_xyz|          | r_x g_x b_x |   | w_x |
+	*	|g_xyz| = inverse| r_y g_y b_y | * | w_y |
+	*	|b_xyz|          | r_z g_z b_z |   | w_z |
+	*
+	*	w_x = white_x/white_y, w_y = 1,
+	*	w_z = (1 - white_x - white_y)/white_y
+	*/
+
+	if (white_y == 0)
+		return -EINVAL;
+
+	w_x = white_x << 2;
+	w_y = white_y << 2;
+	w_z = FP12_1_0 - w_x - w_y;
+
+	w_x = fp_div(w_x, w_y);
+	w_z = fp_div(w_z, w_y);
+	w_y = FP12_1_0;
+
+	r_z = FP12_1_0 - r_x - r_y;
+	g_z = FP12_1_0 - g_x - g_y;
+	b_z = FP12_1_0 - b_x - b_y;
+
+	if (matrix_inverse(inverse,
+		r_x, g_x, b_x, r_y, g_y, b_y, r_z, g_z, b_z) != 0)
+		return -EINVAL;
+
+	r_xyz = fp_mul(inverse[0][0], w_x)
+			+fp_mul(inverse[0][1], w_y)
+			+fp_mul(inverse[0][2], w_z);
+
+	g_xyz = fp_mul(inverse[1][0], w_x)
+			+fp_mul(inverse[1][1], w_y)
+			+fp_mul(inverse[1][2], w_z);
+
+	b_xyz = fp_mul(inverse[2][0], w_x)
+			+fp_mul(inverse[2][1], w_y)
+			+fp_mul(inverse[2][2], w_z);
+
+	if (matrix_inverse(inverse,
+		fp_mul(r_x, r_xyz), fp_mul(g_x, g_xyz), fp_mul(b_x, b_xyz),
+		fp_mul(r_y, r_xyz), fp_mul(g_y, g_xyz), fp_mul(b_y, b_xyz),
+		fp_mul(r_z, r_xyz), fp_mul(g_z, g_xyz), fp_mul(b_z, b_xyz))
+		!= 0)
+		return -EINVAL;
+
+	/* inverse(M) * Matrix 709 */
+	for (r_x = 0; r_x < 3; r_x++) {
+		for (r_y = 0; r_y < 3; r_y++) {
+			coeffs[r_x][r_y] = 0;
+			for (g_x = 0; g_x < 3; g_x++)
+				coeffs[r_x][r_y] +=
+					fp_mul(inverse[r_x][g_x], matrix709[g_x][r_y]);
+		}
+	}
+
+	normalize_matrix(coeffs);
+
+	spin_lock_irqsave(dev->hw_lock, flags);
+
+	for (r_x = 0; r_x < 3; r_x++)
+		for (r_y = 0; r_y < 3; r_y++)
+			dev->color_adjustment_coeffs[r_x * 3 + r_y] =
+				coeffs[r_x][r_y] & 0x7FFF;
+
+	spin_unlock_irqrestore(dev->hw_lock, flags);
+
+	return 0;
+}
diff --git a/devices/malidp/src/malidp_hw.c b/devices/malidp/src/malidp_hw.c
new file mode 100644
index 0000000..5623e64
--- /dev/null
+++ b/devices/malidp/src/malidp_hw.c
@@ -0,0 +1,1902 @@
+/*
+ *
+ * (C) COPYRIGHT 2013-2015 ARM Limited. All rights reserved.
+ *
+ * This program is free software and is provided to you under the terms of the
+ * GNU General Public License version 2 as published by the Free Software
+ * Foundation, and any use by you of this program is subject to the terms
+ * of such GNU licence.
+ *
+ * A copy of the licence is included with the program, and can also be obtained
+ * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA  02110-1301, USA.
+ *
+ */
+
+
+
+#include "malidp_adf.h"
+#include "malidp_product_api.h"
+#include "malidp_de_device.h"
+#include "malidp_se_device.h"
+
+#define MALIDP_AFBC_ALIGN_MASK 0xf
+
+#define MALIDP_MAX_EVENT_STRING 100
+
+/* Global register offset definitions */
+#define MALIDP_REG_DP500_CORE_ID	0x18
+#define MALIDP_REG_CORE_ID		0xC018
+#define		MALIDP_CFG_VALID		0x1
+#define MALIDP_REG_PER_ID_4	0x00
+#define MALIDP_REG_CONFIG_0 0x04
+#define		MALIDP_CONFIG_0_GET_DISP(x)	(((x) >> 0) & 0x1)
+#define		MALIDP_CONFIG_0_GET_LS(x)	(((x) >> 4) & 0x3)
+
+#define MALIDP_DEFAULT_ROTMEM_SIZE 0
+
+#define dev_info(dev, format, arg...)
+
+struct rotmem_partition {
+	int dividers[3];
+};
+
+struct malidp_hw_event_queue {
+	spinlock_t lock;
+	size_t n_events;
+	struct malidp_hw_event *queue;
+	/*
+	 * head == NULL when the queue is empty
+	 * head == tail when the queue is full
+	 */
+	struct malidp_hw_event *head;
+	struct malidp_hw_event *tail;
+};
+
+struct rotmem_partition fixed_partition_table[] = {
+	/* 1 layer */
+	{
+		.dividers = { 1, 0, 0 }
+	},
+	/* 2 layers */
+	{
+		.dividers = { 2, 2, 0 }
+	},
+	/* 3 layers */
+	{
+		.dividers = { 2, 4, 4 }
+	},
+};
+
+/* Start of HW description */
+
+const struct malidp_intf_hw_info dp_interfaces[] = {
+	{
+		.name = "Panel",
+		.type = MALIDP_HW_INTF_PRIMARY,
+		.idx = 0,
+	},
+	{
+		.name = "Memory",
+		.type = MALIDP_HW_INTF_MEMORY,
+		.idx = 0,
+	}
+};
+
+bool malidp_hw_format_is_yuv(u32 format)
+{
+	switch (format) {
+	case DRM_FORMAT_ARGB2101010:
+	case DRM_FORMAT_ABGR2101010:
+	case DRM_FORMAT_RGBA1010102:
+	case DRM_FORMAT_BGRA1010102:
+	case DRM_FORMAT_ARGB8888:
+	case DRM_FORMAT_ABGR8888:
+	case DRM_FORMAT_RGBA8888:
+	case DRM_FORMAT_BGRA8888:
+	case DRM_FORMAT_XRGB8888:
+	case DRM_FORMAT_XBGR8888:
+	case DRM_FORMAT_RGBX8888:
+	case DRM_FORMAT_BGRX8888:
+	case DRM_FORMAT_RGB888:
+	case DRM_FORMAT_BGR888:
+	case DRM_FORMAT_RGBA5551:
+	case DRM_FORMAT_ABGR1555:
+	case DRM_FORMAT_RGB565:
+	case DRM_FORMAT_BGR565:
+		return false;
+	case DRM_FORMAT_UYVY:
+	case DRM_FORMAT_YUYV:
+	case DRM_FORMAT_NV12:
+	case DRM_FORMAT_YUV420:
+	case MALIDP_FORMAT_XYUV:
+	case MALIDP_FORMAT_VYU30:
+	case MALIDP_FORMAT_YUV10_420AFBC:
+	case MALIDP_FORMAT_NV12AFBC:
+	case MALIDP_FORMAT_NV16AFBC:
+	case MALIDP_FORMAT_Y0L2:
+	case MALIDP_FORMAT_P010:
+		return true;
+	default:
+		BUG();
+	}
+}
+
+bool malidp_hw_format_has_alpha(u32 format)
+{
+	switch (format) {
+	case DRM_FORMAT_XRGB8888:
+	case DRM_FORMAT_XBGR8888:
+	case DRM_FORMAT_RGBX8888:
+	case DRM_FORMAT_BGRX8888:
+	case DRM_FORMAT_RGB888:
+	case DRM_FORMAT_BGR888:
+	case DRM_FORMAT_RGB565:
+	case DRM_FORMAT_BGR565:
+	case DRM_FORMAT_UYVY:
+	case DRM_FORMAT_YUYV:
+	case DRM_FORMAT_NV12:
+	case DRM_FORMAT_YUV420:
+	case MALIDP_FORMAT_XYUV:
+	case MALIDP_FORMAT_VYU30:
+	case MALIDP_FORMAT_YUV10_420AFBC:
+	case MALIDP_FORMAT_NV12AFBC:
+	case MALIDP_FORMAT_NV16AFBC:
+	case MALIDP_FORMAT_P010:
+	/* Y0L2 does have alpha, but Mali-DP will ignore it */
+	case MALIDP_FORMAT_Y0L2:
+		return false;
+	case DRM_FORMAT_ARGB2101010:
+	case DRM_FORMAT_ABGR2101010:
+	case DRM_FORMAT_RGBA1010102:
+	case DRM_FORMAT_BGRA1010102:
+	case DRM_FORMAT_ARGB8888:
+	case DRM_FORMAT_ABGR8888:
+	case DRM_FORMAT_RGBA8888:
+	case DRM_FORMAT_BGRA8888:
+	case DRM_FORMAT_RGBA5551:
+	case DRM_FORMAT_ABGR1555:
+		return true;
+	default:
+		BUG();
+	}
+}
+
+u32 malidp_hw_format_bpp(u32 format)
+{
+	switch (format)	{
+	case DRM_FORMAT_ARGB2101010:
+	case DRM_FORMAT_ABGR2101010:
+	case DRM_FORMAT_RGBA1010102:
+	case DRM_FORMAT_BGRA1010102:
+	case DRM_FORMAT_ARGB8888:
+	case DRM_FORMAT_ABGR8888:
+	case DRM_FORMAT_RGBA8888:
+	case DRM_FORMAT_BGRA8888:
+	case DRM_FORMAT_XRGB8888:
+	case DRM_FORMAT_XBGR8888:
+	case DRM_FORMAT_RGBX8888:
+	case DRM_FORMAT_BGRX8888:
+	case MALIDP_FORMAT_VYU30:
+	case MALIDP_FORMAT_XYUV:
+	case MALIDP_FORMAT_Y0L2:
+	case MALIDP_FORMAT_P010:
+		return 32;
+
+	case DRM_FORMAT_RGB888:
+	case DRM_FORMAT_BGR888:
+		return 24;
+
+	case DRM_FORMAT_RGBA5551:
+	case DRM_FORMAT_ABGR1555:
+	case DRM_FORMAT_RGB565:
+	case DRM_FORMAT_BGR565:
+	case DRM_FORMAT_UYVY:
+	case DRM_FORMAT_YUYV:
+	case MALIDP_FORMAT_NV16AFBC:
+		return 16;
+
+	case DRM_FORMAT_NV12:
+	case DRM_FORMAT_YUV420:
+	case MALIDP_FORMAT_NV12AFBC:
+		return 12;
+
+	case MALIDP_FORMAT_YUV10_420AFBC:
+		return 15;
+
+	default:
+		BUG();
+	}
+}
+
+static void malidp_dump_hw_buf(struct malidp_hw_device *hwdev,
+		struct malidp_hw_buffer *buf)
+{
+	int i;
+	struct device *dev = hwdev->device;
+
+	dev_dbg(dev, "hw_buffer:\n");
+	if (buf->hw_layer) {
+		dev_dbg(dev, "  layer: %s\n", buf->hw_layer->name);
+	}
+	dev_dbg(dev, "  natural size: %ix%i\n", buf->natural_w, buf->natural_h);
+	dev_dbg(dev, "  cmp_scaling_enable = %s\n",
+		buf->cmp_scaling_enable ? "true" : "false");
+	dev_dbg(dev, "    cmp_rect src: %ix%i\n", buf->cmp_rect.src_w,
+			buf->cmp_rect.src_h);
+	dev_dbg(dev, "    cmp_rect dest: %ix%i\n", buf->cmp_rect.dest_w,
+			buf->cmp_rect.dest_h);
+	dev_dbg(dev, "  mw_scaling_enable = %s\n",
+		buf->mw_scaling_enable ? "true" : "false");
+	dev_dbg(dev, "    mw_rect src: %ix%i\n", buf->mw_rect.src_w,
+			buf->mw_rect.src_h);
+	dev_dbg(dev, "    mw_rect dest: %ix%i\n", buf->mw_rect.dest_w,
+			buf->mw_rect.dest_h);
+	dev_dbg(dev, "  offset: %ix%i\n",
+			buf->h_offset, buf->v_offset);
+	dev_dbg(dev, "  format: 0x%08x\n", buf->fmt);
+	dev_dbg(dev, "  HW format: 0x%x\n", buf->hw_fmt);
+
+	dev_dbg(dev, "  n_planes: %i\n", buf->n_planes);
+	dev_dbg(dev, "  address: ");
+	for (i = 0; i < buf->n_planes; i++) {
+		dev_dbg(dev, "    0x%llx", (unsigned long long)buf->addr[i]);
+	}
+	dev_dbg(dev, "  pitch: ");
+	for (i = 0; i < buf->n_planes; i++) {
+		dev_dbg(dev, "    %i", buf->pitch[i]);
+	}
+	dev_dbg(dev, "  flags: 0x%08x\n", buf->flags);
+	dev_dbg(dev, "  transform: 0x%08x\n", buf->transform);
+	dev_dbg(dev, "  alpha_mode: %i\n", buf->alpha_mode);
+	dev_dbg(dev, "  layer_alpha: %i\n", buf->layer_alpha);
+	dev_dbg(dev, "  write_out: %s\n", buf->write_out_enable ? "True" : "False");
+}
+
+struct malidp_hw_state_priv {
+	struct malidp_se_mw_conf mw;
+	enum malidp_de_flow_cmp_cfg cmp_flow;
+	/* LEOSW-409: layer_flow is product specific */
+	enum malidp_de_flow_layer_cfg layer_flow[MALIDP_MAX_LAYERS];
+	struct malidp_se_scaler_conf s0;
+};
+
+u32 malidp_hw_read(struct malidp_hw_device *hwdev, u32 reg)
+{
+	return *((volatile unsigned int *)(hwdev->regs + reg));
+}
+
+static const struct malidp_line_size_hw_info *malidp_hw_get_ls_info(
+		struct malidp_hw_device *hwdev,
+		struct malidp_hw_description *hw_desc)
+{
+	u32 config_raw;
+	u32 ls_config_id;
+
+	config_raw = malidp_hw_read(hwdev,
+		hwdev->hw_regmap->id_registers + MALIDP_REG_CONFIG_0);
+
+	ls_config_id = MALIDP_CONFIG_0_GET_LS(config_raw);
+
+	/* The HW can't report a line size config we don't understand */
+	if (ls_config_id >= hw_desc->config->n_configs) {
+		return NULL;
+	}
+
+	return &hw_desc->config->ls_configs[ls_config_id];
+}
+
+void malidp_hw_enumerate(struct malidp_hw_description *hw_desc,
+		enum malidp_hw_product product,
+		struct malidp_hw_pdata *pdata)
+{
+	malidp_dp550_get_hw_description(hw_desc);
+
+	malidp_hw_get_resources(pdata)
+
+	hw_desc->pdata = pdata;
+}
+
+void malidp_hw_write(struct malidp_hw_device *hwdev, u32 value, u32 reg)
+{
+	*((volatile unsigned int *)(hwdev->regs + reg)) = value;
+}
+
+void malidp_hw_setbits(struct malidp_hw_device *hwdev, u32 mask,
+			u32 reg)
+{
+	u32 data = malidp_hw_read(hwdev, reg);
+	data |= mask;
+	malidp_hw_write(hwdev, data, reg);
+}
+
+void malidp_hw_clearbits(struct malidp_hw_device *hwdev, u32 mask,
+			u32 reg)
+{
+	u32 data = malidp_hw_read(hwdev, reg);
+	data &= ~mask;
+	malidp_hw_write(hwdev, data, reg);
+}
+
+void malidp_hw_commit_scene_atomic(struct malidp_hw_device *hwdev, bool set)
+{
+	u32 val = 0;
+
+	dev_dbg(hwdev->device, "%s: start: set = %d\n", __func__, set);
+
+	if (set)
+		val = MALIDP_CFG_VALID;
+	malidp_hw_write(hwdev, val, hwdev->hw_regmap->config_valid);
+
+	dev_dbg(hwdev->device, "%s: end: set = %d\n", __func__, set);
+}
+
+static bool malidp_hw_validate_rotmem_fixed(struct malidp_hw_device *hwdev,
+				struct malidp_hw_state *state)
+{
+	struct rotmem_partition *table;
+	u32 rotmem_idx = 0;
+	u32 rotmem_count = 0;
+	int i, j, k;
+	struct malidp_hw_buffer *valid_hw_bufs[ARRAY_SIZE(fixed_partition_table)];
+
+	memset(valid_hw_bufs, 0, sizeof(valid_hw_bufs));
+
+	/*
+	 * First pass:
+	 * Find out the total number of buffers using rotation memory
+	 * and sort them.
+	 */
+	for (i = 0; i < state->n_bufs; i++) {
+		struct malidp_hw_buffer *hw_buf = &state->bufs[i];
+
+		/* Only AFBC and 90/270 rotations use rotation memory */
+		if ((hw_buf->flags & MALIDP_FLAG_AFBC) ||
+		   (hw_buf->transform & MALIDP_TRANSFORM_R90) ||
+		   (hw_buf->transform & MALIDP_TRANSFORM_R270)) {
+			rotmem_count++;
+			if (rotmem_count > ARRAY_SIZE(fixed_partition_table)) {
+				dev_err(hwdev->device, "Too many hw buffers using rotation memory\n");
+				return false;
+			}
+			for (j = 0; j < rotmem_count; j++) {
+				if (valid_hw_bufs[j] == NULL)
+					valid_hw_bufs[j] = hw_buf;
+				else if (valid_hw_bufs[j]->hw_layer->index >
+					    hw_buf->hw_layer->index) {
+					k = rotmem_count - 1;
+					valid_hw_bufs[k] = hw_buf;
+					while (k-- > j) {
+						struct malidp_hw_buffer *tmp;
+						tmp = valid_hw_bufs[k];
+						valid_hw_bufs[k] = valid_hw_bufs[k + 1];
+						valid_hw_bufs[k + 1] = tmp;
+					}
+					break;
+				}
+			}
+		}
+	}
+
+	/*
+	 * If no buffers use rotation memory
+	 * then there's nothing to validate
+	 */
+	if (!rotmem_count)
+		return true;
+
+	/* Get the correct set of dividers */
+	table = &fixed_partition_table[rotmem_count - 1];
+
+	/*
+	 * Second pass:
+	 * Validate each individual buffer that uses the memory
+	 */
+	for (i = 0; i < rotmem_count; i++) {
+		struct malidp_hw_buffer *hw_buf = valid_hw_bufs[i];
+		u32 layer_divider = table->dividers[rotmem_idx];
+		u32 layer_size = hwdev->dp_api->rotmem_size_required(
+							hw_buf);
+
+		/* Does the layer fit in it's parition? */
+		if (layer_size > (hwdev->rotmem_size / layer_divider)) {
+			dev_err(hwdev->device, "hwbuf(%d) uses too much rotation memory\n"
+				"\tAvailable: %d bytes\n"
+				"\tNeeded: %d bytes\n"
+				"\tCount: %d, Index: %d\n"
+				"\tWidth: %d, Format: %d bpp %d\n",
+				i, (hwdev->rotmem_size / layer_divider), layer_size,
+				rotmem_count, rotmem_idx, hw_buf->cmp_rect.src_w,
+				hw_buf->fmt,
+				malidp_hw_format_bpp(hw_buf->fmt));
+			return false;
+		}
+		rotmem_idx++;
+	}
+	return true;
+}
+
+static bool malidp_hw_validate_rotmem(struct malidp_hw_device *hwdev,
+				struct malidp_hw_state *state)
+{
+	switch (hwdev->partition_type) {
+	case MALIDP_HW_PARTITION_FIXED:
+		return malidp_hw_validate_rotmem_fixed(hwdev, state);
+	default:
+		BUG();
+	}
+}
+
+static int scale_f(u16 in, u16 out)
+{
+	int ret = 0;
+
+	if (in < out)
+		ret = 1; /* upscaling */
+	else if (in > out)
+		ret = -1; /* downscaling */
+
+	return ret;	/* -1: downscaling, 0: no scaling, 1: upscaing */
+}
+
+/* Check limition for scaler, if no limitaion found return true, or return false */
+static bool limitation_check(struct malidp_hw_device *hwdev,
+				struct malidp_hw_state_priv *hw_priv)
+{
+	bool scaling_to_dp = false, scaling_layer_to_mw = false;
+	int i;
+
+	if (hw_priv->s0.scaling_enable == false)
+		return true;
+
+	for (i = 0; i < hwdev->topology->n_layers; i++) {
+		if (hw_priv->layer_flow[i] == MALIDP_DE_LAYER_FLOW_SCALE_SE0)
+			scaling_to_dp = true;
+		else if (hw_priv->layer_flow[i] == MALIDP_DE_LAYER_FLOW_SIMULT_SE0)
+			scaling_layer_to_mw = true;
+	}
+
+	if (scaling_to_dp == true) {
+		if ((scale_f(hw_priv->s0.input_w, hw_priv->s0.output_w)) == -1 ||
+			(scale_f(hw_priv->s0.input_h, hw_priv->s0.output_h) == -1)) {
+			bool supported = hwdev->dp_api->se_api.limitation_check(hwdev->se_dev,
+										&hw_priv->s0);
+			if (!supported) {
+				return false;
+			}
+		}
+	}
+
+	if (scaling_layer_to_mw ||
+			((hw_priv->cmp_flow == MALIDP_DE_CMP_FLOW_SE0) && (hw_priv->mw.mode == MALIDP_SE_MW_L0))) {
+		if ((scale_f(hw_priv->s0.input_w, hw_priv->s0.output_w)) == 1 ||
+			(scale_f(hw_priv->s0.input_h, hw_priv->s0.output_h) == 1)) {
+			dev_err(hwdev->device,
+			"%s: Upscaling the layer or composition to mw only is not supported.",
+			__func__);
+			return false;
+		}
+	}
+
+	return true;
+}
+
+int malidp_hw_buffer_set_hw_fmt(struct malidp_hw_device *hwdev,
+	struct malidp_hw_buffer *hw_buf)
+{
+	const struct malidp_hw_topology *topo = hwdev->topology;
+	int res = -1;
+	unsigned int i;
+	bool afbc_support = false;
+
+	if (hw_buf->flags & MALIDP_FLAG_AFBC) {
+		for (i = 0; i < topo->n_supported_afbc_formats; i++) {
+			if (topo->supported_afbc_formats[i] == hw_buf->fmt) {
+				afbc_support = true;
+				if ((hw_buf->flags & MALIDP_FLAG_AFBC_SPLITBLK) &&
+				    !((1 << i) & topo->supported_afbc_splitblk))
+						afbc_support = false;
+				break;
+			}
+		}
+
+		if (!afbc_support) {
+			dev_err(hwdev->device, "Format 0x%08x unsupported for AFBC flags 0x%08x\n",
+				hw_buf->fmt, hw_buf->flags);
+			return -1;
+		}
+	} else if (hw_buf->transform) {
+		/*
+		 * This needs to be in an "else" branch because the limitations
+		 * don't apply for AFBC
+		 */
+		for (i = 0; i < topo->n_xform_invalid_formats; i++) {
+			if (topo->xform_invalid_formats[i] == hw_buf->fmt) {
+				dev_err(hwdev->device, "Transform not supported for format 0x%08x\n",
+					hw_buf->fmt);
+				return -1;
+			}
+		}
+	}
+
+	if (hw_buf->flags & MALIDP_FLAG_BUFFER_OUTPUT) {
+		res = malidp_se_fmt_drm2mw(hwdev->se_dev, hw_buf->fmt);
+		if (res < 0) {
+			dev_err(hwdev->device, "Format 0x%08x unsupported for MW\n",
+				hw_buf->fmt);
+			return -1;
+		}
+		hw_buf->hw_fmt = res;
+	} else {
+		res = malidp_de_fmt_drm2hw(hwdev->de_dev, hw_buf);
+		if (res < 0) {
+			dev_err(hwdev->device, "Format 0x%08x unsupported\n",
+				hw_buf->fmt);
+			return -1;
+		}
+		hw_buf->hw_fmt = res;
+	}
+	return 0;
+}
+
+static void malidp_dump_all_hw_bufs(struct malidp_hw_device *hwdev,
+			struct malidp_hw_buffer *hw_bufs, int nbuf)
+{
+	int i;
+
+	for (i = 0; i < nbuf; i++)
+		malidp_dump_hw_buf(hwdev, &hw_bufs[i]);
+}
+
+bool malidp_hw_buf_support_srgb(struct malidp_hw_buffer *hw_buf)
+{
+	const struct malidp_layer_hw_info *layer = hw_buf->hw_layer;
+
+	if (layer->features & MALIDP_LAYER_FEATURE_SRGB)
+		return true;
+
+	return false;
+}
+
+static int malidp_hw_validate_srgb(struct malidp_hw_device *hwdev,
+	struct malidp_hw_buffer *hw_buf)
+{
+	if (!(hw_buf->flags & MALIDP_FLAG_SRGB))
+		return 0;
+
+	if (hw_buf->flags & MALIDP_FLAG_BUFFER_OUTPUT) {
+		dev_err(hwdev->device,
+			"%s: buffer is sRGB but it is output buffer.\n",
+			__func__);
+		return -EINVAL;
+	}
+
+	if (malidp_hw_buf_support_srgb(hw_buf) == false) {
+		dev_err(hwdev->device,
+			"%s: buffer is sRGB but layer doesn't support.\n",
+			__func__);
+		return -EINVAL;
+	}
+
+	if (hw_buf->flags & MALIDP_FLAG_FORCE_NO_IGAMMA) {
+		dev_err(hwdev->device,
+			"%s: buffer is sRGB but IG block is disabled.\n",
+			__func__);
+		return -EINVAL;
+	}
+
+	if (malidp_hw_format_is_yuv(hw_buf->fmt) == true) {
+		dev_err(hwdev->device,
+			"%s: buffer is sRGB but its format (%u) is not supported\n",
+			__func__, hw_buf->fmt);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static bool malidp_hw_check_buf_overlap(const struct malidp_hw_buffer *buf_a,
+					const struct malidp_hw_buffer *buf_b) {
+	u16 top_a    = buf_a->v_offset;
+	u16 bottom_a = buf_a->v_offset + buf_a->natural_h;
+	u16 left_a   = buf_a->h_offset;
+	u16 right_a  = buf_a->h_offset + buf_a->natural_w;
+	u16 top_b    = buf_b->v_offset;
+	u16 bottom_b = buf_b->v_offset + buf_b->natural_h;
+	u16 left_b   = buf_b->h_offset;
+	u16 right_b  = buf_b->h_offset + buf_b->natural_w;
+
+	if (min(bottom_a, bottom_b) > max(top_a, top_b) &&
+	    min(right_a, right_b) > max(left_a, left_b)) {
+		return true;
+	}
+
+	return false;
+}
+
+static int malidp_hw_validate_smart_layer(struct malidp_hw_device *hwdev,
+					  struct malidp_hw_state *state,
+					  struct malidp_hw_buffer *ls_buf)
+{
+	u32 i;
+	struct malidp_hw_buffer *hw_bufs = state->bufs;
+	struct malidp_hw_smart_layer_state *ls_state = &state->ls_state;
+	struct malidp_hw_buffer *buf = &hw_bufs[ls_state->ls_hw_buf_idx[0]];
+
+	/* Check the "same format and same alpha" restriction and
+	 * suppose same buffer flags
+	 */
+	if (ls_buf->fmt != buf->fmt ||
+	    ls_buf->layer_alpha != buf->layer_alpha ||
+	    ls_buf->alpha_mode != buf->alpha_mode ||
+	    ls_buf->flags != buf->flags) {
+		dev_err(hwdev->device, "%s : The smart layers have different format or alpha settings or flags\n",
+				__func__);
+		return -EINVAL;
+	}
+
+	/* Check the "no overlap" restriction */
+	for (i = 0; i < ls_buf->ls_rect_idx; i++) {
+		buf = &hw_bufs[ls_state->ls_hw_buf_idx[i]];
+		if (malidp_hw_check_buf_overlap(ls_buf, buf)) {
+			dev_err(hwdev->device, "%s : The smart layer overlapped with an existing smart layer\n",
+					__func__);
+			return -EINVAL;
+		}
+	}
+
+	/* Check the "First sort on x offset, and then on y offset" restriction */
+	i = ls_state->ls_hw_buf_idx[ls_buf->ls_rect_idx-1];
+	buf = &hw_bufs[i];
+	if (buf->h_offset > ls_buf->h_offset ||
+	    (buf->h_offset == ls_buf->h_offset &&
+	     buf->v_offset > ls_buf->v_offset)) {
+		dev_err(hwdev->device, "%s : The smart layer x/y offset sort check failed\n",
+					__func__);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static bool malidp_hw_is_active_rect_in_bbox(struct malidp_hw_smart_layer_state *ls_state,
+					     struct malidp_hw_buffer *ls_buf)
+{
+	u16 bbox_w = ls_state->ls_bbox_right - ls_state->ls_bbox_left;
+	u16 bbox_h = ls_state->ls_bbox_bottom - ls_state->ls_bbox_top;
+
+	if ((ls_buf->v_offset + ls_buf->natural_h) > bbox_h ||
+	    (ls_buf->h_offset + ls_buf->natural_w) > bbox_w) {
+		return false;
+	}
+
+	return true;
+}
+
+int malidp_hw_validate(struct malidp_hw_device *hwdev,
+		struct malidp_hw_state *state)
+{
+	struct drm_mode_modeinfo mode;
+	struct malidp_hw_buffer *de_buffer_to_mw = NULL;
+	struct malidp_hw_buffer *out_buffer = NULL;
+	int n_write_out_buffers = 0, n_scaling_on_mw = 0;
+	u32 n_hw_layers = hwdev->topology->n_layers;
+	u32 n_bufs_per_layer[4] = { 0 };
+	unsigned long flags;
+	u32 min_size = hwdev->ls_info->min_line_size;
+	u32 max_size = hwdev->ls_info->max_line_size;
+	u32 smart_layer_idx = 0;
+	int i, ret = -EINVAL;
+
+	struct malidp_hw_state_priv *hw_priv = &state.hw_priv;
+
+	for (i = 0; i < n_hw_layers; i++)
+		hw_priv->layer_flow[i] = MALIDP_DE_LAYER_FLOW_LOCAL;
+
+	malidp_dump_all_hw_bufs(hwdev, state->bufs, state->n_bufs);
+
+	for (i = 0; i < state->n_bufs; i++) {
+		struct malidp_hw_buffer *hw_buf = &state->bufs[i];
+
+		if (hw_buf->hw_layer &&
+		    hw_buf->hw_layer->type == MALIDP_HW_LAYER_SMART) {
+			struct malidp_hw_smart_layer_state *ls_state = &state->ls_state;
+
+			BUG_ON(smart_layer_idx != hw_buf->ls_rect_idx);
+			/* We don't need check the first smart layer */
+			if (smart_layer_idx > 0) {
+				if (malidp_hw_validate_smart_layer(hwdev, state, hw_buf)) {
+					dev_err(hwdev->device, "%s : smart layer validation failed\n",
+						__func__);
+					goto error;
+				}
+			}
+
+			if (ls_state->ls_bbox_from_user &&
+			    !(malidp_hw_is_active_rect_in_bbox(ls_state, hw_buf))) {
+				dev_err(hwdev->device, "%s : smart layer active rect %d is out of the bounding box\n",
+					__func__, smart_layer_idx);
+				goto error;
+			}
+
+			smart_layer_idx++;
+		}
+
+		if (malidp_hw_validate_srgb(hwdev, hw_buf) != 0)
+			goto error;
+
+		switch (hw_buf->n_planes) {
+		case 3:
+			/*
+			 * The hardware behaviour is as follows:
+			 * "For 3 planes the last bits of the cropping are
+			 * determined by LV2PTR[2:0] and LV1PTR[2:0]/LV3PTR[2:0]
+			 * are ignored."
+			 *
+			 * Compatibility with these constraints is enforced by
+			 * the following checks:
+			 * The plane 0 pointer must be even, as the hardware
+			 * will ignore the least significant bit.
+			 * The plane 2 pointer least-significant bits must match
+			 * the plane 1 pointer, as the hardware will ignore the
+			 * plane 2 value and use the plane 1 value directly
+			 */
+			if ((hw_buf->addr[0] & 0x1) ||
+			    ((hw_buf->addr[1] & 0x7) != (hw_buf->addr[2] & 0x7))) {
+				dev_err(hwdev->device, "%s : buffer %i does not meet alignment constraints\n",
+					__func__, i);
+				goto error;
+			}
+
+			/*
+			 * The 3rd stride will be ignored on some hardware,
+			 * so the 2nd and 3rd pitches of the buffer must be same.
+			 */
+			if ((hw_buf->pitch[2] != hw_buf->pitch[1]) &&
+			    (!hw_buf->hw_layer->p3_stride_offset)) {
+				dev_err(hwdev->device, "%s : the second and third strides are not same\n",
+					__func__);
+				goto error;
+			}
+			break;
+		case 2:
+			/*
+			 * The hardware behaviour is as follows:
+			 * "For 2 plane the last bits of the cropping are
+			 *  determined by bits [2:0] of the LV1PTR register and
+			 *  the [2:0] bits in LV2PTR are ignored."
+			 *
+			 * Compatibility with these constraints is enforced by
+			 * the following checks:
+			 * The plane 0 pointer must be even, as the hardware
+			 * will ignore the least significant bit.
+			 * The plane 1 pointer least-significant bits must match
+			 * the plane 0 pointer, as the hardware will ignore the
+			 * plane 1 value and use the plane 0 value directly
+			 */
+			if ((hw_buf->addr[0] & 0x1) ||
+			    ((hw_buf->addr[0] & 0x7) != (hw_buf->addr[1] & 0x7))) {
+				dev_err(hwdev->device, "%s : buffer %i does not meet alignment constraints\n",
+					__func__, i);
+				goto error;
+			}
+			break;
+		case 1:
+			/* AFBC buffers have to be 128-bit aligned */
+			if ((hw_buf->flags & MALIDP_FLAG_AFBC) &&
+				(hw_buf->addr[0] & MALIDP_AFBC_ALIGN_MASK)) {
+				dev_err(hwdev->device, "%s : AFBC buffers must be aligned to %u bytes (including offset)\n",
+					__func__, MALIDP_AFBC_ALIGN_MASK + 1);
+				goto error;
+			}
+			break;
+		default:
+			/* Nothing to do */
+			break;
+		}
+
+		if ((hw_buf->cmp_rect.src_w < min_size) || (hw_buf->cmp_rect.src_h < min_size) ||
+		    (hw_buf->cmp_rect.dest_w < min_size) || (hw_buf->cmp_rect.dest_h < min_size)) {
+			dev_err(hwdev->device, "%s : buffer dimensions too small. src: %ix%i, dest: %ix%i\n", __func__,
+				hw_buf->cmp_rect.src_w, hw_buf->cmp_rect.src_h,
+				hw_buf->cmp_rect.dest_w, hw_buf->cmp_rect.dest_h);
+			goto error;
+		}
+
+		if ((hw_buf->mw_rect.src_w < min_size) || (hw_buf->mw_rect.src_h < min_size) ||
+		    (hw_buf->mw_rect.dest_w < min_size) || (hw_buf->mw_rect.dest_h < min_size)) {
+			dev_err(hwdev->device, "%s : buffer dimensions too small. src: %ix%i, dest: %ix%i\n", __func__,
+				hw_buf->mw_rect.src_w, hw_buf->mw_rect.src_h,
+				hw_buf->mw_rect.dest_w, hw_buf->mw_rect.dest_h);
+			goto error;
+		}
+
+		if ((hw_buf->cmp_rect.src_w > max_size) || (hw_buf->cmp_rect.src_h > max_size) ||
+		    (hw_buf->cmp_rect.dest_w > max_size) || (hw_buf->cmp_rect.dest_h > max_size)) {
+			dev_err(hwdev->device, "%s : buffer dimensions too big. src: %ix%i, dest: %ix%i\n", __func__,
+				hw_buf->cmp_rect.src_w, hw_buf->cmp_rect.src_h,
+				hw_buf->cmp_rect.dest_w, hw_buf->cmp_rect.dest_h);
+			goto error;
+		}
+
+		if ((hw_buf->mw_rect.src_w > max_size) || (hw_buf->mw_rect.src_h > max_size) ||
+		    (hw_buf->mw_rect.dest_w > max_size) || (hw_buf->mw_rect.dest_h > max_size)) {
+			dev_err(hwdev->device, "%s : buffer dimensions too big. src: %ix%i, dest: %ix%i\n", __func__,
+				hw_buf->mw_rect.src_w, hw_buf->mw_rect.src_h,
+				hw_buf->mw_rect.dest_w, hw_buf->mw_rect.dest_h);
+			goto error;
+		}
+
+		if ((hw_buf->alpha_mode & MALIDP_ALPHA_MODE_PREMULT) &&
+		    !(hw_buf->alpha_mode & MALIDP_ALPHA_MODE_PIXEL)) {
+			dev_err(hwdev->device, "hwbuf(%d) pre-multiplied alpha "
+				"only supported with pixel alpha blending\n", i);
+			goto error;
+		}
+
+		if ((hw_buf->alpha_mode & MALIDP_ALPHA_MODE_PIXEL) &&
+		    !malidp_hw_format_has_alpha(hw_buf->fmt)) {
+			dev_err(hwdev->device, "hwbuf(%d) alpha pixel mode set "
+				"for a pixel format without alpha\n", i);
+			goto error;
+		}
+
+		if (malidp_hw_buffer_set_hw_fmt(hwdev, hw_buf)) {
+			dev_err(hwdev->device,
+				"Couldn't get HW pixel format for buffer %i\n",
+				i);
+			goto error;
+		} else {
+			dev_dbg(hwdev->device, "Set buffer %i hw_fmt: 0x%08x -> 0x%x\n",
+				i, hw_buf->fmt, hw_buf->hw_fmt);
+		}
+
+		if (hw_buf->flags & MALIDP_FLAG_BUFFER_OUTPUT) {
+			if (out_buffer != NULL) {
+				dev_err(hwdev->device, "found more than one output buffer\n");
+				goto error;
+			}
+			out_buffer = &state->bufs[i];
+
+			/* The output buffer cannot be transformed */
+			if (out_buffer->requirements & MALIDP_LAYER_FEATURE_TRANSFORM) {
+				dev_err(hwdev->device, "output buffer cannot be transformed");
+				goto error;
+			}
+
+			/* The output buffer cannot AFBC */
+			if (out_buffer->requirements & MALIDP_LAYER_FEATURE_AFBC) {
+				dev_err(hwdev->device, "output buffer cannot be compressed");
+				goto error;
+			}
+
+			/* cmp_scaling_enable of output buffer should not be 'true' */
+			if (out_buffer->cmp_scaling_enable == true) {
+				dev_err(hwdev->device, "output buffer should not have cmp_scaling_enable set");
+				goto error;
+			}
+		} else {
+			if ((hw_buf->requirements & hw_buf->hw_layer->features) !=
+			    hw_buf->requirements) {
+				dev_err(hwdev->device,
+					"%s: buffer requirements %08x not compatible with layer features %08x\n",
+					__func__, hw_buf->requirements, hw_buf->hw_layer->features);
+				goto error;
+			}
+			if (hw_buf->write_out_enable) {
+				n_write_out_buffers++;
+				de_buffer_to_mw = &state->bufs[i];
+			}
+		}
+
+		if (hw_buf->cmp_scaling_enable) {
+
+			if (hw_buf->mw_scaling_enable == false) {
+				dev_err(hwdev->device, "Input buffer cannot be scaled to composition and not be scaled to MW interface");
+				goto error;
+			} else if (((hw_buf->cmp_rect.dest_w != hw_buf->mw_rect.dest_w) ||
+							(hw_buf->cmp_rect.dest_h != hw_buf->mw_rect.dest_h)) && hw_buf->mw_scaling_enable == true) {
+				dev_err(hwdev->device, "Input buffer cannot be scaled different to composition and MW interface");
+				goto error;
+			}
+
+			if (hw_priv->s0.scaling_enable == true) {
+				dev_err(hwdev->device, "%s: more than 1 input layer to be scaled is not support", __func__);
+				goto error;
+			}
+
+			hw_priv->layer_flow[hw_buf->hw_layer->index] = MALIDP_DE_LAYER_FLOW_SCALE_SE0;
+			hw_priv->s0.scaling_enable = true;
+			hw_priv->s0.input_h = hw_buf->cmp_rect.src_h;
+			hw_priv->s0.input_w = hw_buf->cmp_rect.src_w;
+			hw_priv->s0.output_h = hw_buf->cmp_rect.dest_h;
+			hw_priv->s0.output_w = hw_buf->cmp_rect.dest_w;
+			hw_priv->s0.rgbo_enable = true;
+			hw_priv->s0.scale_alpha = malidp_hw_format_has_alpha(hw_buf->fmt);
+		} else if (!(hw_buf->flags & MALIDP_FLAG_BUFFER_OUTPUT) && hw_buf->mw_scaling_enable) {
+			dev_dbg(hwdev->device, "MW Scaling is detected\n");
+
+			hw_priv->layer_flow[hw_buf->hw_layer->index] = MALIDP_DE_LAYER_FLOW_SIMULT_SE0;
+			hw_priv->s0.input_h = hw_buf->mw_rect.src_h;
+			hw_priv->s0.input_w = hw_buf->mw_rect.src_w;
+			hw_priv->s0.output_h = hw_buf->mw_rect.dest_h;
+			hw_priv->s0.output_w = hw_buf->mw_rect.dest_w;
+			hw_priv->s0.scale_alpha = malidp_hw_format_has_alpha(hw_buf->fmt);
+			hw_priv->s0.rgbo_enable = false;
+			hw_priv->s0.scaling_enable = true;
+			n_scaling_on_mw++;
+		}
+
+		if (hw_buf->hw_layer) {
+			if (n_bufs_per_layer[hw_buf->hw_layer->index] >=
+					hw_buf->hw_layer->n_supported_layers) {
+				dev_err(hwdev->device, "%s: more than max %d buffers for layer %i\n",
+					__func__, hw_buf->hw_layer->n_supported_layers,
+					hw_buf->hw_layer->index);
+				goto error;
+			}
+			n_bufs_per_layer[hw_buf->hw_layer->index]++;
+		}
+
+	}
+
+	/* If all input layers are scaled to mw, then just scale composition */
+	if ((n_scaling_on_mw == state->n_bufs -1) && (out_buffer != NULL && out_buffer->mw_scaling_enable == true)) {
+		/* Disable it, then scaler will be configured to scale composition */
+		hw_priv->s0.scaling_enable = false;
+		/* All the layers will not be sent to SE */
+		for (i = 0; i < n_hw_layers; i++)
+			hw_priv->layer_flow[i] = MALIDP_DE_LAYER_FLOW_LOCAL;
+	} else if (n_scaling_on_mw > 0 && out_buffer == NULL) {
+		dev_err(hwdev->device, "%s: Output buffer is not found", __func__);
+		goto error;
+	} else if (n_scaling_on_mw >= 2) {
+		dev_err(hwdev->device, "%s: More than one but not all layers are scaled to memory", __func__);
+		goto error;
+	}
+
+	/*
+	 * Validate that the scene uses rotation memory appropriately
+	 */
+	if (!malidp_hw_validate_rotmem(hwdev, state))
+		goto error;
+
+	/* Find flow for memory write-out, set scaler configuration for scaling composition to mw */
+	hw_priv->cmp_flow = MALIDP_DE_CMP_FLOW_INTERNAL;
+	if ((n_write_out_buffers == 0) && (!out_buffer)) {
+		/* Do not use the memory write-out interface */
+		hw_priv->mw.mode = MALIDP_SE_MW_DISABLE;
+		hw_priv->mw.buf = NULL;
+	} else if ((n_write_out_buffers == (state->n_bufs - 1)) &&
+		    out_buffer && out_buffer->write_out_enable) {
+		/* Write out the result of the composition.*/
+		spin_lock_irqsave(&hwdev->hw_lock, flags);
+		malidp_de_modeget(hwdev->de_dev, &mode);
+		spin_unlock_irqrestore(&hwdev->hw_lock, flags);
+
+		if ((out_buffer->mw_rect.src_w != mode.hdisplay) ||
+				(out_buffer->mw_rect.src_h != mode.vdisplay)) {
+			dev_err(hwdev->device, "output buffer src size did not match the mode");
+			goto error;
+		}
+		/* check whether output buffer need be scaled */
+		if (out_buffer->mw_scaling_enable == true) {
+			if (hw_priv->s0.scaling_enable == true) {
+				dev_err(hwdev->device, "no scaler for MW");
+				goto error;
+			}
+			hw_priv->mw.mode = MALIDP_SE_MW_L0;
+
+			/* Scale the composition to memory */
+			hw_priv->s0.input_h = out_buffer->mw_rect.src_h;
+			hw_priv->s0.input_w = out_buffer->mw_rect.src_w;
+			hw_priv->s0.output_h = out_buffer->mw_rect.dest_h;
+			hw_priv->s0.output_w = out_buffer->mw_rect.dest_w;
+			hw_priv->s0.scale_alpha = malidp_hw_format_has_alpha(out_buffer->fmt);
+			hw_priv->s0.rgbo_enable = false;
+			hw_priv->s0.scaling_enable = true;
+		} else {
+			hw_priv->mw.mode = (hw_priv->s0.scaling_enable == true) ? MALIDP_SE_MW_L1 : MALIDP_SE_MW_L0;
+
+			/* for L1, no alpha compoment */
+			if (hw_priv->mw.mode == MALIDP_SE_MW_L1 && malidp_hw_format_has_alpha(out_buffer->fmt)) {
+				dev_err(hwdev->device,
+					"hwbuf(%d) alpha not supported when writing-out "
+					"the result of the composition\n", i);
+				goto error;
+			}
+		}
+
+		hw_priv->mw.buf = out_buffer;
+		hw_priv->cmp_flow = MALIDP_DE_CMP_FLOW_SE0;
+	} else if ((n_write_out_buffers == 1) && out_buffer &&
+		    !out_buffer->write_out_enable) {
+		/* Write out the layer indicated by "de_buffer_to_mw" */
+
+		if (!(de_buffer_to_mw->hw_layer->features & MALIDP_LAYER_FEATURE_SCALING)) {
+			dev_err(hwdev->device, "writing layer %s to memory is not supported",
+				de_buffer_to_mw->hw_layer->name);
+			goto error;
+		}
+
+		hw_priv->mw.mode = MALIDP_SE_MW_L0;
+		hw_priv->mw.buf = out_buffer;
+		/* if the layer will be scaled, the size of cmp_rect.dest, should be same as the size of output */
+		if (de_buffer_to_mw->cmp_scaling_enable) {
+			if ((de_buffer_to_mw->cmp_rect.dest_w != out_buffer->mw_rect.dest_w) ||
+				(de_buffer_to_mw->cmp_rect.dest_h != out_buffer->mw_rect.dest_h)) {
+				dev_err(hwdev->device, "scaled input buffer size does not match output size");
+				goto error;
+			}
+		}
+
+		if (hw_priv->layer_flow[de_buffer_to_mw->hw_layer->index] == MALIDP_DE_LAYER_FLOW_LOCAL) {
+			hw_priv->layer_flow[de_buffer_to_mw->hw_layer->index] = MALIDP_DE_LAYER_FLOW_SIMULT_SE0;
+		}
+
+	} else {
+		/* Error condition */
+		dev_err(hwdev->device, "couldn't determine memory write-out configuration");
+		goto error;
+	}
+
+	if (!limitation_check(hwdev, hw_priv))
+		goto error;
+
+	malidp_se_set_scaling_dependent_state(hwdev->se_dev, &hw_priv->s0);
+	state->hw_priv = hw_priv;
+	kfree(n_bufs_per_layer);
+
+	return 0;
+
+error:
+	kfree(n_bufs_per_layer);
+	kfree(hw_priv);
+
+	return ret;
+};
+
+void malidp_hw_state_free(struct malidp_hw_device *hwdev,
+		struct malidp_hw_state *state)
+{
+	kfree(state->hw_priv);
+};
+
+int malidp_hw_commit(struct malidp_hw_device *hwdev,
+		struct malidp_hw_state *state)
+{
+	int i, res = 0;
+	unsigned long flags;
+	struct malidp_hw_state_priv *hw_priv = state->hw_priv;
+
+	spin_lock_irqsave(&hwdev->hw_lock, flags);
+
+	dev_dbg(hwdev->device, "%s: start\n", __func__);
+
+	malidp_hw_commit_scene_atomic(hwdev, false);
+
+	malidp_de_disable_all_layers(hwdev->de_dev);
+
+	for (i = 0; i < state->n_bufs; i++) {
+		struct malidp_hw_buffer *hw_buf = &state->bufs[i];
+
+		if (!(hw_buf->flags & MALIDP_FLAG_BUFFER_OUTPUT)) {
+			res = malidp_de_cfg_layer(hwdev->de_dev, hw_buf);
+			if (res)
+				dev_err(hwdev->device, "%s : cfg layer returned %i",
+						__func__, res);
+		}
+	}
+
+	if (state->ls_state.ls_hw_layer) {
+		dev_dbg(hwdev->device, "%s, smart layer state: bounding box (%d, %d, %d, %d), active smart layers (%d)\n",
+			__func__,
+			state->ls_state.ls_bbox_top,
+			state->ls_state.ls_bbox_left,
+			state->ls_state.ls_bbox_bottom,
+			state->ls_state.ls_bbox_right,
+			state->ls_state.n_smart_layers);
+		malidp_de_cfg_smart_state(hwdev->de_dev, &state->ls_state);
+	}
+
+	/* Set flows for the different layers and composition result */
+	malidp_de_cfg_cmp_flow(hwdev->de_dev, hw_priv->cmp_flow);
+	for (i = 0; i < hwdev->topology->n_layers; i++) {
+		malidp_de_cfg_layer_flow(hwdev->de_dev,
+				 &hwdev->topology->layers[i],
+				 hw_priv->layer_flow[i]);
+	}
+
+	malidp_se_cfg_processing(hwdev->se_dev, &hw_priv->mw, &hw_priv->s0);
+
+	malidp_hw_commit_scene_atomic(hwdev, true);
+
+	dev_dbg(hwdev->device, "%s: end\n", __func__);
+
+	spin_unlock_irqrestore(&hwdev->hw_lock, flags);
+	return res;
+}
+
+static void malidp_hw_pdata_dump(struct platform_device *pdev,
+				struct malidp_hw_pdata *pdata)
+{
+	dev_dbg(&pdev->dev, "%s:\n", __func__);
+	dev_dbg(&pdev->dev, "pxclk: %p, mclk: %p, aclk: %p, pclk: %p\n",
+		pdata->pxclk, pdata->mclk, pdata->aclk, pdata->pclk);
+	dev_dbg(&pdev->dev, "de axi burst length = %d\n", pdata->de_axi_burstlen);
+	dev_dbg(&pdev->dev, "de axi outstanding transactions = %d\n",
+		pdata->de_axi_outstran);
+	dev_dbg(&pdev->dev, "de axi arqos threshold low = 0x%X\n",
+		pdata->de_axi_arqos_low);
+	dev_dbg(&pdev->dev, "de axi arqos threshold high = 0x%X\n",
+		pdata->de_axi_arqos_high);
+	dev_dbg(&pdev->dev, "de axi arqos red = 0x%X\n",
+		pdata->de_axi_arqos_red);
+	dev_dbg(&pdev->dev, "de axi arqos green = 0x%X\n",
+		pdata->de_axi_arqos_green);
+	dev_dbg(&pdev->dev, "se axi burst length = %d\n", pdata->se_axi_burstlen);
+	dev_dbg(&pdev->dev, "se axi outstanding transactions = %d\n",
+		pdata->se_axi_outstran);
+	dev_dbg(&pdev->dev, "se axi awcache  %d\n", pdata->se_axi_awcache);
+	dev_dbg(&pdev->dev, "se axi qos = %d\n", pdata->se_axi_awqos);
+	dev_dbg(&pdev->dev, "rotmem size = %d\n", pdata->rotmem_size);
+}
+
+/* Populate pdata structure using device tree description */
+int malidp_hw_get_resources(struct malidp_hw_pdata *pdata)
+{
+	/*
+	 * Optional, non-standard properties are retrieved parsing
+	 * the device-tree description directly. If we wanted to add support
+	 * for initializing using board files we would need to use a custom
+	 * pdata structure in <linux/platform_data/malidp.h>.
+	 */
+	pdata->de_axi_burstlen = DE_DEFAULT_AXI_BURSTLEN;
+
+	pdata->de_axi_poutstdcab = DE_DEFAULT_AXI_POUTSTDCAB;
+
+	pdata->de_axi_outstran = DE_DEFAULT_AXI_OUTSTRAN;
+
+	pdata->de_axi_arqos_low = DE_DEFAULT_AXI_ARQOS_LOW;
+
+	pdata->de_axi_arqos_high = DE_DEFAULT_AXI_ARQOS_HIGH;
+
+	pdata->de_axi_arqos_red = DE_DEFAULT_AXI_ARQOS_RED;
+
+	pdata->de_axi_arqos_green = DE_DEFAULT_AXI_ARQOS_GREEN;
+
+	pdata->se_axi_burstlen = SE_DEFAULT_AXI_BURSTLEN;
+
+	pdata->se_axi_outstran = SE_DEFAULT_AXI_OUTSTRAN;
+
+	pdata->se_axi_awcache = SE_DEFAULT_AXI_AWCACHE;
+
+	pdata->se_axi_awqos = SE_DEFAULT_AXI_AWQOS;
+
+	pdata->rotmem_size = MALIDP_DEFAULT_ROTMEM_SIZE;
+
+
+	return 0;
+}
+
+static void malidp_hw_enable_clocks(struct malidp_hw_device *hwdev)
+{
+}
+
+static void malidp_hw_disable_clocks(struct malidp_hw_device *hwdev)
+{
+}
+
+/* Must be called with the power_mutex held */
+static enum malidp_op_mode malidp_hw_change_op_mode(struct malidp_hw_device *hwdev,
+		enum malidp_op_mode mode)
+{
+	enum malidp_op_mode old_mode_de;
+
+	BUG_ON(mode == MALIDP_OP_MODE_UNKNOWN);
+
+	/* We're protected by the power mutex, so just read the mode */
+	old_mode_de = malidp_de_get_op_mode(hwdev->de_dev);
+	if (old_mode_de == mode)
+		return old_mode_de;
+
+	old_mode_de = hwdev->dp_api->change_op_mode(hwdev, mode);
+
+	return old_mode_de;
+}
+
+void malidp_hw_cfg_de_disable_mw_flows_atomic(struct malidp_hw_device *hwdev)
+{
+	enum malidp_de_flow_layer_cfg layer_flow;
+	int i;
+
+	for (i = 0; i < hwdev->topology->n_layers; i++) {
+		layer_flow = malidp_de_get_layer_flow(hwdev->de_dev,
+				&hwdev->topology->layers[i]);
+
+		if (layer_flow == MALIDP_DE_LAYER_FLOW_SIMULT_SE0)
+			malidp_de_cfg_layer_flow(hwdev->de_dev,
+					&hwdev->topology->layers[i],
+					MALIDP_DE_LAYER_FLOW_LOCAL);
+	}
+
+	malidp_de_cfg_cmp_flow(hwdev->de_dev, MALIDP_DE_CMP_FLOW_INTERNAL);
+}
+
+static void malidp_hw_update_downscaling_threshold(
+	struct malidp_hw_device *hwdev,
+	struct drm_mode_modeinfo *mode)
+{
+	u32 pxlclk;
+	u32 mclk;
+
+	mclk = clk_get_rate(hwdev->mclk) / 1000;
+	pxlclk = clk_get_rate(hwdev->pxclk) / 1000;
+
+	hwdev->downscaling_threshold =
+			hwdev->dp_api->se_api.calc_downscaling_threshold(mclk,
+					pxlclk, mode);
+}
+
+int malidp_hw_modeset(struct malidp_hw_device *dev, struct drm_mode_modeinfo *mode)
+{
+	struct malidp_se_mw_conf mw_conf;
+	enum malidp_op_mode old_mode;
+	unsigned long flags;
+	long rate = mode->clock * 1000;
+	int ret = 0;
+
+	mutex_lock(&dev->power_mutex);
+
+	old_mode = malidp_de_get_op_mode(dev->de_dev);
+	/* Skip the call if the hardware is suspended */
+	if (old_mode == MALIDP_OP_MODE_POWERSAVE) {
+		goto unlock;
+	}
+
+	old_mode = malidp_hw_change_op_mode(dev, MALIDP_OP_MODE_CONFIG);
+
+	ret = malidp_hw_set_mclk(dev, rate);
+	if (ret < 0)
+		goto exit;
+	dev->clock_ratio = malidp_hw_clock_ratio_get(dev);
+	dev_dbg(dev->device, "%s: New clock ratio: 0x%04x.%04x\n", __func__,
+		(dev->clock_ratio & 0xFFFF0000) >> 16,
+		dev->clock_ratio & 0xFFFF);
+
+	/* Ratio must be >= 1 */
+	if (dev->clock_ratio < (1 << 16)) {
+		dev_dbg(dev->device, "%s: mclk rate must exceed pxclk rate\n",
+			__func__);
+		ret = -ERANGE;
+		goto exit;
+	}
+
+	spin_lock_irqsave(&dev->hw_lock, flags);
+	/*
+	 * Modeset disables all the layers and memory interface in the system
+	 * to avoid displaying an old configuration that doesn't match the same
+	 * resultion.
+	 */
+	mw_conf.mode = MALIDP_SE_MW_DISABLE;
+	malidp_se_cfg_processing(dev->se_dev, &mw_conf, NULL);
+	ret = malidp_de_modeset(dev->de_dev, mode);
+	if (ret == 0)
+		malidp_hw_update_downscaling_threshold(dev, mode);
+	spin_unlock_irqrestore(&dev->hw_lock, flags);
+
+exit:
+	malidp_hw_change_op_mode(dev, old_mode);
+unlock:
+	mutex_unlock(&dev->power_mutex);
+
+	return ret;
+}
+
+int malidp_hw_set_callback(struct malidp_hw_device *dev,
+		const struct malidp_intf_hw_info *hw_intf,
+		void (*callback)(struct device *, void *, struct malidp_hw_event_queue *),
+		void *opaque)
+{
+	unsigned long flags;
+	int ret = 0;
+
+	spin_lock_irqsave(&dev->hw_lock, flags);
+	if (hw_intf->type == MALIDP_HW_INTF_PRIMARY)
+		malidp_de_set_flip_callback(dev->de_dev, callback, opaque);
+	else if (MALIDP_HW_INTF_MEMORY)
+		malidp_se_set_flip_callback(dev->se_dev, callback, opaque);
+	else
+		ret = -EINVAL;
+	spin_unlock_irqrestore(&dev->hw_lock, flags);
+
+	return ret;
+}
+
+inline u32 malidp_hw_get_core_id(struct malidp_hw_device *hwdev)
+{
+	BUG_ON(!hwdev->core_id);
+	return hwdev->core_id;
+}
+
+static inline u32 malidp_hw_identify(struct malidp_hw_device *hwdev)
+{
+	u32 product_id = hwdev->topology->product_id;
+	u32 core_id;
+
+	/*
+	 * If the old register identifies as DP500, then we can be sure that
+	 * the *hardware* is DP500 (this requires that bits [27:24] of register
+	 * MALIDP_REG_DP500_CORE_ID are reserved for all other hardware
+	 * versions).
+	 */
+	core_id = malidp_hw_read(hwdev, MALIDP_REG_DP500_CORE_ID);
+	switch (MALIDP_CORE_ID_PRODUCT_ID(core_id)) {
+	case MALIDP_DP500_PRODUCT_ID:
+		if (product_id == MALIDP_DP500_PRODUCT_ID)
+			return core_id;
+		else
+			goto mismatch;
+	default:
+		if (product_id == MALIDP_DP500_PRODUCT_ID)
+			goto mismatch;
+	}
+
+	/* For all other hardware version, use MALIDP_REG_CORE_ID */
+	core_id = malidp_hw_read(hwdev, MALIDP_REG_CORE_ID);
+	if (MALIDP_CORE_ID_PRODUCT_ID(core_id) == product_id)
+		return core_id;
+
+mismatch:
+	dev_err(hwdev->device, "%s : device-tree expected hwver 0x%X but register suggested 0x%X\n",
+		__func__, product_id, MALIDP_CORE_ID_PRODUCT_ID(core_id));
+
+	return 0;
+}
+
+struct malidp_hw_device *malidp_hw_init(struct malidp_hw_device *hwdev,
+			       struct malidp_hw_description *hw_desc)
+{
+	hwdev->device = &pdev->dev;
+	hwdev->pclk = hw_desc->pdata->pclk;
+	hwdev->mclk = hw_desc->pdata->mclk;
+	hwdev->pxclk = hw_desc->pdata->pxclk;
+	hwdev->aclk = hw_desc->pdata->aclk;
+	hwdev->regs = hw_desc->pdata->regs;
+	hwdev->topology = hw_desc->topology;
+	hwdev->partition_type = hw_desc->config->partition_type;
+	hwdev->clock_ratio = 0x10000;
+	hwdev->dp_api = hw_desc->topology->dp_api;
+	hwdev->hw_regmap = hw_desc->topology->regmap;
+
+	/* We need the APB clock for register accesses */
+	//clk_prepare_enable(hwdev->pclk);
+
+	hwdev->core_id = malidp_hw_identify(hwdev);
+	if (!hwdev->core_id) {
+		dev_err(hwdev->device, "%s : couldn't determine hardware version\n",
+			__func__);
+		goto fail_clk;
+	}
+	dev_info(hwdev->device, "Probed product ID: 0x%04x",
+		 MALIDP_CORE_ID_PRODUCT_ID(hwdev->core_id));
+	dev_info(hwdev->device, "  Major: %d, minor: %d, status: %d\n",
+		 MALIDP_CORE_ID_MAJOR(hwdev->core_id),
+		 MALIDP_CORE_ID_MINOR(hwdev->core_id),
+		 MALIDP_CORE_ID_STATUS(hwdev->core_id));
+
+	hwdev->ls_info = malidp_hw_get_ls_info(hwdev, hw_desc);
+	if (!hwdev->ls_info) {
+		dev_err(hwdev->device, "%s : couldn't determine linesize config\n",
+			__func__);
+		goto fail_clk;
+	}
+
+	/* Look for rotmem in order of priority: platform then HW config */
+	if (hw_desc->pdata->rotmem_size)
+		hwdev->rotmem_size = hw_desc->pdata->rotmem_size;
+	else
+		hwdev->rotmem_size = hwdev->ls_info->default_rotmem_size;
+
+	hwdev->dp_api->disable_irq(hwdev);
+
+	/* Set up the SE device structure */
+	hwdev->se_dev = malidp_se_hw_init(hwdev, pdev,
+			hw_desc->pdata, &hwdev->hw_lock);
+	if (!hwdev->se_dev)
+		goto fail_clk;
+
+	/* Set up the DE device structure */
+	hwdev->de_dev = malidp_de_hw_init(hwdev, pdev,
+			hw_desc->pdata, &hwdev->hw_lock);
+	if (!hwdev->de_dev)
+		goto fail_clk;
+
+	/* Enter config mode and do configuration reset */
+	malidp_hw_runtime_resume(hwdev);
+
+	/* Enter lowpower mode */
+	malidp_hw_runtime_suspend(hwdev);
+	/*
+	 * Drop our reference on the APB clock.
+	 */
+	//clk_disable_unprepare(hwdev->pclk);
+
+	dev_dbg(&pdev->dev, "%s: success\n", __func__);
+
+	return hwdev;
+
+fail_clk:
+	clk_disable_unprepare(hwdev->pclk);
+	return ERR_PTR(-ENODEV);
+}
+
+#if 0
+void malidp_hw_exit(struct malidp_hw_device *hwdev)
+{
+	/* We need the APB clock for register accesses */
+	clk_prepare_enable(hwdev->pclk);
+
+	malidp_hw_change_op_mode(hwdev, MALIDP_OP_MODE_CONFIG);
+
+	hwdev->dp_api->disable_irq(hwdev);
+
+	malidp_se_hw_exit(hwdev->se_dev);
+	malidp_de_hw_exit(hwdev->de_dev);
+
+	malidp_hw_change_op_mode(hwdev, MALIDP_OP_MODE_POWERSAVE);
+
+	clk_disable_unprepare(hwdev->pclk);
+}
+#endif
+
+u32 malidp_hw_rotmem_size_get(struct malidp_hw_device *hwdev)
+{
+	return hwdev->rotmem_size;
+}
+
+u32 malidp_hw_get_fifo_size(struct malidp_hw_device *hwdev)
+{
+	return hwdev->ls_info->input_fifo_size;
+}
+
+void malidp_hw_supported_dimensions_get(struct malidp_hw_device *hwdev,
+					u32 *min_width, u32 *min_height,
+					u32 *max_width, u32 *max_height)
+{
+	if (min_width)
+		*min_width = hwdev->ls_info->min_line_size;
+	if (min_height)
+		*min_height = hwdev->ls_info->min_line_size;
+	if (max_width)
+		*max_width = hwdev->ls_info->max_line_size;
+	if (max_height)
+		*max_height = hwdev->ls_info->max_line_size;
+}
+
+u32 malidp_hw_clock_ratio_get(struct malidp_hw_device *hwdev)
+{
+	u64 current_mclk;
+	u32 clock_r;
+
+	if (hwdev->mclk == hwdev->pxclk)
+		return 1 << 16;
+
+	current_mclk = clk_get_rate(hwdev->mclk) / 1000;
+	clock_r = clk_get_rate(hwdev->pxclk) / 1000;
+
+	current_mclk <<= 16;
+	do_div(current_mclk, clock_r);
+	clock_r = current_mclk;
+	return clock_r;
+}
+
+int malidp_hw_clock_ratio_set(struct malidp_hw_device *hwdev,
+		u32 new_clock_ratio)
+{
+	unsigned long flags;
+
+	if (new_clock_ratio < 0x10000) {
+		dev_err(hwdev->device, "clock ratio is less than 1.");
+		return -EINVAL;
+	}
+
+	if ((hwdev->mclk == hwdev->pxclk) && new_clock_ratio != 0x10000) {
+		dev_err(hwdev->device, "mclk and pxclk are shared. Ratio must be 1.\n");
+		return -EINVAL;
+	}
+
+	spin_lock_irqsave(&hwdev->hw_lock, flags);
+	hwdev->clock_ratio = new_clock_ratio;
+	spin_unlock_irqrestore(&hwdev->hw_lock, flags);
+	return 0;
+}
+
+int malidp_hw_set_mclk(struct malidp_hw_device *hwdev, u32 pxclk)
+{
+	//TODO
+	u32 mclk;
+	u64 tmp64 = pxclk;
+
+	if (pxclk == 0)
+		return -EINVAL;
+
+	if (hwdev->pxclk == hwdev->mclk)
+		return 0;
+
+	tmp64 *= hwdev->clock_ratio;
+	tmp64 >>= 16;
+	mclk = tmp64;
+
+	/*
+	 * This can fail if mclk is fixed, but we will check the actual
+	 * rate later
+	 */
+	clk_set_rate(hwdev->mclk, mclk);
+
+	return 0;
+}
+
+enum malidp_hw_partition_type malidp_hw_rotmem_type_get(struct malidp_hw_device *hwdev)
+{
+	return hwdev->partition_type;
+}
+
+const struct malidp_hw_topology *malidp_hw_get_topology(struct malidp_hw_device *hwdev)
+{
+	return hwdev->topology;
+}
+
+int malidp_hw_get_attr(struct malidp_hw_device *hwdev, u32 attr, u32 *val)
+{
+	int ret;
+	unsigned long flags;
+
+	spin_lock_irqsave(&hwdev->hw_lock, flags);
+
+	switch (attr & (MALIDP_ATTR_FLAG_DE | MALIDP_ATTR_FLAG_SE)) {
+	case MALIDP_ATTR_FLAG_DE:
+		ret = malidp_de_get_attr(hwdev->de_dev, attr, val);
+		break;
+	case MALIDP_ATTR_FLAG_SE:
+		ret = malidp_se_get_attr(hwdev->se_dev, attr, val);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	spin_unlock_irqrestore(&hwdev->hw_lock, flags);
+
+	return ret;
+}
+
+static int malidp_hw_save_attr(struct malidp_hw_device *hwdev, u32 attr, u32 val)
+{
+	int ret;
+
+	switch (attr & (MALIDP_ATTR_FLAG_DE | MALIDP_ATTR_FLAG_SE)) {
+	case MALIDP_ATTR_FLAG_DE:
+		ret = malidp_de_save_attr(hwdev->de_dev, attr, val);
+		break;
+	case MALIDP_ATTR_FLAG_SE:
+		ret = malidp_se_save_attr(hwdev->se_dev, attr, val);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+int malidp_hw_set_attr(struct malidp_hw_device *hwdev, u32 attr, u32 val)
+{
+	int ret;
+	unsigned long flags;
+	enum malidp_op_mode de_mode;
+
+	mutex_lock(&hwdev->power_mutex);
+	de_mode = malidp_de_get_op_mode(hwdev->de_dev);
+
+	if (de_mode == MALIDP_OP_MODE_POWERSAVE) {
+		/*
+		 * If PM runtime is enabled, we just save the attributes
+		 * to device for PSM, they will be reset when the device
+		 * is resumed.
+		 */
+		ret = malidp_hw_save_attr(hwdev, attr, val);
+		goto exit;
+	}
+
+	if (de_mode == MALIDP_OP_MODE_NORMAL) {
+		if ((attr & MALIDP_ATTR_FLAG_CM)) {
+			dev_err(hwdev->device, "%s: can't set attr %u with display on\n", __func__, attr);
+			ret = -EBUSY;
+			goto exit;
+		}
+		/* If attr doesn't need CFM, then we don't need to change */
+	} else {
+		/*
+		 * We need to make sure we aren't in PSM so we can access
+		 * registers, even if the attr doesn't specifically need CFM.
+		 */
+		malidp_hw_change_op_mode(hwdev, MALIDP_OP_MODE_CONFIG);
+	}
+
+	spin_lock_irqsave(&hwdev->hw_lock, flags);
+
+	switch (attr & (MALIDP_ATTR_FLAG_DE | MALIDP_ATTR_FLAG_SE)) {
+	case MALIDP_ATTR_FLAG_DE:
+		ret = malidp_de_set_attr(hwdev->de_dev, attr, val);
+		break;
+	case MALIDP_ATTR_FLAG_SE:
+		ret = malidp_se_set_attr(hwdev->se_dev, attr, val);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	spin_unlock_irqrestore(&hwdev->hw_lock, flags);
+
+	malidp_hw_change_op_mode(hwdev, de_mode);
+
+exit:
+	mutex_unlock(&hwdev->power_mutex);
+	return ret;
+}
+
+/*
+ * Pass-through the gamma settings to DE dev
+ */
+void malidp_hw_update_gamma_settings(struct malidp_hw_device *hwdev,
+				     bool enable,
+				     u32 *coeffs)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&hwdev->hw_lock, flags);
+	malidp_de_update_gamma_settings(hwdev->de_dev, enable, coeffs);
+	spin_unlock_irqrestore(&hwdev->hw_lock, flags);
+}
+
+void malidp_hw_set_de_output_depth(struct malidp_hw_device *hwdev, u8 red,
+		u8 green, u8 blue)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&hwdev->hw_lock, flags);
+	malidp_de_store_output_depth(hwdev->de_dev, red, green, blue);
+	spin_unlock_irqrestore(&hwdev->hw_lock, flags);
+}
+
+/*
+ * The xy CIE coordinates should be in 10bits representing values
+ * from 0 to 1023/1024 as reported by the EDID standard.
+ */
+int malidp_hw_update_color_adjustment(struct malidp_hw_device *hwdev,
+	u16 red_x, u16 red_y, u16 green_x, u16 green_y,
+	u16 blue_x, u16 blue_y, u16 white_x, u16 white_y)
+{
+	return malidp_de_update_cadj_coeffs(hwdev->de_dev, red_x, red_y,
+		green_x, green_y, blue_x, blue_y, white_x, white_y);
+}
+
+u32 malidp_hw_downscaling_threshold(struct malidp_hw_device *hwdev)
+{
+	return hwdev->downscaling_threshold;
+}
+
+static int malidp_hw_dbg_dump_clock(struct seq_file *dump_file,
+		void *x)
+{
+	struct malidp_hw_device *hwdev = dump_file->private;
+
+	return seq_printf(dump_file, "mclk=%luHz pxclk=%luHz\n",
+				clk_get_rate(hwdev->mclk),
+				clk_get_rate(hwdev->pxclk));
+}
+
+static int malidp_hw_dbg_open(struct inode *inode, struct file *pfile)
+{
+	return single_open(pfile, malidp_hw_dbg_dump_clock,
+			inode->i_private);
+}
+
+static const struct file_operations f_ops_clock = {
+	.owner = THIS_MODULE,
+	.open = malidp_hw_dbg_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+};
+
+int malidp_hw_debugfs_init(struct malidp_hw_device *hwdev,
+	struct dentry *parent)
+{
+	struct dentry *dbg_file;
+
+	if (hwdev->dbg_folder != NULL)
+		return 0;
+
+	hwdev->dbg_folder = debugfs_create_dir("hardware", parent);
+	if (hwdev->dbg_folder == NULL)
+		return -EINVAL;
+
+	malidp_de_debugfs_init(hwdev->de_dev, hwdev->dbg_folder);
+
+	dbg_file = debugfs_create_file("clock", S_IROTH,
+			hwdev->dbg_folder, hwdev, &f_ops_clock);
+	if (dbg_file == NULL)
+		dev_err(hwdev->device, "debugfs clock is created error!\n");
+
+	dbg_file = debugfs_create_u32("rotmem", S_IRUSR | S_IWUSR,
+			hwdev->dbg_folder, &hwdev->rotmem_size);
+	if (dbg_file == NULL)
+		dev_err(hwdev->device, "couldn't create rotmem debugfs file\n");
+
+	dbg_file = debugfs_create_u32("maxline", S_IRUSR | S_IRGRP | S_IROTH,
+			hwdev->dbg_folder, (u32 *)&hwdev->ls_info->max_line_size);
+	if (dbg_file == NULL)
+		dev_err(hwdev->device, "couldn't create maxline debugfs file\n");
+
+	if (hwdev->dp_api->debugfs_func != NULL)
+		hwdev->dp_api->debugfs_func(hwdev);
+
+	return 0;
+}
+
+struct malidp_hw_event_queue *malidp_hw_event_queue_create(size_t n_events)
+{
+	//TODO:
+	struct malidp_hw_event_queue *queue;
+	size_t size = sizeof(*queue) +
+		(sizeof(struct malidp_hw_event) * n_events);
+
+	/*
+	queue = kzalloc(size, GFP_KERNEL);
+	if (!queue)
+		return NULL;
+	*/
+
+	spin_lock_init(&queue->lock);
+	queue->n_events = n_events;
+	queue->queue = (struct malidp_hw_event *)((char *)queue + sizeof(*queue));
+	queue->head = NULL;
+	queue->tail = queue->queue;
+	return queue;
+}
+
+void malidp_hw_event_queue_destroy(struct malidp_hw_event_queue *queue)
+{
+	kfree(queue);
+}
+
+void malidp_hw_event_queue_enqueue(struct malidp_hw_event_queue *queue,
+		struct malidp_hw_event *event)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&queue->lock, flags);
+
+	*queue->tail = *event;
+
+	/* If the queue gets full, log an error */
+	if (queue->tail == queue->head)
+		(*queue->tail).type |= MALIDP_HW_EVENT_ERROR | MALIDP_HW_ERROR_QFULL;
+
+	if (!queue->head)
+		queue->head = queue->tail;
+
+	queue->tail--;
+	if (queue->tail < queue->queue)
+		queue->tail = &queue->queue[queue->n_events - 1];
+
+	spin_unlock_irqrestore(&queue->lock, flags);
+}
+
+void malidp_hw_event_queue_dequeue(struct malidp_hw_event_queue *queue,
+		struct malidp_hw_event *event)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&queue->lock, flags);
+
+	if (!queue->head) {
+		event->type = MALIDP_HW_EVENT_NONE;
+	} else {
+		*event = *queue->head;
+
+		queue->head--;
+		if (queue->head < queue->queue)
+			queue->head = &queue->queue[queue->n_events - 1];
+
+		/* Are we empty? */
+		if (queue->head == queue->tail)
+			queue->head = NULL;
+	}
+
+	spin_unlock_irqrestore(&queue->lock, flags);
+}
+
+void malidp_hw_disable_all_layers_and_mw(struct malidp_hw_device *hwdev)
+{
+	struct malidp_se_mw_conf mw_conf = {
+		.mode = MALIDP_SE_MW_DISABLE,
+	};
+	unsigned long flags;
+
+	spin_lock_irqsave(&hwdev->hw_lock, flags);
+	malidp_se_cfg_processing(hwdev->se_dev, &mw_conf, NULL);
+	malidp_de_disable_all_layers(hwdev->de_dev);
+	spin_unlock_irqrestore(&hwdev->hw_lock, flags);
+}
+
+attr_visible_t malidp_hw_get_attr_visible_func(struct malidp_hw_device *hwdev)
+{
+	return hwdev->dp_api->attr_visible;
+}
+
+int malidp_hw_runtime_suspend(struct malidp_hw_device *hwdev)
+{
+	mutex_lock(&hwdev->power_mutex);
+	malidp_hw_change_op_mode(hwdev, MALIDP_OP_MODE_POWERSAVE);
+	mutex_unlock(&hwdev->power_mutex);
+
+	malidp_hw_disable_clocks(hwdev);
+	return 0;
+}
+
+int malidp_hw_runtime_resume(struct malidp_hw_device *hwdev)
+{
+	int res;
+
+	malidp_hw_enable_clocks(hwdev);
+
+	mutex_lock(&hwdev->power_mutex);
+	malidp_hw_change_op_mode(hwdev, MALIDP_OP_MODE_CONFIG);
+	mutex_unlock(&hwdev->power_mutex);
+
+	res = hwdev->dp_api->se_api.hw_cfg(hwdev->se_dev);
+	WARN_ON(res != 0);
+
+	res = hwdev->dp_api->de_api.hw_cfg(hwdev->de_dev);
+	WARN_ON(res != 0);
+
+	return 0;
+}
+
+int malidp_hw_display_switch(struct malidp_hw_device *hwdev, bool power_on)
+{
+
+	if (power_on == true) {
+		pm_runtime_get_sync(hwdev->device);
+
+		mutex_lock(&hwdev->power_mutex);
+		malidp_hw_change_op_mode(hwdev, MALIDP_OP_MODE_NORMAL);
+		mutex_unlock(&hwdev->power_mutex);
+	} else {
+		malidp_hw_disable_all_layers_and_mw(hwdev);
+
+		mutex_lock(&hwdev->power_mutex);
+		malidp_hw_change_op_mode(hwdev, MALIDP_OP_MODE_CONFIG);
+		mutex_unlock(&hwdev->power_mutex);
+
+		pm_runtime_put(hwdev->device);
+	}
+
+	return 0;
+}
+
+void malidp_hw_clear_mw(struct malidp_hw_state *hw_state)
+{
+	struct malidp_hw_state_priv *hw_priv = hw_state->hw_priv;
+	int i;
+
+	hw_priv->mw.mode = MALIDP_SE_MW_DISABLE;
+	hw_priv->mw.buf = NULL;
+
+	hw_priv->cmp_flow = MALIDP_DE_CMP_FLOW_INTERNAL;
+
+	for (i = 0; i < MALIDP_MAX_LAYERS; i++) {
+		if (hw_priv->layer_flow[i] == MALIDP_DE_LAYER_FLOW_SIMULT_SE0)
+			hw_priv->layer_flow[i] = MALIDP_DE_LAYER_FLOW_LOCAL;
+	}
+}
diff --git a/devices/malidp/src/malidp_product_dp550.c b/devices/malidp/src/malidp_product_dp550.c
new file mode 100644
index 0000000..192c945
--- /dev/null
+++ b/devices/malidp/src/malidp_product_dp550.c
@@ -0,0 +1,931 @@
+/*
+ *
+ * (C) COPYRIGHT 2013-2015 ARM Limited. All rights reserved.
+ *
+ * This program is free software and is provided to you under the terms of the
+ * GNU General Public License version 2 as published by the Free Software
+ * Foundation, and any use by you of this program is subject to the terms
+ * of such GNU licence.
+ *
+ * A copy of the licence is included with the program, and can also be obtained
+ * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA  02110-1301, USA.
+ *
+ */
+
+#include "malidp_product_api.h"
+#include "malidp_adf.h"
+
+#define MALI_DP550_REG_DE_STATUS	0x0000
+#define		MALI_DP550_DE_IRQ_UNR	(1 << 0)
+#define		MALI_DP550_DE_IRQ_SAT	(1 << 8)
+#define		MALI_DP550_DE_IRQ_PL1	(1 << 12)
+#define		MALI_DP550_DE_IRQ_PL2	(1 << 13)
+#define		MALI_DP550_DE_AXIE	(1 << 16)
+
+#define MALI_DP550_REG_DE_IRQ_MSK	0x0008
+#define MALI_DP550_REG_DE_IRQ_CLR	0x000C
+#define MALI_DP550_REG_DE_CTRL		0x0010
+#define		DP550_PREFETCH_LINE_MASK	0x3ff
+#define		DP550_PREFETCH_LINE_SET(x)	\
+		((x) & DP550_PREFETCH_LINE_MASK)
+
+#define MALI_DP550_REG_LINE_INT_CTRL	0x0014
+
+#define MALI_DP550_REG_H_INTERVALS	0x0030
+#define MALI_DP550_REG_V_INTERVALS	0x0034
+#define MALI_DP550_REG_SYNC_CTRL	0x0038
+#define		MALI_DP550_VSP	(1 << 28)
+#define		MALI_DP550_HSP	(1 << 12)
+#define MALI_DP550_REG_HV_ACT_SIZE	0x003C
+#define MALI_DP550_REG_BG_COLOR		0x0044
+
+#define MALI_DP550_REG_ID			0xFFD0
+#define MALI_DP550_REG_CFG_VALID	0xC014
+#define MALI_DP550_REG_DE_BASE		0x0000
+#define MALI_DP550_REG_SE_BASE		0x8000
+
+#define MALI_DP550_REG_DE_AXI_CTL	0x0018
+#define MALI_DP550_REG_DE_QOS       0x001C
+#define MALI_DP550_REG_DE_DISP_FUNC	0x0020
+#define		MALI_DP550_COPROC_EN	(1 << 12)
+#define MALI_DP550_REG_DE_OD		0x004C
+#define MALI_DP550_REG_DE_COLORCOEFFS 0x0050
+#define MALI_DP550_DE_COEFTAB_GAMMA	(1 << DE_COEFTAB_GAMMA_SHIFT)
+
+#define MALI_DP550_REG_LV1_YUV2RGB	0x0184
+#define MALI_DP550_REG_LV2_YUV2RGB	0x0284
+
+#define MALI_DP550_REG_SE_IRQ_CLR	0x000C
+#define MALI_DP550_REG_SE_CTL		0x0010
+#define		MALI_DP550_SE_CTL_OFM	(1 << 7)
+#define		MALI_DP550_SE_CTL_xSEL_MASK	7
+#define		MALI_DP550_SE_CTL_VCSEL(x)	(((x) & MALI_DP550_SE_CTL_xSEL_MASK) << 20)
+#define		MALI_DP550_SE_CTL_HCSEL(x)	(((x) & MALI_DP550_SE_CTL_xSEL_MASK) << 16)
+#define MALI_DP550_REG_SE_PL		0x0014
+#define		MALI_DP550_SE_PL_LINE_MASK	0x1fff
+#define		MALI_DP550_SE_PL_LINE(x)	(((x) & MALI_DP550_SE_PL_LINE_MASK) << 0)
+#define		MALI_DP550_SE_PL_INTERVAL_MASK	0x3ff
+#define		MALI_DP550_SE_PL_INTERVAL(x)	(((x) & MALI_DP550_SE_PL_INTERVAL_MASK) << 16)
+#define MALI_DP550_REG_SE_AXI_CRL	0x0018
+#define MALI_DP550_REG_SE_L_CTL		0x0024
+#define MALI_DP550_REG_SE_SCL_CTL	0x0034
+#define MALI_DP550_REG_SE_ENH_CTL	0x004C
+#define MALI_DP550_REG_SE_COV_CTL	0x0074
+#define MALI_DP550_REG_SE_MW_CTL	0x0100
+
+#define MALI_DP550_REG_DC_STATUS	0xC000
+#define		MALI_DP550_DC_IRQ_CVAL	(1 << 0)
+#define		MALI_DP550_DC_IRQ_CM	(1 << 4)
+#define		MALI_DP550_DC_IRQDE	(1 << 20)
+#define		MALI_DP550_DC_IRQSE	(1 << 24)
+#define MALI_DP550_REG_DC_IRQ_SET	0xC004
+#define MALI_DP550_REG_DC_IRQ_MSK	0xC008
+#define MALI_DP550_REG_DC_IRQ_CLR	0xC00C
+#define MALI_DP550_REG_DC_CTRL		0xC010
+#define		MALI_DP550_DC_CM	(1 << 16)
+#define		MALI_DP550_DC_CRST	(1 << 17)
+
+#define MALI_DP550_LV1_BASE		0x0100
+#define MALI_DP550_LV2_BASE		0x0200
+#define MALI_DP550_LG1_BASE		0x0300
+#define MALI_DP550_LS1_BASE		0x0400
+
+#define MALI_DP550_LV1_AD_CTRL	0x01B8
+#define MALI_DP550_LV1_AD_H_CROP	0x01BC
+#define MALI_DP550_LV1_AD_V_CROP	0x01C0
+#define MALI_DP550_LV2_AD_CTRL	0x02B8
+#define MALI_DP550_LV2_AD_H_CROP	0x02BC
+#define MALI_DP550_LV2_AD_V_CROP	0x02C0
+#define MALI_DP550_LG1_AD_CTRL	0x0330
+#define MALI_DP550_LG1_AD_H_CROP	0x0334
+#define MALI_DP550_LG1_AD_V_CROP	0x0338
+
+#define MALI_DP550_SE_IRQ_EOW	(1 << 0)
+#define MALI_DP550_SE_IRQ_PL	(1 << 12)
+#define MALI_DP550_SE_IRQ_PI	(1 << 13)
+
+#define MALI_DP550_SE_AXIE	(1 << 16)
+#define MALI_DP550_SE_OVR	(1 << 17)
+#define MALI_DP550_SE_IBUSY	(1 << 18)
+
+#define MALIDP_FORMAT_ID(__group, __format) ((((__group) & 0x7) << 3) | \
+		(((__format) & 0x7) << 0))
+#define N_RGB_INPUT_FORMATS 18
+
+#define SMART_INPUT_FORMAT_START_IDX 4
+#define N_SMART_INPUT_FORMATS        8
+#define N_SUPPORTED_SMART_LAYERS     4
+
+extern const char *const op_mode_name[];
+extern const struct malidp_intf_hw_info dp_interfaces[];
+
+const u32 malidp550_input_formats[] = {
+	DRM_FORMAT_ARGB2101010,
+	DRM_FORMAT_ABGR2101010,
+	DRM_FORMAT_RGBA1010102,
+	DRM_FORMAT_BGRA1010102,
+	DRM_FORMAT_ARGB8888,
+	DRM_FORMAT_ABGR8888,
+	DRM_FORMAT_RGBA8888,
+	DRM_FORMAT_BGRA8888,
+	DRM_FORMAT_XRGB8888,
+	DRM_FORMAT_XBGR8888,
+	DRM_FORMAT_RGBX8888,
+	DRM_FORMAT_BGRX8888,
+	DRM_FORMAT_RGB888,
+	DRM_FORMAT_BGR888,
+	DRM_FORMAT_RGBA5551,
+	DRM_FORMAT_ABGR1555,
+	DRM_FORMAT_RGB565,
+	DRM_FORMAT_BGR565,
+	/* Formats below here supported by Video layers only */
+	MALIDP_FORMAT_XYUV, /* [31:0] X:Y:Cb:Cr 8:8:8:8 little endian */
+	MALIDP_FORMAT_NV16AFBC, /* AFBC compressed YUV 4:2:2 */
+	DRM_FORMAT_YUYV,  /* YUV 4:2:2 1-plane */
+	DRM_FORMAT_UYVY,  /* YUV 4:2:2 1-plane */
+	DRM_FORMAT_NV12,  /* YUV 4:2:0 2-plane */
+	DRM_FORMAT_YUV420,/* YUV 4:2:0 3-plane */
+	MALIDP_FORMAT_VYU30, /* [31:0] X:Cr:Y:Cb 2:10:10:10 little endian */
+	MALIDP_FORMAT_Y0L2, /* ARM Linear 10-bit packed YUV 4:2:0 */
+	MALIDP_FORMAT_P010, /* 10-bit YUV 4:2:0 2-plane */
+	/* AFBC formats which map to non-compressed format IDs */
+	MALIDP_FORMAT_NV12AFBC, /* Included for backwards-compatibility only. Maps to NV12 */
+	MALIDP_FORMAT_YUV10_420AFBC, /* AFBC compressed YUV 4:2:0, 10 bits per component */
+};
+
+/* We can use the same list for all the input formats */
+const u32 malidp550_input_format_ids[] = {
+	MALIDP_FORMAT_ID(0, 0),
+	MALIDP_FORMAT_ID(0, 1),
+	MALIDP_FORMAT_ID(0, 2),
+	MALIDP_FORMAT_ID(0, 3),
+	MALIDP_FORMAT_ID(1, 0),
+	MALIDP_FORMAT_ID(1, 1),
+	MALIDP_FORMAT_ID(1, 2),
+	MALIDP_FORMAT_ID(1, 3),
+	MALIDP_FORMAT_ID(2, 0),
+	MALIDP_FORMAT_ID(2, 1),
+	MALIDP_FORMAT_ID(2, 2),
+	MALIDP_FORMAT_ID(2, 3),
+	MALIDP_FORMAT_ID(3, 0),
+	MALIDP_FORMAT_ID(3, 1),
+	MALIDP_FORMAT_ID(4, 0),
+	MALIDP_FORMAT_ID(4, 1),
+	MALIDP_FORMAT_ID(4, 2),
+	MALIDP_FORMAT_ID(4, 3),
+	/* Start YUV formats */
+	MALIDP_FORMAT_ID(5, 0),
+	MALIDP_FORMAT_ID(5, 1),
+	MALIDP_FORMAT_ID(5, 2),
+	MALIDP_FORMAT_ID(5, 3),
+	MALIDP_FORMAT_ID(5, 6),
+	MALIDP_FORMAT_ID(5, 7),
+	MALIDP_FORMAT_ID(6, 0),
+	MALIDP_FORMAT_ID(6, 6),
+	MALIDP_FORMAT_ID(6, 7),
+	/* AFBC formats which map to non-compressed format IDs */
+	MALIDP_FORMAT_ID(5, 6),
+	MALIDP_FORMAT_ID(6, 7),
+};
+
+const u32 malidp550_output_formats[] = {
+	DRM_FORMAT_ARGB2101010,
+	DRM_FORMAT_ABGR2101010,
+	DRM_FORMAT_RGBA1010102,
+	DRM_FORMAT_BGRA1010102,
+	DRM_FORMAT_ARGB8888,
+	DRM_FORMAT_ABGR8888,
+	DRM_FORMAT_RGBA8888,
+	DRM_FORMAT_BGRA8888,
+	DRM_FORMAT_XRGB8888,
+	DRM_FORMAT_XBGR8888,
+	DRM_FORMAT_RGBX8888,
+	DRM_FORMAT_BGRX8888,
+	DRM_FORMAT_RGB888,
+	DRM_FORMAT_BGR888,
+	DRM_FORMAT_NV12,  /* YUV 4:2:0 2-plane */
+};
+
+const u32 malidp550_output_format_ids[] = {
+	MALIDP_FORMAT_ID(0, 0),
+	MALIDP_FORMAT_ID(0, 1),
+	MALIDP_FORMAT_ID(0, 2),
+	MALIDP_FORMAT_ID(0, 3),
+	MALIDP_FORMAT_ID(1, 0),
+	MALIDP_FORMAT_ID(1, 1),
+	MALIDP_FORMAT_ID(1, 2),
+	MALIDP_FORMAT_ID(1, 3),
+	MALIDP_FORMAT_ID(2, 0),
+	MALIDP_FORMAT_ID(2, 1),
+	MALIDP_FORMAT_ID(2, 2),
+	MALIDP_FORMAT_ID(2, 3),
+	MALIDP_FORMAT_ID(3, 0),
+	MALIDP_FORMAT_ID(3, 1),
+	MALIDP_FORMAT_ID(5, 6),
+};
+
+const u32 malidp550_afbc_formats[] = {
+	DRM_FORMAT_ARGB2101010,
+	DRM_FORMAT_ABGR2101010,
+	DRM_FORMAT_RGBA1010102,
+	DRM_FORMAT_BGRA1010102,
+	DRM_FORMAT_ARGB8888,
+	DRM_FORMAT_ABGR8888,
+	DRM_FORMAT_RGBA8888,
+	DRM_FORMAT_BGRA8888,
+	DRM_FORMAT_RGB888,
+	DRM_FORMAT_BGR888,
+	DRM_FORMAT_RGBA5551,
+	DRM_FORMAT_ABGR1555,
+	DRM_FORMAT_RGB565,
+	DRM_FORMAT_BGR565,
+	MALIDP_FORMAT_XYUV,
+	MALIDP_FORMAT_NV16AFBC,
+	DRM_FORMAT_YUYV,
+	DRM_FORMAT_UYVY,
+	MALIDP_FORMAT_VYU30,
+	MALIDP_FORMAT_NV12AFBC,
+	MALIDP_FORMAT_YUV10_420AFBC,
+};
+
+const u32 malidp550_xform_invalid_formats[] = {
+	DRM_FORMAT_RGB888,
+	DRM_FORMAT_BGR888,
+	MALIDP_FORMAT_Y0L2,
+};
+
+/*
+ * Format name				Block split support
+ * DRM_FORMAT_ABGR2101010		Yes
+ * DRM_FORMAT_ABGR8888			Yes
+ * DRM_FORMAT_BGR888			Yes
+ * DRM_FORMAT_RGBA5551			No
+ * DRM_FORMAT_RGB565			No
+ * MALIDP_FORMAT_XYUV			Yes
+ * MALIDP_FORMAT_NV16AFBC		No
+ * MALIDP_FORMAT_NV12AFBC		No
+ * MALIDP_FORMAT_VYU30			Yes
+ * MALIDP_FORMAT_YUV10_420AFBC	Yes
+*/
+#define MALIDP_AFBC_SPLIBLK_BITS 0x1443FF
+
+/* Define layer information */
+static struct malidp_layer_hw_info dp550_hw_layers[] = {
+	{
+		.index = 0,
+		.name = "Video-1",
+		.type = MALIDP_HW_LAYER_VIDEO,
+		.features = MALIDP_LAYER_FEATURE_TRANSFORM |
+			    MALIDP_LAYER_FEATURE_AFBC |
+			    MALIDP_LAYER_FEATURE_SCALING |
+			    MALIDP_LAYER_FEATURE_SRGB,
+		.n_supported_formats = ARRAY_SIZE(malidp550_input_formats),
+		.supported_formats = malidp550_input_formats,
+		.format_ids = malidp550_input_format_ids,
+		.n_max_planes = 3,
+		.n_supported_layers = 1,
+		.regs_base = MALI_DP550_LV1_BASE,
+		.ad_ctrl_reg = MALI_DP550_LV1_AD_CTRL,
+		.ad_crop_h_reg = MALI_DP550_LV1_AD_H_CROP,
+		.ad_crop_v_reg = MALI_DP550_LV1_AD_V_CROP,
+		.stride_offset = DE_REG_LV1_STRIDE,
+		.ptr0_low_offset = DE_REG_LV1_PTR0_LOW,
+		.ptr0_high_offset = DE_REG_LV1_PTR0_HIGH,
+		 /* The stride register for plane 3 is unused on DP550 */
+		.p3_stride_offset = 0,
+		.yuv2rgb_reg_offset = MALI_DP550_REG_LV1_YUV2RGB,
+	},
+	{
+		.index = 1,
+		.name = "Graphics-1",
+		.type = MALIDP_HW_LAYER_GRAPHICS,
+		.features = MALIDP_LAYER_FEATURE_TRANSFORM |
+			    MALIDP_LAYER_FEATURE_AFBC |
+			    MALIDP_LAYER_FEATURE_SCALING |
+			    MALIDP_LAYER_FEATURE_SRGB,
+		.n_supported_formats = N_RGB_INPUT_FORMATS,
+		.supported_formats = malidp550_input_formats,
+		.format_ids = malidp550_input_format_ids,
+		.n_max_planes = 1,
+		.n_supported_layers = 1,
+		.regs_base = MALI_DP550_LG1_BASE,
+		.ad_ctrl_reg = MALI_DP550_LG1_AD_CTRL,
+		.ad_crop_h_reg = MALI_DP550_LG1_AD_H_CROP,
+		.ad_crop_v_reg = MALI_DP550_LG1_AD_V_CROP,
+		.stride_offset = DE_REG_LG_STRIDE,
+		.ptr0_low_offset = DE_REG_LG_PTR0_LOW,
+		.ptr0_high_offset = DE_REG_LG_PTR0_HIGH,
+	},
+	{
+		.index = 2,
+		.name = "Video-2",
+		.type = MALIDP_HW_LAYER_VIDEO,
+		.features = MALIDP_LAYER_FEATURE_TRANSFORM |
+			    MALIDP_LAYER_FEATURE_AFBC |
+			    MALIDP_LAYER_FEATURE_SCALING |
+			    MALIDP_LAYER_FEATURE_SRGB,
+		.n_supported_formats = ARRAY_SIZE(malidp550_input_formats),
+		.supported_formats = malidp550_input_formats,
+		.format_ids = malidp550_input_format_ids,
+		.n_max_planes = 3,
+		.n_supported_layers = 1,
+		.regs_base = MALI_DP550_LV2_BASE,
+		.ad_ctrl_reg = MALI_DP550_LV2_AD_CTRL,
+		.ad_crop_h_reg = MALI_DP550_LV2_AD_H_CROP,
+		.ad_crop_v_reg = MALI_DP550_LV2_AD_V_CROP,
+		.stride_offset = DE_REG_LV1_STRIDE,
+		.ptr0_low_offset = DE_REG_LV1_PTR0_LOW,
+		.ptr0_high_offset = DE_REG_LV1_PTR0_HIGH,
+		 /* The stride register for plane 3 is unused on DP550 */
+		.p3_stride_offset = 0,
+		.yuv2rgb_reg_offset = MALI_DP550_REG_LV2_YUV2RGB,
+	},
+	{
+		.index = 3,
+		.name = "Smart-1",
+		.type = MALIDP_HW_LAYER_SMART,
+		.features = MALIDP_LAYER_FEATURE_SRGB,
+		.n_supported_formats = N_SMART_INPUT_FORMATS,
+		.supported_formats = &malidp550_input_formats[SMART_INPUT_FORMAT_START_IDX],
+		.format_ids = &malidp550_input_format_ids[SMART_INPUT_FORMAT_START_IDX],
+		.n_max_planes = 1,
+		.n_supported_layers = N_SUPPORTED_SMART_LAYERS,
+		.regs_base = MALI_DP550_LS1_BASE,
+		.ls_r1_in_size = DE_REG_LS_R1_IN_SIZE,
+		.ls_r1_offset = DE_REG_LS_R1_OFFSET,
+		.ls_r1_stride = DE_REG_LS_R1_STRIDE,
+		.ls_r1_ptr_low = DE_REG_LS_R1_PTR_LOW,
+		.ls_r1_ptr_high = DE_REG_LS_R1_PTR_HIGH,
+	},
+};
+
+static const struct malidp_hw_regmap malidp550_regmap = {
+	.id_registers = MALI_DP550_REG_ID,
+	.config_valid = MALI_DP550_REG_CFG_VALID,
+	.de_base = MALI_DP550_REG_DE_BASE,
+	.se_base = MALI_DP550_REG_SE_BASE,
+	.de_regmap = {
+		.axi_control = MALI_DP550_REG_DE_AXI_CTL,
+		.disp_func = MALI_DP550_REG_DE_DISP_FUNC,
+		.output_depth = MALI_DP550_REG_DE_OD,
+		.coloradj_coeff = MALI_DP550_REG_DE_COLORCOEFFS,
+		.qos_control = MALI_DP550_REG_DE_QOS
+	},
+	.se_regmap = {
+		.control = MALI_DP550_REG_SE_CTL,
+		.axi_control = MALI_DP550_REG_SE_AXI_CRL,
+		.layers_control = MALI_DP550_REG_SE_L_CTL,
+		.scaling_control = MALI_DP550_REG_SE_SCL_CTL,
+		.enhancer_control = MALI_DP550_REG_SE_ENH_CTL,
+		.conv_control = MALI_DP550_REG_SE_COV_CTL,
+		.mw_control = MALI_DP550_REG_SE_MW_CTL
+	},
+};
+
+/* Declare of DP550 API */
+static void dp550_disable_irq(struct malidp_hw_device *);
+static enum malidp_op_mode dp550_change_op_mode(
+		struct malidp_hw_device *,
+		enum malidp_op_mode);
+static int dp550_de_hw_cfg(struct malidp_de_device *);
+static void dp550_de_modeset(struct malidp_de_device *,
+		struct malidp_de_hwmode *);
+static void dp550_de_set_gamma_coeff(struct malidp_de_device *,
+		u32 *coeffs);
+static u32 dp550_de_fmt_fixup(u32 drm_format, u32 flags);
+static int dp550_se_hw_cfg(struct malidp_se_device *);
+static void dp550_se_set_scaler_coeff(struct malidp_se_device *,
+		enum malidp_scaling_coeff_set hcoeff,
+		enum malidp_scaling_coeff_set vcoeff);
+static bool dp550_se_limitation_check(struct malidp_se_device *,
+		struct malidp_se_scaler_conf *);
+static u32 dp550_se_calc_downscaling_threshold(u32, u32,
+		struct drm_mode_modeinfo *);
+static umode_t dp550_attr_visible(struct kobject *obj,
+		struct attribute *attr, int n);
+static void dp550_debugfs(struct malidp_hw_device *);
+static bool dp550_de_axi_valid(u32 attr, u32 val);
+static bool dp550_se_axi_valid(u32 attr, u32 val);
+static u32 dp550_rotmem_required(const struct malidp_hw_buffer *hw_buf);
+
+static const struct malidp_product_api dp550_api = {
+	.change_op_mode = dp550_change_op_mode,
+	.disable_irq = dp550_disable_irq,
+	.attr_visible = dp550_attr_visible,
+	.debugfs_func = dp550_debugfs,
+	.rotmem_size_required = dp550_rotmem_required,
+	.de_api = {
+		.hw_cfg = dp550_de_hw_cfg,
+		.modeset = dp550_de_modeset,
+		.set_gamma_coeff = dp550_de_set_gamma_coeff,
+		.fmt_fixup = dp550_de_fmt_fixup,
+		.axi_valid = dp550_de_axi_valid,
+		//.irq_handler = dp550_de_irq_handler,
+	},
+	.se_api = {
+		.hw_cfg = dp550_se_hw_cfg,
+		.set_scaler_coeff = dp550_se_set_scaler_coeff,
+		.limitation_check = dp550_se_limitation_check,
+		.calc_downscaling_threshold = dp550_se_calc_downscaling_threshold,
+		.axi_valid = dp550_se_axi_valid,
+		//.irq_handler = dp550_se_irq_handler,
+	}
+};
+
+struct malidp_hw_topology malidp_dp550_topology = {
+	.product_id = MALIDP_DP550_PRODUCT_ID,
+	.interfaces = dp_interfaces,
+	.n_interfaces = 2,
+	.layers = dp550_hw_layers,
+	.n_layers = ARRAY_SIZE(dp550_hw_layers),
+	.n_scalers = 1,
+	.n_supported_afbc_formats = ARRAY_SIZE(malidp550_afbc_formats),
+	.supported_afbc_formats = malidp550_afbc_formats,
+	.supported_afbc_splitblk = MALIDP_AFBC_SPLIBLK_BITS,
+	.n_mw_formats = ARRAY_SIZE(malidp550_output_formats),
+	.mw_formats = malidp550_output_formats,
+	.mw_format_ids = malidp550_output_format_ids,
+	.n_xform_invalid_formats = ARRAY_SIZE(malidp550_xform_invalid_formats),
+	.xform_invalid_formats = malidp550_xform_invalid_formats,
+	.dp_api = &dp550_api,
+	.regmap = &malidp550_regmap,
+};
+
+static const struct malidp_line_size_hw_info dp550_ls_configs[] = {
+	{
+		.max_line_size = 2048,
+		.min_line_size = 2,
+		.input_fifo_size = 4096,
+		.default_rotmem_size = 128 * SZ_1K,
+	},
+	{
+		.max_line_size = 4096,
+		.min_line_size = 2,
+		.input_fifo_size = 8192,
+		.default_rotmem_size = 256 * SZ_1K,
+	},
+	{
+		.max_line_size = 1280,
+		.min_line_size = 2,
+		.input_fifo_size = 2560,
+		.default_rotmem_size = 80 * SZ_1K,
+	},
+};
+
+static struct malidp_hw_configuration malidp_hw_dp550_cf = {
+	.ls_configs = dp550_ls_configs,
+	.n_configs = ARRAY_SIZE(dp550_ls_configs),
+	.partition_type = MALIDP_HW_PARTITION_FIXED,
+};
+
+umode_t dp550_attr_visible(struct kobject *obj,
+	struct attribute *attr, int n)
+{
+	/* so far DP550 shows all attributes */
+	return attr->mode;
+}
+
+void malidp_dp550_get_hw_description(struct malidp_hw_description *hwdes)
+{
+	hwdes->topology = &malidp_dp550_topology;
+	hwdes->config = &malidp_hw_dp550_cf;
+}
+
+static bool dp550_axi_burstlen_valid(u32 val)
+{
+	int i;
+
+	/* for 8, 16, 32, 64 */
+	for (i = 3; i < 7; i++)
+		if (val == (1 << i))
+			break;
+	return (i < 7) ? true : false;
+}
+
+/* Implementation of DP550 API */
+static bool dp550_de_axi_valid(u32 attr, u32 val)
+{
+	switch (attr) {
+	case MALIDP_ATTR_DE_BURSTLEN:
+		return dp550_axi_burstlen_valid(val);
+	case MALIDP_ATTR_DE_OUTSTRAN:
+	case MALIDP_ATTR_DE_POUTSTDCAB:
+		if ((val < 1) || (val > 32))
+			return false;
+		break;
+	default:
+		BUG();
+	}
+
+	return true;
+}
+
+static bool dp550_se_axi_valid(u32 attr, u32 val)
+{
+	switch (attr) {
+	case MALIDP_ATTR_SE_BURSTLEN:
+		return dp550_axi_burstlen_valid(val);
+	case MALIDP_ATTR_SE_OUTSTRAN:
+		if ((val < 1) || (val > 32))
+			return false;
+		break;
+	case MALIDP_ATTR_SE_WCACHE:
+		if (val > 15)
+			return false;
+		break;
+	default:
+		BUG();
+	}
+
+	return true;
+}
+
+static u32 dp550_rotmem_required(const struct malidp_hw_buffer *hw_buf)
+{
+	u32 bytes_per_col;
+
+	switch (hw_buf->fmt) {
+	/* 8 lines at 4 bytes per pixel */
+	case DRM_FORMAT_ARGB2101010:
+	case DRM_FORMAT_ABGR2101010:
+	case DRM_FORMAT_RGBA1010102:
+	case DRM_FORMAT_BGRA1010102:
+	case DRM_FORMAT_ARGB8888:
+	case DRM_FORMAT_ABGR8888:
+	case DRM_FORMAT_RGBA8888:
+	case DRM_FORMAT_BGRA8888:
+	case DRM_FORMAT_XRGB8888:
+	case DRM_FORMAT_XBGR8888:
+	case DRM_FORMAT_RGBX8888:
+	case DRM_FORMAT_BGRX8888:
+	case DRM_FORMAT_RGB888:
+	case DRM_FORMAT_BGR888:
+	case MALIDP_FORMAT_VYU30: /* 4:4:4 10-bit per component */
+	case MALIDP_FORMAT_XYUV: /* 4:4:4 8-bit per component */
+	/* 16 lines at 2 bytes per pixel */
+	case DRM_FORMAT_RGBA5551:
+	case DRM_FORMAT_ABGR1555:
+	case DRM_FORMAT_RGB565:
+	case DRM_FORMAT_BGR565:
+	case DRM_FORMAT_UYVY:
+	case DRM_FORMAT_YUYV:
+	case MALIDP_FORMAT_NV16AFBC: /* 4:2:2 8-bit per component */
+	case MALIDP_FORMAT_YUV10_420AFBC: /* 4:2:0 10-bit per component */
+	case MALIDP_FORMAT_Y0L2:
+	case MALIDP_FORMAT_P010:
+		bytes_per_col = 32;
+		break;
+	/* 16 lines at 1.5 bytes per pixel */
+	case DRM_FORMAT_NV12:
+	case DRM_FORMAT_YUV420:
+	case MALIDP_FORMAT_NV12AFBC:
+		bytes_per_col = 24;
+		break;
+	default:
+		BUG();
+	}
+	return hw_buf->cmp_rect.src_w * bytes_per_col;
+}
+
+static void dp550_disable_irq(struct malidp_hw_device *hwdev)
+{
+	malidp_hw_write(hwdev, 0,
+		hwdev->hw_regmap->se_base + SE_REG_MASKIRQ);
+	malidp_hw_write(hwdev, 0, MALI_DP550_REG_DC_IRQ_MSK);
+	malidp_hw_write(hwdev, 0,
+		hwdev->hw_regmap->de_base + MALI_DP550_REG_DE_IRQ_MSK);
+}
+
+/* Must be called with the power_mutex held */
+static enum malidp_op_mode dp550_change_op_mode(
+		struct malidp_hw_device *hwdev,
+		enum malidp_op_mode mode)
+{
+	unsigned long flags;
+	enum malidp_op_mode old_mode_de;
+	u32 status_bits = 0;
+	u32 status;
+
+	BUG_ON(mode == MALIDP_OP_MODE_UNKNOWN);
+
+
+	/* We're protected by the power mutex, so just read the mode */
+	old_mode_de = malidp_de_get_op_mode(hwdev->de_dev);
+	dev_dbg(hwdev->device, "performing op mode change: %s->%s\n",
+		op_mode_name[old_mode_de], op_mode_name[mode]);
+	if (old_mode_de == MALIDP_OP_MODE_UNKNOWN) {
+		/* reset */
+		dev_dbg(hwdev->device, "Requesting configuration reset\n");
+		malidp_hw_setbits(hwdev, MALI_DP550_DC_CRST,
+			MALI_DP550_REG_DC_CTRL);
+	} else if (old_mode_de == mode) {
+		return old_mode_de;
+	} else if (old_mode_de == MALIDP_OP_MODE_POWERSAVE) {
+		/*
+		 * Exiting powersave mode, so clear the status registers
+		 * and re-enable interrupts
+		 */
+		status = malidp_de_read(hwdev->de_dev,
+					MALI_DP550_REG_DE_STATUS);
+		malidp_de_write(hwdev->de_dev, status,
+				MALI_DP550_REG_DE_IRQ_CLR);
+		malidp_de_write(hwdev->de_dev, MALI_DP550_DE_IRQ_UNR |
+				MALI_DP550_DE_IRQ_PL1,
+				MALI_DP550_REG_DE_IRQ_MSK);
+		status = malidp_se_read(hwdev->se_dev,
+					MALI_DP550_REG_DE_STATUS);
+		malidp_se_write(hwdev->se_dev, status,
+				MALI_DP550_REG_SE_IRQ_CLR);
+		malidp_se_write(hwdev->se_dev, MALI_DP550_SE_IRQ_PL |
+				MALI_DP550_SE_IRQ_EOW, SE_REG_MASKIRQ);
+	}
+
+	spin_lock_irqsave(&hwdev->hw_lock, flags);
+
+	switch (mode) {
+	case MALIDP_OP_MODE_POWERSAVE:
+	case MALIDP_OP_MODE_CONFIG:
+		malidp_hw_setbits(hwdev, MALI_DP550_DC_CM,
+			MALI_DP550_REG_DC_CTRL);
+		status_bits = MALI_DP550_DC_CM;
+		break;
+	case MALIDP_OP_MODE_NORMAL:
+		malidp_hw_clearbits(hwdev, MALI_DP550_DC_CM,
+			MALI_DP550_REG_DC_CTRL);
+		break;
+	case MALIDP_OP_MODE_UNKNOWN:
+	default:
+		BUG();
+	}
+
+	/* Wait for the mode change to be applied */
+	do {
+		status = malidp_hw_read(hwdev,
+			MALI_DP550_REG_DC_STATUS);
+	} while ((status & MALI_DP550_DC_CM) != status_bits);
+
+	/* If we did a configuration reset, we have to clear the CRST bit */
+	if (old_mode_de == MALIDP_OP_MODE_UNKNOWN) {
+		malidp_hw_clearbits(hwdev, MALI_DP550_DC_CRST,
+				    MALI_DP550_REG_DC_CTRL);
+	}
+
+	/*
+	 * On entering powersave, disable IRQs and store the pending status
+	 * incase there is still one left to be handled
+	 */
+	if (mode == MALIDP_OP_MODE_POWERSAVE) {
+		status = malidp_hw_read(hwdev, MALI_DP550_REG_DC_STATUS);
+		hwdev->de_dev->pending_status = status;
+		hwdev->se_dev->pending_status = status;
+
+		dp550_disable_irq(hwdev);
+
+		status = malidp_de_read(hwdev->de_dev,
+					MALI_DP550_REG_DE_STATUS);
+		malidp_de_write(hwdev->de_dev, status,
+				MALI_DP550_REG_DE_IRQ_CLR);
+
+		status = malidp_se_read(hwdev->se_dev, SE_REG_STATUS);
+		malidp_se_write(hwdev->se_dev, status,
+				MALI_DP550_REG_SE_IRQ_CLR);
+	}
+
+	hwdev->de_dev->op_mode = mode;
+	hwdev->se_dev->op_mode = mode;
+
+	dev_dbg(hwdev->device, "mode change ok: %s\n", op_mode_name[mode]);
+
+	spin_unlock_irqrestore(&hwdev->hw_lock, flags);
+
+	return old_mode_de;
+}
+
+static int dp550_de_hw_cfg(struct malidp_de_device *de_dev)
+{
+	/* Set AXI configuration */
+	if (!malidp_de_attr_valid(de_dev, MALIDP_ATTR_DE_OUTSTRAN,
+					de_dev->outstran)) {
+		dev_warn(de_dev->device, "%s : invalid value '%d' for de_axi_outstran\n",
+				__func__, de_dev->outstran);
+		de_dev->outstran = DE_DEFAULT_AXI_OUTSTRAN;
+	}
+
+	if (!malidp_de_attr_valid(de_dev, MALIDP_ATTR_DE_POUTSTDCAB,
+					de_dev->poutstdcab)) {
+		dev_warn(de_dev->device, "%s : invalid value '%d' for de_axi_poutstdcab\n",
+				__func__, de_dev->poutstdcab);
+		de_dev->poutstdcab = DE_DEFAULT_AXI_POUTSTDCAB;
+	}
+
+	if (!malidp_de_attr_valid(de_dev, MALIDP_ATTR_DE_BURSTLEN,
+					de_dev->burstlen)) {
+		dev_warn(de_dev->device, "%s : invalid value '%d' for de_axi_burstlen\n",
+				__func__, de_dev->burstlen);
+		de_dev->burstlen = DE_DEFAULT_AXI_BURSTLEN;
+	}
+
+	malidp_de_set_axi_cfg(de_dev, de_dev->outstran,
+			de_dev->poutstdcab,
+			de_dev->burstlen);
+
+	/* Initialize the ARQOS settings */
+	malidp_de_init_axi_qos(de_dev,
+		de_dev->arqos_threshold_low,
+		de_dev->arqos_threshold_high,
+		de_dev->arqos_red,
+		de_dev->arqos_green);
+
+	/* Set default background (black (0, 0, 0))*/
+	malidp_de_write(de_dev, 0, MALI_DP550_REG_BG_COLOR);
+
+	/* Clear display function, as CRST might not have worked */
+	malidp_de_write(de_dev, 0, MALI_DP550_REG_DE_DISP_FUNC);
+
+	/* Set prefetch_line to default value */
+	malidp_de_clearbits(de_dev, DP550_PREFETCH_LINE_MASK,
+		MALI_DP550_REG_DE_CTRL);
+	malidp_de_setbits(de_dev, DP550_PREFETCH_LINE_SET(DE_DEFAULT_PREFETCH_LINE),
+		MALI_DP550_REG_DE_CTRL);
+
+	/*
+	 * We are always interested on getting an IRQ as soon as a frame begins
+	 * to be scanned out.
+	 */
+	malidp_de_write(de_dev, DE_LINE_INT_1(DE_DEFAULT_PREFETCH_LINE),
+		MALI_DP550_REG_LINE_INT_CTRL);
+	malidp_de_write(de_dev, MALI_DP550_DE_IRQ_UNR |
+			MALI_DP550_DE_IRQ_PL1, MALI_DP550_REG_DE_IRQ_MSK);
+
+	/* Write alpha lookup tables */
+	malidp_de_write_alpha_lookup(de_dev);
+
+	/* Disable all the layers so we don't scan out any stale config */
+	malidp_de_disable_all_layers(de_dev);
+
+	malidp_de_cleanup_yuv2rgb_coeffs(de_dev);
+
+	dev_dbg(de_dev->device, "%s : success!\n", __func__);
+	return 0;
+}
+
+static void dp550_de_modeset(struct malidp_de_device *de_dev,
+		struct malidp_de_hwmode *hwmode)
+{
+	u32 sync_ctl = DE_H_SYNCWIDTH(hwmode->hsw) | DE_V_SYNCWIDTH(hwmode->vsw);
+
+	if (hwmode->vsync_pol_pos)
+		sync_ctl |= MALI_DP550_VSP;
+	if (hwmode->hsync_pol_pos)
+		sync_ctl |= MALI_DP550_HSP;
+
+	malidp_de_write(de_dev, DE_H_FRONTPORCH(hwmode->hfp) | DE_H_BACKPORCH(hwmode->hbp),
+			MALI_DP550_REG_H_INTERVALS);
+	malidp_de_write(de_dev, DE_V_FRONTPORCH(hwmode->vfp) | DE_V_BACKPORCH(hwmode->vbp),
+			MALI_DP550_REG_V_INTERVALS);
+	malidp_de_write(de_dev, sync_ctl, MALI_DP550_REG_SYNC_CTRL);
+	malidp_de_write(de_dev, DE_H_ACTIVE(hwmode->h_active) | DE_V_ACTIVE(hwmode->v_active),
+		MALI_DP550_REG_HV_ACT_SIZE);
+
+}
+
+static void dp550_de_set_gamma_coeff(struct malidp_de_device *de_dev, u32 *coeffs)
+{
+	malidp_de_set_coeftab(de_dev, MALI_DP550_DE_COEFTAB_GAMMA,
+		coeffs);
+}
+
+static u32 dp550_de_fmt_fixup(u32 drm_format, u32 flags)
+{
+	if (flags & MALIDP_FLAG_AFBC) {
+		switch (drm_format) {
+		case DRM_FORMAT_ARGB2101010:
+		case DRM_FORMAT_RGBA1010102:
+		case DRM_FORMAT_BGRA1010102:
+			return DRM_FORMAT_ABGR2101010;
+		case DRM_FORMAT_ARGB8888:
+		case DRM_FORMAT_RGBA8888:
+		case DRM_FORMAT_BGRA8888:
+			return DRM_FORMAT_ABGR8888;
+		case DRM_FORMAT_RGB888:
+			return DRM_FORMAT_BGR888;
+		case DRM_FORMAT_RGBA5551:
+			return DRM_FORMAT_ABGR1555;
+		case DRM_FORMAT_RGB565:
+			return DRM_FORMAT_BGR565;
+		case DRM_FORMAT_YUYV:
+		case DRM_FORMAT_UYVY:
+			return MALIDP_FORMAT_NV16AFBC;
+		}
+	}
+	return drm_format;
+}
+
+static int dp550_se_hw_cfg(struct malidp_se_device *se_dev)
+{
+	malidp_se_set_axi_cfg(se_dev, se_dev->outstran,
+			se_dev->burstlen,
+			se_dev->wcache,
+			se_dev->wqos);
+
+	/* Set initial image enhancer state */
+	se_dev->enh_cfg = MALIDP_SE_ENHANCER_OFF;
+	malidp_se_clearbits(se_dev, SE_ENH_H_EN | SE_ENH_V_EN,
+			MALI_DP550_REG_SE_CTL);
+	malidp_se_write(se_dev, SE_SET_ENH_LIMIT_LOW(SE_ENH_LOW_LEVEL) |
+			SE_SET_ENH_LIMIT_HIGH(SE_ENH_HIGH_LEVEL),
+			malidp550_regmap.se_regmap.enhancer_control);
+
+	/*
+	 * Enable OFM in SE, disable everything else as CRST might not
+	 * have worked
+	 */
+	malidp_se_write(se_dev, MALI_DP550_SE_CTL_OFM,
+			MALI_DP550_REG_SE_CTL);
+	/*
+	 * We get an IRQ as soon as a frame starts to be written to memory and
+	 * when config valid is latched by the init signal.
+	 */
+	malidp_se_write(se_dev, MALI_DP550_SE_PL_INTERVAL(32) | MALI_DP550_SE_PL_LINE(0),
+		MALI_DP550_REG_SE_PL);
+	malidp_se_write(se_dev, MALI_DP550_SE_IRQ_PL | MALI_DP550_SE_IRQ_EOW,
+		SE_REG_MASKIRQ);
+
+	/* Force coefficients to be updated next time they are used */
+	se_dev->rgb2yuv_coeffs = NULL;
+	se_dev->v_coeffstab = 0xffff;
+	se_dev->h_coeffstab = 0xffff;
+
+	dev_dbg(se_dev->device, "%s: success!\n", __func__);
+	return 0;
+}
+
+static void dp550_se_set_scaler_coeff(struct malidp_se_device *se_dev,
+		enum malidp_scaling_coeff_set hcoeff,
+		enum malidp_scaling_coeff_set vcoeff)
+{
+	u32 mask = MALI_DP550_SE_CTL_VCSEL(MALI_DP550_SE_CTL_xSEL_MASK) |
+		   MALI_DP550_SE_CTL_HCSEL(MALI_DP550_SE_CTL_xSEL_MASK);
+	u32 new_value = MALI_DP550_SE_CTL_VCSEL(vcoeff + 1) |
+			MALI_DP550_SE_CTL_HCSEL(hcoeff + 1);
+
+	malidp_se_clearbits(se_dev, mask, MALI_DP550_REG_SE_CTL);
+
+	malidp_se_setbits(se_dev, new_value, MALI_DP550_REG_SE_CTL);
+}
+
+static bool dp550_se_limitation_check(struct malidp_se_device *se_dev,
+		struct malidp_se_scaler_conf *s0)
+{
+	bool ret = true;
+	struct malidp_hw_device *hwdev = se_dev->hwdev;
+	struct drm_mode_modeinfo mode;
+	unsigned long flags;
+	unsigned long mclk =
+		clk_get_rate(hwdev->mclk);
+	unsigned long pxclk =
+		clk_get_rate(hwdev->pxclk);
+	unsigned long numerator, denominator;
+
+	spin_lock_irqsave(&hwdev->hw_lock, flags);
+	malidp_de_modeget(hwdev->de_dev, &mode);
+	spin_unlock_irqrestore(&hwdev->hw_lock, flags);
+
+	/*
+	 * Equation:
+	 * a = (max(h_input_size, h_output_size) * v_input_size) /
+	 *         ((h_total_size - 2) * v_output_size)
+	 *
+	 * mclk = a * pxclk
+	 *
+	 * i.e. (h_total_size - 2) * v_output_size * mclk >=
+	 *         max(h_input_size, h_output_size) * v_input_size * pxclk
+	 */
+
+	numerator = max(s0->input_w, s0->output_w) * s0->input_h;
+	denominator = (mode.htotal - 2) * s0->output_h;
+
+	if ((u64)mclk * denominator < (u64)pxclk * numerator) {
+		dev_err(hwdev->device,
+			"%s: Clock ratio (mclk/pxclk) is not high enough for downscale factor.",
+			__func__);
+		ret = false;
+	}
+
+	return ret;
+}
+
+static u32 dp550_se_calc_downscaling_threshold(u32 mclk, u32 pxlclk,
+		struct drm_mode_modeinfo *mode)
+{
+	u64 mclk64 = mclk;
+
+	mclk64 *= mode->htotal - 2;
+
+	/* factor is (16.16) fix point */
+	mclk64 <<= 16;
+	do_div(mclk64, pxlclk);
+
+	return mclk64;
+}
diff --git a/devices/malidp/src/malidp_se_device.c b/devices/malidp/src/malidp_se_device.c
new file mode 100644
index 0000000..383f73d
--- /dev/null
+++ b/devices/malidp/src/malidp_se_device.c
@@ -0,0 +1,503 @@
+/*
+ *
+ * (C) COPYRIGHT 2013-2015 ARM Limited. All rights reserved.
+ *
+ * This program is free software and is provided to you under the terms of the
+ * GNU General Public License version 2 as published by the Free Software
+ * Foundation, and any use by you of this program is subject to the terms
+ * of such GNU licence.
+ *
+ * A copy of the licence is included with the program, and can also be obtained
+ * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA  02110-1301, USA.
+ *
+ */
+
+
+
+#include "malidp_adf.h"
+#include "malidp_hw_types.h"
+#include "malidp_product_api.h"
+#include "malidp_se_device.h"
+#include "malidp_de_device.h"
+
+#define SE_N_QUEUE_EVENTS 8
+#define SE_N_RGB2YUV_COEFFS 12
+#define SE_N_ENH_COEFFS 9
+
+#define SE_N_PHASE	4	/* 2^SE_N_PHASE is real number */
+#define SE_SHIFT_N_PHASE 12
+
+/* pre-define fix-point numbers */
+#define FP_1_00000		0x00010000			/* 1.0 */
+#define FP_0_66667		0x0000AAAA			/* 0.6667 = 1/1.5 */
+#define FP_0_50000		0x00008000			/* 0.5 = 1/2 */
+#define FP_0_36363		0x00005D17			/* 0.36363 = 1/2.75 */
+#define FP_0_25000		0x00004000			/* 0.25 = 1/4 */
+#define FP_0_12610		0x00002048			/* 0.12610 = 1/7.93 */
+
+extern const char *const op_mode_name[];
+
+static const s32 malidp_se_bt601_narrow_coeffs[SE_N_RGB2YUV_COEFFS] = {
+	 66, 129,  25,
+	-38, -74, 112,
+	112, -94, -18,
+
+	 16, 128, 128
+};
+
+static const s32 malidp_se_bt601_wide_coeffs[SE_N_RGB2YUV_COEFFS] = {
+	 77,  150,  29,
+	-43,  -85, 128,
+	128, -107, -21,
+
+	  0,  128, 128
+};
+
+static const s32 malidp_se_bt709_narrow_coeffs[SE_N_RGB2YUV_COEFFS] = {
+	  47,  157,   16,
+	 -26,  -87,  112,
+	 112, -102,  -10,
+
+	  16,  128,  128
+};
+
+static const s32 malidp_se_bt709_wide_coeffs[SE_N_RGB2YUV_COEFFS] = {
+	  54,  183,  19,
+	 -29,  -99, 128,
+	 128, -116, -12,
+
+	   0,  128, 128
+};
+
+static const s32 malidp_se_enhancer_coeffs[3][SE_N_ENH_COEFFS] = {
+	[MALIDP_SE_ENHANCER_HORZ] = {
+		  0,   0,   0, -32, 128, -32,   0,   0,   0
+	},
+	[MALIDP_SE_ENHANCER_VERT] = {
+		  0, -32,   0,   0, 128,   0,   0, -32,   0
+	},
+	[MALIDP_SE_ENHANCER_BOTH] = {
+		 -8,  -8,  -8,  -8, 128,  -8,  -8,  -8,  -8
+	},
+};
+
+int malidp_se_fmt_drm2mw(struct malidp_se_device *dev, u32 drm_fmt)
+{
+	int i, idx;
+	int n_fmts = dev->n_mw_formats;
+	const u32 *fmts = dev->mw_formats;
+	const u32 *ids = dev->mw_format_ids;
+
+	for (i = 0; i < n_fmts; i++) {
+		if (ids)
+			idx = ids[i];
+		else
+			idx = i;
+
+		if (fmts[i] == drm_fmt)
+			return idx;
+	}
+
+	return -1;
+}
+
+static enum malidp_scaling_coeff_set
+malidp_se_scaling_coeffstab_select(u32 factor)
+{
+	/* NOTE: factor should be upscaling factor */
+	if (factor >= FP_1_00000)
+		return MALIDP_UPSCALING_COEFFS;
+	else if ((factor < FP_1_00000) && (factor >= FP_0_66667))
+		return MALIDP_DOWNSCALING_1_5_COEFFS;
+	else if ((factor < FP_0_66667) && (factor >= FP_0_50000))
+		return MALIDP_DOWNSCALING_2_COEFFS;
+	else if ((factor < FP_0_50000) && (factor >= FP_0_36363))
+		return MALIDP_DOWNSCALING_2_75_COEFFS;
+
+	return MALIDP_DOWNSCALING_4_COEFFS;
+}
+
+void malidp_se_write(struct malidp_se_device *dev,
+					  u32 value, u32 reg)
+{
+	
+	*((volatile unsigned int *)(dev->regs + reg)) = value;
+}
+
+u32 malidp_se_read(struct malidp_se_device *dev, u32 reg)
+{
+	return *((volatile unsigned int *)(dev->regs + reg));
+}
+
+void malidp_se_setbits(struct malidp_se_device *dev, u32 mask,
+				     u32 reg)
+{
+	u32 data = malidp_se_read(dev, reg);
+	data |= mask;
+	malidp_se_write(dev, data, reg);
+}
+
+void malidp_se_clearbits(struct malidp_se_device *dev,
+				       u32 mask, u32 reg)
+{
+	u32 data = malidp_se_read(dev, reg);
+	data &= ~mask;
+	malidp_se_write(dev, data, reg);
+}
+
+/*
+ * Set a user callback that will be triggered when the memory write out
+ * interface finishes writing the current buffer.
+ * @dev: pointer to the private malidp_de_device structure.
+ * @callback: the user callback we want to call. This will have the
+ *   the following arguments:
+ *      @device: low level device structure
+ *      event: the kind of event that has occurred in the SE.
+ */
+void malidp_se_set_flip_callback(struct malidp_se_device *dev,
+		void (*callback)(struct device *, void *, struct malidp_hw_event_queue *),
+		void *opaque)
+{
+	dev->flip_callback = callback;
+	dev->callback_opaque = opaque;
+}
+
+static void malidp_se_cfg_enhancer(struct malidp_se_device *dev,
+		enum malidp_se_enhancer_cfg cfg)
+{
+	u32 control;
+	u32 i;
+	const struct malidp_se_regmap *reg = dev->se_regmap;
+
+	/* Don't update anything unless we need to */
+	if (dev->enh_cfg == cfg)
+		return;
+
+	control = malidp_se_read(dev, reg->control);
+	control &= ~(SE_ENH_H_EN | SE_ENH_V_EN);
+
+	switch (cfg) {
+	case MALIDP_SE_ENHANCER_HORZ:
+		control |= SE_ENH_H_EN;
+		break;
+	case MALIDP_SE_ENHANCER_VERT:
+		control |= SE_ENH_V_EN;
+		break;
+	case MALIDP_SE_ENHANCER_BOTH:
+		control |= (SE_ENH_H_EN | SE_ENH_V_EN);
+		break;
+	case MALIDP_SE_ENHANCER_OFF:
+		break;
+	default:
+		BUG();
+	}
+
+	malidp_se_write(dev, control, reg->control);
+	dev->enh_cfg = cfg;
+
+	if (cfg == MALIDP_SE_ENHANCER_OFF) {
+		dev_dbg(dev->device, "%s : Turning enhancer off\n", __func__);
+		return;
+	}
+
+	dev_dbg(dev->device, "%s : Changing enhancer coefficients\n", __func__);
+
+	/* This assumes the coefficients are adjacent in the register map */
+	for (i = 0; i < SE_N_ENH_COEFFS; i++)
+		malidp_se_write(dev, malidp_se_enhancer_coeffs[cfg][i],
+			reg->enhancer_control + (i * 4) + SE_REG_ENH_COEFF1);
+}
+
+static void malidp_se_set_rgb2yuv_coeffs(struct malidp_se_device *dev,
+		struct malidp_hw_buffer *buf)
+{
+	int i;
+	const s32 *coeffs;
+	const struct malidp_se_regmap *reg = dev->se_regmap;
+
+	dev_dbg(dev->device, "%s", __func__);
+
+	switch (buf->flags & MALIDP_FLAG_YUV_MASK) {
+	case (MALIDP_FLAG_YUV_BT601 | MALIDP_FLAG_YUV_NARROW):
+		coeffs = malidp_se_bt601_narrow_coeffs;
+		break;
+	case (MALIDP_FLAG_YUV_BT601 | MALIDP_FLAG_YUV_WIDE):
+		coeffs = malidp_se_bt601_wide_coeffs;
+		break;
+	case (MALIDP_FLAG_YUV_BT709 | MALIDP_FLAG_YUV_NARROW):
+		coeffs = malidp_se_bt709_narrow_coeffs;
+		break;
+	case (MALIDP_FLAG_YUV_BT709 | MALIDP_FLAG_YUV_WIDE):
+		coeffs = malidp_se_bt709_wide_coeffs;
+		break;
+	default:
+		BUG();
+	}
+
+	if (coeffs != dev->rgb2yuv_coeffs) {
+		dev->rgb2yuv_coeffs = coeffs;
+		dev_dbg(dev->device, "%s : changing coefficients", __func__);
+		/*
+		 * This assumes the coefficient registers are adjacent in the
+		 * register map
+		 */
+		for (i = 0; i < SE_N_RGB2YUV_COEFFS; i++)
+			malidp_se_write(dev, dev->rgb2yuv_coeffs[i],
+					reg->conv_control + SE_REG_CONV_COEFF1 +
+					(i * 4));
+	}
+}
+
+/*
+ * Set the configuration for the memory write out interface and scaler.
+ * @dev: private SE hw device.
+ * @cfg: memory write out mode and buffer.
+ * @s0: scaler configuration for scaler 0.
+ */
+void malidp_se_cfg_processing(struct malidp_se_device *dev,
+				struct malidp_se_mw_conf *cfg,
+				struct malidp_se_scaler_conf *s0)
+{
+	u32 control, mw_reg;
+	const struct malidp_se_regmap *reg = dev->se_regmap;
+
+	mw_reg = reg->mw_control;
+
+	if (s0 != NULL)
+		malidp_se_cfg_enhancer(dev, s0->enh_cfg);
+
+	/* Set control register */
+	control = malidp_se_read(dev, reg->control);
+	/* set mw mode */
+	control &= (~SE_MW_IF_SET(SE_MW_IF_MASK));
+	control |= SE_MW_IF_SET(cfg->mode);
+	/* set scaling flag to control register */
+	if (s0 != NULL) {
+		if (s0->scaling_enable == true) {
+			control |= SE_SCALING_EN;
+
+			control &= ~(SE_RGB_MTH_SEL | SE_ALPHA_MTH_SEL);
+			control |= SE_ARGB_MTH_SET(s0->al);
+
+			if (s0->rgbo_enable)
+				control |= SE_RGBO_IF_EN;
+			else
+				control &= ~SE_RGBO_IF_EN;
+
+			if (s0->scale_alpha)
+				control |= SE_ALPHA_EN;
+			else
+				control &= ~SE_ALPHA_EN;
+		} else
+			control &= ~(SE_RGBO_IF_EN | SE_SCALING_EN);
+	}
+
+	/* if we disable mw and rgbo also is diabled, then the scaler will be disabled */
+	if ((cfg->mode == MALIDP_SE_MW_DISABLE) && ((control & SE_RGBO_IF_EN) ==0))
+		control &= ~SE_SCALING_EN;
+
+	malidp_se_write(dev, control, reg->control);
+}
+
+struct se_fixed_point {
+	u16 integer;
+	u16 fract;
+};
+
+/*
+ * Determine parameters for the filter/enhancer blocks (which depend on scaling
+ * factor), to be written at commit
+ */
+void malidp_se_set_scaling_dependent_state(struct malidp_se_device *dev,
+				struct malidp_se_scaler_conf *s0)
+{
+	u32 tmp_fp, phase;
+	struct se_fixed_point sf_h = { 0, 0 };
+	struct se_fixed_point sf_v = { 0, 0 };
+
+	dev_dbg(dev->device, "%s : Scaling factors: 0x%04x.%04x 0x%04x.%04x\n",
+		__func__, sf_h.integer, sf_h.fract, sf_v.integer, sf_v.fract);
+
+	/* Determine Image Enhancer setting */
+	if (sf_h.integer >= 2) {
+		if (sf_v.integer >= 2)
+			s0->enh_cfg = MALIDP_SE_ENHANCER_BOTH;
+		else
+			s0->enh_cfg = MALIDP_SE_ENHANCER_HORZ;
+	} else if (sf_v.integer >= 2) {
+		s0->enh_cfg = MALIDP_SE_ENHANCER_VERT;
+	} else {
+		s0->enh_cfg = MALIDP_SE_ENHANCER_OFF;
+	}
+}
+
+bool malidp_se_attr_valid(struct malidp_se_device *dev, u32 attr, u32 val)
+{
+	switch (attr) {
+	case MALIDP_ATTR_SE_WQOS:
+		if (val > 15)
+			return false;
+		break;
+	default:
+		return dev->hwdev->dp_api->se_api.axi_valid(attr, val);
+	}
+
+	return true;
+}
+
+void malidp_se_set_axi_cfg(struct malidp_se_device *dev, u32 outstran,
+		u32 burstlen, u32 wcache, u32 wqos)
+{
+	dev_dbg(dev->device, "%s: outstran: %i, burstlen: %i\n", __func__, outstran, burstlen);
+	dev_dbg(dev->device, "%s: wcache: %i, wqos: %i\n", __func__, wcache, wqos);
+
+	dev->outstran = outstran;
+	dev->burstlen = burstlen;
+	dev->wcache = wcache;
+	dev->wqos = wqos;
+	malidp_se_write(dev, SE_AXI_OUTSTDCAPB(dev->outstran) |
+			SE_AXI_BURSTLEN(dev->burstlen - 1) |
+			SE_AXI_WCACHE(dev->wcache) |
+			SE_AXI_WQOS(dev->wqos),
+			dev->se_regmap->axi_control);
+}
+
+struct malidp_se_device *malidp_se_hw_init(struct malidp_hw_device *hwdev,
+			     struct platform_device *pdev,
+			     struct malidp_hw_pdata *pdata,
+			     spinlock_t *hw_lock)
+{
+	int res;
+	struct malidp_se_device *dev = &hwdev->se_dev;
+
+	dev->hw_lock = hw_lock;
+	dev->regs = pdata->regs + hwdev->hw_regmap->se_base;
+	dev->se_regmap = &hwdev->hw_regmap->se_regmap;
+	dev->hwdev = hwdev;
+	dev->scene_changing = false;
+
+	dev->n_mw_formats = hwdev->topology->n_mw_formats;
+	dev->mw_formats = hwdev->topology->mw_formats;
+	dev->mw_format_ids = hwdev->topology->mw_format_ids;
+
+	dev->device = &pdev->dev;
+
+	dev->op_mode = MALIDP_OP_MODE_UNKNOWN;
+
+	dev->outstran = pdata->se_axi_outstran;
+	dev->burstlen = pdata->se_axi_burstlen;
+	dev->wcache = pdata->se_axi_awcache;
+	dev->wqos = pdata->se_axi_awqos;
+
+	dev_dbg(dev->device, "%s : success!\n", __func__);
+
+	return dev;
+}
+
+void malidp_se_hw_exit(struct malidp_se_device *dev)
+{
+	malidp_hw_event_queue_destroy(dev->ev_queue);
+	return;
+}
+
+int malidp_se_get_attr(struct malidp_se_device *dev, u32 attr, u32 *val)
+{
+	switch (attr) {
+	case MALIDP_ATTR_SE_BURSTLEN:
+		*val = dev->burstlen;
+		break;
+	case MALIDP_ATTR_SE_OUTSTRAN:
+		*val = dev->outstran;
+		break;
+	case MALIDP_ATTR_SE_WQOS:
+		*val = dev->wqos;
+		break;
+	case MALIDP_ATTR_SE_WCACHE:
+		*val = dev->wcache;
+		break;
+	default:
+		dev_err(dev->device, "%s: unkown SE attribute %i\n",
+			__func__, attr);
+		return -EINVAL;
+	}
+
+	dev_dbg(dev->device, "%s: attr: %i, val: %u\n",
+		__func__, attr, *val);
+
+	return 0;
+}
+
+int malidp_se_set_attr(struct malidp_se_device *dev, u32 attr, u32 val)
+{
+	int ret = 0;
+
+	dev_dbg(dev->device, "%s: attr: %i, val: %u\n", __func__, attr, val);
+
+	if (!malidp_se_attr_valid(dev, attr, val)) {
+		dev_dbg(dev->device, "%s: invalid value %u for attr %u\n",
+			__func__, val, attr);
+		return -EINVAL;
+	}
+
+	switch (attr) {
+	case MALIDP_ATTR_SE_BURSTLEN:
+		malidp_se_set_axi_cfg(dev, dev->outstran, val,
+				      dev->wqos, dev->wcache);
+		break;
+	case MALIDP_ATTR_SE_OUTSTRAN:
+		malidp_se_set_axi_cfg(dev, val, dev->burstlen,
+				      dev->wqos, dev->wcache);
+		break;
+	case MALIDP_ATTR_SE_WCACHE:
+		malidp_se_set_axi_cfg(dev, dev->outstran, dev->burstlen,
+				      val, dev->wqos);
+		break;
+	case MALIDP_ATTR_SE_WQOS:
+		malidp_se_set_axi_cfg(dev, dev->outstran, dev->burstlen,
+				      dev->wcache, val);
+		break;
+	default:
+		dev_err(dev->device, "%s: unkown SE attribute %i\n",
+			__func__, attr);
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+int malidp_se_save_attr(struct malidp_se_device *dev, u32 attr, u32 val)
+{
+	int ret = 0;
+
+	dev_dbg(dev->device, "%s: attr: %i, val: %u\n", __func__, attr, val);
+
+	if (!malidp_se_attr_valid(dev, attr, val)) {
+		dev_dbg(dev->device, "%s: invalid value %u for attr %u\n",
+			__func__, val, attr);
+		return -EINVAL;
+	}
+
+	switch (attr) {
+	case MALIDP_ATTR_SE_BURSTLEN:
+		dev->burstlen = val;
+		break;
+	case MALIDP_ATTR_SE_OUTSTRAN:
+		dev->outstran = val;
+		break;
+	case MALIDP_ATTR_SE_WCACHE:
+		dev->wcache = val;
+		break;
+	case MALIDP_ATTR_SE_WQOS:
+		dev->wqos = val;
+		break;
+	default:
+		dev_err(dev->device, "%s: unkown SE attribute %i\n",
+			__func__, attr);
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
diff --git a/devices/malidp/src/sofia3gx/dsi_display.c b/devices/malidp/src/sofia3gx/dsi_display.c
new file mode 100644
index 0000000..670f213
--- /dev/null
+++ b/devices/malidp/src/sofia3gx/dsi_display.c
@@ -0,0 +1,849 @@
+/* ----------------------------------------------------------------------------
+   Copyright (C) 2013-2014 Intel Mobile Communications GmbH
+
+   Sec Class: Intel Confidential (IC)
+
+   All rights reserved.
+   ----------------------------------------------------------------------------
+   This document contains proprietary information belonging to IMC.
+   Passing on and copying of this document, use
+   and communication of its contents is not permitted without prior written
+   authorisation.
+  ---------------------------------------------------------------------------*/
+
+#include "scu_reg.h"
+
+#include "dsi_hwregs.h"
+#include "bl_display_if_config.h"
+#include "bl_malidp.h"
+
+/* definition */
+//#define DSI_DBG
+
+/*
+ * Divide positive or negative dividend by positive divisor and round
+ * to closest integer. Result is undefined for negative divisors and
+ * for negative dividends if the divisor variable type is unsigned.
+ */
+#define DIV_ROUND_CLOSEST(x, divisor)(			\
+{							\
+	typeof(x) __x = x;				\
+	typeof(divisor) __d = divisor;			\
+	(((typeof(x))-1) > 0 ||				\
+	 ((typeof(divisor))-1) > 0 || (__x) > 0) ?	\
+		(((__x) + ((__d) / 2)) / (__d)) :	\
+		(((__x) - ((__d) / 2)) / (__d));	\
+}							\
+)
+
+#ifndef DIV_ROUND_UP
+#define DIV_ROUND_UP(n, d) (((n) + (d) - 1) / (d))
+#endif
+
+#define BYTES_TO_PIXELS(bytes, bpp) (DIV_ROUND_CLOSEST(bytes * 8, bpp))
+#define PIXELS_TO_BYTES(pixels, bpp) (DIV_ROUND_CLOSEST(pixels * bpp, 8))
+
+#define NSEC_PER_SEC       1000000000L
+
+#ifdef DSI_DBG
+#define DSI_DBG1(x...) TRACE_BL_DISPLAY_PRINTF(x)
+#define DSI_DBG2(x...) TRACE_BL_DISPLAY_PRINTF(x)
+#define DSI_DBG3(x...) TRACE_BL_DISPLAY_PRINTF(x)
+#else
+#define DSI_DBG1(x...)
+#define DSI_DBG2(x...)
+#define DSI_DBG3(x...)
+#endif
+
+#define DSI_ERR(x...) TRACE_BL_DISPLAY_PRINTF(x)
+
+#define DSI_CFG_DATA_PIX	0
+#define DSI_CFG_DATA_DAT	1
+#define DSI_CFG_SOURCE_DPI 0
+#define DSI_CFG_SOURCE_TXD 1
+
+static int g_dsi_cfg_eot = 1; /* default: eot */
+static int g_dsi_cfg_gate = 0; /* default: no gate */
+
+#define DSI_CFG_COMMON(_en_) (\
+	BITFLDS(EXR_DSI_CFG_GATE,	g_dsi_cfg_gate) |\
+	BITFLDS(EXR_DSI_CFG_EOT,	g_dsi_cfg_eot) |\
+	BITFLDS(EXR_DSI_CFG_TURN,	0) |\
+	BITFLDS(EXR_DSI_CFG_VALID,	0) |\
+	BITFLDS(EXR_DSI_CFG_STP,	0) |\
+	BITFLDS(EXR_DSI_CFG_ULPS,	0) |\
+	BITFLDS(EXR_DSI_CFG_ID,	0) |\
+	BITFLDS(EXR_DSI_CFG_VSYNC,	1) |\
+	BITFLDS(EXR_DSI_CFG_PSYNC,	1) |\
+	BITFLDS(EXR_DSI_CFG_EN,	_en_) \
+	)
+
+#define DSI_CFG_OFF(_mode_) (\
+		DSI_CFG_COMMON(0) |\
+		BITFLDS(EXR_DSI_CFG_LANES, 0) |\
+		BITFLDS(EXR_DSI_CFG_LP, 0) |\
+		BITFLDS(EXR_DSI_CFG_MODE, _mode_)|\
+		BITFLDS(EXR_DSI_CFG_DATA, DSI_CFG_DATA_DAT)|\
+		BITFLDS(EXR_DSI_CFG_SOURCE, DSI_CFG_SOURCE_TXD))
+
+#define DSI_CFG_INIT(_nlanes_) (\
+		DSI_CFG_COMMON(1) |\
+		BITFLDS(EXR_DSI_CFG_LANES, (_nlanes_-1)) |\
+		BITFLDS(EXR_DSI_CFG_LP, 0) |\
+		BITFLDS(EXR_DSI_CFG_MODE, DSI_CMD)|\
+		BITFLDS(EXR_DSI_CFG_DATA, DSI_CFG_DATA_DAT)|\
+		BITFLDS(EXR_DSI_CFG_SOURCE, DSI_CFG_SOURCE_TXD))
+/* need_to_modify
+#define DSI_CFG_RX_LP_DATA(_nlanes_) (\
+		DSI_CFG_COMMON(1) |\
+		BITFLDS(EXR_DSI_CFG_LANES, (_nlanes_-1)) |\
+		BITFLDS(EXR_DSI_CFG_TX, 1) |\
+		BITFLDS(EXR_DSI_CFG_LP, 1) |\
+		BITFLDS(EXR_DSI_CFG_TURN, 1) |\
+		BITFLDS(EXR_DSI_CFG_MODE, DSI_CMD)|\
+		BITFLDS(EXR_DSI_CFG_DATA, DSI_CFG_DATA_DAT)|\
+		BITFLDS(EXR_DSI_CFG_SOURCE, DSI_CFG_SOURCE_TXD))
+*/
+#define DSI_CFG_RX_LP_STP(_stp_) (\
+		DSI_CFG_COMMON(1) |\
+		BITFLDS(EXR_DSI_CFG_LANES, 0) |\
+		BITFLDS(EXR_DSI_CFG_TX, 0) |\
+		BITFLDS(EXR_DSI_CFG_LP, 1) |\
+		BITFLDS(EXR_DSI_CFG_STP, _stp_) |\
+		BITFLDS(EXR_DSI_CFG_MODE, DSI_CMD)|\
+		BITFLDS(EXR_DSI_CFG_DATA, DSI_CFG_DATA_DAT)|\
+		BITFLDS(EXR_DSI_CFG_SOURCE, DSI_CFG_SOURCE_TXD))
+
+#define DSI_CFG_TX_LP_DATA(_nlanes_) (\
+		DSI_CFG_COMMON(1) |\
+		BITFLDS(EXR_DSI_CFG_LANES, (0)) |\
+		BITFLDS(EXR_DSI_CFG_LP, 1) |\
+		BITFLDS(EXR_DSI_CFG_MODE, DSI_CMD)|\
+		BITFLDS(EXR_DSI_CFG_DATA, DSI_CFG_DATA_DAT)|\
+		BITFLDS(EXR_DSI_CFG_SOURCE, DSI_CFG_SOURCE_TXD))
+
+/* need_to_modify
+#define DSI_CFG_TX_HS_DATA_ACK(_nlanes_) (\
+		DSICFG_COMMON(1) |\
+		BITFLDS(EXR_DSI_CFG_LANES, (_nlanes_-1)) |\
+		BITFLDS(EXR_DSI_CFG_TX, 1) |\
+		BITFLDS(EXR_DSI_CFG_LP, 0) |\
+		BITFLDS(EXR_DSI_CFG_TURN, 1) |\
+		BITFLDS(EXR_DSI_CFG_MODE, DSI_CMD)|\
+		BITFLDS(EXR_DSI_CFG_DATA, DSI_CFG_DATA_DAT))|\
+		BITFLDS(EXR_DSI_CFG_SOURCE, DSI_CFG_SOURCE_TXD))
+*/
+
+#define DSI_CFG_TX_HS_DATA(_nlanes_) (\
+		DSI_CFG_COMMON(1) |\
+		BITFLDS(EXR_DSI_CFG_LANES, (_nlanes_-1)) |\
+		BITFLDS(EXR_DSI_CFG_LP, 0) |\
+		BITFLDS(EXR_DSI_CFG_MODE, DSI_CMD)|\
+		BITFLDS(EXR_DSI_CFG_DATA, DSI_CFG_DATA_DAT)|\
+		BITFLDS(EXR_DSI_CFG_SOURCE, DSI_CFG_SOURCE_TXD))
+
+#define DSI_CFG_TX_HS_PIXEL(_nlanes_, _mode_) (\
+		DSI_CFG_COMMON(1) |\
+		BITFLDS(EXR_DSI_CFG_LANES, (_nlanes_-1)) |\
+		BITFLDS(EXR_DSI_CFG_TX, 1) |\
+		BITFLDS(EXR_DSI_CFG_LP, 0) |\
+		BITFLDS(EXR_DSI_CFG_MODE, _mode_)|\
+		BITFLDS(EXR_DSI_CFG_DATA, DSI_CFG_DATA_PIX)|\
+		BITFLDS(EXR_DSI_CFG_SOURCE, DSI_CFG_SOURCE_DPI))
+
+#define DSI_RATE_N_MAX	(0xFF)
+#define DSI_RATE_M_MAX	(0xF)
+#define DSI_RATE_MAX	(1000000000)
+#define DSI_REF_CLK_KHZ (26000)
+#define DSI_RATE_MIN	(160000000)
+
+#define DSI_RATE(n, m) (DSI_REF_CLK_KHZ * (n + 1) / (m + 1) * 1000)
+#define DSI_RATE_OVERHEAD(r)    (r / 10 * 11)
+
+#define TLPX_NS 50
+
+static bl_display_cbs_t *disp_ctrl_ops;
+
+static void dsi_wr32tofifo(struct bl_display *display, unsigned int data)
+{
+	/* Write data to the DIF FIFO */
+	dsi_write_field(EXR_DSI_TXD, data);
+}
+
+static int dsi_waitfor_dsidir(struct bl_display *display, unsigned int value)
+{
+	unsigned int reg = 0xFF;
+	int ret = 0;
+
+	while (reg != value)
+		dsi_read_field(EXR_DSI_STAT_DSI_DIR, &reg);
+
+	return ret;
+}
+
+/**
+ * Common TX functions
+ */
+
+static int dsi_completion_fin_timeout_ms(int ms)
+{
+	unsigned int dsi_irq_status = 0;
+	unsigned int dsi_irq_clear = 0;
+
+	while (ms-- > 0) {
+		dsi_read_field(EXR_DSI_RIS, &dsi_irq_status);
+		if (dsi_irq_status & DSI_IRQ_ERR_DSIFIN) {
+			/* clear treated handled interrupts */
+			dsi_irq_clear |= DSI_IRQ_ERR_DSIFIN;
+			dsi_write_field(EXR_DSI_ICR, dsi_irq_clear);
+			break;
+		}
+		disp_ctrl_ops->bl_sleep(1);
+	}
+
+	if (ms > 0)
+		return 1;
+	else
+		return 0;
+}
+
+static void dsi_wait_status(unsigned int reg, unsigned int value,
+			    unsigned int mask, unsigned int delay,
+			    unsigned int count)
+{
+	unsigned int read_value = 0;
+
+	do {
+		dsi_read_field(reg, &read_value);
+		if ((read_value & mask) == value)
+			break;
+
+		if (delay)
+			disp_ctrl_ops->bl_sleep(delay);
+	} while (--count);
+	if (0 == count)
+		DSI_ERR("dsi_wait_status reg 0x%x fail", reg);
+}
+
+static void dsi_mipidsi_send_short_packet(struct bl_display *display,
+					  struct display_msg *msg,
+					  unsigned int dsicfg)
+{
+	unsigned int dsihead =
+		BITFLDS(EXR_DSI_HEAD_WCNT, msg->header) |
+		BITFLDS(EXR_DSI_HEAD_HEADER, msg->type);
+
+	if (msg->length) {
+		unsigned char *data_msg = msg->datas;
+
+		dsihead |= data_msg[0]<<16;
+	}
+	DSI_DBG2("dsi short pkt: (head:0x%08x cfg:0x%08x",
+		 dsihead, dsicfg);
+
+	dsi_write_field(EXR_DSI_VID3,
+			BITFLDS(EXR_DSI_VID3_PIXEL_PACKETS, 1));
+
+	dsi_write_field(EXR_DSI_HEAD, dsihead);
+	dsi_write_field(EXR_DSI_CFG,
+			dsicfg | BITFLDS(EXR_DSI_CFG_HEAD_LAT, 1));
+	dsi_write_field(EXR_DSI_CFG, dsicfg);
+	dsi_write_field(EXR_DSI_CFG,
+			dsicfg | BITFLDS(EXR_DSI_CFG_TX, 1) |
+			BITFLDS(EXR_DSI_CFG_CFG_LAT, 1));
+	dsi_write_field(EXR_DSI_CFG,
+			dsicfg | BITFLDS(EXR_DSI_CFG_TX, 1));
+}
+
+static void dsi_mipidsi_send_long_packet_dma(struct bl_display *display,
+					     struct display_msg *msg,
+					     unsigned int dsicfg)
+{
+	unsigned char *data_msg = msg->datas;
+	unsigned int length = msg->length;
+	unsigned int dsihead =
+		BITFLDS(EXR_DSI_HEAD_CMD, msg->header) |
+		BITFLDS(EXR_DSI_HEAD_WCNT, msg->length+1) |
+		BITFLDS(EXR_DSI_HEAD_HEADER, msg->type);
+
+	DSI_DBG2("dsi long dma pkt: wcnt:0x%04x (head:0x%08x cfg:0x%08x)",
+		 msg->length+1, dsihead, dsicfg);
+
+	dsi_write_field(EXR_DSI_VID3,
+			BITFLDS(EXR_DSI_VID3_PIXEL_PACKETS, 1));
+	dsi_write_field(EXR_DSI_VID6,
+			BITFLDS(EXR_DSI_VID6_LAST_PIXEL, msg->length));
+	dsi_write_field(EXR_DSI_TPS_CTRL,
+			BITFLDS(EXR_DSI_TPS_CTRL_TPS, msg->length));
+
+	while (length > 0) {
+		int j = 0;
+		unsigned int reg = 0;
+
+		for (j = 0; j < 4 && length; j++) {
+			length--;
+			reg |= (*data_msg++)<<(j*8);
+		}
+
+		dsi_wr32tofifo(display, reg);
+		DSI_DBG2("payload 0x%08x\n", reg);
+	}
+
+	dsi_write_field(EXR_DSI_HEAD, dsihead);
+	dsi_write_field(EXR_DSI_CFG,
+			dsicfg | BITFLDS(EXR_DSI_CFG_HEAD_LAT, 1));
+	dsi_write_field(EXR_DSI_CFG, dsicfg);
+	dsi_write_field(EXR_DSI_CFG,
+			dsicfg | BITFLDS(EXR_DSI_CFG_TX, 1) |
+			BITFLDS(EXR_DSI_CFG_CFG_LAT, 1));
+	dsi_write_field(EXR_DSI_CFG, dsicfg | BITFLDS(EXR_DSI_CFG_TX, 1));
+}
+
+static int dsi_mipidsi_force_ownership(struct bl_display *display)
+{
+	dsi_write_field(EXR_DSI_CFG, DSI_CFG_RX_LP_STP(1));
+	dsi_write_field(EXR_DSI_CFG, DSI_CFG_RX_LP_STP(0));
+	return 0;
+}
+
+static int dsi_mipidsi_ack_wait(struct bl_display *display)
+{
+	unsigned int nwords, nbytes;
+	unsigned int data = 0;
+
+	dsi_waitfor_dsidir(display, 0);
+
+	dsi_read_field(EXR_DSI_FIFO_STAT_RXFFS, &nwords);
+
+	if (nwords) {
+		dsi_read_field(EXR_DSI_RPS_STAT, &nbytes);
+		while (nwords) {
+			dsi_read_field(EXR_DSI_RXD, &data);
+			nwords--;
+		}
+		DSI_ERR("error returned (0x%x)\n", data);
+	}
+
+	return data;
+}
+
+static void dsi_send_cmd(struct bl_display *display,
+			 struct display_msg *msg,
+			 bl_display_cbs_t *bl_disp_cb)
+{
+	int ret = 0;
+	unsigned int dsicfg;
+
+	if (msg->flags & LCD_MSG_LP)
+		dsicfg = DSI_CFG_TX_LP_DATA(1);
+	else
+		dsicfg = DSI_CFG_TX_HS_DATA(display->dif.u.dsi.nblanes);
+
+	if (msg->length <= 1)
+		dsi_mipidsi_send_short_packet(display, msg, dsicfg);
+	else
+		dsi_mipidsi_send_long_packet_dma(display, msg, dsicfg);
+
+	DSI_DBG2("wait for eoc\n");
+	ret = dsi_completion_fin_timeout_ms(100);
+
+	if (!ret) {
+		DSI_ERR("dsifin interrupt timedout");
+	} else {
+		DSI_DBG2("eoc received\n");
+#ifdef USE_DSI_ACKNOWLEDGE
+		ret = dsi_mipidsi_ack_wait(display);
+		dsi_mipidsi_force_ownership(display);
+#endif
+	}
+
+	if (msg->delay)
+		bl_disp_cb->bl_sleep(msg->delay);
+}
+
+static int dsi_get_rate(struct bl_display *display)
+{
+	return DSI_RATE(display->dif.u.dsi.n, display->dif.u.dsi.m);
+}
+
+static int dsi_get_bllp(struct bl_display *display,
+			int nlines, int bytes, int clk,
+			int fps, int bitrate, int nlanes,
+			int *bllp_time, int *line_time)
+{
+	/* bits per frames */
+	unsigned int bitpframe = bytes * nlines * 8;
+	/* maximum framerate */
+	unsigned int maxfrate = bitrate * nlanes / bitpframe;
+	/* shortest line time */
+	unsigned int slt = NSEC_PER_SEC / maxfrate / nlines;
+	/* target line time */
+	unsigned int tlt = NSEC_PER_SEC / (fps + 1) / nlines;
+	/* clock cycle duration in ps */
+	unsigned int clk_time = 1000000 / (clk/1000000);
+
+	if (display->dif.u.dsi.video_mode == DSI_BURST)
+		*bllp_time = ((tlt - slt) * 1000) / clk_time;
+	else
+		*bllp_time = 0;
+
+	*line_time = tlt * 1000 / clk_time;
+
+	DSI_DBG2("%d bytes / %d lines\n", bytes, nlines);
+	DSI_DBG2("bits / frame = %d bits\n", bitpframe);
+	DSI_DBG2("fps target %d fps (max=%d)\n", fps, maxfrate);
+	DSI_DBG2("active time  = %d ns\n", slt);
+	DSI_DBG2("target time  = %d ns\n", tlt);
+	DSI_DBG2("clock cycle  = %d\n", clk_time);
+	DSI_DBG2("bllp_time 0x%08x(%d)\n", *bllp_time, *bllp_time);
+	DSI_DBG2("line_time 0x%08x(%d)\n", *line_time, *line_time);
+
+	if (fps >= maxfrate) {
+		DSI_ERR("target framerate(%d) cannot be reached, maxfrate %d",
+				fps, maxfrate);
+		*bllp_time = 0;
+		return 0;
+	}
+
+	return 0;
+}
+
+static int dsi_configure_video_mode(struct bl_display *display,
+				    int stride, int nlines)
+{
+	unsigned int vid0, vid1, vid2, vid3, vid4, vid5, vid6;
+	struct bl_display_if_mipi_dsi *dif = &display->dif.u.dsi;
+
+	if (dif->mode != DSI_VIDEO) {
+		DSI_ERR("%s: not video mode\n", __func__);
+		return -1;
+	}
+
+	dsi_get_bllp(display,
+		     nlines + dif->vfp + dif->vbp + dif->vsa,
+		     stride + dif->hfp + dif->hbp,
+		     dif->dc_clk_rate,
+		     display->fps,
+		     dsi_get_rate(display),
+		     dif->nblanes, &dif->bllp_time, &dif->line_time);
+
+	vid0 =	BITFLDS(EXR_DSI_VID0_HFP, (!!dif->hfp))|
+		BITFLDS(EXR_DSI_VID0_HBP, (!!dif->hbp))|
+		BITFLDS(EXR_DSI_VID0_HSA, (!!dif->hsa))|
+		BITFLDS(EXR_DSI_VID0_HFP_LP, dif->hfp_lp)|
+		BITFLDS(EXR_DSI_VID0_HBP_LP, dif->hbp_lp)|
+		BITFLDS(EXR_DSI_VID0_HSA_LP, dif->hsa_lp)|
+		BITFLDS(EXR_DSI_VID0_HFP_BYTES, dif->hfp)|
+		BITFLDS(EXR_DSI_VID0_HBP_BYTES, dif->hbp)|
+		BITFLDS(EXR_DSI_VID0_HSA_BYTES, dif->hsa);
+
+	vid1 =	BITFLDS(EXR_DSI_VID1_VACT_LINES, nlines)|
+		BITFLDS(EXR_DSI_VID1_MODE, dif->video_mode)|
+		BITFLDS(EXR_DSI_VID1_ID, dif->id)|
+		BITFLDS(EXR_DSI_VID1_PIXEL, dif->video_pixel)|
+		BITFLDS(EXR_DSI_VID1_FILL_BUFFER_TO, 0xFF);
+
+	vid2 =	BITFLDS(EXR_DSI_VID2_VFP, dif->vfp)|
+		BITFLDS(EXR_DSI_VID2_VBP, dif->vbp)|
+		BITFLDS(EXR_DSI_VID2_VSA, dif->vsa);
+
+	vid3 =	BITFLDS(EXR_DSI_VID3_PIXEL_BYTES, stride)|
+		BITFLDS(EXR_DSI_VID3_PIXEL_PACKETS, 1);
+
+	vid4 =	BITFLDS(EXR_DSI_VID4_BLANK_BYTES, stride)|
+		BITFLDS(EXR_DSI_VID4_BLANK_PACKETS, 0);
+
+	vid5 =	BITFLDS(EXR_DSI_VID5_LINE_TIME, dif->line_time)|
+		BITFLDS(EXR_DSI_VID5_BLLP_TIME, dif->bllp_time);
+
+	vid6 =	BITFLDS(EXR_DSI_VID6_LAST_BLANK, stride)|
+		BITFLDS(EXR_DSI_VID6_LAST_PIXEL, stride);
+
+	TRACE_BL_DISPLAY_PRINTF(
+		"MIPI-DSI video:0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x)",
+		vid0, vid1, vid2, vid3, vid4, vid5, vid6);
+
+	dsi_write_field(EXR_DSI_VID0, vid0);
+	dsi_write_field(EXR_DSI_VID1, vid1);
+	dsi_write_field(EXR_DSI_VID2, vid2);
+	dsi_write_field(EXR_DSI_VID3, vid3);
+	dsi_write_field(EXR_DSI_VID4, vid4);
+	dsi_write_field(EXR_DSI_VID5, vid5);
+	dsi_write_field(EXR_DSI_VID6, vid6);
+
+	return 0;
+}
+
+static void dsi_frame_prepare(struct bl_display *display,
+			      int stride, int nlines)
+{
+	struct display_msg *msg;
+	unsigned int dsicfg;
+
+	msg = display->msgs_update;
+
+	if (!msg) {
+		DSI_DBG2("no msg for update command\n");
+		return;
+	}
+	dsicfg = DSI_CFG_TX_HS_PIXEL(display->dif.u.dsi.nblanes,
+				     display->dif.u.dsi.mode);
+
+	if (display->dif.u.dsi.mode == DSI_VIDEO)
+		return;
+}
+
+/**
+ * Callbacks
+ */
+static void dsi_set_phy(struct bl_display *display, int on)
+{
+	unsigned int phy0 = 0, phy1 = 0, phy2 = 0, phy3 = 0, stat = 0, pllstat;
+	struct bl_display_if_mipi_dsi *dif = &display->dif.u.dsi;
+
+	if (!on) {
+		phy0 = BITFLDS(EXR_DSI_PHY0_SHARE, 0x0) |
+			BITFLDS(EXR_DSI_PHY0_M, 0) |
+			BITFLDS(EXR_DSI_PHY0_N, 0xFF) |
+			BITFLDS(EXR_DSI_PHY0_POWERUP, dif->pwup) |
+			BITFLDS(EXR_DSI_PHY0_CALIB, dif->calib) |
+			BITFLDS(EXR_DSI_PHY0_TO_LP_HS_REQ,
+				dif->to_lp_hs_req);
+	} else {
+		phy0 = BITFLDS(EXR_DSI_PHY0_SHARE, 0x0) |
+			BITFLDS(EXR_DSI_PHY0_M, dif->m) |
+			BITFLDS(EXR_DSI_PHY0_N, dif->n) |
+			BITFLDS(EXR_DSI_PHY0_POWERUP, dif->pwup) |
+			BITFLDS(EXR_DSI_PHY0_CALIB, dif->calib) |
+			BITFLDS(EXR_DSI_PHY0_TO_LP_HS_REQ,
+				dif->to_lp_hs_req);
+	}
+
+	phy1 =	BITFLDS(EXR_DSI_PHY1_TO_LP_HS_DIS,
+			dif->to_lp_hs_dis) |
+		BITFLDS(EXR_DSI_PHY1_TO_LP_EOT,
+			dif->to_lp_hs_eot) |
+		BITFLDS(EXR_DSI_PHY1_TO_HS_ZERO,
+			dif->to_hs_zero) |
+		BITFLDS(EXR_DSI_PHY1_TO_HS_FLIP,
+			dif->to_hs_flip) |
+		BITFLDS(EXR_DSI_PHY1_LP_CLK_DIV,
+			dif->lp_clk_div);
+
+	phy2 =	BITFLDS(EXR_DSI_PHY2_HS_CLK_PRE,
+			dif->to_hs_clk_pre) |
+		BITFLDS(EXR_DSI_PHY2_HS_CLK_POST,
+			dif->to_hs_clk_post) |
+		BITFLDS(EXR_DSI_PHY2_DAT_DELAY,
+			dif->data_delay) |
+		BITFLDS(EXR_DSI_PHY2_CLK_DELAY,
+			dif->clock_delay) |
+		BITFLDS(EXR_DSI_PHY2_LPTX_TFALL,
+			dif->lp_tx_tfall);
+
+	phy3 =	BITFLDS(EXR_DSI_PHY3_EN, 0x1) |
+		BITFLDS(EXR_DSI_PHY3_LPTX_TRISE,
+			dif->lp_tx_trise) |
+		BITFLDS(EXR_DSI_PHY3_LPTX_VREF,
+			dif->lp_tx_vref);
+
+	TRACE_BL_DISPLAY_PRINTF("MIPI-DSI @%d bps (%d,%d): 0x%08x 0x%08x 0x%08x 0x%08x)",
+		 dsi_get_rate(display),
+		 dif->n, dif->m,
+		 phy0, phy1, phy2, phy3);
+
+	dsi_write_field(EXR_DSI_PHY0, phy0);
+	dsi_write_field(EXR_DSI_PHY1, phy1);
+	dsi_write_field(EXR_DSI_PHY2, phy2);
+	dsi_write_field(EXR_DSI_PHY3, phy3);
+
+	if (on) {
+		/* wait for PLL lock */
+		dsi_wait_status(EXR_DSI_STAT_DSI_LOCK, 1, 1, 0, 1000);
+	}
+}
+
+int dsi_set_phy_lock(struct bl_display *display)
+{
+	/* need_to_modify
+	struct vop_drvdata *pdata = m_to_vopdata(display, display);
+	if (down_interruptible(&pdata->sem))
+		return -ERESTARTSYS;
+	*/
+	dsi_set_phy(display, 1);
+
+	/* need_to_modify
+	up(&pdata->sem);
+	*/
+	return 0;
+}
+
+static void dsi_send_msglist(struct bl_display *display,
+			     struct display_msg **msgs,
+			     bl_display_cbs_t *bl_display_cb)
+{
+	int i = 0;
+
+	while (msgs[i]) {
+		bl_display_cb->bl_sleep(1);
+		dsi_send_cmd(display, msgs[i], bl_display_cb);
+		/* Next msg from tab */
+		i++;
+	}
+}
+
+static int dsi_panel_init(struct bl_display *display, bl_display_cbs_t *bl_display_cb)
+{
+	struct display_msg **msgs = display->msgs_init;
+
+	if (msgs)
+		dsi_send_msglist(display, msgs, bl_display_cb);
+
+	return 0;
+}
+
+static int dsi_panel_sleep_out(struct bl_display *display, bl_display_cbs_t *bl_display_cb)
+{
+	struct display_msg **msgs = display->msgs_sleep_out;
+
+	if (msgs)
+		dsi_send_msglist(display, msgs, bl_display_cb);
+
+	return 0;
+}
+
+static int dsi_stop(struct bl_display *display)
+{
+	/* swicth off PLL */
+	dsi_set_phy(display, 0);
+	/* switch off phy */
+	dsi_write_field(EXR_DSI_PHY3,
+			BITFLDS(EXR_DSI_PHY3_EN, 0x0));
+	/* switch off DSI block */
+	dsi_write_field(EXR_DSI_CFG, DSI_CFG_OFF(DSI_CMD));
+
+	dsi_write_field(EXR_DSI_CLC,
+			BITFLDS(EXR_DSI_CLC_RUN, DSI_MODE_CONF));
+
+	return 0;
+}
+
+static int dsi_init(struct bl_display *display)
+{
+	unsigned int stat, clcstat;
+
+	dsi_write_field(EXR_DSI_CLC,
+			BITFLDS(EXR_DSI_CLC_RUN, DSI_MODE_RUN));
+
+	clcstat = BITFLDS(EXR_DSI_CLC_STAT_RUN, 1) |
+		BITFLDS(EXR_DSI_CLC_STAT_MODEN, 1) |
+		BITFLDS(EXR_DSI_CLC_STAT_KID, 1);
+	dsi_wait_status(EXR_DSI_CLC_STAT, clcstat, clcstat, 0, 1000);
+	dsi_write_field(EXR_DSI_CLK, 0x000F000F);
+	dsi_write_field(EXR_DSI_TO0, 0);
+	dsi_write_field(EXR_DSI_TO1, 0);
+	dsi_write_field(EXR_DSI_CFG, DSI_CFG_RX_LP_STP(1));
+
+	return 0;
+}
+
+static void dsi_config(struct bl_display *display, int type)
+{
+	unsigned int dsicfg;
+
+	if (type == DIF_TX_DATA) {
+		dsi_write_field(EXR_DSI_CFG, DSI_CFG_OFF(DSI_CMD));
+		dsi_set_phy(display, 1);
+		dsi_write_field(EXR_DSI_CFG,
+				DSI_CFG_INIT(display->dif.u.dsi.nblanes));
+		return;
+	}
+
+	dsi_write_field(EXR_DSI_CFG, DSI_CFG_OFF(DSI_VIDEO));
+	dsi_configure_video_mode(display, PIXELS_TO_BYTES(display->xres, display->bpp),
+				 display->yres);
+	dsi_set_phy(display, 1);
+	dsicfg = DSI_CFG_TX_HS_PIXEL(display->dif.u.dsi.nblanes, display->dif.u.dsi.mode);
+	dsi_write_field(EXR_DSI_CFG, dsicfg);
+	TRACE_BL_DISPLAY_PRINTF("MIPI-DSI video: dsicfg 0x%08x", dsicfg);
+}
+
+static void dsi_dphy_calculation(struct bl_display *display)
+{
+	int ui_ps = 0, ths_prepare_ns, ths_trail_ns, ths_prepare_zero_ns,
+		tclk_post_ns, tclk_prepare_ns;
+	struct bl_display_if_mipi_dsi *dif = &display->dif.u.dsi;
+
+	if (dif->brdef)
+		ui_ps = DIV_ROUND_CLOSEST(1000000000,
+					  dif->brdef / 1000);
+
+	/*
+	 * THS-PREPARE is between 40ns + 4UI and 85ns + 6UI, we set the THS-PREPARE
+	 * to average of THS-PREPARE.
+	 * THS-PREPARE = (40ns + 4UI + 85ns + 6UI) / 2 = 62.5ns + 5UI
+	 */
+	ths_prepare_ns = DIV_ROUND_CLOSEST(62500 + 5 * ui_ps, 1000);
+
+	/*
+	 * THS-TRAIL is 60ns + 4UI, we set THS-TRAIL to 63ns + 4UI for safety
+	 * margin.
+	 */
+	ths_trail_ns = DIV_ROUND_UP(63000 + 4 * ui_ps, 1000);
+
+	/*
+	 * THS-PREPARE + THS-ZERO is 145ns + 10UI, we set THS-PREPARE + THS-ZERO
+	 * to 152.25ns + 11UI for safety margin.
+	 */
+	ths_prepare_zero_ns = DIV_ROUND_UP(152250 + 11 * ui_ps, 1000);
+
+	/*
+	 * TCLK-POST is 60ns + 52UI, we set TCLK-POST to 63ns + 55UI for safety
+	 * margin.
+	 */
+	tclk_post_ns = DIV_ROUND_UP(63000 + 55 * ui_ps, 1000);
+
+	/*
+	 * TCLK-PREPARE is between 38ns and 95ns, we set TCLK-PREPARE to average
+	 * of TCLK-PREPARE 67.
+	 * margin.
+	 */
+	tclk_prepare_ns = 67;
+
+	dif->pwup = 6;
+	dif->calib = 3;
+	dif->data_delay = 7;
+	dif->clock_delay = 7;
+	dif->lp_tx_tfall = 2;
+	dif->lp_tx_trise = 2;
+	dif->lp_tx_vref = 31;
+	dif->lp_clk_div =
+		DIV_ROUND_UP(dif->dc_clk_rate / 1000 * TLPX_NS,
+			     1000000) - 1;
+	dif->to_lp_hs_req = dif->lp_clk_div;
+	dif->to_hs_flip =
+		DIV_ROUND_UP(dif->brdef /
+			     1000 * ths_trail_ns, 1000000 * 8);
+	dif->to_hs_zero =
+		DIV_ROUND_UP(dif->brdef /
+			     1000 * ths_prepare_zero_ns, 1000000 * 8) - 5;
+	dif->to_lp_hs_eot =
+		DIV_ROUND_UP(dif->dc_clk_rate / 1000 *
+		(ths_trail_ns + 18), 1000000) + DIV_ROUND_UP(3000000,
+		dif->brdef / 1000);
+	dif->to_lp_hs_dis =
+		DIV_ROUND_UP(dif->dc_clk_rate / 1000 *
+			     ths_prepare_ns, 1000000) - 1;
+	dif->to_hs_clk_post =
+		DIV_ROUND_UP(dif->dc_clk_rate / 1000 * tclk_post_ns,
+			     1000000);
+	dif->to_hs_clk_pre =
+		DIV_ROUND_UP(dif->dc_clk_rate / 1000 *
+			     tclk_prepare_ns, 1000000) + 5;
+}
+
+static void dsi_rate_calculation(struct bl_display *display)
+{
+	int diff, diff_min = DSI_RATE_MAX, n = 0, m = 0;
+	struct bl_display_if_mipi_dsi *dif = &display->dif.u.dsi;
+
+	dif->brdef = DSI_RATE_OVERHEAD((display->xres +
+		BYTES_TO_PIXELS(dif->hfp, display->bpp) +
+		BYTES_TO_PIXELS(dif->hbp, display->bpp) +
+		BYTES_TO_PIXELS(dif->hsa, display->bpp)) *
+		(display->yres + dif->vfp +
+		dif->vbp + dif->vbp + dif->vsa) *
+		display->fps / dif->nblanes * display->bpp);
+
+	if (dif->brdef > DSI_RATE_MAX)
+		dif->brdef = DSI_RATE_MAX;
+	else if (dif->brdef < DSI_RATE_MIN)
+		dif->brdef = DSI_RATE_MIN;
+
+	for (m = 1; m <= DSI_RATE_M_MAX; m++) {
+		for (n = 1; n <= DSI_RATE_N_MAX; n++) {
+			diff = DSI_RATE(n, m) - dif->brdef;
+
+			if (diff < 0)
+				continue;
+
+			if (diff < diff_min) {
+				diff_min = diff;
+				dif->n = n;
+				dif->m = m;
+			}
+		}
+	}
+}
+
+static void dma_reset(struct bl_display *display, bl_display_cbs_t *bl_disp_cb)
+{
+	*((volatile int *)0xe4801000) = 0x20;
+	bl_disp_cb->bl_sleep(1);
+	*((volatile int *)0xe4801004) = 0x20;
+}
+
+static void dsi_reset(struct bl_display *display, bl_display_cbs_t *bl_disp_cb)
+{
+	setScu_SET_RSTMODS1_DSIRST(&scu, 1);
+	bl_disp_cb->bl_sleep(1); /* 10us */
+	setScu_CLR_RSTMODS1_DSIRST(&scu, 1);
+	bl_disp_cb->bl_sleep(8); /* 8ms */
+}
+
+static int dsi_enable(struct bl_malidp *malidp)
+{
+	struct bl_display *display = (struct bl_display *)malidp->disp_par;
+
+	dma_reset(display, malidp->ctrl_ops);
+	dsi_reset(display, malidp->ctrl_ops);
+	dsi_init(display);
+	dsi_config(display, DIF_TX_DATA);
+
+	dsi_panel_init(display, malidp->ctrl_ops);
+	dsi_panel_sleep_out(display, malidp->ctrl_ops);
+
+	dsi_config(display, DIF_TX_PIXELS);
+
+	return 0;
+}
+
+static struct bl_malidp_trsm_drv_ops dsi_drv_ops = {
+	.enable = dsi_enable,
+};
+
+int dsi_probe(struct bl_malidp *malidp)
+{
+	struct bl_display *display = (struct bl_display *)malidp->disp_par;
+
+	disp_ctrl_ops = malidp->ctrl_ops;
+	malidp->trsm_ops = &dsi_drv_ops;
+
+	display->fps = display->dif.u.dsi.fps;
+	if (display->fps < 20 || display->fps > 100) {
+		TRACE_BL_DISPLAY_PRINTF("DSI: invalid fps %d, set to default", display->fps);
+		display->fps = 60;
+	}
+	g_dsi_cfg_eot = (display->dif.u.dsi.eot)?1:0;
+	g_dsi_cfg_gate = (display->dif.u.dsi.gate)?1:0;
+	display->xres = malidp->panel->timing.xres;
+	display->yres = malidp->panel->timing.yres;
+	display->dif.u.dsi.brmin = 104000000;
+	display->dif.u.dsi.brmax = DSI_RATE_MAX;
+
+	if (malidp->panel->lcd_face == OUT_P565) {
+		display->bpp = 16;
+		display->dif.u.dsi.video_pixel = DSI_PIX_BIT16P;
+	} else if (malidp->panel->lcd_face == OUT_P666) {
+		display->bpp = 18;
+		display->dif.u.dsi.video_pixel = DSI_PIX_BIT18P;
+	} else {
+		display->bpp = 24;
+		display->dif.u.dsi.video_pixel = DSI_PIX_BIT24P;
+	}
+
+	dsi_rate_calculation(display);
+	dsi_dphy_calculation(display);
+
+	return 0;
+}
diff --git a/devices/malidp/src/sofia3gx/dsi_hwregs.c b/devices/malidp/src/sofia3gx/dsi_hwregs.c
new file mode 100644
index 0000000..ba807e2
--- /dev/null
+++ b/devices/malidp/src/sofia3gx/dsi_hwregs.c
@@ -0,0 +1,349 @@
+/* ----------------------------------------------------------------------------
+   Copyright (C) 2013-2014 Intel Mobile Communications GmbH
+
+   Sec Class: Intel Confidential (IC)
+
+   All rights reserved.
+   ----------------------------------------------------------------------------
+   This document contains proprietary information belonging to IMC.
+   Passing on and copying of this document, use
+   and communication of its contents is not permitted without prior written
+   authorisation.
+  ---------------------------------------------------------------------------*/
+
+#include <linux/types.h>
+#include <linux/types.h>
+#include <linux/time.h>
+
+#include "dsi_hwregs.h"
+
+#define regbase		0xE1080000
+#define DSI_WR_REG(val, addr)	(*((volatile unsigned int *)(addr)) = (val))
+#define DSI_RD_REG(addr)	(*((volatile unsigned int *)(addr)))
+
+#define EXTREG(_id_, _addr_, _mask_, _shift_) \
+	{#_id_, _addr_, _mask_, _shift_}
+
+/*external registers*/
+struct dsi_command dsi_regs[] = {
+	/*-------------------------------------------------------*/
+	/*      EXTERNAL REGISTERS                                   */
+	/*-------------------------------------------------------*/
+[EXR_DSI_CLC] =
+	EXTREG(EXR_DSI_CLC, DSI_CLC, 0xFFFFFFFF, 0),
+[EXR_DSI_CLC_RUN] =
+	EXTREG(EXR_DSI_CLC_RUN, DSI_CLC, 0x3, 0),
+[EXR_DSI_CLC_STAT] =
+	EXTREG(EXR_DSI_CLC_STAT, DSI_CLC_STAT, 0xFFFFFFFF, 0),
+[EXR_DSI_CLC_STAT_RUN] =
+	EXTREG(EXR_DSI_CLC_STAT_RUN, DSI_CLC_STAT, 0x1, 0),
+[EXR_DSI_CLC_STAT_MODEN] =
+	EXTREG(EXR_DSI_CLC_STAT_MODEN, DSI_CLC_STAT, 0x1, 1),
+[EXR_DSI_CLC_STAT_KID] =
+	EXTREG(EXR_DSI_CLC_STAT_KID, DSI_CLC_STAT, 0x1, 7),
+[EXR_DSI_ID] =
+	EXTREG(EXR_DSI_ID, DSI_ID, 0xFFFFFFFF, 0),
+[EXR_DSI_FIFO_ID] =
+	EXTREG(EXR_DSI_FIFO_ID, DSI_FIFO_ID, 0xFFFFFFFF, 0),
+[EXR_DSI_SRB_MSCONF_ID] =
+	EXTREG(EXR_DSI_SRB_MSCONF_ID, DSI_SRB_MSCONF_ID, 0xFFFFFFFF, 0),
+[EXR_DSI_SWCID] =
+	EXTREG(EXR_DSI_SWCID, DSI_SWCID, 0xFFFFFFFF, 0),
+[EXR_DSI_FIFO_CFG] =
+	EXTREG(EXR_DSI_FIFO_CFG, DSI_FIFO_CFG, 0xFFFFFFFF, 0),
+[EXR_DSI_FIFO_CTRL] =
+	EXTREG(EXR_DSI_FIFO_CTRL, DSI_FIFO_CTRL, 0xFFFFFFFF, 0),
+[EXR_DSI_MRPS_CTRL] =
+	EXTREG(EXR_DSI_MRPS_CTRL, DSI_MRPS_CTRL, 0xFFFFFFFF, 0),
+[EXR_DSI_RPS_STAT] =
+	EXTREG(EXR_DSI_RPS_STAT, DSI_RPS_STAT, 0xFFFFFFFF, 0),
+[EXR_DSI_TPS_CTRL] =
+	EXTREG(EXR_DSI_TPS_CTRL, DSI_TPS_CTRL, 0xFFFFFFFF, 0),
+[EXR_DSI_TPS_CTRL_TPS] =
+	EXTREG(EXR_DSI_TPS_CTRL_TPS, DSI_TPS_CTRL, 0xFFFF, 0),
+[EXR_DSI_FIFO_STAT] =
+	EXTREG(EXR_DSI_FIFO_STAT, DSI_FIFO_STAT, 0xFFFFFFFF, 0),
+[EXR_DSI_FIFO_STAT_RXFFS] =
+	EXTREG(EXR_DSI_FIFO_STAT_RXFFS, DSI_FIFO_STAT, 0xFF, 0),
+[EXR_DSI_RIS] =
+	EXTREG(EXR_DSI_RIS, DSI_RIS, 0xFFFFFFFF, 0),
+[EXR_DSI_IMSC] =
+	EXTREG(EXR_DSI_IMSC, DSI_IMSC, 0xFFFFFFFF, 0),
+[EXR_DSI_MIS] =
+	EXTREG(EXR_DSI_MIS, DSI_MIS, 0xFFFFFFFF, 0),
+[EXR_DSI_ISR] =
+	EXTREG(EXR_DSI_ISR, DSI_ISR, 0xFFFFFFFF, 0),
+[EXR_DSI_DMAE] =
+	EXTREG(EXR_DSI_DMAE, DSI_DMAE, 0xFFFFFFFF, 0),
+[EXR_DSI_ICR] =
+	EXTREG(EXR_DSI_ICR, DSI_ICR, 0xFFFFFFFF, 0),
+[EXR_DSI_CFG] =
+	EXTREG(EXR_DSI_CFG, DSI_CFG, 0xFFFFFFFF, 0),
+[EXR_DSI_CFG_CFG_LAT] =
+	EXTREG(EXR_DSI_CFG_CFG_LAT, DSI_CFG, 0x1, 0),
+[EXR_DSI_CFG_HEAD_LAT] =
+	EXTREG(EXR_DSI_CFG_HEAD_LAT, DSI_CFG, 0x1, 1),
+[EXR_DSI_CFG_GATE] =
+	EXTREG(EXR_DSI_CFG_GATE, DSI_CFG, 0x1, 2),
+[EXR_DSI_CFG_TX] =
+	EXTREG(EXR_DSI_CFG_TX, DSI_CFG, 0x1, 3),
+[EXR_DSI_CFG_LP] =
+	EXTREG(EXR_DSI_CFG_LP, DSI_CFG, 0x1, 4),
+[EXR_DSI_CFG_MODE] =
+	EXTREG(EXR_DSI_CFG_MODE, DSI_CFG, 0x1, 5),
+[EXR_DSI_CFG_EOT] =
+	EXTREG(EXR_DSI_CFG_EOT, DSI_CFG, 0x1, 6),
+[EXR_DSI_CFG_TURN] =
+	EXTREG(EXR_DSI_CFG_TURN, DSI_CFG, 0x1, 7),
+[EXR_DSI_CFG_VALID] =
+	EXTREG(EXR_DSI_CFG_VALID, DSI_CFG, 0x1, 8),
+[EXR_DSI_CFG_DATA] =
+	EXTREG(EXR_DSI_CFG_DATA, DSI_CFG, 0x1, 9),
+[EXR_DSI_CFG_STP] =
+	EXTREG(EXR_DSI_CFG_STP, DSI_CFG, 0x1, 10),
+[EXR_DSI_CFG_ULPS] =
+	EXTREG(EXR_DSI_CFG_ULPS, DSI_CFG, 0x1, 11),
+[EXR_DSI_CFG_EN] =
+	EXTREG(EXR_DSI_CFG_EN,	DSI_CFG, 0x1, 12),
+[EXR_DSI_CFG_LANES] =
+	EXTREG(EXR_DSI_CFG_LANES, DSI_CFG, 0x3, 13),
+[EXR_DSI_CFG_ID] =
+	EXTREG(EXR_DSI_CFG_ID,	DSI_CFG, 0x3, 15),
+[EXR_DSI_CFG_TXS] =
+	EXTREG(EXR_DSI_CFG_TXS,	DSI_CFG, 0x1, 17),
+[EXR_DSI_CFG_TE] =
+	EXTREG(EXR_DSI_CFG_TE,	DSI_CFG, 0x1, 18),
+[EXR_DSI_CFG_FIN] =
+	EXTREG(EXR_DSI_CFG_FIN,	DSI_CFG, 0x1, 19),
+[EXR_DSI_CFG_VSYNC] =
+	EXTREG(EXR_DSI_CFG_VSYNC,	DSI_CFG, 0x1, 24),
+[EXR_DSI_CFG_PSYNC] =
+	EXTREG(EXR_DSI_CFG_PSYNC,	DSI_CFG, 0x1, 25),
+[EXR_DSI_CFG_SOURCE] =
+	EXTREG(EXR_DSI_CFG_SOURCE,	DSI_CFG, 0x1, 31),
+[EXR_DSI_CLK] =
+	EXTREG(EXR_DSI_CLK, DSI_CLK, 0xFFFFFFFF, 0),
+[EXR_DSI_HEAD] =
+	EXTREG(EXR_DSI_HEAD, DSI_HEAD, 0xFFFFFFFF, 0),
+[EXR_DSI_HEAD_HEADER] =
+	EXTREG(EXR_DSI_HEAD_HEADER, DSI_HEAD, 0xFF, 0),
+[EXR_DSI_HEAD_WCNT] =
+	EXTREG(EXR_DSI_HEAD_WCNT, DSI_HEAD, 0xFFFF, 8),
+[EXR_DSI_HEAD_CMD] =
+	EXTREG(EXR_DSI_HEAD_CMD, DSI_HEAD, 0xFF, 24),
+[EXR_DSI_TO0] =
+	EXTREG(EXR_DSI_TO0, DSI_TO0, 0xFFFFFFFF, 0),
+[EXR_DSI_TO1] =
+	EXTREG(EXR_DSI_TO1, DSI_TO1, 0xFFFFFFFF, 0),
+[EXR_DSI_VID0] =
+	EXTREG(EXR_DSI_VID0, DSI_VID0, 0xFFFFFFFF, 0),
+[EXR_DSI_VID0_HFP_BYTES] =
+	EXTREG(EXR_DSI_VID0_HFP_BYTES, DSI_VID0, 0xFF, 0),
+[EXR_DSI_VID0_HBP_BYTES] =
+	EXTREG(EXR_DSI_VID0_HBP_BYTES, DSI_VID0, 0xFF, 8),
+[EXR_DSI_VID0_HSA_BYTES] =
+	EXTREG(EXR_DSI_VID0_HSA_BYTES, DSI_VID0, 0xFF, 16),
+[EXR_DSI_VID0_HFP] =
+	EXTREG(EXR_DSI_VID0_HFP, DSI_VID0, 0x1, 24),
+[EXR_DSI_VID0_HBP] =
+	EXTREG(EXR_DSI_VID0_HBP, DSI_VID0, 0x1, 25),
+[EXR_DSI_VID0_HSA] =
+	EXTREG(EXR_DSI_VID0_HSA, DSI_VID0, 0x1, 26),
+[EXR_DSI_VID0_HFP_LP] =
+	EXTREG(EXR_DSI_VID0_HFP_LP, DSI_VID0, 0x1, 27),
+[EXR_DSI_VID0_HBP_LP] =
+	EXTREG(EXR_DSI_VID0_HBP_LP, DSI_VID0, 0x1, 28),
+[EXR_DSI_VID0_HSA_LP] =
+	EXTREG(EXR_DSI_VID0_HSA_LP, DSI_VID0, 0x1, 29),
+[EXR_DSI_VID1] =
+	EXTREG(EXR_DSI_VID1, DSI_VID1, 0xFFFFFFFF, 0),
+[EXR_DSI_VID1_VACT_LINES] =
+	EXTREG(EXR_DSI_VID1_VACT_LINES, DSI_VID1, 0xFFF, 0),
+[EXR_DSI_VID1_MODE] =
+	EXTREG(EXR_DSI_VID1_MODE, DSI_VID1, 0x3, 12),
+[EXR_DSI_VID1_ID] =
+	EXTREG(EXR_DSI_VID1_ID, DSI_VID1, 0x3, 14),
+[EXR_DSI_VID1_PIXEL] =
+	EXTREG(EXR_DSI_VID1_PIXEL, DSI_VID1, 0x3, 16),
+[EXR_DSI_VID1_FILL_BUFFER_TO] =
+	EXTREG(EXR_DSI_VID1_FILL_BUFFER_TO, DSI_VID1, 0x3FF, 18),
+[EXR_DSI_VID1_LAST_CS] =
+	EXTREG(EXR_DSI_VID1_LAST_CS, DSI_VID1, 0xF, 28),
+[EXR_DSI_VID2] =
+	EXTREG(EXR_DSI_VID2, DSI_VID2, 0xFFFFFFFF, 0),
+[EXR_DSI_VID2_VFP] =
+	EXTREG(EXR_DSI_VID2_VFP, DSI_VID2, 0xFF, 0),
+[EXR_DSI_VID2_VBP] =
+	EXTREG(EXR_DSI_VID2_VBP, DSI_VID2, 0xFF, 8),
+[EXR_DSI_VID2_VSA] =
+	EXTREG(EXR_DSI_VID2_VSA, DSI_VID2, 0xFF, 16),
+[EXR_DSI_VID3] =
+	EXTREG(EXR_DSI_VID3, DSI_VID3, 0xFFFFFFFF, 0),
+[EXR_DSI_VID3_PIXEL_PACKETS] =
+	EXTREG(EXR_DSI_VID3_PIXEL_PACKETS, DSI_VID3, 0xFFFF, 0),
+[EXR_DSI_VID3_PIXEL_BYTES] =
+	EXTREG(EXR_DSI_VID3_PIXEL_BYTES, DSI_VID3, 0xFFFF, 16),
+[EXR_DSI_VID4] =
+	EXTREG(EXR_DSI_VID4, DSI_VID4, 0xFFFFFFFF, 0),
+[EXR_DSI_VID4_BLANK_PACKETS] =
+	EXTREG(EXR_DSI_VID4_BLANK_PACKETS, DSI_VID4, 0xFFFF, 0),
+[EXR_DSI_VID4_BLANK_BYTES] =
+	EXTREG(EXR_DSI_VID4_BLANK_BYTES, DSI_VID4, 0xFFFF, 16),
+[EXR_DSI_VID5] =
+	EXTREG(EXR_DSI_VID5, DSI_VID5, 0xFFFFFFFF, 0),
+[EXR_DSI_VID5_LINE_TIME] =
+	EXTREG(EXR_DSI_VID5_LINE_TIME, DSI_VID5, 0xFFFF, 0),
+[EXR_DSI_VID5_BLLP_TIME] =
+	EXTREG(EXR_DSI_VID5_BLLP_TIME, DSI_VID5, 0xFFFF, 16),
+[EXR_DSI_VID6] =
+	EXTREG(EXR_DSI_VID6, DSI_VID6, 0xFFFFFFFF, 0),
+[EXR_DSI_VID6_LAST_BLANK] =
+	EXTREG(EXR_DSI_VID6_LAST_BLANK, DSI_VID6, 0xFFFF, 0),
+[EXR_DSI_VID6_LAST_PIXEL] =
+	EXTREG(EXR_DSI_VID6_LAST_PIXEL, DSI_VID6, 0xFFFF, 16),
+[EXR_DSI_PHY0] =
+	EXTREG(EXR_DSI_PHY0, DSI_PHY0, 0xFFFFFFFF, 0),
+[EXR_DSI_PHY0_SHARE] =
+	EXTREG(EXR_DSI_PHY0_SHARE, DSI_PHY0, 0x1, 0),
+[EXR_DSI_PHY0_M] =
+	EXTREG(EXR_DSI_PHY0_M, DSI_PHY0, 0xF, 1),
+[EXR_DSI_PHY0_N] =
+	EXTREG(EXR_DSI_PHY0_N, DSI_PHY0, 0xFF, 5),
+[EXR_DSI_PHY0_POWERUP] =
+	EXTREG(EXR_DSI_PHY0_POWERUP, DSI_PHY0, 0x3F, 13),
+[EXR_DSI_PHY0_CALIB] =
+	EXTREG(EXR_DSI_PHY0_CALIB, DSI_PHY0, 0x3F, 19),
+[EXR_DSI_PHY0_TO_LP_HS_REQ] =
+	EXTREG(EXR_DSI_PHY0_TO_LP_HS_REQ, DSI_PHY0, 0x3F, 25),
+[EXR_DSI_PHY1] =
+	EXTREG(EXR_DSI_PHY1, DSI_PHY1, 0xFFFFFFFF, 0),
+[EXR_DSI_PHY1_TO_LP_HS_DIS] =
+	EXTREG(EXR_DSI_PHY1_TO_LP_HS_DIS, DSI_PHY1, 0x3F, 0),
+[EXR_DSI_PHY1_TO_LP_EOT] =
+	EXTREG(EXR_DSI_PHY1_TO_LP_EOT, DSI_PHY1, 0x3F, 6),
+[EXR_DSI_PHY1_TO_HS_ZERO] =
+	EXTREG(EXR_DSI_PHY1_TO_HS_ZERO, DSI_PHY1, 0x3F, 12),
+[EXR_DSI_PHY1_TO_HS_FLIP] =
+	EXTREG(EXR_DSI_PHY1_TO_HS_FLIP, DSI_PHY1, 0x3F, 18),
+[EXR_DSI_PHY1_LP_CLK_DIV] =
+	EXTREG(EXR_DSI_PHY1_LP_CLK_DIV, DSI_PHY1, 0x3F, 24),
+[EXR_DSI_PHY2] =
+	EXTREG(EXR_DSI_PHY2, DSI_PHY2, 0xFFFFFFFF, 0),
+[EXR_DSI_PHY2_HS_CLK_PRE] =
+	EXTREG(EXR_DSI_PHY2_HS_CLK_PRE, DSI_PHY2, 0x3FF, 0),
+[EXR_DSI_PHY2_HS_CLK_POST] =
+	EXTREG(EXR_DSI_PHY2_HS_CLK_POST, DSI_PHY2, 0x3FF, 10),
+[EXR_DSI_PHY2_DAT_DELAY] =
+	EXTREG(EXR_DSI_PHY2_DAT_DELAY, DSI_PHY2, 0xF, 20),
+[EXR_DSI_PHY2_CLK_DELAY] =
+	EXTREG(EXR_DSI_PHY2_CLK_DELAY, DSI_PHY2, 0xF, 24),
+[EXR_DSI_PHY2_LPTX_TFALL] =
+	EXTREG(EXR_DSI_PHY2_LPTX_TFALL, DSI_PHY2, 0x7, 28),
+[EXR_DSI_PHY3] =
+	EXTREG(EXR_DSI_PHY3, DSI_PHY3, 0xFFFFFFFF, 0),
+[EXR_DSI_PHY3_EN] =
+	EXTREG(EXR_DSI_PHY3_EN, DSI_PHY3, 0x1, 0),
+[EXR_DSI_PHY3_LPTX_TRISE] =
+	EXTREG(EXR_DSI_PHY3_LPTX_TRISE, DSI_PHY3, 0x7, 1),
+[EXR_DSI_PHY3_LPTX_VREF] =
+	EXTREG(EXR_DSI_PHY3_LPTX_VREF, DSI_PHY3, 0x1F, 4),
+[EXR_DSI_STAT] =
+	EXTREG(EXR_DSI_STAT, DSI_STAT, 0xFFFFFFFF, 0),
+[EXR_DSI_STAT_DSI_BSY] =
+	EXTREG(EXR_DSI_STAT_DSI_STAT, DSI_STAT, 0x1, 0),
+[EXR_DSI_STAT_DSI_FULL] =
+	EXTREG(EXR_DSI_STAT_DSI_FULL, DSI_STAT, 0x1, 2),
+[EXR_DSI_STAT_DSI_DIR] =
+	EXTREG(EXR_DSI_STAT_DSI_DIR, DSI_STAT, 0x1, 3),
+[EXR_DSI_STAT_DSI_LOCK] =
+	EXTREG(EXR_DSI_STAT_DSI_LOCK, DSI_STAT, 0x1, 4),
+[EXR_DSI_TXD] =
+	EXTREG(EXR_DSI_TXD, DSI_TXD, 0xFFFFFFFF, 0),
+[EXR_DSI_RXD] =
+	EXTREG(EXR_DSI_RXD, DSI_RXD, 0xFFFFFFFF, 0),
+};
+
+/**
+ * Reads DSI external register field value
+ */
+static unsigned int dsi_rdextfield(unsigned int id)
+{
+	unsigned int retval = 0, regval = 0;
+	struct dsi_command *cmd = &dsi_regs[id];
+
+	if (regbase)
+		regval = DSI_RD_REG(regbase + cmd->addr);
+	else
+		return -1;
+
+	retval = (regval >> cmd->shift) & cmd->mask;
+
+	return retval;
+}
+
+/**
+ * Write DSI external register field value
+ */
+static int dsi_wrextfield(unsigned int id, unsigned int val)
+{
+	unsigned int regval = 0;
+	struct dsi_command *cmd = &dsi_regs[id];
+
+	if (regbase) {
+		if (cmd->mask == 0xFFFFFFFF) {
+			DSI_WR_REG(val, regbase + cmd->addr);
+		} else {
+			val = (val << cmd->shift) & (cmd->mask << cmd->shift);
+			regval =
+			    DSI_RD_REG(regbase + cmd->addr)
+					& ~(cmd->mask << cmd->shift);
+
+			DSI_WR_REG(val | regval, regbase + cmd->addr);
+		}
+	} else {
+		return -1;
+	}
+
+	return 0;
+}
+
+/**
+ * Read DSI register
+ */
+int dsi_read_field(unsigned int id,
+		   unsigned int *reg_value)
+{
+	unsigned int retval = 0xDEADDEAD;
+
+	retval = dsi_rdextfield(id);
+
+	if (!retval)
+		goto error;
+
+	*reg_value = retval;
+	return 0;
+error:
+	return -1;
+}
+
+/**
+ * Write DSI register
+ */
+int
+dsi_write_field(unsigned int id, unsigned int val)
+{
+	int ret = 0;
+
+	ret = dsi_wrextfield(id, val);
+	return ret;
+}
+
+/**
+ * @brief Directly writes to hw (without using fifo)
+ * @param data 32 bit data to write to hwfifo
+ */
+static inline void
+dsi_wr_to_hwfifo(unsigned int data)
+{
+	dsi_wrextfield(EXR_DSI_TXD, data);
+}
diff --git a/devices/malidp/src/sofia3gx/dsi_hwregs.h b/devices/malidp/src/sofia3gx/dsi_hwregs.h
new file mode 100644
index 0000000..1ef5665
--- /dev/null
+++ b/devices/malidp/src/sofia3gx/dsi_hwregs.h
@@ -0,0 +1,260 @@
+/* ----------------------------------------------------------------------------
+   Copyright (C) 2013-2014 Intel Mobile Communications GmbH
+
+   Sec Class: Intel Confidential (IC)
+
+   All rights reserved.
+   ----------------------------------------------------------------------------
+   This document contains proprietary information belonging to IMC.
+   Passing on and copying of this document, use
+   and communication of its contents is not permitted without prior written
+   authorisation.
+  ---------------------------------------------------------------------------*/
+
+#ifndef __DSI_HWREGS_H__
+#define __DSI_HWREGS_H__
+
+/* register addresses external */
+/* external registers are all registers which can be accessed
+   directly via a specified address.
+   These are mainly DIF registers and gRacr control registers
+*/
+#define DSI_CLC               0x0
+#define DSI_CLC_STAT          0x8
+#define DSI_ID                0xC
+#define DSI_FIFO_ID           0x10
+#define DSI_SRB_MSCONF_ID     0x14
+#define DSI_SWCID             0x1C
+#define DSI_FIFO_CFG          0x30
+#define DSI_FIFO_CTRL         0x34
+#define DSI_MRPS_CTRL         0x38
+#define DSI_RPS_STAT          0x3C
+#define DSI_TPS_CTRL          0x40
+#define DSI_FIFO_STAT         0x44
+#define DSI_RIS               0x80
+#define DSI_IMSC              0x84
+#define DSI_MIS               0x88
+#define DSI_ISR               0x90
+#define DSI_DMAE              0x94
+#define DSI_ICR               0x98
+#define DSI_CFG               0x100
+#define DSI_CLK               0x104
+#define DSI_HEAD              0x108
+#define DSI_TO0               0x10C
+#define DSI_TO1               0x110
+#define DSI_VID0              0x114
+#define DSI_VID1              0x118
+#define DSI_VID2              0x11C
+#define DSI_VID3              0x120
+#define DSI_VID4              0x124
+#define DSI_VID5              0x128
+#define DSI_VID6              0x12C
+#define DSI_PHY0              0x130
+#define DSI_PHY1              0x134
+#define DSI_PHY2              0x138
+#define DSI_PHY3              0x13C
+#define DSI_STAT              0x140
+#define DSI_TXD               0x4000
+#define DSI_RXD               0x10000
+
+/* Interrupt source bit masks */
+#define DSI_IRQ_RXLSREQ         (1<<0)
+#define DSI_IRQ_RXSREQ          (1<<1)
+#define DSI_IRQ_RXLBREQ         (1<<2)
+#define DSI_IRQ_RXBREQ          (1<<3)
+#define DSI_IRQ_TXLSREQ         (1<<4)
+#define DSI_IRQ_TXSREQ          (1<<5)
+#define DSI_IRQ_TXLBREQ         (1<<6)
+#define DSI_IRQ_TXBREQ          (1<<7)
+#define DSI_IRQ_ERR_DSITR0      (1<<8)
+#define DSI_IRQ_ERR_DSITR1      (1<<9)
+#define DSI_IRQ_ERR_DSITR2      (1<<10)
+#define DSI_IRQ_ERR_DSITR3      (1<<11)
+#define DSI_IRQ_ERR_DSIUFL      (1<<12)
+#define DSI_IRQ_ERR_DSIFIN      (1<<13)
+#define DSI_IRQ_ERR_DSILTO      (1<<14)
+#define DSI_IRQ_ERR_DSIHTO      (1<<15)
+#define DSI_IRQ_ERR_DSIRTO      (1<<16)
+#define DSI_IRQ_ERR_DSIESC      (1<<17)
+#define DSI_IRQ_ERR_DSISYN      (1<<18)
+#define DSI_IRQ_ERR_DSICTR      (1<<19)
+#define DSI_IRQ_ERR_DSICON      (1<<20)
+#define DSI_IRQ_ERR_DSIOFL      (1<<21)
+#define DSI_IRQ_ERR_IDLE        (1<<22)
+
+#define DSI_IRQ_ERR_MASK (\
+	DSI_IRQ_ERR_RXFUFL |\
+	DSI_IRQ_ERR_RXFOFL |\
+	DSI_IRQ_ERR_TXFOFL |\
+	DSI_IRQ_ERR_PHASE |\
+	DSI_IRQ_ERR_CMD |\
+	DSI_IRQ_ERR_MASTER |\
+	DSI_IRQ_ERR_TXUFL |\
+	DSI_IRQ_ERR_MASTER2 |\
+	DSI_IRQ_ERR_IDLE |\
+	DSI_IRQ_ERR_DSITR0 |\
+	DSI_IRQ_ERR_DSITR1 |\
+	DSI_IRQ_ERR_DSITR2 |\
+	DSI_IRQ_ERR_DSITR3 |\
+	DSI_IRQ_ERR_DSIUFL |\
+	DSI_IRQ_ERR_DSIFIN |\
+	DSI_IRQ_ERR_DSILTO |\
+	DSI_IRQ_ERR_DSIHTO |\
+	DSI_IRQ_ERR_DSIRTO |\
+	DSI_IRQ_ERR_DSIESC |\
+	DSI_IRQ_ERR_DSISYN |\
+	DSI_IRQ_ERR_DSICTR |\
+	DSI_IRQ_ERR_DSICON)
+
+#define DSI_MODE_CONF	2
+#define DSI_MODE_RUN	1
+
+#define DSI_DIR_TX 0
+#define DSI_DIR_RX 1
+
+/* Reg description table indices */
+/* ---------------------  */
+
+enum {
+	EXR_DSI_CLC = 1,
+	EXR_DSI_CLC_RUN,
+	EXR_DSI_CLC_STAT,
+	EXR_DSI_CLC_STAT_RUN,
+	EXR_DSI_CLC_STAT_MODEN,
+	EXR_DSI_CLC_STAT_KID,
+	EXR_DSI_ID,
+	EXR_DSI_FIFO_ID,
+	EXR_DSI_SRB_MSCONF_ID,
+	EXR_DSI_SWCID,
+	EXR_DSI_FIFO_CFG,
+	EXR_DSI_FIFO_CTRL,
+	EXR_DSI_MRPS_CTRL,
+	EXR_DSI_RPS_STAT,
+	EXR_DSI_TPS_CTRL,
+	EXR_DSI_TPS_CTRL_TPS,
+	EXR_DSI_FIFO_STAT,
+	EXR_DSI_FIFO_STAT_RXFFS,
+	EXR_DSI_RIS,
+	EXR_DSI_IMSC,
+	EXR_DSI_MIS,
+	EXR_DSI_ISR,
+	EXR_DSI_DMAE,
+	EXR_DSI_ICR,
+	EXR_DSI_CFG,
+	EXR_DSI_CFG_CFG_LAT,
+	EXR_DSI_CFG_HEAD_LAT,
+	EXR_DSI_CFG_GATE,
+	EXR_DSI_CFG_TX,
+	EXR_DSI_CFG_LP,
+	EXR_DSI_CFG_MODE,
+	EXR_DSI_CFG_EOT,
+	EXR_DSI_CFG_TURN,
+	EXR_DSI_CFG_VALID,
+	EXR_DSI_CFG_DATA,
+	EXR_DSI_CFG_STP,
+	EXR_DSI_CFG_ULPS,
+	EXR_DSI_CFG_EN,
+	EXR_DSI_CFG_LANES,
+	EXR_DSI_CFG_ID,
+	EXR_DSI_CFG_TXS,
+	EXR_DSI_CFG_TE,
+	EXR_DSI_CFG_FIN,
+	EXR_DSI_CFG_VSYNC,
+	EXR_DSI_CFG_PSYNC,
+	EXR_DSI_CFG_SOURCE,
+	EXR_DSI_CLK,
+	EXR_DSI_HEAD,
+	EXR_DSI_HEAD_HEADER,
+	EXR_DSI_HEAD_WCNT,
+	EXR_DSI_HEAD_CMD,
+	EXR_DSI_TO0,
+	EXR_DSI_TO1,
+	EXR_DSI_VID0,
+	EXR_DSI_VID0_HFP_BYTES,
+	EXR_DSI_VID0_HBP_BYTES,
+	EXR_DSI_VID0_HSA_BYTES,
+	EXR_DSI_VID0_HFP,
+	EXR_DSI_VID0_HBP,
+	EXR_DSI_VID0_HSA,
+	EXR_DSI_VID0_HFP_LP,
+	EXR_DSI_VID0_HBP_LP,
+	EXR_DSI_VID0_HSA_LP,
+	EXR_DSI_VID1,
+	EXR_DSI_VID1_VACT_LINES,
+	EXR_DSI_VID1_MODE,
+	EXR_DSI_VID1_ID,
+	EXR_DSI_VID1_PIXEL,
+	EXR_DSI_VID1_FILL_BUFFER_TO,
+	EXR_DSI_VID1_LAST_CS,
+	EXR_DSI_VID2,
+	EXR_DSI_VID2_VFP,
+	EXR_DSI_VID2_VBP,
+	EXR_DSI_VID2_VSA,
+	EXR_DSI_VID3,
+	EXR_DSI_VID3_PIXEL_PACKETS,
+	EXR_DSI_VID3_PIXEL_BYTES,
+	EXR_DSI_VID4,
+	EXR_DSI_VID4_BLANK_PACKETS,
+	EXR_DSI_VID4_BLANK_BYTES,
+	EXR_DSI_VID5,
+	EXR_DSI_VID5_LINE_TIME,
+	EXR_DSI_VID5_BLLP_TIME,
+	EXR_DSI_VID6,
+	EXR_DSI_VID6_LAST_BLANK,
+	EXR_DSI_VID6_LAST_PIXEL,
+	EXR_DSI_PHY0,
+	EXR_DSI_PHY0_SHARE,
+	EXR_DSI_PHY0_M,
+	EXR_DSI_PHY0_N,
+	EXR_DSI_PHY0_POWERUP,
+	EXR_DSI_PHY0_CALIB,
+	EXR_DSI_PHY0_TO_LP_HS_REQ,
+	EXR_DSI_PHY1,
+	EXR_DSI_PHY1_TO_LP_HS_DIS,
+	EXR_DSI_PHY1_TO_LP_EOT,
+	EXR_DSI_PHY1_TO_HS_ZERO,
+	EXR_DSI_PHY1_TO_HS_FLIP,
+	EXR_DSI_PHY1_LP_CLK_DIV,
+	EXR_DSI_PHY2,
+	EXR_DSI_PHY2_HS_CLK_PRE,
+	EXR_DSI_PHY2_HS_CLK_POST,
+	EXR_DSI_PHY2_DAT_DELAY,
+	EXR_DSI_PHY2_CLK_DELAY,
+	EXR_DSI_PHY2_LPTX_TFALL,
+	EXR_DSI_PHY3,
+	EXR_DSI_PHY3_EN,
+	EXR_DSI_PHY3_LPTX_TRISE,
+	EXR_DSI_PHY3_LPTX_VREF,
+	EXR_DSI_STAT,
+	EXR_DSI_STAT_DSI_BSY,
+	EXR_DSI_STAT_DSI_FULL,
+	EXR_DSI_STAT_DSI_DIR,
+	EXR_DSI_STAT_DSI_LOCK,
+	EXR_DSI_TXD,
+	EXR_DSI_RXD,
+	NBREG_MAX,
+};
+
+struct dsi_command {
+	char *name;		/* command name string */
+	/*int access; *//* access restrictions */
+	unsigned int addr;	/* command register address */
+	unsigned int mask;	/* value field mask */
+	int shift;		/* value field shift */
+};
+
+/* -------------------------  */
+/* Declaration for Reg description table  */
+/* -------------------------  */
+extern struct dsi_command dsi_regs[];
+
+/* -------------------------  */
+/* Macro definitions          */
+/* -------------------------  */
+#define BITFLDS(_id_, _val_) \
+		(((_val_) & dsi_regs[_id_].mask) << (dsi_regs[_id_].shift))
+
+int dsi_read_field(unsigned int id, unsigned int *reg_value);
+int dsi_write_field(unsigned int id, unsigned int value);
+
+#endif
-- 
1.7.9.5

