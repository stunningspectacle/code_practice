diff --git a/arch/x86/boot/dts/Sf3gr_mrd_n1.dts b/arch/x86/boot/dts/Sf3gr_mrd_n1.dts
index ef20692..a8993cc 100644
--- a/arch/x86/boot/dts/Sf3gr_mrd_n1.dts
+++ b/arch/x86/boot/dts/Sf3gr_mrd_n1.dts
@@ -497,9 +497,8 @@
 	pinctrl-1 = <&i2c4_sleep_pins>;
 	pinctrl-2 = <&i2c4_inactive_pins>;
 
-#ifndef RECOVERY_KERNEL
         touchscreen {
-                compatible = "goodix,GT9157";
+		compatible = "goodix,GOOD9157";
                 reg = < 0x14 >;
                 interrupt-parent = <&eint>;
                 interrupts = < EINT_EXI12 XGOLD_IRQ_TYPE_EDGE_FALLING >;
@@ -513,8 +512,34 @@
                 pm,user-name = "tp";
                 pm,state-D0 = "enable";
                 pm,state-D3 = "disable";
-        };
-#endif
+
+		goodix,buttons = < 580 /* KEY_APP_SWITCH */
+				   172 /* KEY_HOMEPAGE */
+				   158 /* KEY_BACK */
+				 >;
+		goodix,firmware-update;
+		goodix,firmware-name = "gt9157.fw";
+
+                goodix,config = /bits/ 8 <0x41 0xD0 0x02 0x00 0x05 0x0A 0x05 0x01 0x01 0x08
+			0x1E 0x05 0x50 0x32 0x03 0x05 0x00 0x00 0xE0 0x03
+			0x00 0x11 0x00 0x17 0x19 0x1C 0x14 0x8C 0x2E 0x0E
+		        0x2C 0x2F 0xF1 0x08 0x00 0x00 0x00 0x9B 0x32 0x1D
+		        0x00 0x00 0x00 0x00 0x00 0x03 0x64 0x32 0x00 0x00
+		        0x2A 0x23 0x4E 0x94 0xC5 0x02 0x07 0x00 0x00 0x04
+		        0x91 0x26 0x00 0x80 0x2C 0x00 0x6E 0x34 0x00 0x61
+		        0x3D 0x00 0x55 0x48 0x00 0x55 0x18 0x40 0x60 0x00
+		        0xF0 0x4A 0x30 0xCB 0xBB 0x17 0x00 0x00 0x00 0x00
+			0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
+		        0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x19 0x00 0x00
+		        0x3C 0x00 0x02 0x04 0x06 0x08 0x0A 0x0C 0x0E 0x10
+		        0x12 0x14 0x16 0x18 0x1A 0x1C 0x00 0x00 0x00 0x00
+		        0x00 0x00 0x00 0x00 0x00 0x00 0xFF 0x00 0xFF 0x0F
+		        0x00 0x00 0x00 0x02 0x04 0x06 0x08 0x0A 0x0C 0x0F
+		        0x10 0x12 0x13 0x14 0x16 0x18 0x1C 0x1D 0x1E 0x1F
+		        0x20 0x21 0x22 0x24 0x26 0x28 0x29 0x2A 0x00 0x00
+		        0x00 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
+		        0xFF 0xFF 0xFF 0xFF 0x65 0x01>;
+	};
 };
 
 &i2c_5 {
diff --git a/arch/x86/configs/i386_sofia_defconfig b/arch/x86/configs/i386_sofia_defconfig
index 3838446..70b81a6 100644
--- a/arch/x86/configs/i386_sofia_defconfig
+++ b/arch/x86/configs/i386_sofia_defconfig
@@ -1472,7 +1472,7 @@ CONFIG_INPUT_TABLET=y
 # CONFIG_TABLET_USB_KBTAB is not set
 # CONFIG_TABLET_USB_WACOM is not set
 CONFIG_INPUT_TOUCHSCREEN=y
-CONFIG_TOUCHSCREEN_FT5X0X=y
+# CONFIG_TOUCHSCREEN_FT5X0X is not set
 # CONFIG_TOUCHSCREEN_ADS7846 is not set
 # CONFIG_TOUCHSCREEN_AD7877 is not set
 # CONFIG_TOUCHSCREEN_AD7879 is not set
@@ -1516,8 +1516,9 @@ CONFIG_TOUCHSCREEN_FT5X0X=y
 # CONFIG_TOUCHSCREEN_HIMAX is not set
 # CONFIG_TOUCHSCREEN_FT3X27 is not set
 # CONFIG_TOUCHSCREEN_GT910 is not set
-CONFIG_TOUCHSCREEN_GT915=y
-CONFIG_TOUCHSCREEN_VTL_CT36X=y
+# CONFIG_TOUCHSCREEN_GT915 is not set
+CONFIG_TOUCHSCREEN_GT9XX=y
+# CONFIG_TOUCHSCREEN_VTL_CT36X is not set
 CONFIG_INPUT_MISC=y
 # CONFIG_INPUT_AD714X is not set
 CONFIG_INPUT_APDS990X=y
diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index 0e4876d..19f141f 100644
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -35,6 +35,18 @@ config TOUCHSCREEN_88PM860X
 	  To compile this driver as a module, choose M here: the
 	  module will be called 88pm860x-ts.
 
+config TOUCHSCREEN_GT9XX
+	  tristate "Goodix GT911 touchscreen"
+	  select SERIO
+	  help
+	  Say Y here if you have the Goodix GT911 touchscreen connected to
+	  your system.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called gt9xx.
+
 config TOUCHSCREEN_ADS7846
 	tristate "ADS7846/TSC2046/AD7873 and AD(S)7843 based touchscreens"
 	depends on SPI_MASTER
diff --git a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
index 2856b34..932085b 100644
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -81,6 +81,7 @@ obj-$(CONFIG_TOUCHSCREEN_FOCALTECH_FT5X06)	+= ft5x06_ts.o
 obj-$(CONFIG_TOUCHSCREEN_FT5X0X)	+= ft5x0x_ts.o
 obj-$(CONFIG_TOUCHSCREEN_GT910)		+= gt910/
 obj-$(CONFIG_TOUCHSCREEN_GT915)		+= gt910/
+obj-$(CONFIG_TOUCHSCREEN_GT9XX)         += gt9xx.o
 obj-$(CONFIG_TOUCHSCREEN_VTL_CT36X)		+= vtl_ts/
 obj-$(CONFIG_TOUCHSCREEN_HIMAX)   	+= himax_platform.o himax_852xES.o
 obj-$(CONFIG_TOUCHSCREEN_FT3X27)	+= ft3x27/
diff --git a/drivers/input/touchscreen/ft3x27/ftxxxx_ts.c b/drivers/input/touchscreen/ft3x27/ftxxxx_ts.c
index b28192d..56aa98b 100644
--- a/drivers/input/touchscreen/ft3x27/ftxxxx_ts.c
+++ b/drivers/input/touchscreen/ft3x27/ftxxxx_ts.c
@@ -1253,6 +1253,7 @@ enum{
 
 static int ftxxxx_ts_probe(struct i2c_client *client, const struct i2c_device_id *id)
 {
+	adfasf
 	struct focal_i2c_platform_data *pdata;
 	int err = 0;
         struct input_dev *input_dev;
diff --git a/drivers/input/touchscreen/gt9xx.c b/drivers/input/touchscreen/gt9xx.c
index 7793293..9face54 100644
--- a/drivers/input/touchscreen/gt9xx.c
+++ b/drivers/input/touchscreen/gt9xx.c
@@ -1,2687 +1,2113 @@
-/* drivers/input/touchscreen/gt9xx.c
- * 
- * 2010 - 2013 Goodix Technology.
- * 
+/**
+ * Driver for Goodix GT911 touchscreen.
+ *
+ * Copyright (c) 2014 Intel Corporation
+ *
+ * Based on Goodix GT9xx driver:
+ *	(c) 2010 - 2013 Goodix Technology.
+ *	Version: 2.0
+ *	Authors: andrew@goodix.com, meta@goodix.com
+ *	Release Date: 2013/04/25
+ *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
- * This program is distributed in the hope that it will be a reference 
- * to you, when you are integrating the GOODiX's CTP IC into your system, 
- * but WITHOUT ANY WARRANTY; without even the implied warranty of 
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+ *
+ * This program is distributed in the hope that it will be a reference
+ * to you, when you are integrating the GOODiX's CTP IC into your system,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * General Public License for more details.
- * 
- * Version: 2.0
- * Authors: andrew@goodix.com, meta@goodix.com
- * Release Date: 2013/04/25
- * Revision record:
- *      V1.0:   
- *          first Release. By Andrew, 2012/08/31 
- *      V1.2:
- *          modify gtp_reset_guitar,slot report,tracking_id & 0x0F. By Andrew, 2012/10/15
- *      V1.4:
- *          modify gt9xx_update.c. By Andrew, 2012/12/12
- *      V1.6: 
- *          1. new heartbeat/esd_protect mechanism(add external watchdog)
- *          2. doze mode, sliding wakeup 
- *          3. 3 more cfg_group(GT9 Sensor_ID: 0~5) 
- *          3. config length verification
- *          4. names & comments
- *                  By Meta, 2013/03/11
- *      V1.8:
- *          1. pen/stylus identification 
- *          2. read double check & fixed config support
- *          3. new esd & slide wakeup optimization
- *                  By Meta, 2013/06/08
- *      V2.0:
- *          1. compatible with GT9XXF
- *          2. send config after resume
- *                  By Meta, 2013/08/06
  */
-
 #include <linux/irq.h>
-#include "gt9xx.h"
-
-#if GTP_ICS_SLOT_REPORT
-    #include <linux/input/mt.h>
+#include <linux/acpi.h>
+#include <linux/gpio/consumer.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/interrupt.h>
+#include <linux/input/mt.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/firmware.h>
+#ifdef CONFIG_PM
+#include <linux/power_hal_sysfs.h>
+#include <linux/device_pm_data.h>
 #endif
 
-static const char *goodix_ts_name = "Goodix Capacitive TouchScreen";
-static struct workqueue_struct *goodix_wq;
-struct i2c_client * i2c_connect_client = NULL; 
-u8 config[GTP_CONFIG_MAX_LENGTH + GTP_ADDR_LENGTH]
-                = {GTP_REG_CONFIG_DATA >> 8, GTP_REG_CONFIG_DATA & 0xff};
-
-#if GTP_HAVE_TOUCH_KEY
-    static const u16 touch_key_array[] = GTP_KEY_TAB;
-    #define GTP_MAX_KEY_NUM  (sizeof(touch_key_array)/sizeof(touch_key_array[0]))
-    
-#if GTP_DEBUG_ON
-    static const int  key_codes[] = {KEY_HOME, KEY_BACK, KEY_MENU, KEY_SEARCH};
-    static const char *key_names[] = {"Key_Home", "Key_Back", "Key_Menu", "Key_Search"};
-#endif
-    
-#endif
+#define GT9XX_MAX_TOUCHES		5
+#define GT9XX_REG_CONFIG_DATA		0x8047
+#define GT9XX_CONFIG_LENGTH		186
+#define GT9XX_MAX_NUM_BUTTONS		8
+#define GT9XX_FW_FILE_NAME		"gt9xx_firmware.fw"
+#define GT9XX_FW_HEAD_LEN		14
+
+#define GT9XX_SS51_BLOCK_ADDR		0xc000
+#define GT9XX_DSP_BLOCK_ADDR		0xc000
+#define GT9XX_SRAM_BANK_ADDR		0x4048
+#define GT9XX_SW_WDT_ADDR		0x8041
+#define GT9XX_MEM_CD_EN_ADDR		0x4049
+#define GT9XX_CACHE_EN_ADDR		0x404B
+#define GT9XX_TMR0_EN_ADDR		0x40B0
+#define GT9XX_SWRST_B0_ADDR		0x4180
+#define GT9XX_CPU_SWRST_PULSE_ADDR	0x4184
+#define GT9XX_FW_REL_ADDR		0x4180
+#define GT9XX_BOOTCTL_B0_ADDR		0x4190
+#define GT9XX_BOOT_OPT_B0_ADDR		0x4218
+#define GT9XX_BOOT_CTL_ADDR		0x5094
+#define GT9XX_DSP_CLK_ADDR		0x4010
+
+#define GT9X5_SS51_BLOCK_ADDR1		0xc000
+#define GT9X5_SS51_BLOCK_ADDR2		0xe000
+#define GT9X5_DSP_BLOCK_ADDR		0x9000
+#define GT9X5_DSP_ISP_BLOCK_ADDR	0xc000
+#define GT9X5_BOOT_BLOCK_ADDR		0x9000
+#define GT9X5_BOOT_ISP_BLOCK_ADDR	0x9000
+#define GT9X5_GFWLINK_BLOCK_ADDR	0x9000
+#define GT9X5_GWAKE_BLOCK_ADDR		0x9000
+#define GT9X5_DSP_ISP_BLOCK_ADDR	0xc000
+
+#define GT9XX_SS51_SECTION_LEN		0x2000 /* total 4 sections */
+#define GT9XX_DSP_SECTION_LEN		0x1000
+
+#define GT9X5_SS51_SECTION_LEN		0x2000 /* total 4 sections */
+#define GT9X5_DSP_SECTION_LEN		0x1000
+#define GT9X5_DSP_ISP_SECTION_LEN	0x1000
+#define GT9X5_BOOT_SECTION_LEN		0x800
+#define GT9X5_BOOT_ISP_SECTION_LEN	0x800
+#define GT9X5_GFWLINK_SECTION_LEN	0x2000
+#define GT9X5_GFWLINK_LEN		0x3000
+#define GT9X5_GWAKE_SECTION_LEN		0x2000 /* total 4 section */
+#define GT9X5_GWAKE_LEN			(GT9X5_GWAKE_SECTION_LEN * 4)
+
+#define GT9XX_SS51_START_INDEX		(0)
+#define GT9XX_DSP_START_INDEX		(GT9XX_SS51_SECTION_LEN * 4)
+
+#define GT9X5_SS51_START_INDEX		(0)
+#define GT9X5_DSP_START_INDEX		(GT9XX_SS51_SECTION_LEN * 4)
+#define GT9X5_BOOT_START_INDEX		(GT9XX_DSP_START_INDEX + \
+					 GT9XX_DSP_SECTION_LEN)
+#define GT9X5_BOOT_ISP_START_INDEX	(GT9X5_BOOT_START_INDEX + \
+					 GT9X5_BOOT_SECTION_LEN)
+#define GT9X5_GFWLINK_START_INDEX	(GT9X5_BOOT_ISP_START_INDEX + \
+					 GT9X5_BOOT_ISP_SECTION_LEN)
+#define GT9X5_GWAKE_START_INDEX		(GT9X5_GFWLINK_START_INDEX + \
+					 GT9X5_GFWLINK_LEN)
+#define GT9X5_DSP_ISP_START_INDEX	(GT9X5_DSP_ISP_SECTION_LEN)
+
+#define GT9XX_SS51_BANK_INDEX0		0
+#define GT9XX_SS51_BANK_INDEX1		1
+#define GT9XX_DSP_BANK_INDEX0		2
+
+#define GT9XX_FW_CHK_SIZE		1024
+#define GT9XX_FW_CHK_RETRY		40
+#define GT9XX_FW_DOWNLOAD_RETRY		5
+#define GT9XX_FW_HOLD_RETRY		200
+
+#define GT9XX_CFG_DN_RETRY		3
+
+#define GT9XX_SW_WDT_DEF_VAL		0xaa
+#define GT9XX_SWRST_B0_DEF_VAL		0x0c
+#define GT9XX_SWRST_B0_REL_SS51_DSP	0x04
+
+#define GT9X5_SWRST_REL_DSP_HOLD_SS51	0x04
+#define GT9X5_SWRST_REL_SS51_HOLD_DSP	0x08
+
+#define GT9X5_FLASH_PACK_LEN		256
+
+#define GT9XX_BOOTCTL_B0_SRAM		0x02
+
+#define GT9XX_BUTTONS_PROPERTY		"goodix,buttons"
+#define GT9XX_FIRMWARE_UPDATE_PROPERTY	"goodix,firmware-update"
+#define GT9XX_FW_NAME_PROPERTY		"goodix,firmware-name"
+#define GT9XX_COMPAT_MODE_PROPERTY	"goodix,compat-mode"
+
+enum gt9xx_status_bits {
+	/* bits 0 .. GT9XX_MAX_TOUCHES - 1 are use to track touches */
+	GT9XX_STATUS_SLEEP_BIT = GT9XX_MAX_TOUCHES,
+	GT9XX_STATUS_BITS,
+};
 
-static s8 gtp_i2c_test(struct i2c_client *client);
-void gtp_reset_guitar(struct i2c_client *client, s32 ms);
-s32 gtp_send_cfg(struct i2c_client *client);
-void gtp_int_sync(s32 ms);
+struct gt9xx_fw_head {
+	u8 hw_info[4]; /* hardware info */
+	u8 pid[8]; /* product id */
+	u16 vid; /* vendor id */
+};
 
-#ifdef CONFIG_HAS_EARLYSUSPEND
-static void goodix_ts_early_suspend(struct early_suspend *h);
-static void goodix_ts_late_resume(struct early_suspend *h);
-#endif
- 
-#if GTP_CREATE_WR_NODE
-extern s32 init_wr_node(struct i2c_client*);
-extern void uninit_wr_node(void);
-#endif
+struct gt9xx_ts {
+	struct i2c_client *client;
+	struct input_dev *input;
+	char phys[32];
 
-#if GTP_AUTO_UPDATE
-extern u8 gup_init_update_proc(struct goodix_ts_data *);
-#endif
+	struct pinctrl *pinctrl;
+	struct pinctrl_state *ctrl_state;
+	struct pinctrl_state *int_state;
 
-#if GTP_ESD_PROTECT
-static struct delayed_work gtp_esd_check_work;
-static struct workqueue_struct * gtp_esd_check_workqueue = NULL;
-static void gtp_esd_check_func(struct work_struct *);
-static s32 gtp_init_ext_watchdog(struct i2c_client *client);
-void gtp_esd_switch(struct i2c_client *, s32);
-#endif
+	struct gpio_desc *gpiod_int;
+	struct gpio_desc *gpiod_rst;
+	int irq_type;
+	int compat_mode;
 
-//*********** For GT9XXF Start **********//
-#if GTP_COMPATIBLE_MODE
-extern s32 i2c_read_bytes(struct i2c_client *client, u16 addr, u8 *buf, s32 len);
-extern s32 i2c_write_bytes(struct i2c_client *client, u16 addr, u8 *buf, s32 len);
-extern s32 gup_clk_calibration(void);
-extern s32 gup_fw_download_proc(void *dir, u8 dwn_mode);
-extern u8 gup_check_fs_mounted(char *path_name);
-
-void gtp_recovery_reset(struct i2c_client *client);
-static s32 gtp_esd_recovery(struct i2c_client *client);
-s32 gtp_fw_startup(struct i2c_client *client);
-static s32 gtp_main_clk_proc(struct goodix_ts_data *ts);
-static s32 gtp_bak_ref_proc(struct goodix_ts_data *ts, u8 mode);
-#endif
-//********** For GT9XXF End **********//
+	u16 max_x;
+	u16 max_y;
 
-#if GTP_SLIDE_WAKEUP
-typedef enum
-{
-    DOZE_DISABLED = 0,
-    DOZE_ENABLED = 1,
-    DOZE_WAKEUP = 2,
-}DOZE_T;
-static DOZE_T doze_status = DOZE_DISABLED;
-static s8 gtp_enter_doze(struct goodix_ts_data *ts);
-#endif
+	const char *fw_name;
+	const struct firmware *fw;
+	struct gt9xx_fw_head *fw_head;
+	int num_buttons;
+	unsigned int button_codes[GT9XX_MAX_NUM_BUTTONS];
 
-static u8 chip_gt9xxs = 0;  // true if ic is gt9xxs, like gt915s
-u8 grp_cfg_version = 0;
-
-/*******************************************************
-Function:
-    Read data from the i2c slave device.
-Input:
-    client:     i2c device.
-    buf[0~1]:   read start address.
-    buf[2~len-1]:   read data buffer.
-    len:    GTP_ADDR_LENGTH + read bytes count
-Output:
-    numbers of i2c_msgs to transfer: 
-      2: succeed, otherwise: failed
-*********************************************************/
-s32 gtp_i2c_read(struct i2c_client *client, u8 *buf, s32 len)
-{
-    struct i2c_msg msgs[2];
-    s32 ret=-1;
-    s32 retries = 0;
-
-    GTP_DEBUG_FUNC();
-
-    msgs[0].flags = !I2C_M_RD;
-    msgs[0].addr  = client->addr;
-    msgs[0].len   = GTP_ADDR_LENGTH;
-    msgs[0].buf   = &buf[0];
-    //msgs[0].scl_rate = 300 * 1000;    // for Rockchip, etc.
-    
-    msgs[1].flags = I2C_M_RD;
-    msgs[1].addr  = client->addr;
-    msgs[1].len   = len - GTP_ADDR_LENGTH;
-    msgs[1].buf   = &buf[GTP_ADDR_LENGTH];
-    //msgs[1].scl_rate = 300 * 1000;
-
-    while(retries < 5)
-    {
-        ret = i2c_transfer(client->adapter, msgs, 2);
-        if(ret == 2)break;
-        retries++;
-    }
-    if((retries >= 5))
-    {
-    #if GTP_COMPATIBLE_MODE
-        struct goodix_ts_data *ts = i2c_get_clientdata(client);
-    #endif
-        
-    #if GTP_SLIDE_WAKEUP
-        // reset chip would quit doze mode
-        if (DOZE_ENABLED == doze_status)
-        {
-            return ret;
-        }
-    #endif
-        GTP_ERROR("I2C Read: 0x%04X, %d bytes failed, errcode: %d! Process reset.", (((u16)(buf[0] << 8)) | buf[1]), len-2, ret);
-    #if GTP_COMPATIBLE_MODE
-        if (CHIP_TYPE_GT9F == ts->chip_type)
-        {
-            gtp_recovery_reset(client);
-        }
-        else
-    #endif
-        {
-            gtp_reset_guitar(client, 10);  
-        }
-    }
-    return ret;
-}
+	DECLARE_BITMAP(status, GT9XX_STATUS_BITS);
+
+	struct device_pm_platdata *pm_platdata;
+};
 
+/* Registers define */
+#define GT9XX_REG_CMD			0x8040
+#define GT9XX_REG_CONFIG		0x8047
+#define GT9XX_REG_ID			0x8140
+#define GT9XX_REG_STATUS		0x814E
+#define GT9XX_REG_DATA			0x814F
 
+static void gt9xx_reset(struct gt9xx_ts *ts);
 
-/*******************************************************
-Function:
-    Write data to the i2c slave device.
-Input:
-    client:     i2c device.
-    buf[0~1]:   write start address.
-    buf[2~len-1]:   data buffer
-    len:    GTP_ADDR_LENGTH + write bytes count
-Output:
-    numbers of i2c_msgs to transfer: 
-        1: succeed, otherwise: failed
-*********************************************************/
-s32 gtp_i2c_write(struct i2c_client *client,u8 *buf,s32 len)
+static int gt9xx_i2c_read(struct i2c_client *client, u16 addr,
+			  void *buf, unsigned len)
 {
-    struct i2c_msg msg;
-    s32 ret = -1;
-    s32 retries = 0;
-
-    GTP_DEBUG_FUNC();
-
-    msg.flags = !I2C_M_RD;
-    msg.addr  = client->addr;
-    msg.len   = len;
-    msg.buf   = buf;
-    //msg.scl_rate = 300 * 1000;    // for Rockchip, etc
-
-    while(retries < 5)
-    {
-        ret = i2c_transfer(client->adapter, &msg, 1);
-        if (ret == 1)break;
-        retries++;
-    }
-    if((retries >= 5))
-    {
-    #if GTP_COMPATIBLE_MODE
-        struct goodix_ts_data *ts = i2c_get_clientdata(client);
-    #endif
-    
-    #if GTP_SLIDE_WAKEUP
-        if (DOZE_ENABLED == doze_status)
-        {
-            return ret;
-        }
-    #endif
-        GTP_ERROR("I2C Write: 0x%04X, %d bytes failed, errcode: %d! Process reset.", (((u16)(buf[0] << 8)) | buf[1]), len-2, ret);
-    #if GTP_COMPATIBLE_MODE
-        if (CHIP_TYPE_GT9F == ts->chip_type)
-        {
-            gtp_recovery_reset(client);
-        }
-        else
-    #endif
-        {
-            gtp_reset_guitar(client, 10);  
-        }
-    }
-    return ret;
-}
+	u8 addr_buf[2];
+	struct i2c_msg msgs[2];
+	int ret, retries = 0;
+
+	addr_buf[0] = addr >> 8;
+	addr_buf[1] = addr & 0xFF;
+
+	msgs[0].flags = 0;
+	msgs[0].addr = client->addr;
+	msgs[0].buf = addr_buf;
+	msgs[0].len = sizeof(addr_buf);
+
+	msgs[1].flags = I2C_M_RD;
+	msgs[1].addr = client->addr;
+	msgs[1].buf = buf;
+	msgs[1].len = len;
+
+	while (retries < 5) {
+		ret = i2c_transfer(client->adapter, msgs, 2);
+		if (ret == 2)
+			break;
+		retries++;
+	}
+
+	if (retries >= 5) {
+		dev_err(&client->dev, "I2C read @0x%04X (%d) failed: %d", addr,
+			len, ret);
+		gt9xx_reset(i2c_get_clientdata(client));
+		return ret;
+	}
+
+	return ret;
 
+}
 
-/*******************************************************
-Function:
-    i2c read twice, compare the results
-Input:
-    client:  i2c device
-    addr:    operate address
-    rxbuf:   read data to store, if compare successful
-    len:     bytes to read
-Output:
-    FAIL:    read failed
-    SUCCESS: read successful
-*********************************************************/
-s32 gtp_i2c_read_dbl_check(struct i2c_client *client, u16 addr, u8 *rxbuf, int len)
+static int gt9xx_i2c_write(struct i2c_client *client, u16 addr, void *buf,
+			  unsigned len)
 {
-    u8 buf[16] = {0};
-    u8 confirm_buf[16] = {0};
-    u8 retry = 0;
-    
-    while (retry++ < 3)
-    {
-        memset(buf, 0xAA, 16);
-        buf[0] = (u8)(addr >> 8);
-        buf[1] = (u8)(addr & 0xFF);
-        gtp_i2c_read(client, buf, len + 2);
-        
-        memset(confirm_buf, 0xAB, 16);
-        confirm_buf[0] = (u8)(addr >> 8);
-        confirm_buf[1] = (u8)(addr & 0xFF);
-        gtp_i2c_read(client, confirm_buf, len + 2);
-        
-        if (!memcmp(buf, confirm_buf, len+2))
-        {
-            memcpy(rxbuf, confirm_buf+2, len);
-            return SUCCESS;
-        }
-    }    
-    GTP_ERROR("I2C read 0x%04X, %d bytes, double check failed!", addr, len);
-    return FAIL;
+	u8 *addr_buf;
+	struct i2c_msg msg;
+	int ret = 0, retries = 0;
+
+	addr_buf = kmalloc(len + 2, GFP_KERNEL);
+	if (!addr_buf)
+		return -ENOMEM;
+
+	addr_buf[0] = addr >> 8;
+	addr_buf[1] = addr & 0xFF;
+
+	memcpy(&addr_buf[2], buf, len);
+
+	msg.flags = 0;
+	msg.addr = client->addr;
+	msg.buf = addr_buf;
+	msg.len = len + 2;
+
+	while (retries < 5 ) {
+		ret = i2c_transfer(client->adapter, &msg, 1);
+		if (ret == 1)
+			break;
+		retries++;
+	}
+
+	kfree(addr_buf);
+
+	if (retries >= 5) {
+		dev_err(&client->dev, "I2C write @0x%04X (%d) failed: %d", addr,
+			len, ret);
+		gt9xx_reset(i2c_get_clientdata(client));
+		return ret;
+	}
+
+	return ret;
 }
 
-/*******************************************************
-Function:
-    Send config.
-Input:
-    client: i2c device.
-Output:
-    result of i2c write operation. 
-        1: succeed, otherwise: failed
-*********************************************************/
-
-s32 gtp_send_cfg(struct i2c_client *client)
+static int gt9xx_i2c_write_u8(struct i2c_client *client, u16 addr, u8 value)
 {
-    s32 ret = 2;
-
-#if GTP_DRIVER_SEND_CFG
-    s32 retry = 0;
-    struct goodix_ts_data *ts = i2c_get_clientdata(client);
-
-    if (ts->fixed_cfg)
-    {
-        GTP_INFO("Ic fixed config, no config sent!");
-        return 0;
-    }
-    else if (ts->pnl_init_error)
-    {
-        GTP_INFO("Error occured in init_panel, no config sent");
-        return 0;
-    }
-    
-    GTP_INFO("Driver send config.");
-    for (retry = 0; retry < 5; retry++)
-    {
-        ret = gtp_i2c_write(client, config , GTP_CONFIG_MAX_LENGTH + GTP_ADDR_LENGTH);
-        if (ret > 0)
-        {
-            break;
-        }
-    }
-#endif
-    return ret;
+	return gt9xx_i2c_write(client, addr, &value, sizeof(value));
 }
-/*******************************************************
-Function:
-    Disable irq function
-Input:
-    ts: goodix i2c_client private data
-Output:
-    None.
-*********************************************************/
-void gtp_irq_disable(struct goodix_ts_data *ts)
-{
-    unsigned long irqflags;
-
-    GTP_DEBUG_FUNC();
 
-    spin_lock_irqsave(&ts->irq_lock, irqflags);
-    if (!ts->irq_is_disable)
-    {
-        ts->irq_is_disable = 1; 
-        disable_irq_nosync(ts->client->irq);
-    }
-    spin_unlock_irqrestore(&ts->irq_lock, irqflags);
+static void gt9xx_irq_disable(struct gt9xx_ts *ts, bool no_sync)
+{
+	if (no_sync)
+		disable_irq_nosync(ts->client->irq);
+	else
+		disable_irq(ts->client->irq);
+	gpiod_unlock_as_irq(ts->gpiod_int);
 }
 
-/*******************************************************
-Function:
-    Enable irq function
-Input:
-    ts: goodix i2c_client private data
-Output:
-    None.
-*********************************************************/
-void gtp_irq_enable(struct goodix_ts_data *ts)
+static void gt9xx_irq_enable(struct gt9xx_ts *ts)
 {
-    unsigned long irqflags = 0;
-
-    GTP_DEBUG_FUNC();
-    
-    spin_lock_irqsave(&ts->irq_lock, irqflags);
-    if (ts->irq_is_disable) 
-    {
-        enable_irq(ts->client->irq);
-        ts->irq_is_disable = 0; 
-    }
-    spin_unlock_irqrestore(&ts->irq_lock, irqflags);
+	gpiod_lock_as_irq(ts->gpiod_int);
+	enable_irq(ts->client->irq);
 }
 
-
-/*******************************************************
-Function:
-    Report touch point event 
-Input:
-    ts: goodix i2c_client private data
-    id: trackId
-    x:  input x coordinate
-    y:  input y coordinate
-    w:  input pressure
-Output:
-    None.
-*********************************************************/
-static void gtp_touch_down(struct goodix_ts_data* ts,s32 id,s32 x,s32 y,s32 w)
+static int gt9xx_send_cfg(struct gt9xx_ts *ts, u8 *cfg_data, size_t cfg_size)
 {
-#if GTP_CHANGE_X2Y
-    GTP_SWAP(x, y);
-#endif
+	int ret, i, retry = 0;
+	size_t raw_cfg_len;
+	u8 check_sum = 0;
+
+	if (cfg_size != GT9XX_CONFIG_LENGTH) {
+		dev_err(&ts->client->dev, "The length of the config buffer array is not correct");
+		return -EINVAL;
+	}
+
+	raw_cfg_len = cfg_size - 2;
+	for (i = 0; i < raw_cfg_len; i++)
+		check_sum += cfg_data[i];
+	check_sum = (~check_sum) + 1;
+	if (check_sum != cfg_data[raw_cfg_len]) {
+		dev_err(&ts->client->dev, "The checksum of the config buffer array is not correct");
+		return -EINVAL;
+	}
+
+	if (cfg_data[raw_cfg_len + 1] != 1) {
+		dev_err(&ts->client->dev, "The Config_Fresh register needs to be set");
+		return -EINVAL;
+	}
+
+again:
+	ret = gt9xx_i2c_write(ts->client, GT9XX_REG_CONFIG_DATA,
+				cfg_data, GT9XX_CONFIG_LENGTH);
+	if ((ret == -EAGAIN) && (retry++ < GT9XX_CFG_DN_RETRY)) {
+		dev_err(&ts->client->dev, "Config send failed, retry %d",
+				retry);
+		goto again;
+	}
+	if (ret <= 0) {
+		dev_err(&ts->client->dev, "Config send failed, err: %d", ret);
+		return ret;
+	}
+	dev_info(&ts->client->dev, "Config settings sent sucessfully");
+
+	/* Let the firmware reconfigure itself, so sleep for 10ms */
+	usleep_range(10000, 11000);
+	return ret;
+}
 
-#if GTP_ICS_SLOT_REPORT
-    input_mt_slot(ts->input_dev, id);
-    input_report_abs(ts->input_dev, ABS_MT_TRACKING_ID, id);
-    input_report_abs(ts->input_dev, ABS_MT_POSITION_X, x);
-    input_report_abs(ts->input_dev, ABS_MT_POSITION_Y, y);
-    input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, w);
-    input_report_abs(ts->input_dev, ABS_MT_WIDTH_MAJOR, w);
-#else
-    input_report_abs(ts->input_dev, ABS_MT_POSITION_X, x);
-    input_report_abs(ts->input_dev, ABS_MT_POSITION_Y, y);
-    input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, w);
-    input_report_abs(ts->input_dev, ABS_MT_WIDTH_MAJOR, w);
-    input_report_abs(ts->input_dev, ABS_MT_TRACKING_ID, id);
-    input_mt_sync(ts->input_dev);
-#endif
+#define GT9XX_STATUS_REG_MASK_TOUCHES		0x0F
+#define GT9XX_STATUS_REG_MASK_VALID		0x80
 
-    GTP_DEBUG("ID:%d, X:%d, Y:%d, W:%d", id, x, y, w);
+static irqreturn_t gt9xx_thread_handler(int irq, void *arg)
+{
+	struct gt9xx_ts *ts = arg;
+	struct gt9xx_touch_data {
+		u8 id;
+		__le16 x;
+		__le16 y;
+		__le16 witdh;
+		u8 reserved;
+	} __packed data[GT9XX_MAX_TOUCHES];
+	int touches;
+	DECLARE_BITMAP(active_touches, GT9XX_MAX_TOUCHES);
+	u8 status;
+	int ret;
+	int i;
+	int retries = 5;
+
+	while (--retries) {
+		ret = gt9xx_i2c_read(ts->client, GT9XX_REG_STATUS, &status, 1);
+		if (ret <= 0)
+			goto out;
+
+		if (status & GT9XX_STATUS_REG_MASK_VALID)
+			break;
+
+		/*
+		 * If we reach this place, it means the interrupt may be out of
+		 * sync with GT9XX_STATUS_REG_MASK_VALID bit. In other words,
+		 * the interrupt event is coming too early while the buffer of
+		 * events is not ready yet.
+		 * Our tests show this bit will (almost) always be set if user
+		 * is still pressing screen and we wait a bit. So we'll wait
+		 * and retry few times before discard the buffer for good.
+		 */
+		usleep_range(500, 1000);
+	}
+
+	if (!retries) {
+		/* GT9XX_STATUS_REG_MASK_VALID was never set. Bad data? */
+		dev_dbg(&ts->client->dev, "buffer status was never set\n");
+		goto out;
+	}
+
+	touches = status & GT9XX_STATUS_REG_MASK_TOUCHES;
+	if (touches > GT9XX_MAX_TOUCHES) {
+		dev_err(&ts->client->dev, "invalid number of touches");
+		goto out;
+	}
+
+	if (touches) {
+		int len = touches * sizeof(struct gt9xx_touch_data);
+
+		ret = gt9xx_i2c_read(ts->client, GT9XX_REG_DATA, data, len);
+		if (ret <= 0)
+			goto out;
+	}
+
+	if (ts->num_buttons > 0) {
+		u8 key_values;
+		int offset = GT9XX_REG_DATA +
+				touches * sizeof(struct gt9xx_touch_data);
+		int i;
+		ret = gt9xx_i2c_read(ts->client, offset,
+					&key_values, sizeof(key_values));
+		if (ret <= 0)
+			goto out;
+
+		for (i = 0; i < ts->num_buttons; i++) {
+			int value = key_values & (1 << i) ? 1 : 0;
+			input_report_key(ts->input,
+					ts->button_codes[i], value);
+		}
+	}
+
+	bitmap_clear(active_touches, 0, GT9XX_MAX_TOUCHES);
+
+	input_report_key(ts->input, BTN_TOUCH, touches);
+
+	/* generate touch down events */
+	for (i = 0; i < touches; i++) {
+		int id = data[i].id;
+		int x = le16_to_cpu(data[i].x);
+		int y = le16_to_cpu(data[i].y);
+		int w = le16_to_cpu(data[i].witdh);
+
+		set_bit(id, active_touches);
+
+		input_mt_slot(ts->input, id);
+		input_mt_report_slot_state(ts->input, MT_TOOL_FINGER, true);
+		input_report_abs(ts->input, ABS_MT_POSITION_X, x);
+		input_report_abs(ts->input, ABS_MT_POSITION_Y, y);
+		input_report_abs(ts->input, ABS_MT_TOUCH_MAJOR, w);
+		input_report_abs(ts->input, ABS_MT_WIDTH_MAJOR, w);
+	}
+
+	/* generate touch up events */
+	for (i = 0; i < GT9XX_MAX_TOUCHES; i++) {
+		if (test_bit(i, active_touches)) {
+			set_bit(i, ts->status);
+			continue;
+		} else {
+			if (!test_and_clear_bit(i, ts->status))
+				continue;
+		}
+
+		input_mt_slot(ts->input, i);
+		input_mt_report_slot_state(ts->input, MT_TOOL_FINGER, false);
+	}
+
+	input_sync(ts->input);
+
+out:
+	gt9xx_i2c_write_u8(ts->client, GT9XX_REG_STATUS, 0);
+
+	return IRQ_HANDLED;
 }
 
-/*******************************************************
-Function:
-    Report touch release event
-Input:
-    ts: goodix i2c_client private data
-Output:
-    None.
-*********************************************************/
-static void gtp_touch_up(struct goodix_ts_data* ts, s32 id)
+static int gt9xx_i2c_test(struct i2c_client *client)
 {
-#if GTP_ICS_SLOT_REPORT
-    input_mt_slot(ts->input_dev, id);
-    input_report_abs(ts->input_dev, ABS_MT_TRACKING_ID, -1);
-    GTP_DEBUG("Touch id[%2d] release!", id);
-#else
-    input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0);
-    input_report_abs(ts->input_dev, ABS_MT_WIDTH_MAJOR, 0);
-    input_mt_sync(ts->input_dev);
-#endif
-}
+	u8 test;
 
+	return gt9xx_i2c_read(client, GT9XX_REG_CONFIG, &test, sizeof(test));
+}
 
-/*******************************************************
-Function:
-    Goodix touchscreen work function
-Input:
-    work: work struct of goodix_workqueue
-Output:
-    None.
-*********************************************************/
-static void goodix_ts_work_func(struct work_struct *work)
+static int gt9xx_get_info(struct gt9xx_ts *ts)
 {
-    u8  end_cmd[3] = {GTP_READ_COOR_ADDR >> 8, GTP_READ_COOR_ADDR & 0xFF, 0};
-    u8  point_data[2 + 1 + 8 * GTP_MAX_TOUCH + 1]={GTP_READ_COOR_ADDR >> 8, GTP_READ_COOR_ADDR & 0xFF};
-    u8  touch_num = 0;
-    u8  finger = 0;
-    static u16 pre_touch = 0;
-    static u8 pre_key = 0;
-#if GTP_WITH_PEN
-    static u8 pre_pen = 0;
-#endif
-    u8  key_value = 0;
-    u8* coor_data = NULL;
-    s32 input_x = 0;
-    s32 input_y = 0;
-    s32 input_w = 0;
-    s32 id = 0;
-    s32 i  = 0;
-    s32 ret = -1;
-    struct goodix_ts_data *ts = NULL;
-
-#if GTP_COMPATIBLE_MODE
-    u8 rqst_buf[3] = {0x80, 0x43};  // for GT9XXF
-#endif
+	struct gt9xx_config {
+		u8 version;
+		__le16 max_x;
+		__le16 max_y;
+		u8 reserved, touch_no:4;
+		u8 reserved2:2, stretch_rank:2, x2y:1, sito:1, int_trigger:2;
+		u8 data[182];
+	} __packed cfg;
+	const int irq_table[] = {
+		IRQ_TYPE_EDGE_RISING,
+		IRQ_TYPE_EDGE_FALLING,
+		IRQ_TYPE_LEVEL_LOW,
+		IRQ_TYPE_LEVEL_HIGH,
+	};
+	struct {
+		u8 id[4];	/* may not be NULL terminated */
+		__le16 fw_version;
+	} __packed id;
+	char id_str[5];
+	int ret;
+
+	ret = gt9xx_i2c_read(ts->client, GT9XX_REG_ID, &id, sizeof(id));
+	if (ret <= 0) {
+		dev_err(&ts->client->dev, "read id failed");
+		return ret;
+	}
+
+	memcpy(id_str, id.id, 4);
+	id_str[4] = 0;
+	if (kstrtou16(id_str, 10, &ts->input->id.product))
+		ts->input->id.product = 0;
+	ts->input->id.version = le16_to_cpu(id.fw_version);
+
+	dev_info(&ts->client->dev, "version: %d_%04x", ts->input->id.product,
+		 ts->input->id.version);
+
+	ret = gt9xx_i2c_read(ts->client, GT9XX_REG_CONFIG, &cfg, sizeof(cfg));
+	if (ret <= 0)
+		return ret;
+
+	ts->max_x = le16_to_cpu(cfg.max_x);
+	ts->max_y = le16_to_cpu(cfg.max_y);
+	ts->irq_type = irq_table[cfg.int_trigger];
+
+	dev_info(&ts->client->dev, "max_x = %d, max_y = %d, irq_type = 0x%02x",
+		 ts->max_x, ts->max_y, ts->irq_type);
+
+	return ret;
+}
 
-#if GTP_SLIDE_WAKEUP
-    u8 doze_buf[3] = {0x81, 0x4B};
-#endif
 
-    GTP_DEBUG_FUNC();
-    ts = container_of(work, struct goodix_ts_data, work);
-    if (ts->enter_update)
-    {
-        return;
-    }
-#if GTP_SLIDE_WAKEUP
-    if (DOZE_ENABLED == doze_status)
-    {               
-        ret = gtp_i2c_read(i2c_connect_client, doze_buf, 3);
-        GTP_DEBUG("0x814B = 0x%02X", doze_buf[2]);
-        if (ret > 0)
-        {               
-            if (doze_buf[2] == 0xAA)
-            {
-                GTP_INFO("Forward slide to light up the screen!");
-                doze_status = DOZE_WAKEUP;
-                input_report_key(ts->input_dev, KEY_POWER, 1);
-                input_sync(ts->input_dev);
-                input_report_key(ts->input_dev, KEY_POWER, 0);
-                input_sync(ts->input_dev);
-                // clear 0x814B
-                doze_buf[2] = 0x00;
-                gtp_i2c_write(i2c_connect_client, doze_buf, 3);
-            }
-            else if (doze_buf[2] == 0xBB)
-            {
-                GTP_INFO("Backward slide to light up the screen!");
-                doze_status = DOZE_WAKEUP;
-                input_report_key(ts->input_dev, KEY_POWER, 1);
-                input_sync(ts->input_dev);
-                input_report_key(ts->input_dev, KEY_POWER, 0);
-                input_sync(ts->input_dev);
-                // clear 0x814B
-                doze_buf[2] = 0x00;
-                gtp_i2c_write(i2c_connect_client, doze_buf, 3);
-            }
-            else if (0xC0 == (doze_buf[2] & 0xC0))
-            {
-                GTP_INFO("Double click to light up the screen!");
-                doze_status = DOZE_WAKEUP;
-                input_report_key(ts->input_dev, KEY_POWER, 1);
-                input_sync(ts->input_dev);
-                input_report_key(ts->input_dev, KEY_POWER, 0);
-                input_sync(ts->input_dev);
-                // clear 0x814B
-                doze_buf[2] = 0x00;
-                gtp_i2c_write(i2c_connect_client, doze_buf, 3);
-            }
-            else
-            {
-                gtp_enter_doze(ts);
-            }
-        }
-        if (ts->use_irq)
-        {
-            gtp_irq_enable(ts);
-        }
-        return;
-    }
-#endif
 
-    ret = gtp_i2c_read(ts->client, point_data, 12);
-    if (ret < 0)
-    {
-        GTP_ERROR("I2C transfer error. errno:%d\n ", ret);
-        goto exit_work_func;
-    }
-
-    finger = point_data[GTP_ADDR_LENGTH];    
-
-#if GTP_COMPATIBLE_MODE
-    // GT9XXF
-    if ((finger == 0x00) && (CHIP_TYPE_GT9F == ts->chip_type))     // request arrived
-    {
-        ret = gtp_i2c_read(ts->client, rqst_buf, 3);
-        if (ret < 0)
-        {
-           GTP_ERROR("Read request status error!");
-           goto exit_work_func;
-        } 
-        
-        switch (rqst_buf[2] & 0x0F)
-        {
-        case GTP_RQST_CONFIG:
-            GTP_INFO("Request for config.");
-            ret = gtp_send_cfg(ts->client);
-            if (ret < 0)
-            {
-                GTP_ERROR("Request for config unresponded!");
-            }
-            else
-            {
-                rqst_buf[2] = GTP_RQST_RESPONDED;
-                gtp_i2c_write(ts->client, rqst_buf, 3);
-                GTP_INFO("Request for config responded!");
-            }
-            break;
-            
-        case GTP_RQST_BAK_REF:
-            GTP_INFO("Request for backup reference.");
-            ret = gtp_bak_ref_proc(ts, GTP_BAK_REF_SEND);
-            if (SUCCESS == ret)
-            {
-                rqst_buf[2] = GTP_RQST_RESPONDED;
-                gtp_i2c_write(ts->client, rqst_buf, 3);
-                GTP_INFO("Request for backup reference responded!");
-            }
-            else
-            {
-                GTP_ERROR("Requeset for backup reference unresponed!");
-            }
-            break;
-            
-        case GTP_RQST_RESET:
-            GTP_INFO("Request for reset.");
-            gtp_recovery_reset(ts->client);
-            break;
-            
-        case GTP_RQST_MAIN_CLOCK:
-            GTP_INFO("Request for main clock.");
-            ts->rqst_processing = 1;
-            ret = gtp_main_clk_proc(ts);
-            if (FAIL == ret)
-            {
-                GTP_ERROR("Request for main clock unresponded!");
-            }
-            else
-            {
-                GTP_INFO("Request for main clock responded!");
-                rqst_buf[2] = GTP_RQST_RESPONDED;
-                gtp_i2c_write(ts->client, rqst_buf, 3);
-                ts->rqst_processing = 0;
-                ts->clk_chk_fs_times = 0;
-            }
-            break;
-            
-        case GTP_RQST_IDLE:
-        default:
-            break;
-        }
-    }
-#endif
+static void gt9xx_int_sync(struct gt9xx_ts *ts)
+{
+	struct pinctrl *pinctrl = ts->pinctrl;
 
-    if((finger & 0x80) == 0)
-    {
-        goto exit_work_func;
-    }
-
-    touch_num = finger & 0x0f;
-    if (touch_num > GTP_MAX_TOUCH)
-    {
-        goto exit_work_func;
-    }
-
-    if (touch_num > 1)
-    {
-        u8 buf[8 * GTP_MAX_TOUCH] = {(GTP_READ_COOR_ADDR + 10) >> 8, (GTP_READ_COOR_ADDR + 10) & 0xff};
-
-        ret = gtp_i2c_read(ts->client, buf, 2 + 8 * (touch_num - 1)); 
-        memcpy(&point_data[12], &buf[2], 8 * (touch_num - 1));
-    }
-
-#if GTP_HAVE_TOUCH_KEY
-    key_value = point_data[3 + 8 * touch_num];
-    
-    if(key_value || pre_key)
-    {
-        for (i = 0; i < GTP_MAX_KEY_NUM; i++)
-        {
-        #if GTP_DEBUG_ON
-            for (ret = 0; ret < 4; ++ret)
-            {
-                if (key_codes[ret] == touch_key_array[i])
-                {
-                    GTP_DEBUG("Key: %s %s", key_names[ret], (key_value & (0x01 << i)) ? "Down" : "Up");
-                    break;
-                }
-            }
-        #endif
-            input_report_key(ts->input_dev, touch_key_array[i], key_value & (0x01<<i));   
-        }
-        touch_num = 0;
-        pre_touch = 0;
-    }
-#endif
-    pre_key = key_value;
+	gpiod_direction_output(ts->gpiod_int, 0);
+	msleep(50);
+	gpiod_direction_input(ts->gpiod_int);
 
-    GTP_DEBUG("pre_touch:%02x, finger:%02x.", pre_touch, finger);
+	if (pinctrl)
+		pinctrl_select_state(pinctrl, ts->int_state);
+}
 
-#if GTP_ICS_SLOT_REPORT
+static void gt9xx_reset(struct gt9xx_ts *ts)
+{
+	struct pinctrl *pinctrl = ts->pinctrl;
+
+	if (pinctrl)
+		pinctrl_select_state(pinctrl, ts->ctrl_state);
+
+	/* begin select I2C slave addr */
+	gpiod_direction_output(ts->gpiod_rst, 0);
+	msleep(20);				/* T2: > 10ms */
+	/* HIGH: 0x28/0x29, LOW: 0xBA/0xBB */
+	gpiod_direction_output(ts->gpiod_int, ts->client->addr == 0x14);
+	msleep(2);				/* T3: > 100us */
+	gpiod_direction_output(ts->gpiod_rst, 1);
+	msleep(6);				/* T4: > 5ms */
+	/* end select I2C slave addr */
+	gpiod_direction_input(ts->gpiod_rst);
+
+	gt9xx_int_sync(ts);
+}
 
-#if GTP_WITH_PEN
-    if (pre_pen && (touch_num == 0))
-    {
-        GTP_DEBUG("Pen touch UP(Slot)!");
-        input_report_key(ts->input_dev, BTN_TOOL_PEN, 0);
-        input_mt_slot(ts->input_dev, 5);
-        input_report_abs(ts->input_dev, ABS_MT_TRACKING_ID, -1);
-        pre_pen = 0;
-    }
-#endif
-    if (pre_touch || touch_num)
-    {
-        s32 pos = 0;
-        u16 touch_index = 0;
-        u8 report_num = 0;
-        coor_data = &point_data[3];
-        
-        if(touch_num)
-        {
-            id = coor_data[pos] & 0x0F;
-        
-        #if GTP_WITH_PEN
-            id = coor_data[pos];
-            if ((id & 0x80))  
-            {
-                GTP_DEBUG("Pen touch DOWN(Slot)!");
-                input_x  = coor_data[pos + 1] | (coor_data[pos + 2] << 8);
-                input_y  = coor_data[pos + 3] | (coor_data[pos + 4] << 8);
-                input_w  = coor_data[pos + 5] | (coor_data[pos + 6] << 8);
-                
-                input_report_key(ts->input_dev, BTN_TOOL_PEN, 1);
-                input_mt_slot(ts->input_dev, 5);
-                input_report_abs(ts->input_dev, ABS_MT_TRACKING_ID, 5);
-                input_report_abs(ts->input_dev, ABS_MT_POSITION_X, input_x);
-                input_report_abs(ts->input_dev, ABS_MT_POSITION_Y, input_y);
-                input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, input_w);
-                GTP_DEBUG("Pen/Stylus: (%d, %d)[%d]", input_x, input_y, input_w);
-                pre_pen = 1;
-                pre_touch = 0;
-            }    
-        #endif
-        
-            touch_index |= (0x01<<id);
-        }
-        
-        GTP_DEBUG("id = %d,touch_index = 0x%x, pre_touch = 0x%x\n",id, touch_index,pre_touch);
-        for (i = 0; i < GTP_MAX_TOUCH; i++)
-        {
-        #if GTP_WITH_PEN
-            if (pre_pen == 1)
-            {
-                break;
-            }
-        #endif
-        
-            if ((touch_index & (0x01<<i)))
-            {
-                input_x  = coor_data[pos + 1] | (coor_data[pos + 2] << 8);
-                input_y  = coor_data[pos + 3] | (coor_data[pos + 4] << 8);
-                input_w  = coor_data[pos + 5] | (coor_data[pos + 6] << 8);
-
-                gtp_touch_down(ts, id, input_x, input_y, input_w);
-                pre_touch |= 0x01 << i;
-                
-                report_num++;
-                if (report_num < touch_num)
-                {
-                    pos += 8;
-                    id = coor_data[pos] & 0x0F;
-                    touch_index |= (0x01<<id);
-                }
-            }
-            else
-            {
-                gtp_touch_up(ts, i);
-                pre_touch &= ~(0x01 << i);
-            }
-        }
-    }
+#ifdef CONFIG_ACPI
+static int gt9xx_get_and_send_cfg(struct gt9xx_ts *ts)
+{
+	int ret;
+	struct device *dev = &ts->client->dev;
+	struct acpi_buffer buf = {ACPI_ALLOCATE_BUFFER, NULL};
+	union acpi_object *out;
+	acpi_handle handle;
+	acpi_status err;
+
+	handle = ACPI_HANDLE(dev);
+	if (!handle) {
+		dev_err(&ts->client->dev, "Cannot get ACPI handle");
+		return -EINVAL;
+	}
+
+	err = acpi_evaluate_object(handle, "_DSM", NULL, &buf);
+	out = buf.pointer;
+	if (ACPI_FAILURE(err) || !(out->type == ACPI_TYPE_BUFFER)) {
+		dev_err(&ts->client->dev, "Cannot get ACPI config buffer array");
+		return -EINVAL;
+	}
+
+	ret = gt9xx_send_cfg(ts, out->buffer.pointer, out->buffer.length);
+	if (ret > 0)
+		ret = 0;
+
+	kfree(out);
+
+	return ret;
+}
 #else
-    input_report_key(ts->input_dev, BTN_TOUCH, (touch_num || key_value));
-    if (touch_num)
-    {
-        for (i = 0; i < touch_num; i++)
-        {
-            coor_data = &point_data[i * 8 + 3];
-
-            id = coor_data[0] & 0x0F;
-            input_x  = coor_data[1] | (coor_data[2] << 8);
-            input_y  = coor_data[3] | (coor_data[4] << 8);
-            input_w  = coor_data[5] | (coor_data[6] << 8);
-        
-        #if GTP_WITH_PEN
-            id = coor_data[0];
-            if (id & 0x80)
-            {
-                GTP_DEBUG("Pen touch DOWN!");
-                input_report_key(ts->input_dev, BTN_TOOL_PEN, 1);
-                pre_pen = 1;
-                id = 0;   
-            }
-        #endif
-        
-            gtp_touch_down(ts, id, input_x, input_y, input_w);
-        }
-    }
-    else if (pre_touch)
-    {
-    
-    #if GTP_WITH_PEN
-        if (pre_pen == 1)
-        {
-            GTP_DEBUG("Pen touch UP!");
-            input_report_key(ts->input_dev, BTN_TOOL_PEN, 0);
-            pre_pen = 0;
-        }
-    #endif
-    
-        GTP_DEBUG("Touch Release!");
-        gtp_touch_up(ts, 0);
-    }
-
-    pre_touch = touch_num;
+static inline int gt9xx_get_and_send_cfg(struct gt9xx_ts *ts)
+{
+	u8 *config;
+	int ret;
+
+	config = kzalloc(sizeof(*config)*GT9XX_CONFIG_LENGTH, GFP_KERNEL);
+	if (!config)
+		return -ENOMEM;
+
+	ret = of_property_read_u8_array(ts->client->dev.of_node,
+				"goodix,config", config, GT9XX_CONFIG_LENGTH);
+	if (ret) {
+		dev_err(&ts->client->dev,
+			"Cannot get OF config buffer array. Err: %d", ret);
+		goto out;
+	}
+
+	ret = gt9xx_send_cfg(ts, config, GT9XX_CONFIG_LENGTH);
+	if (ret > 0)
+		ret = 0;
+
+out:
+	kfree(config);
+	return ret;
+}
 #endif
 
-    input_sync(ts->input_dev);
-
-exit_work_func:
-    if(!ts->gtp_rawdiff_mode)
-    {
-        ret = gtp_i2c_write(ts->client, end_cmd, 3);
-        if (ret < 0)
-        {
-            GTP_INFO("I2C write end_cmd error!");
-        }
-    }
-    if (ts->use_irq)
-    {
-        gtp_irq_enable(ts);
-    }
+static int gt9xx_fw_check_and_repair(struct i2c_client *client, u16 start_addr,
+				     u8 *comp_buf, u32 len)
+{
+	int i = 0, ret = 0, retry = 0, comp_len, index = 0;
+	u8 *buf;
+	bool check_failed = false;
+
+	buf = kmalloc(GT9XX_FW_CHK_SIZE, GFP_KERNEL);
+
+	while (index < len && retry < GT9XX_FW_CHK_RETRY) {
+		comp_len = ((len - index) < GT9XX_FW_CHK_SIZE) ? (len - index) :
+				GT9XX_FW_CHK_SIZE;
+
+		ret = gt9xx_i2c_read(client, start_addr + index, buf, comp_len);
+		if (ret <= 0)
+			break;
+
+		for (i = 0; i < comp_len; i++) {
+			if (buf[i] != comp_buf[index + i]) {
+				gt9xx_i2c_write(client, start_addr + index + i,
+						&comp_buf[index + i],
+						comp_len - i);
+				retry++;
+				check_failed = true;
+				break;
+			}
+		}
+		if (!check_failed)
+			index += comp_len;
+
+		check_failed = false;
+	}
+
+	kfree(buf);
+
+	if ((len - index) > 0)
+		return -EIO;
+
+	return ret;
 }
 
-/*******************************************************
-Function:
-    Timer interrupt service routine for polling mode.
-Input:
-    timer: timer struct pointer
-Output:
-    Timer work mode. 
-        HRTIMER_NORESTART: no restart mode
-*********************************************************/
-static enum hrtimer_restart goodix_ts_timer_handler(struct hrtimer *timer)
+static int gt9xx_fw_flash_verify(struct i2c_client *client, u8 bank, u16 addr,
+				 u8 *data, u32 len)
 {
-    struct goodix_ts_data *ts = container_of(timer, struct goodix_ts_data, timer);
+	int ret;
 
-    GTP_DEBUG_FUNC();
+	ret = gt9xx_i2c_write_u8(client, GT9XX_SRAM_BANK_ADDR, bank);
+	if (ret <= 0)
+		return ret;
 
-    queue_work(goodix_wq, &ts->work);
-    hrtimer_start(&ts->timer, ktime_set(0, (GTP_POLL_TIME+6)*1000000), HRTIMER_MODE_REL);
-    return HRTIMER_NORESTART;
+	ret = gt9xx_i2c_write(client, addr, data, len);
+	if (ret <= 0)
+		return ret;
+
+	return gt9xx_fw_check_and_repair(client, addr, data, len);
 }
 
-/*******************************************************
-Function:
-    External interrupt service routine for interrupt mode.
-Input:
-    irq:  interrupt number.
-    dev_id: private data pointer
-Output:
-    Handle Result.
-        IRQ_HANDLED: interrupt handled successfully
-*********************************************************/
-static irqreturn_t goodix_ts_irq_handler(int irq, void *dev_id)
+static int gt9x5_flash_and_check(struct i2c_client *client,
+				u16 addr, u8 *data, u32 tot_len)
 {
-    struct goodix_ts_data *ts = dev_id;
-
-    GTP_DEBUG_FUNC();
- 
-    gtp_irq_disable(ts);
-
-    queue_work(goodix_wq, &ts->work);
-    
-    return IRQ_HANDLED;
+	u16 cur_addr = addr;
+	u32 cur_len = 0, pack_len = 0;
+	int ret = 0, retry;
+	u8 *cur_data = data;
+	u8 rd_buf[GT9X5_FLASH_PACK_LEN];
+
+	dev_dbg(&client->dev,
+		"Begin flash %dk data to addr 0x%x\n", (tot_len/1024),
+		cur_addr);
+	while (cur_len < tot_len) {
+		pack_len = tot_len - cur_len;
+		dev_dbg(&client->dev, "B/T:%04d/%04d\n", cur_len, tot_len);
+		if (pack_len > GT9X5_FLASH_PACK_LEN)
+			pack_len = GT9X5_FLASH_PACK_LEN;
+		for (retry = 0; retry < 5; retry++) {
+			ret = gt9xx_i2c_write(client, cur_addr, cur_data,
+					      pack_len);
+			if (ret <= 0) {
+				dev_err(&client->dev,
+					"write packet data i2c err\n");
+				continue;
+			}
+			ret = gt9xx_i2c_read(client, cur_addr, rd_buf,
+					     pack_len);
+			if (ret <= 0) {
+				dev_err(&client->dev,
+					"read packet data i2c err\n");
+				continue;
+			}
+			if (memcmp(cur_data, rd_buf, pack_len)) {
+				dev_err(&client->dev,
+					"check pack data failed, not equal");
+				continue;
+			} else
+				break;
+		}
+		if (retry >= 5) {
+			dev_err(&client->dev, "flash data time out, exit\n");
+			return -EINVAL;
+		}
+		cur_len += pack_len;
+		cur_addr += pack_len;
+		cur_data += pack_len;
+	}
+
+	return 1;
 }
-/*******************************************************
-Function:
-    Synchronization.
-Input:
-    ms: synchronization time in millisecond.
-Output:
-    None.
-*******************************************************/
-void gtp_int_sync(s32 ms)
+
+static int gt9x5_fw_flash_ss51_section(struct i2c_client *client, u8 bank,
+				       u16 addr, u8 *data, u32 len)
 {
-    GTP_GPIO_OUTPUT(GTP_INT_PORT, 0);
-    msleep(ms);
-    GTP_GPIO_AS_INT(GTP_INT_PORT);
+	int ret, val = 0, retry = 0;
+
+	dev_dbg(&client->dev,
+		"ss51 fw flash section bank:%d addr:%04x len:%d\n",
+		bank, addr, len);
+
+	/* select and hold ss51 & dsp */
+	ret = gt9xx_i2c_write_u8(client, GT9XX_SWRST_B0_ADDR,
+				 GT9XX_SWRST_B0_DEF_VAL);
+	if (ret <= 0)
+		return ret;
+
+	/* set scramble */
+	ret = gt9xx_i2c_write_u8(client, GT9XX_BOOT_OPT_B0_ADDR, 0);
+	if (ret <= 0)
+		return ret;
+
+	/* select bank */
+	ret = gt9xx_i2c_write_u8(client, GT9XX_SRAM_BANK_ADDR,
+				 (bank >> 4) & 0x0f);
+	if (ret <= 0)
+		return ret;
+
+	/* enable accessing mode */
+	ret = gt9xx_i2c_write_u8(client, GT9XX_MEM_CD_EN_ADDR, 1);
+	if (ret <= 0)
+		return ret;
+
+	/* write the data */
+	ret = gt9x5_flash_and_check(client, addr, data, len);
+	if (ret <= 0)
+		return ret;
+
+	/* release dsp & hold ss51 */
+	ret = gt9xx_i2c_write_u8(client, GT9XX_SWRST_B0_ADDR,
+				 GT9X5_SWRST_REL_DSP_HOLD_SS51);
+	if (ret <= 0)
+		return ret;
+
+	/* must sleep for a millisecond */
+	usleep_range(1000, 2000);
+
+	/* send burn command to move data to flash from sram */
+	ret = gt9xx_i2c_write_u8(client, GT9XX_BOOT_CTL_ADDR, bank & 0x0f);
+	if (ret <= 0)
+		return ret;
+
+	/* wait for flash burn to complete */
+	do {
+		ret = gt9xx_i2c_read(client, GT9XX_BOOT_CTL_ADDR, &val, 1);
+		if (ret <= 0)
+			return ret;
+		/* wait for 10 ms, value based on reference driver*/
+		usleep_range(10000, 11000);
+	} while (val && retry++ < len);
+
+	dev_dbg(&client->dev,
+		"ss51 section burn command complete val:%d retry:%d len:%d\n",
+		 val, retry, len);
+
+	/* select bank */
+	ret = gt9xx_i2c_write_u8(client, GT9XX_SRAM_BANK_ADDR,
+				 (bank >> 4) & 0x0f);
+	if (ret <= 0)
+		return ret;
+
+	/* enable accessing mode */
+	ret = gt9xx_i2c_write_u8(client, GT9XX_MEM_CD_EN_ADDR, 1);
+	if (ret <= 0)
+		return ret;
+
+	ret = gt9xx_fw_check_and_repair(client, addr, data, len);
+	if (ret <= 0)
+		return ret;
+
+	/* disable accessing mode */
+	return gt9xx_i2c_write_u8(client, GT9XX_MEM_CD_EN_ADDR, 0);
 }
 
-
-/*******************************************************
-Function:
-    Reset chip.
-Input:
-    ms: reset time in millisecond
-Output:
-    None.
-*******************************************************/
-void gtp_reset_guitar(struct i2c_client *client, s32 ms)
+static int gt9x5_fw_flash_block_ss51(struct gt9xx_ts *ts)
 {
-#if GTP_COMPATIBLE_MODE
-    struct goodix_ts_data *ts = i2c_get_clientdata(client);
-#endif    
-
-    GTP_DEBUG_FUNC();
-    GTP_INFO("Guitar reset");
-    GTP_GPIO_OUTPUT(GTP_RST_PORT, 0);   // begin select I2C slave addr
-    msleep(ms);                         // T2: > 10ms
-    // HIGH: 0x28/0x29, LOW: 0xBA/0xBB
-    GTP_GPIO_OUTPUT(GTP_INT_PORT, client->addr == 0x14);
-
-    msleep(2);                          // T3: > 100us
-    GTP_GPIO_OUTPUT(GTP_RST_PORT, 1);
-    
-    msleep(6);                          // T4: > 5ms
-
-    GTP_GPIO_AS_INPUT(GTP_RST_PORT);    // end select I2C slave addr
-
-#if GTP_COMPATIBLE_MODE
-    if (CHIP_TYPE_GT9F == ts->chip_type)
-    {
-        return;
-    }
-#endif
+	struct i2c_client *client = ts->client;
+	int ret;
+	const u8 *data;
+	u8 *temp_data;
 
-    gtp_int_sync(50);  
-#if GTP_ESD_PROTECT
-    gtp_init_ext_watchdog(client);
-#endif
-}
+	temp_data = kmalloc((GT9XX_SS51_SECTION_LEN + 1), GFP_KERNEL);
 
-#if GTP_SLIDE_WAKEUP
-/*******************************************************
-Function:
-    Enter doze mode for sliding wakeup.
-Input:
-    ts: goodix tp private data
-Output:
-    1: succeed, otherwise failed
-*******************************************************/
-static s8 gtp_enter_doze(struct goodix_ts_data *ts)
-{
-    s8 ret = -1;
-    s8 retry = 0;
-    u8 i2c_control_buf[3] = {(u8)(GTP_REG_SLEEP >> 8), (u8)GTP_REG_SLEEP, 8};
+	/* move head to section 1 address*/
+	data = &ts->fw->data[GT9XX_FW_HEAD_LEN + GT9XX_SS51_START_INDEX];
 
-    GTP_DEBUG_FUNC();
+	memset(temp_data, 0xff, GT9XX_SS51_SECTION_LEN);
 
-#if GTP_DBL_CLK_WAKEUP
-    i2c_control_buf[2] = 0x09;
-#endif
+	/* clear control flag */
+	ret = gt9xx_i2c_write_u8(client, GT9XX_BOOT_CTL_ADDR, 0);
+	if (ret <= 0)
+		return ret;
 
-    gtp_irq_disable(ts);
-    
-    GTP_DEBUG("Entering doze mode.");
-    while(retry++ < 5)
-    {
-        i2c_control_buf[0] = 0x80;
-        i2c_control_buf[1] = 0x46;
-        ret = gtp_i2c_write(ts->client, i2c_control_buf, 3);
-        if (ret < 0)
-        {
-            GTP_DEBUG("failed to set doze flag into 0x8046, %d", retry);
-            continue;
-        }
-        i2c_control_buf[0] = 0x80;
-        i2c_control_buf[1] = 0x40;
-        ret = gtp_i2c_write(ts->client, i2c_control_buf, 3);
-        if (ret > 0)
-        {
-            doze_status = DOZE_ENABLED;
-            GTP_INFO("GTP has been working in doze mode!");
-            gtp_irq_enable(ts);
-            return ret;
-        }
-        msleep(10);
-    }
-    GTP_ERROR("GTP send doze cmd failed.");
-    gtp_irq_enable(ts);
-    return ret;
-}
-#else 
-/*******************************************************
-Function:
-    Enter sleep mode.
-Input:
-    ts: private data.
-Output:
-    Executive outcomes.
-       1: succeed, otherwise failed.
-*******************************************************/
-static s8 gtp_enter_sleep(struct goodix_ts_data * ts)
-{
-    s8 ret = -1;
-    s8 retry = 0;
-    u8 i2c_control_buf[3] = {(u8)(GTP_REG_SLEEP >> 8), (u8)GTP_REG_SLEEP, 5};
+	/* flash ss51 firmware section 1*/
+	ret =  gt9x5_fw_flash_ss51_section(client, 1, GT9X5_SS51_BLOCK_ADDR1,
+					   (u8 *)temp_data,
+					   GT9XX_SS51_SECTION_LEN);
+	kfree(temp_data);
+	if (ret <= 0)
+		return ret;
 
-#if GTP_COMPATIBLE_MODE
-    u8 status_buf[3] = {0x80, 0x44};
-#endif
-    
-    GTP_DEBUG_FUNC();
-    
-#if GTP_COMPATIBLE_MODE
-    if (CHIP_TYPE_GT9F == ts->chip_type)
-    {
-        // GT9XXF: host interact with ic
-        ret = gtp_i2c_read(ts->client, status_buf, 3);
-        if (ret < 0)
-        {
-            GTP_ERROR("failed to get backup-reference status");
-        }
-        
-        if (status_buf[2] & 0x80)
-        {
-            ret = gtp_bak_ref_proc(ts, GTP_BAK_REF_STORE);
-            if (FAIL == ret)
-            {
-                GTP_ERROR("failed to store bak_ref");
-            }
-        }
-    }
-#endif
+	/* move head to section 2 address */
+	data = &ts->fw->data[GT9XX_FW_HEAD_LEN + GT9XX_SS51_SECTION_LEN];
 
-    GTP_GPIO_OUTPUT(GTP_INT_PORT, 0);
-    msleep(5);
-    
-    while(retry++ < 5)
-    {
-        ret = gtp_i2c_write(ts->client, i2c_control_buf, 3);
-        if (ret > 0)
-        {
-            GTP_INFO("GTP enter sleep!");
-            
-            return ret;
-        }
-        msleep(10);
-    }
-    GTP_ERROR("GTP send sleep cmd failed.");
-    return ret;
-}
-#endif 
-/*******************************************************
-Function:
-    Wakeup from sleep.
-Input:
-    ts: private data.
-Output:
-    Executive outcomes.
-        >0: succeed, otherwise: failed.
-*******************************************************/
-static s8 gtp_wakeup_sleep(struct goodix_ts_data * ts)
-{
-    u8 retry = 0;
-    s8 ret = -1;
-    
-    GTP_DEBUG_FUNC();
-
-#if GTP_COMPATIBLE_MODE
-    if (CHIP_TYPE_GT9F == ts->chip_type)
-    {
-        u8 opr_buf[3] = {0x41, 0x80};
-        
-        GTP_GPIO_OUTPUT(GTP_INT_PORT, 1);
-        msleep(5);
-    
-        for (retry = 0; retry < 20; ++retry)
-        {
-            // hold ss51 & dsp
-            opr_buf[2] = 0x0C;
-            ret = gtp_i2c_write(ts->client, opr_buf, 3);
-            if (FAIL == ret)
-            {
-                GTP_ERROR("failed to hold ss51 & dsp!");
-                continue;
-            }
-            opr_buf[2] = 0x00;
-            ret = gtp_i2c_read(ts->client, opr_buf, 3);
-            if (FAIL == ret)
-            {
-                GTP_ERROR("failed to get ss51 & dsp status!");
-                continue;
-            }
-            if (0x0C != opr_buf[2])
-            {
-                GTP_DEBUG("ss51 & dsp not been hold, %d", retry+1);
-                continue;
-            }
-            GTP_DEBUG("ss51 & dsp confirmed hold");
-            
-            ret = gtp_fw_startup(ts->client);
-            if (FAIL == ret)
-            {
-                GTP_ERROR("failed to startup GT9XXF, process recovery");
-                gtp_esd_recovery(ts->client);
-            }
-            break;
-        }
-        if (retry >= 10)
-        {
-            GTP_ERROR("failed to wakeup, processing esd recovery");
-            gtp_esd_recovery(ts->client);
-        }
-        else
-        {
-            GTP_INFO("GT9XXF gtp wakeup success");
-        }
-        return ret;
-    }
-#endif
+	/* flash ss51 firmware section 2*/
+	ret =  gt9x5_fw_flash_ss51_section(client, 2, GT9X5_SS51_BLOCK_ADDR2,
+					   (u8 *)data, GT9XX_SS51_SECTION_LEN);
+	if (ret <= 0)
+		return ret;
 
-#if GTP_POWER_CTRL_SLEEP
-    while(retry++ < 5)
-    {
-        gtp_reset_guitar(ts->client, 20);
-        
-        GTP_INFO("GTP wakeup sleep.");
-        return 1;
-    }
-#else
-    while(retry++ < 10)
-    {
-    #if GTP_SLIDE_WAKEUP
-        if (DOZE_WAKEUP != doze_status)       // wakeup not by slide 
-        {
-            GTP_DEBUG("wakeup by power, reset guitar");
-            doze_status = DOZE_DISABLED;   
-            gtp_irq_disable(ts);
-            gtp_reset_guitar(ts->client, 10);
-            gtp_irq_enable(ts);
-        }
-        else              // wakeup by slide 
-        {
-            GTP_DEBUG("wakeup by slide/double-click, no reset guitar");
-            doze_status = DOZE_DISABLED;
-        #if GTP_ESD_PROTECT
-            gtp_init_ext_watchdog(ts->client);
-        #endif
-        }
-        
-    #else
-        if (chip_gt9xxs == 1)
-        {
-           gtp_reset_guitar(ts->client, 10);
-        }
-        else
-        {
-            GTP_GPIO_OUTPUT(GTP_INT_PORT, 1);
-            msleep(5);
-        }
-    #endif
-    
-        ret = gtp_i2c_test(ts->client);
-        if (ret > 0)
-        {
-            GTP_INFO("GTP wakeup sleep.");
-            
-        #if (!GTP_SLIDE_WAKEUP)
-            if (chip_gt9xxs == 0)
-            {
-                gtp_int_sync(25);
-            #if GTP_ESD_PROTECT
-                gtp_init_ext_watchdog(ts->client);
-            #endif
-            }
-        #endif
-            
-            return ret;
-        }
-        gtp_reset_guitar(ts->client, 20);
-    }
-#endif
+	/* move head to section 3 address */
+	data = &ts->fw->data[GT9XX_FW_HEAD_LEN + 2 * GT9XX_SS51_SECTION_LEN];
 
-    GTP_ERROR("GTP wakeup sleep failed.");
-    return ret;
-}
-#if GTP_DRIVER_SEND_CFG
-static s32 gtp_get_info(struct goodix_ts_data *ts)
-{
-    u8 opr_buf[6] = {0};
-    s32 ret = 0;
-    
-    opr_buf[0] = (u8)((GTP_REG_CONFIG_DATA+1) >> 8);
-    opr_buf[1] = (u8)((GTP_REG_CONFIG_DATA+1) & 0xFF);
-    
-    ret = gtp_i2c_read(ts->client, opr_buf, 6);
-    if (ret < 0)
-    {
-        return FAIL;
-    }
-    
-    ts->abs_x_max = (opr_buf[3] << 8) + opr_buf[2];
-    ts->abs_y_max = (opr_buf[5] << 8) + opr_buf[4];
-    
-    opr_buf[0] = (u8)((GTP_REG_CONFIG_DATA+6) >> 8);
-    opr_buf[1] = (u8)((GTP_REG_CONFIG_DATA+6) & 0xFF);
-    
-    ret = gtp_i2c_read(ts->client, opr_buf, 3);
-    if (ret < 0)
-    {
-        return FAIL;
-    }
-    ts->int_trigger_type = opr_buf[2] & 0x03;
-    
-    GTP_INFO("X_MAX = %d, Y_MAX = %d, TRIGGER = 0x%02x",
-            ts->abs_x_max,ts->abs_y_max,ts->int_trigger_type);
-    
-    return SUCCESS;    
+	/* flash ss51 firmware section 3*/
+	ret =  gt9x5_fw_flash_ss51_section(client, 0x13, GT9X5_SS51_BLOCK_ADDR1,
+					   (u8 *)data, GT9XX_SS51_SECTION_LEN);
+	if (ret <= 0)
+		return ret;
+
+	/* move head to section 4 address */
+	data = &ts->fw->data[GT9XX_FW_HEAD_LEN + 3 * GT9XX_SS51_SECTION_LEN];
+
+	/* flash ss51 firmware section 4*/
+	ret =  gt9x5_fw_flash_ss51_section(client, 0x14, GT9X5_SS51_BLOCK_ADDR2,
+					   (u8 *)data, GT9XX_SS51_SECTION_LEN);
+
+	dev_info(&ts->client->dev, "ss51 fw flash sucess\n");
+
+	return ret;
 }
-#endif 
-
-/*******************************************************
-Function:
-    Initialize gtp.
-Input:
-    ts: goodix private data
-Output:
-    Executive outcomes.
-        0: succeed, otherwise: failed
-*******************************************************/
-static s32 gtp_init_panel(struct goodix_ts_data *ts)
+
+static int gt9x5_fw_flash_block_dsp(struct gt9xx_ts *ts)
 {
-    s32 ret = -1;
-
-#if GTP_DRIVER_SEND_CFG
-    s32 i = 0;
-    u8 check_sum = 0;
-    u8 opr_buf[16] = {0};
-    u8 sensor_id = 0; 
-    
-    u8 cfg_info_group1[] = CTP_CFG_GROUP1;
-    u8 cfg_info_group2[] = CTP_CFG_GROUP2;
-    u8 cfg_info_group3[] = CTP_CFG_GROUP3;
-    u8 cfg_info_group4[] = CTP_CFG_GROUP4;
-    u8 cfg_info_group5[] = CTP_CFG_GROUP5;
-    u8 cfg_info_group6[] = CTP_CFG_GROUP6;
-    u8 *send_cfg_buf[] = {cfg_info_group1, cfg_info_group2, cfg_info_group3,
-                        cfg_info_group4, cfg_info_group5, cfg_info_group6};
-    u8 cfg_info_len[] = { CFG_GROUP_LEN(cfg_info_group1),
-                          CFG_GROUP_LEN(cfg_info_group2),
-                          CFG_GROUP_LEN(cfg_info_group3),
-                          CFG_GROUP_LEN(cfg_info_group4),
-                          CFG_GROUP_LEN(cfg_info_group5),
-                          CFG_GROUP_LEN(cfg_info_group6)};
-
-    GTP_DEBUG_FUNC();
-    GTP_DEBUG("Config Groups\' Lengths: %d, %d, %d, %d, %d, %d", 
-        cfg_info_len[0], cfg_info_len[1], cfg_info_len[2], cfg_info_len[3],
-        cfg_info_len[4], cfg_info_len[5]);
-
-    
-#if GTP_COMPATIBLE_MODE
-    if (CHIP_TYPE_GT9F == ts->chip_type)
-    {
-        ts->fw_error = 0;
-    }
-    else
-#endif
-    {
-        ret = gtp_i2c_read_dbl_check(ts->client, 0x41E4, opr_buf, 1);
-        if (SUCCESS == ret) 
-        {
-            if (opr_buf[0] != 0xBE)
-            {
-                ts->fw_error = 1;
-                GTP_ERROR("Firmware error, no config sent!");
-                return -1;
-            }
-        }
-    }
-
-    if ((!cfg_info_len[1]) && (!cfg_info_len[2]) && 
-        (!cfg_info_len[3]) && (!cfg_info_len[4]) && 
-        (!cfg_info_len[5]))
-    {
-        sensor_id = 0; 
-    }
-    else
-    {
-    #if GTP_COMPATIBLE_MODE
-        msleep(50);
-    #endif
-        ret = gtp_i2c_read_dbl_check(ts->client, GTP_REG_SENSOR_ID, &sensor_id, 1);
-        if (SUCCESS == ret)
-        {
-            if (sensor_id >= 0x06)
-            {
-                GTP_ERROR("Invalid sensor_id(0x%02X), No Config Sent!", sensor_id);
-                ts->pnl_init_error = 1;
-            #if GTP_COMPATIBLE_MODE
-                if (CHIP_TYPE_GT9F == ts->chip_type)
-                {
-                    return -1;
-                }
-                else
-            #endif
-                {
-                    gtp_get_info(ts);
-                }
-                return 0;
-            }
-        }
-        else
-        {
-            GTP_ERROR("Failed to get sensor_id, No config sent!");
-            ts->pnl_init_error = 1;
-            return -1;
-        }
-        GTP_INFO("Sensor_ID: %d", sensor_id);
-    }
-    ts->gtp_cfg_len = cfg_info_len[sensor_id];
-    GTP_INFO("CTP_CONFIG_GROUP%d used, config length: %d", sensor_id + 1, ts->gtp_cfg_len);
-    
-    if (ts->gtp_cfg_len < GTP_CONFIG_MIN_LENGTH)
-    {
-        GTP_ERROR("Config Group%d is INVALID CONFIG GROUP(Len: %d)! NO Config Sent! You need to check you header file CFG_GROUP section!", sensor_id+1, ts->gtp_cfg_len);
-        ts->pnl_init_error = 1;
-        return -1;
-    }
-
-#if GTP_COMPATIBLE_MODE
-    if (CHIP_TYPE_GT9F == ts->chip_type)
-    {
-        ts->fixed_cfg = 0;
-    }
-    else
-#endif
-    {
-        ret = gtp_i2c_read_dbl_check(ts->client, GTP_REG_CONFIG_DATA, &opr_buf[0], 1);
-        
-        if (ret == SUCCESS)
-        {
-            GTP_DEBUG("CFG_GROUP%d Config Version: %d, 0x%02X; IC Config Version: %d, 0x%02X", sensor_id+1, 
-                        send_cfg_buf[sensor_id][0], send_cfg_buf[sensor_id][0], opr_buf[0], opr_buf[0]);
-            
-            if (opr_buf[0] < 90)    
-            {
-                grp_cfg_version = send_cfg_buf[sensor_id][0];       // backup group config version
-                send_cfg_buf[sensor_id][0] = 0x00;
-                ts->fixed_cfg = 0;
-            }
-            else        // treated as fixed config, not send config
-            {
-                GTP_INFO("Ic fixed config with config version(%d, 0x%02X)", opr_buf[0], opr_buf[0]);
-                ts->fixed_cfg = 1;
-                gtp_get_info(ts);
-                return 0;
-            }
-        }
-        else
-        {
-            GTP_ERROR("Failed to get ic config version!No config sent!");
-            return -1;
-        }
-    }
-    
-    memset(&config[GTP_ADDR_LENGTH], 0, GTP_CONFIG_MAX_LENGTH);
-    memcpy(&config[GTP_ADDR_LENGTH], send_cfg_buf[sensor_id], ts->gtp_cfg_len);
-
-#if GTP_CUSTOM_CFG
-    config[RESOLUTION_LOC]     = (u8)GTP_MAX_WIDTH;
-    config[RESOLUTION_LOC + 1] = (u8)(GTP_MAX_WIDTH>>8);
-    config[RESOLUTION_LOC + 2] = (u8)GTP_MAX_HEIGHT;
-    config[RESOLUTION_LOC + 3] = (u8)(GTP_MAX_HEIGHT>>8);
-    
-    if (GTP_INT_TRIGGER == 0)  //RISING
-    {
-        config[TRIGGER_LOC] &= 0xfe; 
-    }
-    else if (GTP_INT_TRIGGER == 1)  //FALLING
-    {
-        config[TRIGGER_LOC] |= 0x01;
-    }
-#endif  // GTP_CUSTOM_CFG
-    
-    check_sum = 0;
-    for (i = GTP_ADDR_LENGTH; i < ts->gtp_cfg_len; i++)
-    {
-        check_sum += config[i];
-    }
-    config[ts->gtp_cfg_len] = (~check_sum) + 1;
-
-#else // driver not send config
-
-    ts->gtp_cfg_len = GTP_CONFIG_MAX_LENGTH;
-    ret = gtp_i2c_read(ts->client, config, ts->gtp_cfg_len + GTP_ADDR_LENGTH);
-    if (ret < 0)
-    {
-        GTP_ERROR("Read Config Failed, Using Default Resolution & INT Trigger!");
-        ts->abs_x_max = GTP_MAX_WIDTH;
-        ts->abs_y_max = GTP_MAX_HEIGHT;
-        ts->int_trigger_type = GTP_INT_TRIGGER;
-    }
-    
-#endif // GTP_DRIVER_SEND_CFG
-
-    if ((ts->abs_x_max == 0) && (ts->abs_y_max == 0))
-    {
-        ts->abs_x_max = (config[RESOLUTION_LOC + 1] << 8) + config[RESOLUTION_LOC];
-        ts->abs_y_max = (config[RESOLUTION_LOC + 3] << 8) + config[RESOLUTION_LOC + 2];
-        ts->int_trigger_type = (config[TRIGGER_LOC]) & 0x03; 
-    }
-
-#if GTP_COMPATIBLE_MODE
-    if (CHIP_TYPE_GT9F == ts->chip_type)
-    {
-        u8 sensor_num = 0;
-        u8 driver_num = 0;
-        u8 have_key = 0;
-        
-        have_key = (config[GTP_REG_HAVE_KEY - GTP_REG_CONFIG_DATA + 2] & 0x01);
-        
-        if (1 == ts->is_950)
-        {
-            driver_num = config[GTP_REG_MATRIX_DRVNUM - GTP_REG_CONFIG_DATA + 2];
-            sensor_num = config[GTP_REG_MATRIX_SENNUM - GTP_REG_CONFIG_DATA + 2];
-            if (have_key)
-            {
-                driver_num--;
-            }
-            ts->bak_ref_len = (driver_num * (sensor_num - 1) + 2) * 2 * 6;
-        }
-        else
-        {
-            driver_num = (config[CFG_LOC_DRVA_NUM] & 0x1F) + (config[CFG_LOC_DRVB_NUM]&0x1F);
-            if (have_key)
-            {
-                driver_num--;
-            }
-            sensor_num = (config[CFG_LOC_SENS_NUM] & 0x0F) + ((config[CFG_LOC_SENS_NUM] >> 4) & 0x0F);
-            ts->bak_ref_len = (driver_num * (sensor_num - 2) + 2) * 2;
-        }
-    
-        GTP_INFO("Drv * Sen: %d * %d(key: %d), X_MAX: %d, Y_MAX: %d, TRIGGER: 0x%02x",
-           driver_num, sensor_num, have_key, ts->abs_x_max,ts->abs_y_max,ts->int_trigger_type);
-        return 0;
-    }
-    else
-#endif
-    {
-    #if GTP_DRIVER_SEND_CFG
-        ret = gtp_send_cfg(ts->client);
-        if (ret < 0)
-        {
-            GTP_ERROR("Send config error.");
-        }
-        // set config version to CTP_CFG_GROUP, for resume to send config
-        config[GTP_ADDR_LENGTH] = grp_cfg_version;
-        check_sum = 0;
-        for (i = GTP_ADDR_LENGTH; i < ts->gtp_cfg_len; i++)
-        {
-            check_sum += config[i];
-        }
-        config[ts->gtp_cfg_len] = (~check_sum) + 1;
-    #endif
-        GTP_INFO("X_MAX: %d, Y_MAX: %d, TRIGGER: 0x%02x", ts->abs_x_max,ts->abs_y_max,ts->int_trigger_type);
-    }
-    
-    msleep(10);
-    return 0;
+	struct i2c_client *client = ts->client;
+	const u8 *data;
+	int val = 0, ret, retry = 0;
+
+	/* move head to dsp section 1 address*/
+	data = &ts->fw->data[GT9XX_FW_HEAD_LEN + GT9XX_DSP_START_INDEX];
+
+	/* select bank 3*/
+	ret = gt9xx_i2c_write_u8(client, GT9XX_SRAM_BANK_ADDR, 0x03);
+	if (ret <= 0)
+		return ret;
+
+	/* select and hold ss51 & dsp */
+	ret = gt9xx_i2c_write_u8(client, GT9XX_SWRST_B0_ADDR,
+				 GT9XX_SWRST_B0_DEF_VAL);
+	if (ret <= 0)
+		return ret;
+
+	/* set scramble */
+	ret = gt9xx_i2c_write_u8(client, GT9XX_BOOT_OPT_B0_ADDR, 0);
+	if (ret <= 0)
+		return ret;
+
+	/* hold ss51 & release dsp */
+	ret = gt9xx_i2c_write_u8(client, GT9XX_SWRST_B0_ADDR,
+				 GT9X5_SWRST_REL_DSP_HOLD_SS51);
+	if (ret <= 0)
+		return ret;
+
+	/* must sleep for a millisecond */
+	usleep_range(1000, 2000);
+
+	/* write the data & verify */
+	ret = gt9x5_flash_and_check(client, GT9X5_DSP_BLOCK_ADDR, (u8 *)data,
+			      GT9XX_DSP_SECTION_LEN);
+	if (ret <= 0)
+		return ret;
+
+	/* send burn command to move data to flash from sram */
+	ret = gt9xx_i2c_write_u8(client, GT9XX_BOOT_CTL_ADDR, 0x05);
+	if (ret <= 0)
+		return ret;
+
+	/* wait for flash burn to complete */
+	do {
+		ret = gt9xx_i2c_read(client, GT9XX_BOOT_CTL_ADDR, &val, 1);
+		if (ret <= 0)
+			return ret;
+		/* wait for 10 ms, value based on reference driver*/
+		usleep_range(10000, 11000);
+	} while (val && retry++ < GT9XX_DSP_SECTION_LEN);
+
+	dev_dbg(&client->dev,
+		"dsp section flash send burn command done %d %d %d\n",
+		val, retry, GT9XX_DSP_SECTION_LEN);
+
+	ret = gt9xx_fw_check_and_repair(client, GT9X5_DSP_BLOCK_ADDR,
+					(u8 *)data, GT9XX_DSP_SECTION_LEN);
+
+	dev_info(&ts->client->dev, "dsp fw flash sucess\n");
+
+	return ret;
 }
 
-/*******************************************************
-Function:
-    Read chip version.
-Input:
-    client:  i2c device
-    version: buffer to keep ic firmware version
-Output:
-    read operation return.
-        2: succeed, otherwise: failed
-*******************************************************/
-s32 gtp_read_version(struct i2c_client *client, u16* version)
+static int gt9x5_fw_flash_block_boot(struct gt9xx_ts *ts)
 {
-    s32 ret = -1;
-    u8 buf[8] = {GTP_REG_VERSION >> 8, GTP_REG_VERSION & 0xff};
-
-    GTP_DEBUG_FUNC();
-
-    ret = gtp_i2c_read(client, buf, sizeof(buf));
-    if (ret < 0)
-    {
-        GTP_ERROR("GTP read version failed");
-        return ret;
-    }
-
-    if (version)
-    {
-        *version = (buf[7] << 8) | buf[6];
-    }
-    
-    if (buf[5] == 0x00)
-    {
-        GTP_INFO("IC Version: %c%c%c_%02x%02x", buf[2], buf[3], buf[4], buf[7], buf[6]);
-    }
-    else
-    {
-        if (buf[5] == 'S' || buf[5] == 's')
-        {
-            chip_gt9xxs = 1;
-        }
-        GTP_INFO("IC Version: %c%c%c%c_%02x%02x", buf[2], buf[3], buf[4], buf[5], buf[7], buf[6]);
-    }
-    return ret;
+	struct i2c_client *client = ts->client;
+	int ret, val = 0, retry = 0;
+	const u8 *data;
+
+	/* move head to boot section 1 address*/
+	data = &ts->fw->data[GT9XX_FW_HEAD_LEN + GT9X5_BOOT_START_INDEX];
+
+	/* select and hold ss51 & dsp */
+	ret = gt9xx_i2c_write_u8(client, GT9XX_SWRST_B0_ADDR,
+				 GT9XX_SWRST_B0_DEF_VAL);
+	if (ret <= 0)
+		return ret;
+
+	/* set scramble */
+	ret = gt9xx_i2c_write_u8(client, GT9XX_BOOT_OPT_B0_ADDR, 0);
+	if (ret <= 0)
+		return ret;
+
+	/* release ss51 & release dsp */
+	ret = gt9xx_i2c_write_u8(client, GT9XX_SWRST_B0_ADDR,
+				 GT9XX_SWRST_B0_REL_SS51_DSP);
+	if (ret <= 0)
+		return ret;
+
+	/* must sleep for a millisecond */
+	usleep_range(1000, 2000);
+
+	/* select bank 3*/
+	ret = gt9xx_i2c_write_u8(client, GT9XX_SRAM_BANK_ADDR, 0x03);
+	if (ret <= 0)
+		return ret;
+
+	/* write the data & verify */
+	ret = gt9x5_flash_and_check(client, GT9X5_BOOT_BLOCK_ADDR, (u8 *)data,
+			      GT9X5_BOOT_SECTION_LEN);
+	if (ret <= 0)
+		return ret;
+
+	/* send burn command to move data to flash from sram */
+	ret = gt9xx_i2c_write_u8(client, GT9XX_BOOT_CTL_ADDR, 0x06);
+	if (ret <= 0)
+		return ret;
+
+	/* wait for flash burn to complete */
+	do {
+		ret = gt9xx_i2c_read(client, GT9XX_BOOT_CTL_ADDR, &val, 1);
+		if (ret <= 0)
+			return ret;
+		/* wait for 10 ms, value based on reference driver*/
+		usleep_range(10000, 11000);
+	} while (val && retry++ < GT9X5_BOOT_SECTION_LEN);
+	dev_dbg(&client->dev,
+		"boot section flash send burn cmd complete %d %d %d\n",
+		val, retry, GT9X5_BOOT_SECTION_LEN);
+
+	ret = gt9xx_fw_check_and_repair(client, GT9X5_BOOT_BLOCK_ADDR,
+					(u8 *)data, GT9X5_BOOT_SECTION_LEN);
+	if (ret <= 0)
+		return ret;
+
+	dev_info(&ts->client->dev, "boot fw flash sucess\n");
+
+	return ret;
 }
 
-/*******************************************************
-Function:
-    I2c test Function.
-Input:
-    client:i2c client.
-Output:
-    Executive outcomes.
-        2: succeed, otherwise failed.
-*******************************************************/
-static s8 gtp_i2c_test(struct i2c_client *client)
+static int gt9x5_fw_flash_block_boot_isp(struct gt9xx_ts *ts)
 {
-    u8 test[3] = {GTP_REG_CONFIG_DATA >> 8, GTP_REG_CONFIG_DATA & 0xff};
-    u8 retry = 0;
-    s8 ret = -1;
-  
-    GTP_DEBUG_FUNC();
-  
-    while(retry++ < 5)
-    {
-        ret = gtp_i2c_read(client, test, 3);
-        if (ret > 0)
-        {
-            return ret;
-        }
-        GTP_ERROR("GTP i2c test failed time %d.",retry);
-        msleep(10);
-    }
-    return ret;
+	struct i2c_client *client = ts->client;
+	int ret, val = 0, retry = 0;
+	const u8 *data;
+
+	/* move head to boot section 1 address*/
+	data = &ts->fw->data[GT9XX_FW_HEAD_LEN + GT9X5_BOOT_ISP_START_INDEX];
+
+	/* select and hold ss51 & dsp */
+	ret = gt9xx_i2c_write_u8(client, GT9XX_SWRST_B0_ADDR,
+				 GT9XX_SWRST_B0_DEF_VAL);
+	if (ret <= 0)
+		return ret;
+
+	/* set scramble */
+	ret = gt9xx_i2c_write_u8(client, GT9XX_BOOT_OPT_B0_ADDR, 0);
+	if (ret <= 0)
+		return ret;
+
+	/* release ss51 & release dsp */
+	ret = gt9xx_i2c_write_u8(client, GT9XX_SWRST_B0_ADDR,
+				 GT9XX_SWRST_B0_REL_SS51_DSP);
+	if (ret <= 0)
+		return ret;
+
+	/* must sleep for a millisecond */
+	usleep_range(1000, 2000);
+
+	/* select bank 3*/
+	ret = gt9xx_i2c_write_u8(client, GT9XX_SRAM_BANK_ADDR, 0x03);
+	if (ret <= 0)
+		return ret;
+
+	/* write the data & verify */
+	ret = gt9x5_flash_and_check(client, GT9X5_BOOT_ISP_BLOCK_ADDR,
+				    (u8 *)data, GT9X5_BOOT_ISP_SECTION_LEN);
+	if (ret <= 0)
+		return ret;
+
+	/* send burn command to move data to flash from sram */
+	ret = gt9xx_i2c_write_u8(client, GT9XX_BOOT_CTL_ADDR, 0x07);
+	if (ret <= 0)
+		return ret;
+
+	/* wait for flash burn to complete */
+	do {
+		ret = gt9xx_i2c_read(client, GT9XX_BOOT_CTL_ADDR, &val, 1);
+		if (ret <= 0)
+			return ret;
+		/* wait for 10 ms, value based on reference driver*/
+		usleep_range(10000, 11000);
+	} while (val && retry++ < GT9X5_BOOT_ISP_SECTION_LEN);
+	dev_dbg(&client->dev,
+		"boot isp section flash send burn cmd complete %d %d %d\n",
+		val, retry, GT9X5_BOOT_ISP_SECTION_LEN);
+
+	ret = gt9xx_fw_check_and_repair(client, GT9X5_BOOT_ISP_BLOCK_ADDR,
+					(u8 *)data, GT9X5_BOOT_ISP_SECTION_LEN);
+	if (ret <= 0)
+		return ret;
+
+	dev_info(&ts->client->dev, "boot isp fw flash sucess\n");
+
+	return ret;
 }
 
-/*******************************************************
-Function:
-    Request gpio(INT & RST) ports.
-Input:
-    ts: private data.
-Output:
-    Executive outcomes.
-        >= 0: succeed, < 0: failed
-*******************************************************/
-static s8 gtp_request_io_port(struct goodix_ts_data *ts)
+static int gt9x5_fw_flash_g_section(struct i2c_client *client, u8 bank,
+				       u16 addr, u8 *data, u32 len)
 {
-    s32 ret = 0;
-
-    GTP_DEBUG_FUNC();
-    ret = GTP_GPIO_REQUEST(GTP_INT_PORT, "GTP_INT_IRQ");
-    if (ret < 0) 
-    {
-        GTP_ERROR("Failed to request GPIO:%d, ERRNO:%d", (s32)GTP_INT_PORT, ret);
-        ret = -ENODEV;
-    }
-    else
-    {
-        GTP_GPIO_AS_INT(GTP_INT_PORT);  
-        ts->client->irq = GTP_INT_IRQ;
-    }
-
-    ret = GTP_GPIO_REQUEST(GTP_RST_PORT, "GTP_RST_PORT");
-    if (ret < 0) 
-    {
-        GTP_ERROR("Failed to request GPIO:%d, ERRNO:%d",(s32)GTP_RST_PORT,ret);
-        ret = -ENODEV;
-    }
-
-    GTP_GPIO_AS_INPUT(GTP_RST_PORT);
-
-    gtp_reset_guitar(ts->client, 20);
-    
-    if(ret < 0)
-    {
-        GTP_GPIO_FREE(GTP_RST_PORT);
-        GTP_GPIO_FREE(GTP_INT_PORT);
-    }
-
-    return ret;
+	int ret, val = 0, retry = 0;
+
+	dev_dbg(&client->dev,
+		"fw flash g section bank:%d addr:%04x len:%d\n",
+		bank, addr, len);
+
+	/* select and hold ss51 & dsp */
+	ret = gt9xx_i2c_write_u8(client, GT9XX_SWRST_B0_ADDR,
+				 GT9XX_SWRST_B0_DEF_VAL);
+	if (ret <= 0)
+		return ret;
+
+	/* set scramble */
+	ret = gt9xx_i2c_write_u8(client, GT9XX_BOOT_OPT_B0_ADDR, 0);
+	if (ret <= 0)
+		return ret;
+
+	/* release dsp & hold ss51 */
+	ret = gt9xx_i2c_write_u8(client, GT9XX_SWRST_B0_ADDR,
+				 GT9X5_SWRST_REL_DSP_HOLD_SS51);
+	if (ret <= 0)
+		return ret;
+
+	/* must sleep for a millisecond */
+	usleep_range(1000, 2000);
+
+	/* select bank */
+	ret = gt9xx_i2c_write_u8(client, GT9XX_SRAM_BANK_ADDR,
+				 (bank >> 4) & 0x0f);
+	if (ret <= 0)
+		return ret;
+
+	/* write the data */
+	ret = gt9x5_flash_and_check(client, addr, data, len);
+	if (ret <= 0)
+		return ret;
+
+	/* send burn command to move data to flash from sram */
+	ret = gt9xx_i2c_write_u8(client, GT9XX_BOOT_CTL_ADDR, bank & 0x0f);
+	if (ret <= 0)
+		return ret;
+
+	/* wait for flash burn to complete */
+	do {
+		ret = gt9xx_i2c_read(client, GT9XX_BOOT_CTL_ADDR, &val, 1);
+		if (ret <= 0)
+			return ret;
+		/* wait for 10 ms, value based on reference driver*/
+		usleep_range(10000, 11000);
+	} while (val && retry++ < len);
+
+	dev_dbg(&client->dev,
+		"g section burn command complete val:%d retry:%d len:%d\n",
+		val, retry, len);
+
+	ret = gt9xx_fw_check_and_repair(client, addr, data, len);
+
+	return ret;
 }
 
-/*******************************************************
-Function:
-    Request interrupt.
-Input:
-    ts: private data.
-Output:
-    Executive outcomes.
-        0: succeed, -1: failed.
-*******************************************************/
-static s8 gtp_request_irq(struct goodix_ts_data *ts)
+
+static int gt9x5_fw_flash_block_gfwlink(struct gt9xx_ts *ts)
 {
-    s32 ret = -1;
-    const u8 irq_table[] = GTP_IRQ_TAB;
-
-    GTP_DEBUG_FUNC();
-    GTP_DEBUG("INT trigger type:%x", ts->int_trigger_type);
-
-    ret  = request_irq(ts->client->irq, 
-                       goodix_ts_irq_handler,
-                       irq_table[ts->int_trigger_type],
-                       ts->client->name,
-                       ts);
-    if (ret)
-    {
-        GTP_ERROR("Request IRQ failed!ERRNO:%d.", ret);
-        GTP_GPIO_AS_INPUT(GTP_INT_PORT);
-        GTP_GPIO_FREE(GTP_INT_PORT);
-
-        hrtimer_init(&ts->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
-        ts->timer.function = goodix_ts_timer_handler;
-        hrtimer_start(&ts->timer, ktime_set(1, 0), HRTIMER_MODE_REL);
-        return -1;
-    }
-    else 
-    {
-        gtp_irq_disable(ts);
-        ts->use_irq = 1;
-        return 0;
-    }
+	struct i2c_client *client = ts->client;
+	int ret, newlen;
+	const u8 *data;
+
+	/* move head to g section 1 address*/
+	data = &ts->fw->data[GT9XX_FW_HEAD_LEN + GT9X5_GFWLINK_START_INDEX];
+
+	/* flash g firmware section 1*/
+	ret =  gt9x5_fw_flash_g_section(client, 0x38, GT9X5_GFWLINK_BLOCK_ADDR,
+					   (u8 *)data,
+					   GT9X5_GFWLINK_SECTION_LEN);
+	if (ret <= 0)
+		return ret;
+
+	/* move head to g section 2 address */
+	data = data + GT9X5_GFWLINK_SECTION_LEN;
+
+	newlen = GT9X5_GFWLINK_LEN - GT9X5_GFWLINK_SECTION_LEN;
+
+	/* flash firmware g section 2*/
+	ret =  gt9x5_fw_flash_g_section(client, 0x39, GT9X5_GFWLINK_BLOCK_ADDR,
+					   (u8 *)data, newlen);
+	if (ret <= 0)
+		return ret;
+
+	dev_info(&ts->client->dev, "gfwlink flash sucess\n");
+
+	return ret;
 }
 
-/*******************************************************
-Function:
-    Request input device Function.
-Input:
-    ts:private data.
-Output:
-    Executive outcomes.
-        0: succeed, otherwise: failed.
-*******************************************************/
-static s8 gtp_request_input_dev(struct goodix_ts_data *ts)
+static int gt9x5_fw_flash_block_gwake(struct gt9xx_ts *ts)
 {
-    s8 ret = -1;
-    s8 phys[32];
-#if GTP_HAVE_TOUCH_KEY
-    u8 index = 0;
-#endif
-  
-    GTP_DEBUG_FUNC();
-  
-    ts->input_dev = input_allocate_device();
-    if (ts->input_dev == NULL)
-    {
-        GTP_ERROR("Failed to allocate input device.");
-        return -ENOMEM;
-    }
-
-    ts->input_dev->evbit[0] = BIT_MASK(EV_SYN) | BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS) ;
-#if GTP_ICS_SLOT_REPORT
-    __set_bit(INPUT_PROP_DIRECT, ts->input_dev->propbit);
-    input_mt_init_slots(ts->input_dev, 16);     // in case of "out of memory"
-#else
-    ts->input_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
-#endif
+	struct i2c_client *client = ts->client;
+	int ret;
+	const u8 *data;
 
-#if GTP_HAVE_TOUCH_KEY
-    for (index = 0; index < GTP_MAX_KEY_NUM; index++)
-    {
-        input_set_capability(ts->input_dev, EV_KEY, touch_key_array[index]);  
-    }
-#endif
+	/* move head to g section 1 address*/
+	data = &ts->fw->data[GT9XX_FW_HEAD_LEN + GT9X5_GWAKE_START_INDEX];
 
-#if GTP_SLIDE_WAKEUP
-    input_set_capability(ts->input_dev, EV_KEY, KEY_POWER);
-#endif 
+	/* flash g firmware section 1*/
+	ret =  gt9x5_fw_flash_g_section(client, 0x3a, GT9X5_GWAKE_BLOCK_ADDR,
+					   (u8 *)data, GT9X5_GWAKE_SECTION_LEN);
+	if (ret <= 0)
+		return ret;
 
-#if GTP_WITH_PEN
-    // pen support
-    __set_bit(BTN_TOOL_PEN, ts->input_dev->keybit);
-    __set_bit(INPUT_PROP_DIRECT, ts->input_dev->propbit);
-    //__set_bit(INPUT_PROP_POINTER, ts->input_dev->propbit);
-#endif
+	/* move head to g section 2 address */
+	data = data + GT9X5_GWAKE_SECTION_LEN;
 
-#if GTP_CHANGE_X2Y
-    GTP_SWAP(ts->abs_x_max, ts->abs_y_max);
-#endif
+	/* flash firmware g section 2*/
+	ret =  gt9x5_fw_flash_g_section(client, 0x3b, GT9X5_GWAKE_BLOCK_ADDR,
+					   (u8 *)data, GT9X5_GWAKE_SECTION_LEN);
+	if (ret <= 0)
+		return ret;
 
-    input_set_abs_params(ts->input_dev, ABS_MT_POSITION_X, 0, ts->abs_x_max, 0, 0);
-    input_set_abs_params(ts->input_dev, ABS_MT_POSITION_Y, 0, ts->abs_y_max, 0, 0);
-    input_set_abs_params(ts->input_dev, ABS_MT_WIDTH_MAJOR, 0, 255, 0, 0);
-    input_set_abs_params(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
-    input_set_abs_params(ts->input_dev, ABS_MT_TRACKING_ID, 0, 255, 0, 0);
-
-    sprintf(phys, "input/ts");
-    ts->input_dev->name = goodix_ts_name;
-    ts->input_dev->phys = phys;
-    ts->input_dev->id.bustype = BUS_I2C;
-    ts->input_dev->id.vendor = 0xDEAD;
-    ts->input_dev->id.product = 0xBEEF;
-    ts->input_dev->id.version = 10427;
-    
-    ret = input_register_device(ts->input_dev);
-    if (ret)
-    {
-        GTP_ERROR("Register %s input device failed", ts->input_dev->name);
-        return -ENODEV;
-    }
-    
-#ifdef CONFIG_HAS_EARLYSUSPEND
-    ts->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
-    ts->early_suspend.suspend = goodix_ts_early_suspend;
-    ts->early_suspend.resume = goodix_ts_late_resume;
-    register_early_suspend(&ts->early_suspend);
-#endif
+	/* move head to g section 3 address */
+	data = data + GT9X5_GWAKE_SECTION_LEN;
 
-    return 0;
-}
+	/* flash firmware g section 3*/
+	ret =  gt9x5_fw_flash_g_section(client, 0x3c, GT9X5_GWAKE_BLOCK_ADDR,
+					   (u8 *)data, GT9X5_GWAKE_SECTION_LEN);
+	if (ret <= 0)
+		return ret;
 
-//************** For GT9XXF Start *************//
-#if GTP_COMPATIBLE_MODE
+	/* move head to g section 4 address */
+	data = data + GT9X5_GWAKE_SECTION_LEN;
 
-s32 gtp_fw_startup(struct i2c_client *client)
-{
-    u8 opr_buf[4];
-    s32 ret = 0;
-    
-    //init sw WDT
-	opr_buf[0] = 0xAA;
-	ret = i2c_write_bytes(client, 0x8041, opr_buf, 1);
-    if (ret < 0)
-    {
-        return FAIL;
-    }
-    
-    //release SS51 & DSP
-    opr_buf[0] = 0x00;
-    ret = i2c_write_bytes(client, 0x4180, opr_buf, 1);
-    if (ret < 0)
-    {
-        return FAIL;
-    }
-    //int sync
-    gtp_int_sync(25);  
-    
-    //check fw run status
-    ret = i2c_read_bytes(client, 0x8041, opr_buf, 1);
-    if (ret < 0)
-    {
-        return FAIL;
-    }
-    if(0xAA == opr_buf[0])
-    {
-        GTP_ERROR("IC works abnormally,startup failed.");
-        return FAIL;
-    }
-    else
-    {
-        GTP_INFO("IC works normally, Startup success.");
-        opr_buf[0] = 0xAA;
-        i2c_write_bytes(client, 0x8041, opr_buf, 1);
-        return SUCCESS;
-    }
+	/* flash firmware g section 4*/
+	ret =  gt9x5_fw_flash_g_section(client, 0x3d, GT9X5_GWAKE_BLOCK_ADDR,
+					   (u8 *)data, GT9X5_GWAKE_SECTION_LEN);
+	if (ret <= 0)
+		return ret;
+
+	dev_info(&ts->client->dev, "gwake flash sucess\n");
+
+	return ret;
 }
 
-static s32 gtp_esd_recovery(struct i2c_client *client)
+static int gt9x5_fw_flash_block_dsp_isp(struct gt9xx_ts *ts)
 {
-    s32 retry = 0;
-    s32 ret = 0;
-    struct goodix_ts_data *ts;
-    
-    ts = i2c_get_clientdata(client);
-    
-    gtp_irq_disable(ts);
-    
-    GTP_INFO("GT9XXF esd recovery mode");
-    gtp_reset_guitar(client, 20);       // reset & select I2C addr
-    for (retry = 0; retry < 5; ++retry)
-    {
-        ret = gup_fw_download_proc(NULL, GTP_FL_ESD_RECOVERY); 
-        if (FAIL == ret)
-        {
-            GTP_ERROR("esd recovery failed %d", retry+1);
-            continue;
-        }
-        ret = gtp_fw_startup(ts->client);
-        if (FAIL == ret)
-        {
-            GTP_ERROR("GT9XXF start up failed %d", retry+1);
-            continue;
-        }
-        break;
-    }
-    gtp_irq_enable(ts);
-    
-    if (retry >= 5)
-    {
-        GTP_ERROR("failed to esd recovery");
-        return FAIL;
-    }
-    
-    GTP_INFO("Esd recovery successful");
-    return SUCCESS;
+	struct i2c_client *client = ts->client;
+	int ret;
+	const u8 *data;
+
+	/* move head to dsp isp address*/
+	data = &ts->fw->data[ts->fw->size - GT9X5_DSP_ISP_START_INDEX];
+
+	/* disable wdt */
+	ret = gt9xx_i2c_write_u8(client, GT9XX_TMR0_EN_ADDR, 0);
+	if (ret <= 0)
+		return ret;
+
+	/* clear cache */
+	ret = gt9xx_i2c_write_u8(client, GT9XX_CACHE_EN_ADDR, 0);
+	if (ret <= 0)
+		return ret;
+
+	/* select and hold ss51 & dsp */
+	ret = gt9xx_i2c_write_u8(client, GT9XX_SWRST_B0_ADDR,
+				 GT9XX_SWRST_B0_DEF_VAL);
+	if (ret <= 0)
+		return ret;
+
+	/* set boot from SRAM */
+	ret = gt9xx_i2c_write_u8(client, GT9XX_BOOTCTL_B0_ADDR,
+				 GT9XX_BOOTCTL_B0_SRAM);
+	if (ret <= 0)
+		return ret;
+
+	/* software reset */
+	ret = gt9xx_i2c_write_u8(client, GT9XX_CPU_SWRST_PULSE_ADDR, 1);
+	if (ret <= 0)
+		return ret;
+
+	/* select bank 2*/
+	ret = gt9xx_i2c_write_u8(client, GT9XX_SRAM_BANK_ADDR, 0x02);
+	if (ret <= 0)
+		return ret;
+
+	/* enable accessing mode */
+	ret = gt9xx_i2c_write_u8(client, GT9XX_MEM_CD_EN_ADDR, 1);
+	if (ret <= 0)
+		return ret;
+
+	/* write the data & verify */
+	ret = gt9x5_flash_and_check(client, GT9X5_DSP_ISP_BLOCK_ADDR,
+				    (u8 *)data, GT9X5_DSP_ISP_SECTION_LEN);
+	if (ret <= 0)
+		return ret;
+
+	ret = gt9xx_fw_check_and_repair(client, GT9X5_DSP_ISP_BLOCK_ADDR,
+					(u8 *)data, GT9X5_DSP_ISP_SECTION_LEN);
+	if (ret <= 0)
+		return ret;
+
+	/* set scramble */
+	ret = gt9xx_i2c_write_u8(client, GT9XX_BOOT_OPT_B0_ADDR, 0);
+
+	dev_info(&ts->client->dev, "dsp isp fw flash sucess\n");
+
+	return ret;
 }
 
-void gtp_recovery_reset(struct i2c_client *client)
+static int gt9x5_fw_flash_finish(struct gt9xx_ts *ts)
 {
-#if GTP_ESD_PROTECT
-    gtp_esd_switch(client, SWITCH_OFF);
-#endif
-    GTP_DEBUG_FUNC();
-    
-    gtp_esd_recovery(client); 
-    
-#if GTP_ESD_PROTECT
-    gtp_esd_switch(client, SWITCH_ON);
-#endif
+	struct i2c_client *client = ts->client;
+	int ret;
+	const u8 *data;
+
+	/* move head to section 1 address*/
+	data = &ts->fw->data[GT9XX_FW_HEAD_LEN + GT9XX_SS51_START_INDEX];
+
+	/* clear control flag */
+	ret = gt9xx_i2c_write_u8(client, GT9XX_BOOT_CTL_ADDR, 0);
+	if (ret <= 0)
+		return ret;
+
+	/* flash ss51 firmware section 1*/
+	ret =  gt9x5_fw_flash_ss51_section(client, 1, GT9X5_SS51_BLOCK_ADDR1,
+					   (u8 *)data,
+					   GT9XX_SS51_SECTION_LEN);
+	if (ret <= 0)
+		return ret;
+
+	/* enable download DSP code */
+	ret = gt9xx_i2c_write_u8(client, GT9XX_BOOT_CTL_ADDR, 0x99);
+	if (ret <= 0)
+		return ret;
+
+	/* release ss51 & hold dsp */
+	ret = gt9xx_i2c_write_u8(client, GT9XX_SWRST_B0_ADDR,
+				 GT9X5_SWRST_REL_SS51_HOLD_DSP);
+
+	dev_info(&ts->client->dev, "dsp fw flash finish sucess\n");
+
+	return ret;
 }
 
-static s32 gtp_bak_ref_proc(struct goodix_ts_data *ts, u8 mode)
+static int gt9xx_fw_flash_block_dsp(struct gt9xx_ts *ts)
 {
-    s32 ret = 0;
-    s32 i = 0;
-    s32 j = 0;
-    u16 ref_sum = 0;
-    u16 learn_cnt = 0;
-    u16 chksum = 0;
-    s32 ref_seg_len = 0;
-    s32 ref_grps = 0;
-    struct file *ref_filp = NULL;
-    u8 *p_bak_ref;
-    
-    ret = gup_check_fs_mounted("/data");
-    if (FAIL == ret)
-    {
-        ts->ref_chk_fs_times++;
-        GTP_DEBUG("Ref check /data times/MAX_TIMES: %d / %d", ts->ref_chk_fs_times, GTP_CHK_FS_MNT_MAX);
-        if (ts->ref_chk_fs_times < GTP_CHK_FS_MNT_MAX)
-        {
-            msleep(50);
-            GTP_INFO("/data not mounted.");
-            return FAIL;
-        }
-        GTP_INFO("check /data mount timeout...");
-    }
-    else
-    {
-        GTP_INFO("/data mounted!!!(%d/%d)", ts->ref_chk_fs_times, GTP_CHK_FS_MNT_MAX);
-    }
-    
-    p_bak_ref = (u8 *)kzalloc(ts->bak_ref_len, GFP_KERNEL);
-    
-    if (NULL == p_bak_ref)
-    {
-        GTP_ERROR("Allocate memory for p_bak_ref failed!");
-        return FAIL;   
-    }
-    
-    if (ts->is_950)
-    {
-        ref_seg_len = ts->bak_ref_len / 6;
-        ref_grps = 6;
-    }
-    else
-    {
-        ref_seg_len = ts->bak_ref_len;
-        ref_grps = 1;
-    }
-    ref_filp = filp_open(GTP_BAK_REF_PATH, O_RDWR | O_CREAT, 0666);
-    if (IS_ERR(ref_filp))
-    {
-        GTP_INFO("%s is unavailable, default backup-reference used", GTP_BAK_REF_PATH);
-        goto bak_ref_default;
-    }
-    
-    switch (mode)
-    {
-    case GTP_BAK_REF_SEND:
-        GTP_INFO("Send backup-reference");
-        ref_filp->f_op->llseek(ref_filp, 0, SEEK_SET);
-        ret = ref_filp->f_op->read(ref_filp, (char*)p_bak_ref, ts->bak_ref_len, &ref_filp->f_pos);
-        if (ret < 0)
-        {
-            GTP_ERROR("failed to read bak_ref info from file, sending defualt bak_ref");
-            goto bak_ref_default;
-        }
-        for (j = 0; j < ref_grps; ++j)
-        {
-            ref_sum = 0;
-            for (i = 0; i < (ref_seg_len); i += 2)
-            {
-                ref_sum += (p_bak_ref[i + j * ref_seg_len] << 8) + p_bak_ref[i+1 + j * ref_seg_len];
-            }
-            learn_cnt = (p_bak_ref[j * ref_seg_len + ref_seg_len -4] << 8) + (p_bak_ref[j * ref_seg_len + ref_seg_len -3]);
-            chksum = (p_bak_ref[j * ref_seg_len + ref_seg_len -2] << 8) + (p_bak_ref[j * ref_seg_len + ref_seg_len -1]);
-            GTP_DEBUG("learn count = %d", learn_cnt);
-            GTP_DEBUG("chksum = %d", chksum);
-            GTP_DEBUG("ref_sum = 0x%04X", ref_sum & 0xFFFF);
-            // Sum(1~ref_seg_len) == 1
-            if (1 != ref_sum)
-            {
-                GTP_INFO("wrong chksum for bak_ref, reset to 0x00 bak_ref");
-                memset(&p_bak_ref[j * ref_seg_len], 0, ref_seg_len);
-                p_bak_ref[ref_seg_len + j * ref_seg_len - 1] = 0x01;
-            }
-            else
-            {
-                if (j == (ref_grps - 1))
-                {
-                    GTP_INFO("backup-reference data in %s used", GTP_BAK_REF_PATH);
-                }
-            }
-        }
-        ret = i2c_write_bytes(ts->client, GTP_REG_BAK_REF, p_bak_ref, ts->bak_ref_len);
-        if (FAIL == ret)
-        {
-            GTP_ERROR("failed to send bak_ref because of iic comm error");
-            filp_close(ref_filp, NULL);
-            return FAIL;
-        }
-        break;
-        
-    case GTP_BAK_REF_STORE:
-        GTP_INFO("Store backup-reference");
-        ret = i2c_read_bytes(ts->client, GTP_REG_BAK_REF, p_bak_ref, ts->bak_ref_len);
-        if (ret < 0)
-        {
-            GTP_ERROR("failed to read bak_ref info, sending default back-reference");
-            goto bak_ref_default;
-        }
-        ref_filp->f_op->llseek(ref_filp, 0, SEEK_SET);
-        ref_filp->f_op->write(ref_filp, (char*)p_bak_ref, ts->bak_ref_len, &ref_filp->f_pos);
-        break;
-        
-    default:
-        GTP_ERROR("invalid backup-reference request");
-        break;
-    }
-    filp_close(ref_filp, NULL);
-    return SUCCESS;
-
-bak_ref_default:
-    
-    for (j = 0; j < ref_grps; ++j)
-    {
-        memset(&p_bak_ref[j * ref_seg_len], 0, ref_seg_len);
-        p_bak_ref[j * ref_seg_len + ref_seg_len - 1] = 0x01;  // checksum = 1     
-    }
-    ret = i2c_write_bytes(ts->client, GTP_REG_BAK_REF, p_bak_ref, ts->bak_ref_len);
-    if (!IS_ERR(ref_filp))
-    {
-        GTP_INFO("write backup-reference data into %s", GTP_BAK_REF_PATH);
-        ref_filp->f_op->llseek(ref_filp, 0, SEEK_SET);
-        ref_filp->f_op->write(ref_filp, (char*)p_bak_ref, ts->bak_ref_len, &ref_filp->f_pos);
-        filp_close(ref_filp, NULL);
-    }
-    if (ret == FAIL)
-    {
-        GTP_ERROR("failed to load the default backup reference");
-        return FAIL;
-    }
-    return SUCCESS;
-}
+	struct i2c_client *client = ts->client;
+	const u8 *data;
 
+	data = &ts->fw->data[GT9XX_FW_HEAD_LEN + GT9XX_DSP_START_INDEX];
 
-static s32 gtp_verify_main_clk(u8 *p_main_clk)
-{
-    u8 chksum = 0;
-    u8 main_clock = p_main_clk[0];
-    s32 i = 0;
-    
-    if (main_clock < 50 || main_clock > 120)    
-    {
-        return FAIL;
-    }
-    
-    for (i = 0; i < 5; ++i)
-    {
-        if (main_clock != p_main_clk[i])
-        {
-            return FAIL;
-        }
-        chksum += p_main_clk[i];
-    }
-    chksum += p_main_clk[5];
-    if ( (chksum) == 0)
-    {
-        return SUCCESS;
-    }
-    else
-    {
-        return FAIL;
-    }
+	return gt9xx_fw_flash_verify(client, GT9XX_DSP_BANK_INDEX0,
+				     GT9XX_DSP_BLOCK_ADDR, (u8 *)data,
+				     GT9XX_DSP_SECTION_LEN);
 }
 
-static s32 gtp_main_clk_proc(struct goodix_ts_data *ts)
+static int gt9xx_fw_flash_block_ss51(struct gt9xx_ts *ts)
 {
-    s32 ret = 0;
-    s32 i = 0;
-    s32 clk_chksum = 0;
-    struct file *clk_filp = NULL;
-    u8 p_main_clk[6] = {0};
-
-    ret = gup_check_fs_mounted("/data");
-    if (FAIL == ret)
-    {
-        ts->clk_chk_fs_times++;
-        GTP_DEBUG("Clock check /data times/MAX_TIMES: %d / %d", ts->clk_chk_fs_times, GTP_CHK_FS_MNT_MAX);
-        if (ts->clk_chk_fs_times < GTP_CHK_FS_MNT_MAX)
-        {
-            msleep(50);
-            GTP_INFO("/data not mounted.");
-            return FAIL;
-        }
-        GTP_INFO("Check /data mount timeout!");
-    }
-    else
-    {
-        GTP_INFO("/data mounted!!!(%d/%d)", ts->clk_chk_fs_times, GTP_CHK_FS_MNT_MAX);
-    }
-    
-    clk_filp = filp_open(GTP_MAIN_CLK_PATH, O_RDWR | O_CREAT, 0666);
-    if (IS_ERR(clk_filp))
-    {
-        GTP_ERROR("%s is unavailable, calculate main clock", GTP_MAIN_CLK_PATH);
-    }
-    else
-    {
-        clk_filp->f_op->llseek(clk_filp, 0, SEEK_SET);
-        clk_filp->f_op->read(clk_filp, (char *)p_main_clk, 6, &clk_filp->f_pos);
-       
-        ret = gtp_verify_main_clk(p_main_clk);
-        if (FAIL == ret)
-        {
-            // recalculate main clock & rewrite main clock data to file
-            GTP_ERROR("main clock data in %s is wrong, recalculate main clock", GTP_MAIN_CLK_PATH);
-        }
-        else
-        { 
-            GTP_INFO("main clock data in %s used, main clock freq: %d", GTP_MAIN_CLK_PATH, p_main_clk[0]);
-            filp_close(clk_filp, NULL);
-            goto update_main_clk;
-        }
-    }
-    
-#if GTP_ESD_PROTECT
-    gtp_esd_switch(ts->client, SWITCH_OFF);
-#endif
-    ret = gup_clk_calibration();
-    gtp_esd_recovery(ts->client);
-    
-#if GTP_ESD_PROTECT
-    gtp_esd_switch(ts->client, SWITCH_ON);
-#endif
+	struct i2c_client *client = ts->client;
+	int ret;
+	const u8 *data;
+
+	data = &ts->fw->data[GT9XX_FW_HEAD_LEN + GT9XX_SS51_START_INDEX];
+
+	/* flash first sections */
+	ret = gt9xx_fw_flash_verify(client, GT9XX_SS51_BANK_INDEX0,
+				    GT9XX_SS51_BLOCK_ADDR, (u8 *)data,
+				    GT9XX_SS51_SECTION_LEN * 2);
+	if (ret <= 0)
+		return ret;
 
-    GTP_INFO("calibrate main clock: %d", ret);
-    if (ret < 50 || ret > 120)
-    {
-        GTP_ERROR("wrong main clock: %d", ret);
-        goto exit_main_clk;
-    }
-    
-    // Sum{0x8020~0x8025} = 0
-    for (i = 0; i < 5; ++i)
-    {
-        p_main_clk[i] = ret;
-        clk_chksum += p_main_clk[i];
-    }
-    p_main_clk[5] = 0 - clk_chksum;
-    
-    if (!IS_ERR(clk_filp))
-    {
-        GTP_DEBUG("write main clock data into %s", GTP_MAIN_CLK_PATH);
-        clk_filp->f_op->llseek(clk_filp, 0, SEEK_SET);
-        clk_filp->f_op->write(clk_filp, (char *)p_main_clk, 6, &clk_filp->f_pos);
-        filp_close(clk_filp, NULL);
-    }
-    
-update_main_clk:
-    ret = i2c_write_bytes(ts->client, GTP_REG_MAIN_CLK, p_main_clk, 6);
-    if (FAIL == ret)
-    {
-        GTP_ERROR("update main clock failed!");
-        return FAIL;
-    }
-    return SUCCESS;
-    
-exit_main_clk:
-    if (!IS_ERR(clk_filp))
-    {
-        filp_close(clk_filp, NULL);
-    }
-    return FAIL;
+	data = &ts->fw->data[GT9XX_FW_HEAD_LEN + 2 * GT9XX_SS51_SECTION_LEN];
+
+	/* flash next 2 sections */
+	return gt9xx_fw_flash_verify(client, GT9XX_SS51_BANK_INDEX1,
+				     GT9XX_SS51_BLOCK_ADDR, (u8 *)data,
+				     GT9XX_SS51_SECTION_LEN * 2);
 }
 
-s32 gtp_gt9xxf_init(struct i2c_client *client)
+/* If the version of current fw in tp is not older than the
+ * target updated fw, return 0, otherwise return 1.
+ */
+static int gt9xx_fw_ver_check(struct gt9xx_ts *ts)
 {
-    s32 ret = 0;
-    
-    ret = gup_fw_download_proc(NULL, GTP_FL_FW_BURN); 
-    if (FAIL == ret)
-    {
-        return FAIL;
-    }
-    
-    ret = gtp_fw_startup(client);
-    if (FAIL == ret)
-    {
-        return FAIL;
-    }
-    return SUCCESS;
+	/* perform checksum calculation */
+	ts->fw_head = (struct gt9xx_fw_head *)ts->fw->data;
+
+	ts->fw_head->vid = (u16)be16_to_cpu(ts->fw_head->vid);
+
+	if (ts->input->id.version >= ts->fw_head->vid)
+		return 0;
+
+	return 1;
 }
 
-void gtp_get_chip_type(struct goodix_ts_data *ts)
+static int gt9xx_fw_checksum(struct gt9xx_ts *ts)
 {
-    u8 opr_buf[10] = {0x00};
-    s32 ret = 0;
-    
-    msleep(10);
-    
-    ret = gtp_i2c_read_dbl_check(ts->client, GTP_REG_CHIP_TYPE, opr_buf, 10);
-    
-    if (FAIL == ret)
-    {
-        GTP_ERROR("Failed to get chip-type, set chip type default: GOODIX_GT9");
-        ts->chip_type = CHIP_TYPE_GT9;
-        return;
-    }
-    
-    if (!memcmp(opr_buf, "GOODIX_GT9", 10))
-    {
-        ts->chip_type = CHIP_TYPE_GT9;
-    }
-    else // GT9XXF
-    {
-        ts->chip_type = CHIP_TYPE_GT9F;
-    }
-    GTP_INFO("Chip Type: %s", (ts->chip_type == CHIP_TYPE_GT9) ? "GOODIX_GT9" : "GOODIX_GT9F");
+	int i, checksum = 0;
+
+	for (i = GT9XX_FW_HEAD_LEN; i < ts->fw->size; i += 2)
+		checksum += (ts->fw->data[i] << 8) + ts->fw->data[i+1];
+
+	if (checksum & 0xffff)
+		return -EINVAL;
+
+	return 0;
 }
 
-#endif
-//************* For GT9XXF End ************//
-
-/*******************************************************
-Function:
-    I2c probe.
-Input:
-    client: i2c device struct.
-    id: device id.
-Output:
-    Executive outcomes. 
-        0: succeed.
-*******************************************************/
- static int goodix_ts_probe(struct i2c_client *client, const struct i2c_device_id *id)
+static int gt9xx_fw_download_enabled(struct gt9xx_ts *ts)
 {
-    s32 ret = -1;
-    struct goodix_ts_data *ts;
-    u16 version_info;
-    
-    GTP_DEBUG_FUNC();
-    
-    //do NOT remove these logs
-    GTP_INFO("GTP Driver Version: %s", GTP_DRIVER_VERSION);
-    GTP_INFO("GTP Driver Built@%s, %s", __TIME__, __DATE__);
-    GTP_INFO("GTP I2C Address: 0x%02x", client->addr);
-
-    i2c_connect_client = client;
-    
-    if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) 
-    {
-        GTP_ERROR("I2C check functionality failed.");
-        return -ENODEV;
-    }
-    ts = kzalloc(sizeof(*ts), GFP_KERNEL);
-    if (ts == NULL)
-    {
-        GTP_ERROR("Alloc GFP_KERNEL memory failed.");
-        return -ENOMEM;
-    }
-    
-    memset(ts, 0, sizeof(*ts));
-    INIT_WORK(&ts->work, goodix_ts_work_func);
-    ts->client = client;
-    spin_lock_init(&ts->irq_lock);          // 2.6.39 later
-    // ts->irq_lock = SPIN_LOCK_UNLOCKED;   // 2.6.39 & before
-#if GTP_ESD_PROTECT
-    ts->clk_tick_cnt = 2 * HZ;      // HZ: clock ticks in 1 second generated by system
-    GTP_DEBUG("Clock ticks for an esd cycle: %d", ts->clk_tick_cnt);  
-    spin_lock_init(&ts->esd_lock);
-    // ts->esd_lock = SPIN_LOCK_UNLOCKED;
-#endif
-    i2c_set_clientdata(client, ts);
-    
-    ts->gtp_rawdiff_mode = 0;
-
-    ret = gtp_request_io_port(ts);
-    if (ret < 0)
-    {
-        GTP_ERROR("GTP request IO port failed.");
-        kfree(ts);
-        return ret;
-    }
-    
-#if GTP_COMPATIBLE_MODE
-    gtp_get_chip_type(ts);
-    
-    if (CHIP_TYPE_GT9F == ts->chip_type)
-    {
-        ret = gtp_gt9xxf_init(ts->client);
-        if (FAIL == ret)
-        {
-            GTP_INFO("Failed to init GT9XXF.");
-        }
-    }
+	unsigned long long load_firmware = 0;
+	struct device_node *of_np = ts->client->dev.of_node;
+#ifdef CONFIG_ACPI
+	acpi_handle handle;
+	acpi_status status;
+
+	handle = ACPI_HANDLE(&ts->client->dev);
+	if (!handle)
+		return load_firmware;
+
+	status = acpi_evaluate_integer(handle, "_FRM", NULL, &load_firmware);
+	if (ACPI_SUCCESS(status))
+		dev_info(&ts->client->dev, "_FRM=%llu\n", load_firmware);
 #endif
 
-    ret = gtp_i2c_test(client);
-    if (ret < 0)
-    {
-        GTP_ERROR("I2C communication ERROR!");
-    }
-
-    ret = gtp_read_version(client, &version_info);
-    if (ret < 0)
-    {
-        GTP_ERROR("Read version failed.");
-    }
-    
-    ret = gtp_init_panel(ts);
-    if (ret < 0)
-    {
-        GTP_ERROR("GTP init panel failed.");
-        ts->abs_x_max = GTP_MAX_WIDTH;
-        ts->abs_y_max = GTP_MAX_HEIGHT;
-        ts->int_trigger_type = GTP_INT_TRIGGER;
-    }
-    
-
-    
-#if GTP_AUTO_UPDATE
-    ret = gup_init_update_proc(ts);
-    if (ret < 0)
-    {
-        GTP_ERROR("Create update thread error.");
-    }
+#ifdef CONFIG_OF
+	if (of_get_property(of_np, GT9XX_FIRMWARE_UPDATE_PROPERTY, NULL)) {
+		dev_info(&ts->client->dev, "of firmware-udpate enabled\n");
+		load_firmware = 1;
+	}
 #endif
 
-    ret = gtp_request_input_dev(ts);
-    if (ret < 0)
-    {
-        GTP_ERROR("GTP request input dev failed");
-    }
-    
-    ret = gtp_request_irq(ts); 
-    if (ret < 0)
-    {
-        GTP_INFO("GTP works in polling mode.");
-    }
-    else
-    {
-        GTP_INFO("GTP works in interrupt mode.");
-    }
-
-    if (ts->use_irq)
-    {
-        gtp_irq_enable(ts);
-    }
-    
-#if GTP_CREATE_WR_NODE
-    init_wr_node(client);
-#endif
-    
-#if GTP_ESD_PROTECT
-    gtp_esd_switch(client, SWITCH_ON);
-#endif
-    return 0;
+	return load_firmware;
 }
 
+static int gt9xx_fw_is_valid(struct gt9xx_ts *ts)
+{
+	struct {
+		u8 id[4];	/* may not be NULL terminated */
+		__le16 fw_version;
+	} __packed id;
+	char id_str[5];
+	int ret = 0;
+
+	if (!gt9xx_fw_download_enabled(ts)) {
+		dev_warn(&ts->client->dev, "gt9xx fw download not enabled\n");
+		return 0;
+	}
+
+	/* Get the current version in tp ic */
+	ret = gt9xx_i2c_read(ts->client, GT9XX_REG_ID, &id, sizeof(id));
+	if (ret <= 0) {
+		dev_err(&ts->client->dev, "[%s] read id failed", __func__);
+		return ret;
+	}
+
+	memcpy(id_str, id.id, 4);
+	id_str[4] = 0;
+	if (kstrtou16(id_str, 10, &ts->input->id.product))
+		ts->input->id.product = 0;
+	ts->input->id.version = le16_to_cpu(id.fw_version);
+
+	dev_info(&ts->client->dev, "[%s] current version: %d_%04x", __func__,
+		ts->input->id.product, ts->input->id.version);
+
+	/* Get the version info of the firmware file */
+	ret = request_firmware(&ts->fw, ts->fw_name, &ts->client->dev);
+	if (ret < 0 || !ts->fw) {
+		dev_err(&ts->client->dev, "[%s] gt9xx request firmware failed\n",
+			__func__);
+		return ret;
+	}
+
+	if (ts->fw->size < (GT9XX_SS51_SECTION_LEN * 4 +
+				GT9XX_DSP_SECTION_LEN)) {
+		dev_err(&ts->client->dev, "[%s] Invalid FW size", __func__,
+				ts->fw->size);
+		goto fw_err;
+	}
+
+	if (gt9xx_fw_checksum(ts)) {
+		dev_err(&ts->client->dev, "[%s] fw checksum error", __func__);
+		goto fw_err;
+	}
+
+	return 1;
+
+fw_err:
+	release_firmware(ts->fw);
+	return 0;
+}
 
-/*******************************************************
-Function:
-    Goodix touchscreen driver release function.
-Input:
-    client: i2c device struct.
-Output:
-    Executive outcomes. 0---succeed.
-*******************************************************/
-static int goodix_ts_remove(struct i2c_client *client)
+static int gt9x5_enter_fw_burn_mode(struct gt9xx_ts *ts)
 {
-    struct goodix_ts_data *ts = i2c_get_clientdata(client);
-    
-    GTP_DEBUG_FUNC();
-    
-#ifdef CONFIG_HAS_EARLYSUSPEND
-    unregister_early_suspend(&ts->early_suspend);
-#endif
+	int retry = 0, ret;
+	struct i2c_client *client = ts->client;
+	u8 val;
 
-#if GTP_CREATE_WR_NODE
-    uninit_wr_node();
-#endif
+	/* Step1: RST output low last at least 2ms */
+	gpiod_direction_output(ts->gpiod_rst, 0);
+	gpiod_set_value(ts->gpiod_rst, 0);
+	usleep_range(2000, 2200);
 
-#if GTP_ESD_PROTECT
-    destroy_workqueue(gtp_esd_check_workqueue);
-#endif
+	/* Step2: select I2C slave addr,INT:0--0xBA;1--0x28 */
+	gpiod_direction_output(ts->gpiod_int, (ts->client->addr == 0x14));
+	gpiod_set_value(ts->gpiod_rst, (ts->client->addr == 0x14));
+	usleep_range(2000, 2200);
+
+	/* Step3: RST output high reset guitar */
+	gpiod_direction_output(ts->gpiod_rst, 1);
+	gpiod_set_value(ts->gpiod_rst, 1);
+	usleep_range(6000, 6200);
+
+	/* select and hold ss51 & dsp */
+	while (retry++ < GT9XX_FW_HOLD_RETRY) {
+
+		ret = gt9xx_i2c_write_u8(client, GT9XX_SWRST_B0_ADDR,
+					 GT9XX_SWRST_B0_DEF_VAL);
+		if (ret <= 0)
+			continue;
+
+		ret = gt9xx_i2c_read(client, GT9XX_SWRST_B0_ADDR, &val, 1);
+		if (ret <= 0)
+			continue;
+
+		if (val == GT9XX_SWRST_B0_DEF_VAL)
+			break;
+	}
+
+	if (retry >= GT9XX_FW_HOLD_RETRY)
+		return -ENODEV;
+
+	/* dsp clock power on*/
+	ret = gt9xx_i2c_write_u8(client, GT9XX_DSP_CLK_ADDR, 0);
 
-    if (ts) 
-    {
-        if (ts->use_irq)
-        {
-            GTP_GPIO_AS_INPUT(GTP_INT_PORT);
-            GTP_GPIO_FREE(GTP_INT_PORT);
-            free_irq(client->irq, ts);
-        }
-        else
-        {
-            hrtimer_cancel(&ts->timer);
-        }
-    }   
-    
-    GTP_INFO("GTP driver removing...");
-    i2c_set_clientdata(client, NULL);
-    input_unregister_device(ts->input_dev);
-    kfree(ts);
-
-    return 0;
+	return ret;
 }
 
-#ifdef CONFIG_HAS_EARLYSUSPEND
-/*******************************************************
-Function:
-    Early suspend function.
-Input:
-    h: early_suspend struct.
-Output:
-    None.
-*******************************************************/
-static void goodix_ts_early_suspend(struct early_suspend *h)
+static int gt9xx_enter_fw_burn_mode(struct gt9xx_ts *ts)
 {
-    struct goodix_ts_data *ts;
-    s8 ret = -1;    
-    ts = container_of(h, struct goodix_ts_data, early_suspend);
-    
-    GTP_DEBUG_FUNC();
-
-#if GTP_ESD_PROTECT
-    gtp_esd_switch(ts->client, SWITCH_OFF);
-#endif
-    ts->gtp_is_suspend = 1;
-    
-#if GTP_SLIDE_WAKEUP
-    ret = gtp_enter_doze(ts);
-#else
-    if (ts->use_irq)
-    {
-        gtp_irq_disable(ts);
-    }
-    else
-    {
-        hrtimer_cancel(&ts->timer);
-    }
-    ret = gtp_enter_sleep(ts);
-#endif 
-    if (ret < 0)
-    {
-        GTP_ERROR("GTP early suspend failed.");
-    }
-    // to avoid waking up while not sleeping
-    //  delay 48 + 10ms to ensure reliability    
-    msleep(58);   
+	int retry = 0, ret;
+	struct i2c_client *client = ts->client;
+	u8 val;
+
+	/* Step1: RST output low last at least 2ms */
+	gpiod_direction_output(ts->gpiod_rst, 0);
+	usleep_range(2000, 2200);
+
+	/* Step2: select I2C slave addr,INT:0--0xBA;1--0x28 */
+	gpiod_direction_output(ts->gpiod_int, ts->client->addr == 0x14);
+	usleep_range(2000, 2200);
+
+	/* Step3: RST output high reset guitar */
+	gpiod_direction_output(ts->gpiod_rst, 1);
+	usleep_range(6000, 6200);
+
+	/* select and hold ss51 & dsp */
+	while (retry++ < GT9XX_FW_HOLD_RETRY) {
+
+		ret = gt9xx_i2c_write_u8(client, GT9XX_SWRST_B0_ADDR,
+					 GT9XX_SWRST_B0_DEF_VAL);
+		if (ret <= 0)
+			continue;
+
+		ret = gt9xx_i2c_read(client, GT9XX_SWRST_B0_ADDR, &val, 1);
+		if (ret <= 0)
+			continue;
+
+		if (val == GT9XX_SWRST_B0_DEF_VAL)
+			break;
+	}
+
+	if (retry >= GT9XX_FW_HOLD_RETRY)
+		return -ENODEV;
+
+	/* dsp clock power on*/
+	ret = gt9xx_i2c_write_u8(client, GT9XX_DSP_CLK_ADDR, 0);
+	if (ret <= 0)
+		return ret;
+
+	/* disable wdt */
+	ret = gt9xx_i2c_write_u8(client, GT9XX_TMR0_EN_ADDR, 0);
+	if (ret <= 0)
+		return ret;
+
+	/* clear cache */
+	ret = gt9xx_i2c_write_u8(client, GT9XX_CACHE_EN_ADDR, 0);
+	if (ret <= 0)
+		return ret;
+
+	/* set boot from SRAM */
+	ret = gt9xx_i2c_write_u8(client, GT9XX_BOOTCTL_B0_ADDR,
+				 GT9XX_BOOTCTL_B0_SRAM);
+	if (ret <= 0)
+		return ret;
+
+	/* software reset */
+	ret = gt9xx_i2c_write_u8(client, GT9XX_CPU_SWRST_PULSE_ADDR, 1);
+	if (ret <= 0)
+		return ret;
+
+	/* clear control flag */
+	ret = gt9xx_i2c_write_u8(client, GT9XX_BOOT_CTL_ADDR, 0);
+	if (ret <= 0)
+		return ret;
+
+	/* set scramble */
+	ret = gt9xx_i2c_write_u8(client, GT9XX_BOOT_OPT_B0_ADDR, 0);
+	if (ret <= 0)
+		return ret;
+
+	/* enable accessing mode */
+	ret = gt9xx_i2c_write_u8(client, GT9XX_MEM_CD_EN_ADDR, 1);
+
+	return ret;
 }
 
-/*******************************************************
-Function:
-    Late resume function.
-Input:
-    h: early_suspend struct.
-Output:
-    None.
-*******************************************************/
-static void goodix_ts_late_resume(struct early_suspend *h)
+static int gt9xx_fw_start(struct gt9xx_ts *ts)
 {
-    struct goodix_ts_data *ts;
-    s8 ret = -1;
-    ts = container_of(h, struct goodix_ts_data, early_suspend);
-    
-    GTP_DEBUG_FUNC();
+	struct i2c_client *client = ts->client;
+	int ret;
+	u8 val;
+
+	if (!ts->compat_mode)
+		return 1;
+
+	/* init sw WDT */
+	ret = gt9xx_i2c_write_u8(client, GT9XX_SW_WDT_ADDR,
+				 GT9XX_SW_WDT_DEF_VAL);
+	if (ret <= 0)
+		return ret;
+
+	/* release SS51 & DSP */
+	ret = gt9xx_i2c_write_u8(client, GT9XX_FW_REL_ADDR, 0x00);
+	if (ret <= 0)
+		return ret;
+
+	gt9xx_int_sync(ts);
+
+	/* Check fw run status by verifying WDT default */
+	ret = gt9xx_i2c_read(client, GT9XX_SW_WDT_ADDR, &val, sizeof(u8));
+	if (ret <= 0)
+		return ret;
+
+	if (val == GT9XX_SW_WDT_DEF_VAL) {
+		dev_err(&client->dev, "fw_start failed\n");
+		return -ENODEV;
+	}
+
+	/* on success init sw WDT again*/
+	ret = gt9xx_i2c_write_u8(client, GT9XX_SW_WDT_ADDR,
+				 GT9XX_SW_WDT_DEF_VAL);
+	return ret;
+}
 
-    ret = gtp_wakeup_sleep(ts);
+static int gt9xx_flash_fw(struct gt9xx_ts *ts)
+{
+	int ret, retry = 0;
 
-#if GTP_SLIDE_WAKEUP
-    doze_status = DOZE_DISABLED;
-#endif
+	gt9xx_irq_disable(ts, false);
 
-    if (ret < 0)
-    {
-        GTP_ERROR("GTP later resume failed.");
-    }
-#if (GTP_COMPATIBLE_MODE)
-    if (CHIP_TYPE_GT9F == ts->chip_type)
-    {
-        // do nothing
-    }
-    else
-#endif
-    {
-        gtp_send_cfg(ts->client);
-    }
-
-    if (ts->use_irq)
-    {
-        gtp_irq_enable(ts);
-    }
-    else
-    {
-        hrtimer_start(&ts->timer, ktime_set(1, 0), HRTIMER_MODE_REL);
-    }
-
-    ts->gtp_is_suspend = 0;
-#if GTP_ESD_PROTECT
-    gtp_esd_switch(ts->client, SWITCH_ON);
-#endif
+	ret = gt9xx_enter_fw_burn_mode(ts);
+	if (ret <= 0) {
+		dev_err(&ts->client->dev, "gt9xx fw burn mode set failed\n");
+		return ret;
+	}
+
+	while (retry++ < GT9XX_FW_DOWNLOAD_RETRY) {
+		ret = gt9xx_fw_flash_block_ss51(ts);
+		if (ret <= 0)
+			continue;
+
+		ret = gt9xx_fw_flash_block_dsp(ts);
+		if (ret <= 0)
+			continue;
+		break;
+	}
+
+	if (retry >= GT9XX_FW_DOWNLOAD_RETRY)
+		dev_info(&ts->client->dev, "gt9xx exceeds max retry count\n");
+
+	return ret;
 }
-#endif
 
-#if GTP_ESD_PROTECT
-s32 gtp_i2c_read_no_rst(struct i2c_client *client, u8 *buf, s32 len)
+static int gt9x5_flash_fw(struct gt9xx_ts *ts)
 {
-    struct i2c_msg msgs[2];
-    s32 ret=-1;
-    s32 retries = 0;
-
-    GTP_DEBUG_FUNC();
-
-    msgs[0].flags = !I2C_M_RD;
-    msgs[0].addr  = client->addr;
-    msgs[0].len   = GTP_ADDR_LENGTH;
-    msgs[0].buf   = &buf[0];
-    //msgs[0].scl_rate = 300 * 1000;    // for Rockchip, etc.
-    
-    msgs[1].flags = I2C_M_RD;
-    msgs[1].addr  = client->addr;
-    msgs[1].len   = len - GTP_ADDR_LENGTH;
-    msgs[1].buf   = &buf[GTP_ADDR_LENGTH];
-    //msgs[1].scl_rate = 300 * 1000;
-
-    while(retries < 5)
-    {
-        ret = i2c_transfer(client->adapter, msgs, 2);
-        if(ret == 2)break;
-        retries++;
-    }
-    if ((retries >= 5))
-    {    
-        GTP_ERROR("I2C Read: 0x%04X, %d bytes failed, errcode: %d!", (((u16)(buf[0] << 8)) | buf[1]), len-2, ret);
-    }
-    return ret;
+	int ret, retry = 0;
+
+	gt9xx_irq_disable(ts, true);
+
+	ret = gt9x5_enter_fw_burn_mode(ts);
+	if (ret <= 0) {
+		dev_err(&ts->client->dev, "gt9xx fw burn mode set failed\n");
+		return ret;
+	}
+
+	while (retry++ < GT9XX_FW_DOWNLOAD_RETRY) {
+		ret = gt9x5_fw_flash_block_dsp_isp(ts);
+		if (ret <= 0) {
+			dev_info(&ts->client->dev,
+				 "dsp isp fw flash failed, retry:%d\n", retry);
+			continue;
+		}
+
+		ret = gt9x5_fw_flash_block_ss51(ts);
+		if (ret <= 0) {
+			dev_info(&ts->client->dev,
+				 "ss51 fw flash failed, retry:%d\n", retry);
+			continue;
+		}
+
+		ret = gt9x5_fw_flash_block_dsp(ts);
+		if (ret <= 0) {
+			dev_info(&ts->client->dev,
+				 "dsp fw flash failed, retry:%d\n", retry);
+			continue;
+		}
+
+		ret = gt9x5_fw_flash_block_boot(ts);
+		if (ret <= 0) {
+			dev_info(&ts->client->dev,
+				 "boot fw flash failed, retry:%d\n", retry);
+			continue;
+		}
+
+		ret = gt9x5_fw_flash_block_boot_isp(ts);
+		if (ret <= 0) {
+			dev_info(&ts->client->dev,
+				 "boot isp fw flash failed, retry:%d\n", retry);
+			continue;
+		}
+
+		ret = gt9x5_fw_flash_block_gfwlink(ts);
+		if (ret <= 0) {
+			dev_info(&ts->client->dev,
+				 "gfwlink fw flash failed, retry:%d\n", retry);
+			continue;
+		}
+
+		ret = gt9x5_fw_flash_block_gwake(ts);
+		if (ret <= 0) {
+			dev_info(&ts->client->dev,
+				 "gwake fw flash failed, retry:%d\n", retry);
+			continue;
+		}
+
+		ret = gt9x5_fw_flash_finish(ts);
+		if (ret <= 0) {
+			dev_info(&ts->client->dev,
+				 "fw finish flash failed, retry:%d\n", retry);
+			continue;
+		}
+
+		break;
+	}
+
+	if (retry >= GT9XX_FW_DOWNLOAD_RETRY)
+		dev_info(&ts->client->dev, "gt9xx exceeds max retry count\n");
+
+	return ret;
 }
 
-s32 gtp_i2c_write_no_rst(struct i2c_client *client,u8 *buf,s32 len)
+static int gt9xx_fw_download(struct gt9xx_ts *ts)
 {
-    struct i2c_msg msg;
-    s32 ret = -1;
-    s32 retries = 0;
-
-    GTP_DEBUG_FUNC();
-
-    msg.flags = !I2C_M_RD;
-    msg.addr  = client->addr;
-    msg.len   = len;
-    msg.buf   = buf;
-    //msg.scl_rate = 300 * 1000;    // for Rockchip, etc
-
-    while(retries < 5)
-    {
-        ret = i2c_transfer(client->adapter, &msg, 1);
-        if (ret == 1)break;
-        retries++;
-    }
-    if((retries >= 5))
-    {
-        GTP_ERROR("I2C Write: 0x%04X, %d bytes failed, errcode: %d!", (((u16)(buf[0] << 8)) | buf[1]), len-2, ret);
-    }
-    return ret;
+	int ret;
+
+	dev_warn(&ts->client->dev, "firmware name %s\n", ts->fw_name);
+
+	if (!ts->fw) {
+		dev_err(&ts->client->dev, "gt9xx invalid firmware\n");
+		return -EINVAL;
+	}
+
+	ret = gt9xx_fw_ver_check(ts);
+	if (0 == ret) {
+		dev_warn(&ts->client->dev, "[%s] target version is not new: %04x",
+				__func__, ts->fw_head->vid);
+		goto fw_err;
+	}
+
+	if (ts->compat_mode) {
+		ret = gt9xx_flash_fw(ts);
+		if (ret < 0) {
+			dev_err(&ts->client->dev, "gt9xx fw flash failed\n");
+			goto fw_err;
+		}
+	} else {
+		ret = gt9x5_flash_fw(ts);
+		if (ret < 0) {
+			dev_err(&ts->client->dev, "gt9x5 fw flash failed\n");
+			goto fw_err;
+		}
+	}
+
+	dev_info(&ts->client->dev, "gt9xx download fw sucessfull\n");
+
+fw_err:
+	release_firmware(ts->fw);
+	gt9xx_fw_start(ts);
+	/* reset the controller */
+	gt9xx_reset(ts);
+	/* send the _DSM ts configuration to the firmware */
+#ifdef CONFIG_ACPI
+	gt9xx_send_cfg(ts);
+#else
+	gt9xx_get_and_send_cfg(ts);
+#endif
+	gt9xx_int_sync(ts);
+	gt9xx_irq_enable(ts);
+	return ret;
 }
-/*******************************************************
-Function:
-    switch on & off esd delayed work
-Input:
-    client:  i2c device
-    on:      SWITCH_ON / SWITCH_OFF
-Output:
-    void
-*********************************************************/
-void gtp_esd_switch(struct i2c_client *client, s32 on)
+
+static int gt9xx_set_device_data(struct gt9xx_ts *ts)
 {
-    struct goodix_ts_data *ts;
-    
-    ts = i2c_get_clientdata(client);
-    spin_lock(&ts->esd_lock);
-    
-    if (SWITCH_ON == on)     // switch on esd 
-    {
-        if (!ts->esd_running)
-        {
-            ts->esd_running = 1;
-            spin_unlock(&ts->esd_lock);
-            GTP_INFO("Esd started");
-            queue_delayed_work(gtp_esd_check_workqueue, &gtp_esd_check_work, ts->clk_tick_cnt);
-        }
-        else
-        {
-            spin_unlock(&ts->esd_lock);
-        }
-    }
-    else    // switch off esd
-    {
-        if (ts->esd_running)
-        {
-            ts->esd_running = 0;
-            spin_unlock(&ts->esd_lock);
-            GTP_INFO("Esd cancelled");
-            cancel_delayed_work_sync(&gtp_esd_check_work);
-        }
-        else
-        {
-            spin_unlock(&ts->esd_lock);
-        }
-    }
+	struct device *dev = &ts->client->dev;
+	struct gpio_desc *gpiod;
+	struct pinctrl_state *state;
+	struct pinctrl *pinctrl;
+	struct device_node *of_np = ts->client->dev.of_node;
+	int ret;
+
+	if (of_np) {
+		struct property *prop = of_find_property(
+						of_np,
+						GT9XX_BUTTONS_PROPERTY,
+						NULL);
+		if (prop) {
+			size_t code_size = sizeof(ts->button_codes[0]);
+
+			/* The button property size to be an
+			 * even number of u32's and bigger than zero
+			 */
+			ts->num_buttons = prop->length / code_size;
+			if (prop->length % code_size ||
+			     ts->num_buttons == 0 ||
+			     ts->num_buttons > GT9XX_MAX_NUM_BUTTONS) {
+				dev_err(&ts->client->dev,
+					"button property size is incorrect\n");
+				return -EINVAL;
+			}
+
+			ret = of_property_read_u32_array(
+					ts->client->dev.of_node,
+					GT9XX_BUTTONS_PROPERTY,
+					ts->button_codes,
+					ts->num_buttons);
+			if (ret) {
+				dev_err(&ts->client->dev,
+					"failed to read button property\n");
+				return ret;
+			}
+		}
+		if (!of_property_read_string(of_np, GT9XX_FW_NAME_PROPERTY,
+				    &ts->fw_name))
+			dev_info(&ts->client->dev, "found new firmware %s\n",
+				 ts->fw_name);
+		if (of_get_property(of_np, GT9XX_COMPAT_MODE_PROPERTY,
+				    NULL)) {
+			dev_info(&ts->client->dev, "of compatibility mode enabled\n");
+			ts->compat_mode = 1;
+		}
+	}
+
+	pinctrl = devm_pinctrl_get(dev);
+	if (!IS_ERR(ts->pinctrl))
+		ts->pinctrl = pinctrl;
+
+	if (ts->pinctrl) {
+		state = pinctrl_lookup_state(pinctrl, "interrupt");
+		if (IS_ERR(state)) {
+			dev_err(&ts->client->dev, "could not get interrupt pin state!\n");
+			return PTR_ERR(state);
+		}
+		ts->int_state = state;
+
+		state = pinctrl_lookup_state(pinctrl, "control");
+		if (IS_ERR(state)) {
+			dev_err(&ts->client->dev, "could not get control pin state!\n");
+			return PTR_ERR(state);
+		}
+		ts->ctrl_state = state;
+	}
+
+	/* Get interrupt GPIO pin number */
+	if (ACPI_HANDLE(dev))
+		gpiod = devm_gpiod_get_index(dev, "gt9xx_gpio_int", 0);
+	else
+		gpiod = devm_gpiod_get(dev, "irq");
+
+	if (IS_ERR(gpiod)) {
+		int err = PTR_ERR(gpiod);
+
+		dev_err(dev, "get gt9xx_gpio_int failed: %d\n", err);
+		return err;
+	}
+
+	gpiod_direction_input(gpiod);
+	ts->gpiod_int = gpiod;
+
+	if (!ts->client->irq)
+		ts->client->irq = gpiod_to_irq(gpiod);
+
+	/* get the reset line GPIO pin number */
+	if (ACPI_HANDLE(dev))
+		gpiod = devm_gpiod_get_index(dev, "gt9xx_gpio_rst", 1);
+	else
+		gpiod = devm_gpiod_get(dev, "reset");
+
+	if (IS_ERR(gpiod)) {
+		int err = PTR_ERR(gpiod);
+
+		dev_err(dev, "get gt9xx_gpio_rst failed: %d\n", err);
+		return err;
+	}
+
+	gpiod_direction_input(gpiod);
+	ts->gpiod_rst = gpiod;
+
+#ifdef CONFIG_PM
+	if (of_np) {
+		ts->pm_platdata = of_device_state_pm_setup(of_np);
+		if (IS_ERR(ts->pm_platdata)) {
+			dev_err(dev, "error during device state pm init");
+			ret = PTR_ERR(ts->pm_platdata);
+			return ret;
+		}
+
+		ret = device_state_pm_set_class(dev,
+			ts->pm_platdata->pm_user_name);
+		if (ret) {
+			dev_err(dev, "error while setting the pm class");
+			return ret;
+		}
+
+		ret = device_state_pm_set_state_by_name(dev,
+			ts->pm_platdata->pm_state_D0_name);
+		if (ret) {
+			dev_err(dev, "error while setting the pm state");
+			return ret;
+		}
+	}
+#endif
+    /* reset the controller */
+	gt9xx_reset(ts);
+
+	return  gt9xx_get_and_send_cfg(ts);
 }
 
-/*******************************************************
-Function:
-    Initialize external watchdog for esd protect
-Input:
-    client:  i2c device.
-Output:
-    result of i2c write operation. 
-        1: succeed, otherwise: failed
-*********************************************************/
-static s32 gtp_init_ext_watchdog(struct i2c_client *client)
+#ifdef CONFIG_PM
+static void gt9xx_sleep(struct gt9xx_ts *ts)
 {
-    u8 opr_buffer[3] = {0x80, 0x41, 0xAA};
-    GTP_DEBUG("[Esd]Init external watchdog");
-    return gtp_i2c_write_no_rst(client, opr_buffer, 3);
+	int ret;
+	struct pinctrl *pinctrl = ts->pinctrl;
+	struct device *dev = &ts->client->dev;
+
+	if (test_and_set_bit(GT9XX_STATUS_SLEEP_BIT, ts->status))
+		return;
+
+	gt9xx_irq_disable(ts, false);
+
+	if (pinctrl)
+		pinctrl_select_state(pinctrl, ts->ctrl_state);
+
+	gpiod_direction_output(ts->gpiod_int, 0);
+	msleep(5);
+
+	ret = gt9xx_i2c_write_u8(ts->client, GT9XX_REG_CMD, 5);
+	if (ret <= 0) {
+		dev_err(dev, "sleep cmd failed");
+	}
+
+	ret = device_state_pm_set_state_by_name(dev,
+		ts->pm_platdata->pm_state_D3_name);
+	if (ret)
+		dev_err(dev, "error while setting the pm state");
+
+	dev_dbg(dev, "sleeping");
 }
 
-/*******************************************************
-Function:
-    Esd protect function.
-    External watchdog added by meta, 2013/03/07
-Input:
-    work: delayed work
-Output:
-    None.
-*******************************************************/
-static void gtp_esd_check_func(struct work_struct *work)
+static void gt9xx_wakeup(struct gt9xx_ts *ts)
 {
-    s32 i;
-    s32 ret = -1;
-    struct goodix_ts_data *ts = NULL;
-    u8 esd_buf[4] = {0x80, 0x40};
-    
-    GTP_DEBUG_FUNC();
-   
-    ts = i2c_get_clientdata(i2c_connect_client);
-
-    if (ts->gtp_is_suspend)
-    {
-        GTP_INFO("Esd suspended!");
-        return;
-    }
-    
-    for (i = 0; i < 3; i++)
-    {
-        ret = gtp_i2c_read_no_rst(ts->client, esd_buf, 4);
-        
-        GTP_DEBUG("[Esd]0x8040 = 0x%02X, 0x8041 = 0x%02X", esd_buf[2], esd_buf[3]);
-        if ((ret < 0))
-        {
-            // IIC communication problem
-            continue;
-        }
-        else
-        { 
-            if ((esd_buf[2] == 0xAA) || (esd_buf[3] != 0xAA))
-            {
-                // IC works abnormally..
-                u8 chk_buf[4] = {0x80, 0x40};
-                
-                gtp_i2c_read_no_rst(ts->client, chk_buf, 4);
-                
-                GTP_DEBUG("[Check]0x8040 = 0x%02X, 0x8041 = 0x%02X", chk_buf[2], chk_buf[3]);
-                
-                if ((chk_buf[2] == 0xAA) || (chk_buf[3] != 0xAA))
-                {
-                    i = 3;
-                    break;
-                }
-                else
-                {
-                    continue;
-                }
-            }
-            else 
-            {
-                // IC works normally, Write 0x8040 0xAA, feed the dog
-                esd_buf[2] = 0xAA; 
-                gtp_i2c_write_no_rst(ts->client, esd_buf, 3);
-                break;
-            }
-        }
-    }
-    if (i >= 3)
-    {
-    #if GTP_COMPATIBLE_MODE
-        if (CHIP_TYPE_GT9F == ts->chip_type)
-        {        
-            if (ts->rqst_processing)
-            {
-                GTP_INFO("Request processing, no esd recovery");
-            }
-            else
-            {
-                GTP_ERROR("IC working abnormally! Process esd recovery.");
-                gtp_esd_recovery(ts->client);
-            }
-        }
-        else
-    #endif
-        {
-            GTP_ERROR("IC working abnormally! Process reset guitar.");
-            gtp_reset_guitar(ts->client, 50);
-        }
-    }
-
-    if(!ts->gtp_is_suspend)
-    {
-        queue_delayed_work(gtp_esd_check_workqueue, &gtp_esd_check_work, ts->clk_tick_cnt);
-    }
-    else
-    {
-        GTP_INFO("Esd suspended!");
-    }
-    return;
+	int ret;
+	struct device *dev = &ts->client->dev;
+
+	if (!test_and_clear_bit(GT9XX_STATUS_SLEEP_BIT, ts->status))
+		return;
+
+	ret = device_state_pm_set_state_by_name(dev,
+		ts->pm_platdata->pm_state_D0_name);
+	if (ret)
+		dev_err(dev, "error while setting the pm state");
+
+	gt9xx_reset(ts);
+
+	ret = gt9xx_i2c_test(ts->client);
+	if (ret <= 0) {
+		dev_err(dev, "i2c test after reset failed");
+	}
+
+	gt9xx_irq_enable(ts);
+
+	dev_dbg(dev, "woke up");
 }
-#endif
 
-static const struct i2c_device_id goodix_ts_id[] = {
-    { GTP_I2C_NAME, 0 },
-    { }
-};
+static ssize_t gt9xx_power_hal_suspend_store(struct device *dev,
+					     struct device_attribute *attr,
+					     const char *buf, size_t count)
+{
+	struct input_dev *input = to_input_dev(dev);
+	struct gt9xx_ts *ts = input_get_drvdata(input);
+	static DEFINE_MUTEX(mutex);
+
+	mutex_lock(&mutex);
+	if (!strncmp(buf, POWER_HAL_SUSPEND_ON, POWER_HAL_SUSPEND_STATUS_LEN))
+		gt9xx_sleep(ts);
+	else
+		gt9xx_wakeup(ts);
+	mutex_unlock(&mutex);
+
+	return count;
+}
 
-static struct i2c_driver goodix_ts_driver = {
-    .probe      = goodix_ts_probe,
-    .remove     = goodix_ts_remove,
-#ifdef CONFIG_HAS_EARLYSUSPEND
-     .suspend    = goodix_ts_early_suspend,
-     .resume     = goodix_ts_late_resume,
+static DEVICE_POWER_HAL_SUSPEND_ATTR(gt9xx_power_hal_suspend_store);
 #endif
-    .id_table   = goodix_ts_id,
-    .driver = {
-        .name     = GTP_I2C_NAME,
-        .owner    = THIS_MODULE,
-    },
-};
 
-/*******************************************************    
-Function:
-    Driver Install function.
-Input:
-    None.
-Output:
-    Executive Outcomes. 0---succeed.
-********************************************************/
-static int __devinit goodix_ts_init(void)
+static int gt9xx_ts_probe(struct i2c_client *client,
+			  const struct i2c_device_id *id)
 {
-    s32 ret;
-
-    GTP_DEBUG_FUNC();   
-    GTP_INFO("GTP driver installing...");
-    goodix_wq = create_singlethread_workqueue("goodix_wq");
-    if (!goodix_wq)
-    {
-        GTP_ERROR("Creat workqueue failed.");
-        return -ENOMEM;
-    }
-#if GTP_ESD_PROTECT
-    INIT_DELAYED_WORK(&gtp_esd_check_work, gtp_esd_check_func);
-    gtp_esd_check_workqueue = create_workqueue("gtp_esd_check");
+	int ret = -1;
+	struct gt9xx_ts *ts;
+	struct device *dev = &client->dev;
+	int i;
+	static int first_time = 0;
+
+	if(++first_time <= 1) {
+		dev_info(dev, "deferring probe gt911\n");
+		return -EPROBE_DEFER;
+	}
+
+	dev_info(dev, "probing GT911 @ 0x%02x", client->addr);
+
+	ts = devm_kzalloc(dev, sizeof(*ts), GFP_KERNEL);
+	if (!ts)
+		return -ENOMEM;
+
+	ts->client = client;
+	i2c_set_clientdata(client, ts);
+
+	ts->input = devm_input_allocate_device(dev);
+	if (!ts->input)
+		return -ENOMEM;
+
+	__set_bit(EV_SYN, ts->input->evbit);
+	__set_bit(EV_ABS, ts->input->evbit);
+	__set_bit(EV_KEY, ts->input->evbit);
+	__set_bit(BTN_TOUCH, ts->input->keybit);
+
+	input_mt_init_slots(ts->input, GT9XX_MAX_TOUCHES, 0);
+	input_set_abs_params(ts->input, ABS_MT_WIDTH_MAJOR, 0, 255, 0, 0);
+	input_set_abs_params(ts->input, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
+	input_set_abs_params(ts->input, ABS_MT_TRACKING_ID, 0, 255, 0, 0);
+
+	snprintf(ts->phys, sizeof(ts->phys), "%s/input0", dev_name(dev));
+	ts->input->name = "goodix_ts";
+	ts->input->phys = ts->phys;
+	ts->input->id.bustype = BUS_I2C;
+	ts->input->dev.parent = dev;
+	input_set_drvdata(ts->input, ts);
+
+	ts->fw_name = GT9XX_FW_FILE_NAME;
+
+	ret = gt9xx_set_device_data(ts);
+	if (ret)
+		return ret;
+
+	ret = gt9xx_fw_is_valid(ts);
+	if (ret > 0)
+		ret = gt9xx_fw_download(ts);
+
+	ret = gt9xx_get_info(ts);
+	if (ret <= 0)
+		return ret;
+
+	for (i = 0; i < ts->num_buttons; i++)
+		__set_bit(ts->button_codes[i], ts->input->keybit);
+
+	input_set_abs_params(ts->input, ABS_MT_POSITION_X, 0, ts->max_x, 0, 0);
+	input_set_abs_params(ts->input, ABS_MT_POSITION_Y, 0, ts->max_y, 0, 0);
+
+	ret = input_register_device(ts->input);
+	if (ret)
+		return ret;
+
+	ret = devm_request_threaded_irq(dev, client->irq, NULL,
+					gt9xx_thread_handler,
+					ts->irq_type | IRQF_ONESHOT,
+					client->name, ts);
+	if (ret) {
+		dev_err(dev, "request IRQ failed: %d", ret);
+		input_unregister_device(ts->input);
+		return -1;
+	}
+
+#ifdef CONFIG_PM
+	ret = device_create_file(dev, &dev_attr_power_HAL_suspend);
+	if (ret < 0) {
+		dev_err(dev, "unable to create suspend entry");
+		goto out;
+	}
+
+	ret = register_power_hal_suspend_device(dev);
+	if (ret < 0)
+		dev_err(dev, "unable to register for power hal");
+out:
 #endif
-    ret = i2c_add_driver(&goodix_ts_driver);
-    return ret; 
+
+	return 0;
 }
 
-/*******************************************************    
-Function:
-    Driver uninstall function.
-Input:
-    None.
-Output:
-    Executive Outcomes. 0---succeed.
-********************************************************/
-static void __exit goodix_ts_exit(void)
+static int gt9xx_ts_remove(struct i2c_client *client)
 {
-    GTP_DEBUG_FUNC();
-    GTP_INFO("GTP driver exited.");
-    i2c_del_driver(&goodix_ts_driver);
-    if (goodix_wq)
-    {
-        destroy_workqueue(goodix_wq);
-    }
+	struct gt9xx_ts *ts = i2c_get_clientdata(client);
+
+#ifdef CONFIG_PM
+	device_remove_file(&client->dev, &dev_attr_power_HAL_suspend);
+	unregister_power_hal_suspend_device(&ts->input->dev);
+#endif
+	i2c_set_clientdata(client, NULL);
+	gpiod_direction_input(ts->gpiod_int);
+	input_unregister_device(ts->input);
+
+	return 0;
 }
 
-late_initcall(goodix_ts_init);
-module_exit(goodix_ts_exit);
+static const struct i2c_device_id gt9xx_ts_id[] = {
+	{ "GODX0911", 0 },
+	{ "GODX0912", 0 },
+	{ "GOOD9271", 0 },
+	{ "GOOD9157", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, gt9xx_ts_id);
+
+#ifdef CONFIG_ACPI
+static struct acpi_device_id gt9xx_acpi_match[] = {
+	{ "GODX0911", 0 },
+	{ "GODX0912", 0 },
+	{ "GOOD9271", 0 },
+	{ "GOOD9157", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(acpi, gt9xx_acpi_match);
+#endif
+
+#ifdef CONFIG_OF
+static struct of_device_id goodix_gt9157[] = {
+	{.compatible = "goodix,GOOD9157", },
+	{},
+};
+#endif
+
+static struct i2c_driver gt9xx_ts_driver = {
+	.probe      = gt9xx_ts_probe,
+	.remove     = gt9xx_ts_remove,
+	.id_table   = gt9xx_ts_id,
+	.driver = {
+		.name = "gt9xx_ts",
+		.owner = THIS_MODULE,
+		//.acpi_match_table = ACPI_PTR(gt9xx_acpi_match),
+		.of_match_table = goodix_gt9157,
+	},
+};
+
+module_i2c_driver(gt9xx_ts_driver);
 
-MODULE_DESCRIPTION("GTP Series Driver");
-MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Goodix GT911 Touchscreen Driver");
+MODULE_AUTHOR("Octavian Purdila <octavian.purdila@intel.com>");
+MODULE_LICENSE("GPL v2");
