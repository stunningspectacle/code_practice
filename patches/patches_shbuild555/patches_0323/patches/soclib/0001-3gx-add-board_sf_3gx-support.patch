From 373a8662365d8040d7f102dedf70d7562e1b80c8 Mon Sep 17 00:00:00 2001
From: Bin Yang <bin.yang@intel.com>
Date: Wed, 17 Feb 2016 10:35:25 +0800
Subject: [PATCH 1/5] 3gx add board_sf_3gx support

Change-Id: I16505cd6310a43b14a84c1535fbe4e59d4ba04be
Signed-off-by: Bin Yang <bin.yang@intel.com>
---
 devices/meas/src/sofia3gx                          |    1 +
 devices/mmc_sd/src/sofia3gx/mmcsd_cfg.h            |  424 ++
 devices/mmc_sd/src/sofia3gx/mmcsd_variant_def.h    |  302 ++
 devices/mmc_sd/src/sofia3gx/sdmmc_reg.h            | 5486 ++++++++++++++++++++
 devices/noc_qos/src/sofia3gx                       |    1 +
 devices/pcl/src/sofia3gx                           |    1 +
 devices/pm/inc/power_control/board_sf_3gx          |    1 +
 devices/pm/inc/power_management/board_sf_3gx       |    1 +
 devices/pm/pm_device.c                             |    2 +-
 devices/pm/power_control/cpu/make/board_sf_3gx     |    1 +
 devices/pm/power_control/cpu/src/board_sf_3gx      |    1 +
 devices/pm/power_control/emif/make/board_sf_3gx    |    1 +
 .../emif/src/board_sf_3gx/emic_generated_cfg.h     |   38 +
 .../emic_generated_sdram_ctl_26_156_312MHZ.h       |  332 ++
 .../emic_generated_sdram_ctl_26_156_400MHZ.h       |  332 ++
 .../emic_generated_sdram_ctl_26_156_533MHZ.h       |  251 +
 .../emic_generated_sdram_phy_26_156_533MHZ.h       |   57 +
 .../emif/src/board_sf_3gx/emic_mem_cfg.h           |    1 +
 .../inc/board_sf_3gx/pow_driverif_board.h          |  537 ++
 devices/pm/power_control/make/power_control.mk     |   11 +
 devices/pm/power_control/pmu/make/board_sf_3gx     |    1 +
 .../pmu/make/board_sf_3gx_ext_pmic/ext_pmic.mk     |   57 +
 devices/pm/power_control/pmu/src/board_sf_3gx      |    1 +
 devices/pm/power_control/pow/make/board_sf_3gx     |    1 +
 devices/pm/power_control/pow/src/board_sf_3gx      |    1 +
 devices/pm/power_management/omp/make/board_sf_3gx  |    1 +
 devices/pm/power_management/omp/src/board_sf_3gx   |    1 +
 devices/pm/power_management/prh/make/board_sf_3gx  |    1 +
 .../prh/src/board_sf_3gx/prh_cfg.c                 |    1 +
 .../prh/src/board_sf_3gx/prh_cfg_at.c              |    1 +
 .../prh/src/board_sf_3gx/prh_cfg_internal.h        |    1 +
 .../prh/src/board_sf_3gx/prh_cpu_drv_cfg.c         |  824 +++
 .../board_sf_3gx/prh_ext_accelerometer_drv_cfg.c   |    1 +
 .../board_sf_3gx/prh_ext_accelerometer_drv_cfg.h   |    1 +
 .../prh/src/board_sf_3gx/prh_ext_cam_drv_cfg.c     |  503 ++
 .../prh/src/board_sf_3gx/prh_ext_cam_drv_cfg.h     |    1 +
 .../prh/src/board_sf_3gx/prh_ext_disp_drv_cfg.c    |  387 ++
 .../prh/src/board_sf_3gx/prh_ext_disp_drv_cfg.h    |    1 +
 .../src/board_sf_3gx/prh_ext_gyroscope_drv_cfg.c   |    1 +
 .../src/board_sf_3gx/prh_ext_gyroscope_drv_cfg.h   |    1 +
 .../board_sf_3gx/prh_ext_magnetometer_drv_cfg.c    |    1 +
 .../board_sf_3gx/prh_ext_magnetometer_drv_cfg.h    |    1 +
 .../prh_ext_proximity_sensor_drv_cfg.c             |    1 +
 .../prh_ext_proximity_sensor_drv_cfg.h             |    1 +
 .../prh/src/board_sf_3gx/prh_ext_tp_drv_cfg.c      |    1 +
 .../prh/src/board_sf_3gx/prh_ext_tp_drv_cfg.h      |    1 +
 .../prh/src/board_sf_3gx/prh_gpu_drv_cfg.c         |  597 +++
 .../prh/src/board_sf_3gx/prh_mmcsd_drv_cfg.c       |    1 +
 .../prh/src/board_sf_3gx/prh_pwm_drv_cfg.c         |    1 +
 .../prh/src/board_sf_3gx/prh_pwm_drv_cfg.h         |    1 +
 .../prh/src/board_sf_3gx/prh_rga_drv_cfg.c         |    1 +
 .../prh/src/board_sf_3gx/prh_rga_drv_cfg.h         |    1 +
 .../prh/src/board_sf_3gx/prh_usb_drv_cfg.c         |  563 ++
 .../prh/src/board_sf_3gx/prh_usb_drv_cfg.h         |  103 +
 devices/scu/src/sofia3gx                           |    1 +
 devices/stm/src/sofia3gx                           |    1 +
 devices/tado/src/sofia3gx                          |    1 +
 make/configs/sofia3gx/platform_common.cfg          |   75 +
 58 files changed, 10919 insertions(+), 1 deletion(-)
 create mode 120000 devices/meas/src/sofia3gx
 create mode 100644 devices/mmc_sd/src/sofia3gx/mmcsd_cfg.h
 create mode 100644 devices/mmc_sd/src/sofia3gx/mmcsd_variant_def.h
 create mode 100644 devices/mmc_sd/src/sofia3gx/sdmmc_reg.h
 create mode 120000 devices/noc_qos/src/sofia3gx
 create mode 120000 devices/pcl/src/sofia3gx
 create mode 120000 devices/pm/inc/power_control/board_sf_3gx
 create mode 120000 devices/pm/inc/power_management/board_sf_3gx
 create mode 120000 devices/pm/power_control/cpu/make/board_sf_3gx
 create mode 120000 devices/pm/power_control/cpu/src/board_sf_3gx
 create mode 120000 devices/pm/power_control/emif/make/board_sf_3gx
 create mode 100644 devices/pm/power_control/emif/src/board_sf_3gx/emic_generated_cfg.h
 create mode 100644 devices/pm/power_control/emif/src/board_sf_3gx/emic_generated_sdram_ctl_26_156_312MHZ.h
 create mode 100644 devices/pm/power_control/emif/src/board_sf_3gx/emic_generated_sdram_ctl_26_156_400MHZ.h
 create mode 100644 devices/pm/power_control/emif/src/board_sf_3gx/emic_generated_sdram_ctl_26_156_533MHZ.h
 create mode 100644 devices/pm/power_control/emif/src/board_sf_3gx/emic_generated_sdram_phy_26_156_533MHZ.h
 create mode 120000 devices/pm/power_control/emif/src/board_sf_3gx/emic_mem_cfg.h
 create mode 100644 devices/pm/power_control/inc/board_sf_3gx/pow_driverif_board.h
 create mode 120000 devices/pm/power_control/pmu/make/board_sf_3gx
 create mode 100644 devices/pm/power_control/pmu/make/board_sf_3gx_ext_pmic/ext_pmic.mk
 create mode 120000 devices/pm/power_control/pmu/src/board_sf_3gx
 create mode 120000 devices/pm/power_control/pow/make/board_sf_3gx
 create mode 120000 devices/pm/power_control/pow/src/board_sf_3gx
 create mode 120000 devices/pm/power_management/omp/make/board_sf_3gx
 create mode 120000 devices/pm/power_management/omp/src/board_sf_3gx
 create mode 120000 devices/pm/power_management/prh/make/board_sf_3gx
 create mode 120000 devices/pm/power_management/prh/src/board_sf_3gx/prh_cfg.c
 create mode 120000 devices/pm/power_management/prh/src/board_sf_3gx/prh_cfg_at.c
 create mode 120000 devices/pm/power_management/prh/src/board_sf_3gx/prh_cfg_internal.h
 create mode 100644 devices/pm/power_management/prh/src/board_sf_3gx/prh_cpu_drv_cfg.c
 create mode 120000 devices/pm/power_management/prh/src/board_sf_3gx/prh_ext_accelerometer_drv_cfg.c
 create mode 120000 devices/pm/power_management/prh/src/board_sf_3gx/prh_ext_accelerometer_drv_cfg.h
 create mode 100644 devices/pm/power_management/prh/src/board_sf_3gx/prh_ext_cam_drv_cfg.c
 create mode 120000 devices/pm/power_management/prh/src/board_sf_3gx/prh_ext_cam_drv_cfg.h
 create mode 100644 devices/pm/power_management/prh/src/board_sf_3gx/prh_ext_disp_drv_cfg.c
 create mode 120000 devices/pm/power_management/prh/src/board_sf_3gx/prh_ext_disp_drv_cfg.h
 create mode 120000 devices/pm/power_management/prh/src/board_sf_3gx/prh_ext_gyroscope_drv_cfg.c
 create mode 120000 devices/pm/power_management/prh/src/board_sf_3gx/prh_ext_gyroscope_drv_cfg.h
 create mode 120000 devices/pm/power_management/prh/src/board_sf_3gx/prh_ext_magnetometer_drv_cfg.c
 create mode 120000 devices/pm/power_management/prh/src/board_sf_3gx/prh_ext_magnetometer_drv_cfg.h
 create mode 120000 devices/pm/power_management/prh/src/board_sf_3gx/prh_ext_proximity_sensor_drv_cfg.c
 create mode 120000 devices/pm/power_management/prh/src/board_sf_3gx/prh_ext_proximity_sensor_drv_cfg.h
 create mode 120000 devices/pm/power_management/prh/src/board_sf_3gx/prh_ext_tp_drv_cfg.c
 create mode 120000 devices/pm/power_management/prh/src/board_sf_3gx/prh_ext_tp_drv_cfg.h
 create mode 100644 devices/pm/power_management/prh/src/board_sf_3gx/prh_gpu_drv_cfg.c
 create mode 120000 devices/pm/power_management/prh/src/board_sf_3gx/prh_mmcsd_drv_cfg.c
 create mode 120000 devices/pm/power_management/prh/src/board_sf_3gx/prh_pwm_drv_cfg.c
 create mode 120000 devices/pm/power_management/prh/src/board_sf_3gx/prh_pwm_drv_cfg.h
 create mode 120000 devices/pm/power_management/prh/src/board_sf_3gx/prh_rga_drv_cfg.c
 create mode 120000 devices/pm/power_management/prh/src/board_sf_3gx/prh_rga_drv_cfg.h
 create mode 100644 devices/pm/power_management/prh/src/board_sf_3gx/prh_usb_drv_cfg.c
 create mode 100644 devices/pm/power_management/prh/src/board_sf_3gx/prh_usb_drv_cfg.h
 create mode 120000 devices/scu/src/sofia3gx
 create mode 120000 devices/stm/src/sofia3gx
 create mode 120000 devices/tado/src/sofia3gx
 create mode 100644 make/configs/sofia3gx/platform_common.cfg

diff --git a/devices/meas/src/sofia3gx b/devices/meas/src/sofia3gx
new file mode 120000
index 0000000..d12d0b7
--- /dev/null
+++ b/devices/meas/src/sofia3gx
@@ -0,0 +1 @@
+sofia3g
\ No newline at end of file
diff --git a/devices/mmc_sd/src/sofia3gx/mmcsd_cfg.h b/devices/mmc_sd/src/sofia3gx/mmcsd_cfg.h
new file mode 100644
index 0000000..5d1f603
--- /dev/null
+++ b/devices/mmc_sd/src/sofia3gx/mmcsd_cfg.h
@@ -0,0 +1,424 @@
+/* =============================================================================
+ * Copyright (C) 2014 Intel Mobile Communications GmbH
+ * 
+ *      Sec Class: Intel Confidential (IC)
+ * 
+ * =============================================================================
+ * =============================================================================
+ *
+ * This document contains proprietary information belonging to IMC.
+ * Passing on and copying of this document, use and communication of its
+ * contents is not permitted without prior written authorisation.
+ *
+ * =============================================================================
+ *
+ *   Comment:     for customization for MMCSD
+ */
+
+#ifndef __MMCSD_CFG_H__
+#define __MMCSD_CFG_H__
+
+#if !defined(POWER_MANAGEMENT_USE_PRH_IF)
+#include <pow_board.h>
+#include <emif_driverif.h>
+#endif
+
+#include <mmcsd.h>
+
+#if defined(MMCSD_DETECT_VIA_DAT3)
+  #define MEMCARD_MMCSD_DETECT_VIA_DAT3
+#else
+    #undef EXT_CARD_DETECT
+#endif
+
+#define MMCSD_PAD_UNUSE 0xFFFF
+
+// disable lint warnings caused by generated files (until the files are fixed)
+//lint --e{46,528}     "field type should be int" / "Symbol 'xxx' not referenced"
+
+// number of kernel clock support
+// 3GR SD controller has issue with 48MHz kernel clock, restrict kernel clock to only 52MHz
+#define MMCSD_NOF_INPUT_CLOCKS 1
+
+#if defined(MMCSD_IO) && defined(EMMC_ESD_SUPPORT)
+  #define MMCSD_CONTROLLER3_SUPPORTED
+  #define MMCSD_CONTROLLER2_SUPPORTED
+  #define MMCSD_NUMBER_OF_CONTROLLERS 3
+  #define MMCSD_NUMBER_OF_CARDS 3
+  #define IOCARD_ID     2
+#else
+  #if defined(MMCSD_IO)
+    #define MMCSD_CONTROLLER2_SUPPORTED
+    #define MMCSD_NUMBER_OF_CONTROLLERS 2
+    #define MMCSD_NUMBER_OF_CARDS 2
+    #define IOCARD_ID     1
+  #elif defined(EMMC_ESD_SUPPORT)
+    #define MMCSD_CONTROLLER2_SUPPORTED
+    #define MMCSD_NUMBER_OF_CONTROLLERS 2
+    #define MMCSD_NUMBER_OF_CARDS 2
+  #else
+    #define MMCSD_NUMBER_OF_CONTROLLERS 1
+    #define MMCSD_NUMBER_OF_CARDS 1
+  #endif
+#endif //defined(MMCSD_IO)
+
+#define MEMORYCARD_ID 0
+
+#define ACMD_ENABLED
+#define MMCSD_USE_NEW_ERASE_IMPL
+//#define MMCSD_SET_PCL_CONTROL
+
+#if defined(EMMC_ESD_SUPPORT)
+  /* eMMC device MMC/SD Host COntroller number */
+  #define EMMCSD_CONTROLLER_NUMBER 0
+  /* eSD device MMC/SD Host COntroller number */
+  #define ESD_CONTROLLER_NUMBER 0
+  #define EMMCV44_SUPPORTED
+  #define DDR_SUPPORTED
+  /* MMCI1 PAD definition for eMMC device */
+  #define MMCSD1_VDD_PAD    MMCSD_PAD_UNUSE
+  #define MMCSD1_CD_PAD     MMCSD_PAD_UNUSE
+  #define MMCSD1_WP_PAD     MMCSD_PAD_UNUSE
+  #define MMCSD1_CLK_PAD    25
+  #define MMCSD1_CMD_PP_PAD 20
+  #define MMCSD1_CMD_OD_PAD 20
+  #define MMCSD1_DAT0_PAD   21
+  #define MMCSD1_DAT1_PAD   22
+  #define MMCSD1_DAT2_PAD   23
+  #define MMCSD1_DAT3_PAD   24
+  #define MMCSD1_DAT4_PAD   27
+  #define MMCSD1_DAT5_PAD   28
+  #define MMCSD1_DAT6_PAD   29
+  #define MMCSD1_DAT7_PAD   30
+  /* eMMC 4.4 device support external reset line */
+  #ifdef EMMCV44_SUPPORTED
+    #define MMCSD1_RST_PAD          26
+    #define MMCSD_EMMC_RST_ASSERT   0
+    #define MMCSD_EMMC_RST_DEASSERT 1
+  #else
+    #define MMCSD1_RST_PAD    MMCSD_PAD_UNUSE
+  #endif
+
+  #define MMCSD1_VDD_ACTIVE    0 // not use
+  #define MMCSD1_VDD_INACTIVE  0 // not use
+  #define MMCSD1_WP_ACTIVE     0 // not use
+  #define MMCSD1_WP_INACTIVE   0 // not use
+  #define MMCSD1_CD_ACTIVE     0 // not use
+  #define MMCSD1_CD_INACTIVE   0 // not use
+
+  #define MMCSD1_RST_ACTIVE    0x00011010
+  #define MMCSD1_RST_INACTIVE  0x00003100
+  #define MMCSD1_CLK_ACTIVE    0x00031011
+  #define MMCSD1_CLK_INACTIVE  0x00003100
+  #define MMCSD1_CMD_ACTIVE    0x00033011
+  #define MMCSD1_CMD_OD_ACTIVE 0x00032011
+  #define MMCSD1_CMD_INACTIVE  0x00003100
+  #define MMCSD1_DATA_ACTIVE   0x00033011
+  #define MMCSD1_DATA_INACTIVE 0x00003100
+
+  #if defined(POWER_MANAGEMENT_USE_PRH_IF)
+  /* eMMC PRH defines */
+  // PRH Peripheral ID (ePRH_PER_ID_T) defines
+  #define MMCSD1_PRH_PER_ID_CLK           PRH_PER_EMMC_CLK
+  #define MMCSD1_PRH_PER_ID_VOLT          PRH_PER_VMMC_VOLT
+  #define MMCSD1_PRH_PER_ID_POW_DOMAIN    PRH_PER_EMMC_POW
+  #define MMCSD1_PRH_PER_ID_PSV           PRH_PER_EMMC_PSV
+  // PRH Peripheral Type (sPRH_PER_MODE_INFO_T->ePRH_PER_TYPE_T) defines
+  #define MMCSD1_PRH_PER_TYPE_CLK         PRH_PER_TYPE_MMCSD_CLK
+  #define MMCSD1_PRH_PER_TYPE_VOLT        PRH_PER_TYPE_MMCSD_VOLT
+  #define MMCSD1_PRH_PER_TYPE_POW_DOMAIN  PRH_PER_TYPE_GENERIC
+  #define MMCSD1_PRH_PER_TYPE_PSV         PRH_PER_TYPE_GENERIC
+  #endif
+  #define MMCSD1_INPUT_CLK_FREQ                    52000000
+  #define MMCSD1_MAX_CONTROLLER_CLOCK_FREQUENCY    52000000
+  #define MMCSD1_POWER_OFF_AT_CARD_REMOVAL         FALSE
+  //#define MMCSD1_TARGET_HAS_PHYSICAL_POWER_CONTROL TRUE
+  #define MMCSD1_MAX_BUS_WIDTH                     EIGHT_BIT_BUS_WIDTH
+  #define MMCSD1_PCL_CTL_OPS                       PCL_CONTROL_OPS_eMMC1_HS_EN
+  #define MMCSD1_PCL_CTL_HS_SET                    PCL_CONTROL_eMMC1_HS_EN_HS
+  #define MMCSD1_PCL_CTL_HS_RESET                  PCL_CONTROL_eMMC1_HS_EN_NORM
+  #define MMCSD1_USE_POLLING_FOR_CMD               0
+  #define MMCSD1_USE_POLLING_FOR_DATA              0
+  #define MMCSD1_PARTIAL_TRANSFER_PIO_SIZE         0
+#endif //defined(EMMC_ESD_SUPPORT)
+
+#if !defined(EMMC_ESD_SUPPORT)
+  #define MMCSD_SD_CARD_CONTROLLER 0
+#else
+  #define MMCSD_SD_CARD_CONTROLLER 1
+#endif
+  // TODO: support SDV3?
+  //#define SDV3_SUPPORTED
+  //#define TUNING_IN_HAL
+
+  #define TARGET_DRIVER_STRENGTH   MMCSD_DRIVER_TYPE_B
+  #define TARGET_ACCESS_MODE       MMCSD_DDR50
+  #define TARGET_CURRENT_LIMIT     MMCSD_CURRENT_LIMIT_400MA
+  
+#if !defined(EMMC_ESD_SUPPORT)
+  /* MMCI1 PAD definition for SD/MMC card for Leptoon project */ 
+  #define MMCSD1_VDD_PAD    MMCSD_PAD_UNUSE
+  #define MMCSD1_CD_PAD     43
+  #define MMCSD1_WP_PAD     MMCSD_PAD_UNUSE
+  #define MMCSD1_CLK_PAD    42
+  #define MMCSD1_CMD_PP_PAD 37
+  #define MMCSD1_CMD_OD_PAD 37
+  #define MMCSD1_DAT0_PAD   38
+  #define MMCSD1_DAT1_PAD   39
+  #define MMCSD1_DAT2_PAD   40
+  #define MMCSD1_DAT3_PAD   41
+  #define MMCSD1_DAT4_PAD   MMCSD_PAD_UNUSE
+  #define MMCSD1_DAT5_PAD   MMCSD_PAD_UNUSE
+  #define MMCSD1_DAT6_PAD   MMCSD_PAD_UNUSE
+  #define MMCSD1_DAT7_PAD   MMCSD_PAD_UNUSE
+  #define MMCSD1_RST_PAD    MMCSD_PAD_UNUSE
+
+  #define MMCSD1_VDD_ACTIVE    0 // not use
+  #define MMCSD1_VDD_INACTIVE  0 // not use
+  #define MMCSD1_WP_ACTIVE     0 // not use
+  #define MMCSD1_WP_INACTIVE   0 // not use
+  #define MMCSD1_RST_ACTIVE    0 // not use
+  #define MMCSD1_RST_INACTIVE  0 // not use
+
+  #define MMCSD1_CD_ACTIVE     0x00003001
+  #define MMCSD1_CD_INACTIVE   0x00001001
+  #define MMCSD1_CLK_ACTIVE    0x00001011 //0x00031011
+  #define MMCSD1_CLK_INACTIVE  0x00005100
+  #define MMCSD1_CMD_ACTIVE    0x00003011 //0x00033011
+  #define MMCSD1_CMD_OD_ACTIVE 0x00002011 //0x00032011
+  #define MMCSD1_CMD_INACTIVE  0x00005100
+  #define MMCSD1_DATA_ACTIVE   0x00003011 //0x00033011
+  #define MMCSD1_DATA_INACTIVE 0x00005100
+
+#if defined(POWER_MANAGEMENT_USE_PRH_IF)
+  /* SDMMC PRH defines */
+  // PRH Peripheral ID (ePRH_PER_ID_T) defines
+  #define MMCSD1_PRH_PER_ID_CLK           PRH_PER_SDMMC1_CLK
+  #define MMCSD1_PRH_PER_ID_VOLT          PRH_PER_SDMMC1_VOLT
+  #define MMCSD1_PRH_PER_ID_POW_DOMAIN    PRH_PER_SDMMC1_POW
+  #define MMCSD1_PRH_PER_ID_PSV           PRH_PER_SDMMC1_PSV
+  // PRH Peripheral Type (sPRH_PER_MODE_INFO_T->ePRH_PER_TYPE_T) defines
+  #define MMCSD1_PRH_PER_TYPE_CLK         PRH_PER_TYPE_MMCSD_CLK
+  #define MMCSD1_PRH_PER_TYPE_VOLT        PRH_PER_TYPE_MMCSD_VOLT
+  #define MMCSD1_PRH_PER_TYPE_POW_DOMAIN  PRH_PER_TYPE_GENERIC
+  #define MMCSD1_PRH_PER_TYPE_PSV         PRH_PER_TYPE_GENERIC
+#endif //defined(POWER_MANAGEMENT_USE_PRH_IF)
+  #define MMCSD1_INPUT_CLK_FREQ                    52000000
+  #define MMCSD1_MAX_CONTROLLER_CLOCK_FREQUENCY    96000000
+  #define MMCSD1_POWER_OFF_AT_CARD_REMOVAL         FALSE
+  //#define MMCSD2_TARGET_HAS_PHYSICAL_POWER_CONTROL TRUE
+  #define MMCSD1_MAX_BUS_WIDTH                     FOUR_BIT_BUS_WIDTH
+  #define MMCSD1_PCL_CTL_OPS                       PCL_CONTROL_OPS_SDMMC2_HS_EN
+  #define MMCSD1_PCL_CTL_HS_SET                    PCL_CONTROL_SDMMC2_HS_EN_HS
+  #define MMCSD1_PCL_CTL_HS_RESET                  PCL_CONTROL_SDMMC2_HS_EN_NORM
+  #define MMCSD1_USE_POLLING_FOR_CMD               0
+  #define MMCSD1_USE_POLLING_FOR_DATA              0
+  #define MMCSD1_PARTIAL_TRANSFER_PIO_SIZE         0
+#else
+  /* MMCI2 PAD definition for SD/MMC card for 6310 platform project */
+  #define MMCSD2_VDD_PAD    MMCSD_PAD_UNUSE
+  #define MMCSD2_CD_PAD     43
+  #define MMCSD2_WP_PAD     MMCSD_PAD_UNUSE
+  #define MMCSD2_CLK_PAD    42
+  #define MMCSD2_CMD_PP_PAD 37
+  #define MMCSD2_CMD_OD_PAD 37
+  #define MMCSD2_DAT0_PAD   38
+  #define MMCSD2_DAT1_PAD   39
+  #define MMCSD2_DAT2_PAD   40
+  #define MMCSD2_DAT3_PAD   41
+  #define MMCSD2_DAT4_PAD   MMCSD_PAD_UNUSE
+  #define MMCSD2_DAT5_PAD   MMCSD_PAD_UNUSE
+  #define MMCSD2_DAT6_PAD   MMCSD_PAD_UNUSE
+  #define MMCSD2_DAT7_PAD   MMCSD_PAD_UNUSE
+  #define MMCSD2_RST_PAD    MMCSD_PAD_UNUSE
+
+  #define MMCSD2_VDD_ACTIVE     0 // not use
+  #define MMCSD2_VDD_INACTIVE   0 // not use
+  #define MMCSD2_WP_ACTIVE      0 // not use
+  #define MMCSD2_WP_INACTIVE    0 // not use
+  #define MMCSD2_RST_ACTIVE     0 // not use
+  #define MMCSD2_RST_INACTIVE   0 // not use
+
+  #define MMCSD2_CD_ACTIVE     0x00003001
+  #define MMCSD2_CD_INACTIVE   0x00001001
+  #define MMCSD2_CLK_ACTIVE    0x00031011
+  #define MMCSD2_CLK_INACTIVE  0x00005100
+  #define MMCSD2_CMD_ACTIVE    0x00033011
+  #define MMCSD2_CMD_OD_ACTIVE 0x00032011
+  #define MMCSD2_CMD_INACTIVE  0x00005100
+  #define MMCSD2_DATA_ACTIVE   0x00033011
+  #define MMCSD2_DATA_INACTIVE 0x00005100
+
+  #if defined(POWER_MANAGEMENT_USE_PRH_IF)
+  /* SDMMC PRH defines */
+  // PRH Peripheral ID (ePRH_PER_ID_T) defines
+  #define MMCSD2_PRH_PER_ID_CLK           PRH_PER_SDMMC1_CLK
+  #define MMCSD2_PRH_PER_ID_VOLT          PRH_PER_SDMMC1_VOLT
+  #define MMCSD2_PRH_PER_ID_POW_DOMAIN    PRH_PER_SDMMC1_POW
+  #define MMCSD2_PRH_PER_ID_PSV           PRH_PER_SDMMC1_PSV
+  // PRH Peripheral Type (sPRH_PER_MODE_INFO_T->ePRH_PER_TYPE_T) defines
+  #define MMCSD2_PRH_PER_TYPE_CLK         PRH_PER_TYPE_MMCSD_CLK
+  #define MMCSD2_PRH_PER_TYPE_VOLT        PRH_PER_TYPE_MMCSD_VOLT
+  #define MMCSD2_PRH_PER_TYPE_POW_DOMAIN  PRH_PER_TYPE_GENERIC
+  #define MMCSD2_PRH_PER_TYPE_PSV         PRH_PER_TYPE_GENERIC
+  #endif //defined(POWER_MANAGEMENT_USE_PRH_IF)
+  #define MMCSD2_INPUT_CLK_FREQ                    52000000
+  #define MMCSD2_MAX_CONTROLLER_CLOCK_FREQUENCY    96000000
+  #define MMCSD2_POWER_OFF_AT_CARD_REMOVAL         FALSE
+  //#define MMCSD2_TARGET_HAS_PHYSICAL_POWER_CONTROL TRUE
+  #define MMCSD2_MAX_BUS_WIDTH                     FOUR_BIT_BUS_WIDTH
+  #define MMCSD2_PCL_CTL_OPS                       PCL_CONTROL_OPS_SDMMC2_HS_EN
+  #define MMCSD2_PCL_CTL_HS_SET                    PCL_CONTROL_SDMMC2_HS_EN_HS
+  #define MMCSD2_PCL_CTL_HS_RESET                  PCL_CONTROL_SDMMC2_HS_EN_NORM
+  #define MMCSD2_HAS_INTERNAL_SLEEP_MANAGE         1
+  #define MMCSD2_USE_POLLING_FOR_CMD               0
+  #define MMCSD2_USE_POLLING_FOR_DATA              0
+  #define MMCSD2_PARTIAL_TRANSFER_PIO_SIZE         0
+#endif //!defined(EMMC_ESD_SUPPORT)
+
+#if defined(MMCSD_IO)
+  #if defined(MMCSD_WLAN_WAKEUP_OOB)
+    #define MMCSD_IO_WAKEUP_INTR                     PCL_HW_EINT7
+    #else
+    #define MMCSD_IO_WAKEUP_INTR                     PCL_HW_EINT14
+  #endif
+#if !defined(EMMC_ESD_SUPPORT)
+  #define MMCSD_SDIO_CONTROLLER 1
+  /* MMCI1 PAD definition for SDIO */
+  /* Not supported*/
+  #define MMCSD2_VDD_PAD    MMCSD_PAD_UNUSE
+  #define MMCSD2_CD_PAD     MMCSD_PAD_UNUSE
+  #define MMCSD2_WP_PAD     MMCSD_PAD_UNUSE
+  #define MMCSD2_CLK_PAD    MMCSD_PAD_UNUSE
+  #define MMCSD2_CMD_PP_PAD MMCSD_PAD_UNUSE
+  #define MMCSD2_CMD_OD_PAD MMCSD_PAD_UNUSE
+  #define MMCSD2_DAT0_PAD   MMCSD_PAD_UNUSE
+  #define MMCSD2_DAT1_PAD   MMCSD_PAD_UNUSE
+  #define MMCSD2_DAT2_PAD   MMCSD_PAD_UNUSE
+  #define MMCSD2_DAT3_PAD   MMCSD_PAD_UNUSE
+  #define MMCSD2_DAT4_PAD   MMCSD_PAD_UNUSE
+  #define MMCSD2_DAT5_PAD   MMCSD_PAD_UNUSE
+  #define MMCSD2_DAT6_PAD   MMCSD_PAD_UNUSE
+  #define MMCSD2_DAT7_PAD   MMCSD_PAD_UNUSE
+  #define MMCSD2_RST_PAD    MMCSD_PAD_UNUSE
+
+  #if defined(POWER_MANAGEMENT_USE_PRH_IF)
+  /* SDIO PRH defines */
+  // PRH Peripheral ID (ePRH_PER_ID_T) defines
+  #define MMCSD2_PRH_PER_ID_CLK           PRH_PER_SDIO_CLK
+  #define MMCSD2_PRH_PER_ID_VOLT          PRH_PER_SDIO_VOLT
+  #define MMCSD2_PRH_PER_ID_POW_DOMAIN    PRH_PER_SDIO_POW
+  #define MMCSD2_PRH_PER_ID_PSV           PRH_PER_SDIO_PSV
+  // PRH Peripheral Type (sPRH_PER_MODE_INFO_T->ePRH_PER_TYPE_T) defines
+  #define MMCSD2_PRH_PER_TYPE_CLK         PRH_PER_TYPE_MMCSD_CLK
+  #define MMCSD2_PRH_PER_TYPE_VOLT        PRH_PER_TYPE_MMCSD_VOLT
+  #define MMCSD2_PRH_PER_TYPE_POW_DOMAIN  PRH_PER_TYPE_GENERIC
+  #define MMCSD2_PRH_PER_TYPE_PSV         PRH_PER_TYPE_GENERIC
+  #endif
+  #define MMCSD2_INPUT_CLK_FREQ                    52000000
+  //#define MMCSD3_MAX_CONTROLLER_CLOCK_FREQUENCY    96000000
+  #define MMCSD2_POWER_OFF_AT_CARD_REMOVAL         FALSE
+  //#define MMCSD2_TARGET_HAS_PHYSICAL_POWER_CONTROL TRUE
+  #define MMCSD2_MAX_BUS_WIDTH                     FOUR_BIT_BUS_WIDTH
+  #define MMCSD2_PCL_CTL_OPS                       PCL_CONTROL_OPS_SDMMC3_HS_EN
+  #define MMCSD2_PCL_CTL_HS_SET                    PCL_CONTROL_SDMMC3_HS_EN_HS
+  #define MMCSD2_PCL_CTL_HS_RESET                  PCL_CONTROL_SDMMC3_HS_EN_NORM
+  #define MMCSD2_HAS_INTERNAL_SLEEP_MANAGE         0
+  #define MMCSD2_USE_POLLING_FOR_CMD               1
+  #define MMCSD2_USE_POLLING_FOR_DATA              1
+  #define MMCSD2_PARTIAL_TRANSFER_PIO_SIZE         128
+#else
+  #define MMCSD_SDIO_CONTROLLER 2
+  /* MMCI1 PAD definition for SDIO */
+  /* Not supported */
+  #define MMCSD3_VDD_PAD    MMCSD_PAD_UNUSE
+  #define MMCSD3_CD_PAD     MMCSD_PAD_UNUSE
+  #define MMCSD3_WP_PAD     MMCSD_PAD_UNUSE
+  #define MMCSD3_CLK_PAD    MMCSD_PAD_UNUSE
+  #define MMCSD3_CMD_PP_PAD MMCSD_PAD_UNUSE
+  #define MMCSD3_CMD_OD_PAD MMCSD_PAD_UNUSE
+  #define MMCSD3_DAT0_PAD   MMCSD_PAD_UNUSE
+  #define MMCSD3_DAT1_PAD   MMCSD_PAD_UNUSE
+  #define MMCSD3_DAT2_PAD   MMCSD_PAD_UNUSE
+  #define MMCSD3_DAT3_PAD   MMCSD_PAD_UNUSE
+  #define MMCSD3_DAT4_PAD   MMCSD_PAD_UNUSE
+  #define MMCSD3_DAT5_PAD   MMCSD_PAD_UNUSE
+  #define MMCSD3_DAT6_PAD   MMCSD_PAD_UNUSE
+  #define MMCSD3_DAT7_PAD   MMCSD_PAD_UNUSE
+  #define MMCSD3_RST_PAD    MMCSD_PAD_UNUSE
+
+  #if defined(POWER_MANAGEMENT_USE_PRH_IF)
+  /* SDIO PRH defines */
+  // PRH Peripheral ID (ePRH_PER_ID_T) defines
+  #define MMCSD3_PRH_PER_ID_CLK           PRH_PER_SDIO_CLK
+  #define MMCSD3_PRH_PER_ID_VOLT          PRH_PER_SDIO_VOLT
+  #define MMCSD3_PRH_PER_ID_POW_DOMAIN    PRH_PER_SDIO_POW
+  #define MMCSD3_PRH_PER_ID_PSV           PRH_PER_SDIO_PSV
+  // PRH Peripheral Type (sPRH_PER_MODE_INFO_T->ePRH_PER_TYPE_T) defines
+  #define MMCSD3_PRH_PER_TYPE_CLK         PRH_PER_TYPE_MMCSD_CLK
+  #define MMCSD3_PRH_PER_TYPE_VOLT        PRH_PER_TYPE_MMCSD_VOLT
+  #define MMCSD3_PRH_PER_TYPE_POW_DOMAIN  PRH_PER_TYPE_GENERIC
+  #define MMCSD3_PRH_PER_TYPE_PSV         PRH_PER_TYPE_GENERIC
+  #endif
+  #define MMCSD3_INPUT_CLK_FREQ                    52000000
+  //#define MMCSD3_MAX_CONTROLLER_CLOCK_FREQUENCY    96000000
+  #define MMCSD3_POWER_OFF_AT_CARD_REMOVAL         FALSE
+  //#define MMCSD3_TARGET_HAS_PHYSICAL_POWER_CONTROL TRUE
+  #define MMCSD3_MAX_BUS_WIDTH                     FOUR_BIT_BUS_WIDTH
+  #define MMCSD3_PCL_CTL_OPS                       PCL_CONTROL_OPS_SDMMC3_HS_EN
+  #define MMCSD3_PCL_CTL_HS_SET                    PCL_CONTROL_SDMMC3_HS_EN_HS
+  #define MMCSD3_PCL_CTL_HS_RESET                  PCL_CONTROL_SDMMC3_HS_EN_NORM
+  #define MMCSD3_HAS_INTERNAL_SLEEP_MANAGE         0
+  #define MMCSD3_USE_POLLING_FOR_CMD               1
+  #define MMCSD3_USE_POLLING_FOR_DATA              1
+  #define MMCSD3_PARTIAL_TRANSFER_PIO_SIZE         128
+#endif
+  /* Currently, SDIO 3.0 support is not available in MMCSD driver
+  #define SDV3_SUPPORTED
+  #define TARGET_DRIVER_STRENGTH   MMCSD_DRIVER_TYPE_B
+  #define TARGET_ACCESS_MODE       MMCSD_DDR50
+  #define TARGET_CURRENT_LIMIT     MMCSD_CURRENT_LIMIT_400MA
+  */
+
+#endif
+
+#define MMCSD3_MAX_CONTROLLER_CLOCK_FREQUENCY    96000000
+
+#define CHECK_SEND_ACMD(Cmd) (Cmd >= APPL_CMD_BIT)
+
+#define MMCSD_IDLE_TIME_OUT                   500
+#define MMCSD_READ_DATA_TIME                  1000
+#define MMCSD_WRITE_DATA_TIME                 1000
+#define MMCSD_RESOURCE_TIME_OUT_CNT           1
+
+
+
+/* This number must max be 0xFFFF, since the MMCSD controller will fail if
+   it is requested to transfer 0x10000 bytes or more*/
+#if defined(MMCSD_UPDATE_MODE)
+  #define SIZE_OF_DMA_BUFFERS       2048
+#else
+  #define SIZE_OF_DMA_BUFFERS       32768
+#endif
+
+#undef SETUP_DATA_IN_BYTES
+
+#if defined(EXT_CARD_DETECT)
+  #define HWPCL_MMCSD_DETECT PCL_HW_EINT6
+  #define MMCSD_DETECT_IN_VALUE(value)  (BOOL)(!value)
+#else
+  #if defined(MMCSD_DETECT_VIA_DAT3)
+    #define MMCSD_DETECT_IN_VALUE(value) (BOOL)(value)
+  #endif
+#endif // EXT_CARD_DETECT
+
+#define MMCSD_EXT_MEM_IF_SUCCESS    T_EMIF_RES_SUCCESS
+#define MMCSD1_EXT_MEM_IF_ID        T_EMIF_USER_SDMMC1
+#define MMCSD2_EXT_MEM_IF_ID        T_EMIF_USER_SDMMC2
+#define MMCSD3_EXT_MEM_IF_ID        T_EMIF_USER_SDMMC3
+
+#define MMCSD_POWER_ON_DELAY 5000
+#define MMCSD_POWER_OFF_DELAY 5000
+
+#endif //__MMCSD_CFG_H__
+
diff --git a/devices/mmc_sd/src/sofia3gx/mmcsd_variant_def.h b/devices/mmc_sd/src/sofia3gx/mmcsd_variant_def.h
new file mode 100644
index 0000000..351c221
--- /dev/null
+++ b/devices/mmc_sd/src/sofia3gx/mmcsd_variant_def.h
@@ -0,0 +1,302 @@
+/*  -------------------------------------------------------------------------
+    Copyright (C) 2013-2014 Intel Mobile Communications GmbH
+    
+         Sec Class: Intel Confidential (IC)
+    
+     ----------------------------------------------------------------------
+
+     ---------------------------------------------------------------------- */
+
+#ifndef __MMCSD_VARIANT_DEF_H__
+#define __MMCSD_VARIANT_DEF_H__
+
+#include "mmcsd_hal_internal.h"
+#include "sdmmc_reg.h"
+#include "scu_reg.h"
+#include "emif_driverif.h"
+
+#define SET_RESET_DAT(Controller)             (setSdmmc_SW_RESET_SW_RST_DAT_LINE(Controller->Registers, 1))
+#define SET_RESET_CMD(Controller)             (setSdmmc_SW_RESET_SW_RST_CMD_LINE(Controller->Registers, 1))
+#define SET_RESET_ALL(Controller)             (setSdmmc_SW_RESET_SW_RST_ALL(Controller->Registers, 1))
+#define GET_RESET_CMD_STATUS(Controller)      (getSdmmc_SW_RESET_SW_RST_CMD_LINE(Controller->Registers)) //check if CMD RESET bit is zero
+#define GET_RESET_DAT_STATUS(Controller)      (getSdmmc_SW_RESET_SW_RST_DAT_LINE(Controller->Registers)) //check if DAT RESET bit is zero
+#define GET_RESET_ALL_STATUS(Controller)      (getSdmmc_SW_RESET_SW_RST_ALL(Controller->Registers)) //check if all RESET bits are zero
+
+#define SELECT_BUS_VOLTAGE(Controller, a)     (setSdmmc_POWER_CTRL_SD_BUS_VOLTAGE_SEL(Controller->Registers, a))
+#define SET_BUS_POWER_ON(Controller)          (setSdmmc_POWER_CTRL_SD_BUS_POWER(Controller->Registers, 1))  //power on SD bus
+#define SET_BUS_POWER_OFF(Controller)         (setSdmmc_POWER_CTRL_SD_BUS_POWER(Controller->Registers, 0))  //power off SD bus
+
+#define SET_BUS_WIDTH_1_BIT(Controller)       (setSdmmc_HOST_CTRL(Controller->Registers, (getSdmmc_HOST_CTRL(Controller->Registers) & 0xDD)))  //1 Bit bus
+#define SET_BUS_WIDTH_4_BIT(Controller)       (setSdmmc_HOST_CTRL(Controller->Registers, (getSdmmc_HOST_CTRL(Controller->Registers) & 0xDD) | 0x02))  //4 Bit bus
+#define SET_BUS_WIDTH_8_BIT(Controller)       (setSdmmc_HOST_CTRL(Controller->Registers, (getSdmmc_HOST_CTRL(Controller->Registers) & 0xDD) | 0x20))  //8 Bit bus
+
+#define SET_COMMAND_ARGUMENT(Controller, a)   (setSdmmc_ARGUMENT1(Controller->Registers, a))
+#define SET_COMMAND_MODE(Controller, a)       (setSdmmc_TRANSFER_MODE(Controller->Registers, a))
+#define SET_COMMAND(Controller, a)            (setSdmmc_COMMAND(Controller->Registers, a))
+
+#define GET_INTERRUPT_STATUS(Controller)      ((ulong)getSdmmc_INT_STATUS_NORM(Controller->Registers)|(ulong)getSdmmc_INT_STATUS_ERR(Controller->Registers)<<16)
+#define SET_INTERRUPT_STATUS(Controller, a)   setSdmmc_INT_STATUS_NORM(Controller->Registers, (ushort)(a&0x0000FFFF));\
+                                                                             setSdmmc_INT_STATUS_ERR(Controller->Registers, (ushort)((a&0xFFFF0000)>>16))
+
+#define ENABLE_INTERRUPTS(Controller, a)      setSdmmc_EN_INT_SIGNAL_NORM(Controller->Registers, getSdmmc_EN_INT_SIGNAL_NORM(Controller->Registers) | (ushort)(a&0x0000FFFF));\
+                                                                             setSdmmc_EN_INT_SIGNAL_ERR(Controller->Registers, getSdmmc_EN_INT_SIGNAL_ERR(Controller->Registers) | (ushort)((a&0xFFFF0000)>>16))
+#define DISABLE_INTERRUPTS(Controller, a)     setSdmmc_EN_INT_SIGNAL_NORM(Controller->Registers, getSdmmc_EN_INT_SIGNAL_NORM(Controller->Registers) & (ushort)(~a&0x0000FFFF));\
+                                                                             setSdmmc_EN_INT_SIGNAL_ERR(Controller->Registers, getSdmmc_EN_INT_SIGNAL_ERR(Controller->Registers) | (ushort)((~a&0xFFFF0000)>>16))
+
+#define ENABLE_INTERRUPTS_NORM(Controller, a) setSdmmc_EN_INT_SIGNAL_NORM(Controller->Registers, getSdmmc_EN_INT_SIGNAL_NORM(Controller->Registers) | (ushort)(a&0x0000FFFF))
+
+#define ENABLE_INTERRUPT_STATUS(Controller, a) (setSdmmc_EN_INT_STATUS_NORM(Controller->Registers, getSdmmc_EN_INT_STATUS_NORM(Controller->Registers) | a))
+#define DISABLE_INTERRUPT_STATUS(Controller, a) (setSdmmc_EN_INT_STATUS_NORM(Controller->Registers, getSdmmc_EN_INT_STATUS_NORM(Controller->Registers) & ~a))
+
+#define ENABLE_CMD_INTERRUPTS(Controller)     ENABLE_INTERRUPTS(Controller, (MMCSD_ERR_INT_CMD | MMCSD_NORM_INT_CMD))
+#define DISABLE_CMD_INTERRUPTS(Controller)    DISABLE_INTERRUPTS(Controller, (MMCSD_ERR_INT_CMD | MMCSD_NORM_INT_CMD))
+
+#define ENABLE_DAT_INTERRUPTS(Controller)     ENABLE_INTERRUPTS(Controller, (MMCSD_ERR_INT_DATA |  MMCSD_NORM_INT_DATA))
+#define DISABLE_DAT_INTERRUPTS(Controller)    DISABLE_INTERRUPTS(Controller, (MMCSD_ERR_INT_DATA |  MMCSD_NORM_INT_DATA))
+
+#define ENABLE_DETECT_INTERRUPTS(Controller)  ENABLE_INTERRUPTS(Controller, (MMCSD_NORM_INT_CARDINSERT | MMCSD_NORM_INT_CARDREMOVE))
+#define DISABLE_DETECT_INTERRUPTS(Controller) DISABLE_INTERRUPTS(Controller, (MMCSD_NORM_INT_CARDINSERT | MMCSD_NORM_INT_CARDREMOVE))
+
+
+#define DISABLE_ALL_INTERRUPTS(Controller)    setSdmmc_EN_INT_SIGNAL_NORM(Controller->Registers, 0);\
+                                                                              setSdmmc_EN_INT_SIGNAL_ERR(Controller->Registers, 0)
+#if defined(EMMC_ESD_SUPPORT)
+  #define ENABLE_ALL_INTERRUPTS(Controller)     ENABLE_INTERRUPTS(Controller, (MMCSD_ERR_INT_CMD | MMCSD_NORM_INT_CMD | MMCSD_ERR_INT_DATA |  MMCSD_NORM_INT_DATA))
+#else
+#if defined(EXT_CARD_DETECT)
+  #define ENABLE_ALL_INTERRUPTS(Controller)     ENABLE_INTERRUPTS(Controller, (MMCSD_ERR_INT_CMD | MMCSD_NORM_INT_CMD | MMCSD_ERR_INT_DATA |  MMCSD_NORM_INT_DATA /* |MMCSD_NORM_INT_CARDINSERT | MMCSD_NORM_INT_CARDREMOVE*/))
+#else
+  #define ENABLE_ALL_INTERRUPTS(Controller)     ENABLE_INTERRUPTS(Controller, (MMCSD_ERR_INT_CMD | MMCSD_NORM_INT_CMD | MMCSD_ERR_INT_DATA |  MMCSD_NORM_INT_DATA | MMCSD_NORM_INT_CARDINSERT | MMCSD_NORM_INT_CARDREMOVE))
+#endif
+#endif
+
+#define CLEAR_ALL_INTERRUPTS(Controller)      setSdmmc_INT_STATUS_NORM(Controller->Registers, 0xFFFF);\
+                                                                              setSdmmc_INT_STATUS_ERR(Controller->Registers, 0xFFFF)
+
+#define IS_CMD_LINE_BUSY(Controller)         (getSdmmc_PRESENT_STATE_COMMAND_INHIBIT_CMD(Controller->Registers))
+#define IS_DAT_LINE_BUSY(Controller)         (getSdmmc_PRESENT_STATE_COMMAND_INHIBIT_DAT(Controller->Registers))
+
+#define IS_READ_ACTIVE(Controller)           (getSdmmc_PRESENT_STATE_READ_TRANSFER_ACTIVE(Controller->Registers))
+#define IS_WRITE_ACTIVE(Controller)          (getSdmmc_PRESENT_STATE_WRITE_TRANSFER_ACTIVE(Controller->Registers))
+
+#define START_INTERNAL_SDCLK(Controller)     (setSdmmc_CLOCK_CTRL_INTERNAL_CLOCK_EN(Controller->Registers, 1))
+#define STOP_INTERNAL_SDCLK(Controller)      (setSdmmc_CLOCK_CTRL_INTERNAL_CLOCK_EN(Controller->Registers, 0))
+#define IS_INTERNAL_SDCLK_STABLE(Controller) (getSdmmc_CLOCK_CTRL_INTERNAL_CLOCK_STABLE(Controller->Registers))
+#define START_SDCLK(Controller)              (setSdmmc_CLOCK_CTRL_SDCLOCK_EN(Controller->Registers, 1))
+#define STOP_SDCLK(Controller)               (setSdmmc_CLOCK_CTRL_SDCLOCK_EN(Controller->Registers, 0))
+#define IS_CLOCK_RUNNING(Controller)         (getSdmmc_CLOCK_CTRL_SDCLOCK_EN(Controller->Registers))
+
+#define IS_POWER_ON(Controller)              (getSdmmc_POWER_CTRL_SD_BUS_POWER(Controller->Registers))
+
+//*************************************************
+// Unification of MACRO names
+//*************************************************
+#define getSdmmc_INT_SIGNAL_EN_CARD_INT_EN(Controller)   getSdmmc_EN_INT_SIGNAL_NORM_CARD_INT_EN(Controller)
+#define  setSdmmc_INT_STATUS(Controller, a)  setSdmmc_INT_STATUS_NORM(Controller, (ushort)(a&0x0000FFFF));\
+                                                                             setSdmmc_INT_STATUS_ERR(Controller, (ushort)((a&0xFFFF0000)>>16))
+#define setSdmmc_INT_STATUS_EN_DMA_INT_EN(Controller, a)   setSdmmc_EN_INT_STATUS_NORM_DMA_INT_EN(Controller, (ushort)a)
+#define setSdmmc_INT_STATUS_EN(Controller, a)     setSdmmc_EN_INT_STATUS_NORM(Controller, (ushort)(a&0x0000FFFF));\
+                                                                                       setSdmmc_EN_INT_STATUS_ERR(Controller, (ushort)((a&0xFFFF0000)>>16))
+#define setSdmmc_CTRL_DMA_SELECT(Controller, a)    setSdmmc_HOST_CTRL_DMA_SELECT(Controller, (ubyte)a)
+#define getSdmmc_PRESENT_STATE_CARD_INS(Controller)   getSdmmc_PRESENT_STATE_CARD_INSERTED(Controller)
+#define getSdmmc_PRESENT_STATE_CARD_DETECT_PIN(Controller)  getSdmmc_PRESENT_STATE_CARD_DETECT_PIN_LEVEL(Controller)
+#define setSdmmc_CLOCK_CTRL_SDCLOCK_FREQ_SEL(Controller, a)        setSdmmc_CLOCK_CTRL_SDCLK_FREQ_SEL(Controller, (ushort)(a&0x0000FFFF));\
+                                                                                                               setSdmmc_CLOCK_CTRL_SDCLK_FREQ_SEL_H(Controller, (ushort)((a&0x00FF0000)>>16))
+#define setSdmmc_CLOCK_CTRL_SW_RST_CMD_LINE(Controller, a)     setSdmmc_SW_RESET_SW_RST_CMD_LINE(Controller, a)
+#define setSdmmc_CTRL_HIGH_SPEED_EN(Controller, a)      setSdmmc_HOST_CTRL_HIGH_SPEED_EN(Controller, a)
+#define setSdmmc_ADMA_ADDR_HIGH(Controller, a)
+#define setSdmmc_CLOCK_CTRL_DAT_TIMEOUT_CNT_VAL(Controller, a)    setSdmmc_TIMEOUT_CTRL_DAT_TIMEOUT_CNT_VAL(Controller, (ubyte)a)
+
+
+
+#define getNonR2Response_0(Register)    getSdmmc_RESPONSE0(Register)
+#define getNonR2Response_1(Register)     getSdmmc_RESPONSE2(Register)
+#define getNonR2Response_2(Register)     getSdmmc_RESPONSE4(Register)
+#define getNonR2Response_3(Register)     getSdmmc_RESPONSE6(Register)
+
+#define getR2Response_3(Register)     getSdmmc_RESPONSE0_RESPONSE0(Register) *0x100 + 0x1000000 * getSdmmc_RESPONSE0_RESPONSE1(Register)
+#define getR2Response_2(Register)     getSdmmc_RESPONSE2_RESPONSE2(Register) *0x100 + 0x1000000 * getSdmmc_RESPONSE2_RESPONSE3(Register) + ((getSdmmc_RESPONSE0_RESPONSE1(Register) >> 8) & 0x00FF)
+#define getR2Response_1(Register)     getSdmmc_RESPONSE4_RESPONSE4(Register) *0x100 + 0x1000000 * getSdmmc_RESPONSE4_RESPONSE5(Register) + ((getSdmmc_RESPONSE2_RESPONSE3(Register) >> 8) & 0x00FF)
+#define getR2Response_0(Register)     getSdmmc_RESPONSE6_RESPONSE6(Register) *0x100 + 0x1000000 * getSdmmc_RESPONSE6_RESPONSE7(Register) + ((getSdmmc_RESPONSE4_RESPONSE5(Register) >> 8) & 0x00FF)
+
+
+static const float tde[4] ={250, 400, 550, 700};
+
+struct tap_delay {
+   unsigned long op_tap_en;
+   unsigned long op_del_ctl;
+   unsigned long op_tap_del;
+   unsigned long ip_tap_en;
+   unsigned long ip_del_ctl;
+   unsigned long ip_tap_del;
+   unsigned long async_fifo;
+   unsigned long fb_en;
+   unsigned long sdmmc_tune;
+};
+
+static const struct tap_delay tap_delay_settings[MMCSD_NOF_TIMING_MODE] = {
+  // default
+  {
+    // Default mode 0x080400F5
+    // 0x0000_1000_0000_0100_0000_0000_1111_0101
+    1, // OP_TAP_EN :1;
+    2, // OP_DEL_CTL :3;
+    15, // OP_TAP_DEL :4;
+    0, // IP_TAP_EN :1;
+    2, // IP_DEL_CTL :3;
+    0, // IP_TAP_DEL :6;
+    0, // AFIFO_SEL :1;
+    1, // FB_EN :1;
+    0, // TUNE :4;
+  },
+#if defined (MMCSD_SET_TAP_DELAY_SD2V) || defined (TUNING_IN_HAL)
+  // MMCSD_TIMING_SD_HS
+  {
+    // Default mode 0x08040004
+    // 0x0000_0000_1000_0100_0000_0000_0000_0100
+    0, // OP_TAP_EN :1;
+    2, // OP_DEL_CTL :3;
+    0, // OP_TAP_DEL :4;
+    0, // IP_TAP_EN :1;
+    2, // IP_DEL_CTL :3;
+    8, // IP_TAP_DEL :6;
+    0, // AFIFO_SEL :1;
+    0, // FB_EN :1;
+    0, // TUNE :4;
+  },
+#endif
+  // eMMC 4.4 DDR
+  {
+    // Default mode 0x08040004
+    // 0x0000_0000_1000_0100_0000_0000_0000_0100
+    0, // OP_TAP_EN :1;
+    2, // OP_DEL_CTL :3;
+    0, // OP_TAP_DEL :4;
+    0, // IP_TAP_EN :1;
+    2, // IP_DEL_CTL :3;
+    8, // IP_TAP_DEL :6;
+    0, // AFIFO_SEL :1;
+    0, // FB_EN :1;
+    0, // TUNE :4;
+  },
+  // SD3.0 SDR50
+  {
+    // Default mode 0x08040004
+    // 0x0000_0000_1000_0100_0000_0000_0000_0100
+    0, // OP_TAP_EN :1;
+    2, // OP_DEL_CTL :3;
+    0, // OP_TAP_DEL :4;
+    0, // IP_TAP_EN :1;
+    2, // IP_DEL_CTL :3;
+    8, // IP_TAP_DEL :6;
+    0, // AFIFO_SEL :1;
+    0, // FB_EN :1;
+    0, // TUNE :4;
+  },
+  // SD3.0 DDR50
+  {
+    // Default mode 0x00F500A5
+    // 0x0000_0000_1111_0101_0000_0000_1010_0101
+    1, // OP_TAP_EN :1;
+    2, // OP_DEL_CTL :3;
+    10, // OP_TAP_DEL :4;
+    1, // IP_TAP_EN :1;
+    2, // IP_DEL_CTL :3;
+    15, // IP_TAP_DEL :6;
+    0, // AFIFO_SEL :1;
+    0, // FB_EN :1;
+    0, // TUNE :4;
+  },
+};
+
+#define mmcsd_SetTuningTapDelay(ControllerNumber, Mode)   { \
+  switch(ControllerNumber) \
+  { \
+    case 0: \
+    setScu_EMMC_CTL_OP_TAP_EN(&scu, (eEMMC_CTL_OP_TAP_EN)0);\
+    setScu_EMMC_CTL_IP_TAP_EN(&scu, (eEMMC_CTL_IP_TAP_EN)0);\
+    setScu_EMMC_CTL_OP_TAP_DEL(&scu, tap_delay_settings[Mode].op_tap_del);\
+    setScu_EMMC_CTL_IP_TAP_DEL(&scu, tap_delay_settings[Mode].ip_tap_del);\
+    setScu_EMMC_CTL_OP_DEL_CTL(&scu, tap_delay_settings[Mode].op_del_ctl);\
+    setScu_EMMC_CTL_IP_DEL_CTL(&scu, tap_delay_settings[Mode].ip_del_ctl);\
+    setScu_EMMC_CTL_AFIFO_SEL(&scu, tap_delay_settings[Mode].async_fifo);\
+    setScu_EMMC_CTL_FB_EN(&scu, tap_delay_settings[Mode].fb_en);\
+    setScu_EMMC_CTL_TUNE(&scu, tap_delay_settings[Mode].sdmmc_tune);\
+    setScu_EMMC_CTL_OP_TAP_EN(&scu, (eEMMC_CTL_OP_TAP_EN)tap_delay_settings[Mode].op_tap_en);\
+    setScu_EMMC_CTL_IP_TAP_EN(&scu, (eEMMC_CTL_IP_TAP_EN)tap_delay_settings[Mode].ip_tap_en);\
+    break; \
+    case 1: \
+    setScu_SDMMC_CTL_OP_TAP_EN(&scu, (eSDMMC_CTL_OP_TAP_EN)0);\
+    setScu_SDMMC_CTL_IP_TAP_EN(&scu, (eSDMMC_CTL_IP_TAP_EN)0);\
+    setScu_SDMMC_CTL_OP_TAP_DEL(&scu, tap_delay_settings[Mode].op_tap_del);\
+    setScu_SDMMC_CTL_IP_TAP_DEL(&scu, tap_delay_settings[Mode].ip_tap_del);\
+    setScu_SDMMC_CTL_OP_DEL_CTL(&scu, tap_delay_settings[Mode].op_del_ctl);\
+    setScu_SDMMC_CTL_IP_DEL_CTL(&scu, tap_delay_settings[Mode].ip_del_ctl);\
+    setScu_SDMMC_CTL_AFIFO_SEL(&scu, tap_delay_settings[Mode].async_fifo);\
+    setScu_SDMMC_CTL_FB_EN(&scu, tap_delay_settings[Mode].fb_en);\
+    setScu_SDMMC_CTL_TUNE(&scu, tap_delay_settings[Mode].sdmmc_tune);\
+    setScu_SDMMC_CTL_OP_TAP_EN(&scu, (eSDMMC_CTL_OP_TAP_EN)tap_delay_settings[Mode].op_tap_en);\
+    setScu_SDMMC_CTL_IP_TAP_EN(&scu, (eSDMMC_CTL_IP_TAP_EN)tap_delay_settings[Mode].ip_tap_en);\
+    break; \
+    case 2: \
+    setScu_SDIO_CTL_OP_TAP_EN(&scu, (eSDIO_CTL_OP_TAP_EN)0);\
+    setScu_SDIO_CTL_IP_TAP_EN(&scu, (eSDIO_CTL_IP_TAP_EN)0);\
+    setScu_SDIO_CTL_OP_TAP_DEL(&scu, tap_delay_settings[Mode].op_tap_del);\
+    setScu_SDIO_CTL_IP_TAP_DEL(&scu, tap_delay_settings[Mode].ip_tap_del);\
+    setScu_SDIO_CTL_OP_DEL_CTL(&scu, tap_delay_settings[Mode].op_del_ctl);\
+    setScu_SDIO_CTL_IP_DEL_CTL(&scu, tap_delay_settings[Mode].ip_del_ctl);\
+    setScu_SDIO_CTL_AFIFO_SEL(&scu, tap_delay_settings[Mode].async_fifo);\
+    setScu_SDIO_CTL_FB_EN(&scu, tap_delay_settings[Mode].fb_en);\
+    setScu_SDIO_CTL_TUNE(&scu, tap_delay_settings[Mode].sdmmc_tune);\
+    setScu_SDIO_CTL_OP_TAP_EN(&scu, (eSDIO_CTL_OP_TAP_EN)tap_delay_settings[Mode].op_tap_en);\
+    setScu_SDIO_CTL_IP_TAP_EN(&scu, (eSDIO_CTL_IP_TAP_EN)tap_delay_settings[Mode].ip_tap_en);\
+    break; \
+  } \
+}
+
+#define mmcsd_SetReTuningTapDelay(CardNumber, Del_Ctl)  { \
+  switch(CardNumber) \
+  { \
+    case 0: \
+    if(Del_Ctl != getScu_EMMC_CTL_OP_DEL_CTL(&scu)) \
+    { \
+      eEMMC_CTL_OP_TAP_EN op_tap_en = getScu_EMMC_CTL_OP_TAP_EN(&scu);\
+      eEMMC_CTL_IP_TAP_EN ip_tap_en = getScu_EMMC_CTL_IP_TAP_EN(&scu);\
+      setScu_EMMC_CTL_OP_TAP_EN(&scu, (eEMMC_CTL_OP_TAP_EN)0);\
+      setScu_EMMC_CTL_IP_TAP_EN(&scu, (eEMMC_CTL_IP_TAP_EN)0);\
+      setScu_EMMC_CTL_OP_DEL_CTL(&scu, (unsigned long)Del_Ctl);\
+      setScu_EMMC_CTL_OP_TAP_EN(&scu, (eEMMC_CTL_OP_TAP_EN)op_tap_en);\
+      setScu_EMMC_CTL_IP_TAP_EN(&scu, (eEMMC_CTL_IP_TAP_EN)ip_tap_en);\
+    } \
+    break; \
+    case 1: \
+    if(Del_Ctl != getScu_SDMMC_CTL_OP_DEL_CTL(&scu)) \
+    { \
+      eSDMMC_CTL_OP_TAP_EN op_tap_en = getScu_SDMMC_CTL_OP_TAP_EN(&scu);\
+      eSDMMC_CTL_IP_TAP_EN ip_tap_en = getScu_SDMMC_CTL_IP_TAP_EN(&scu);\
+      setScu_SDMMC_CTL_OP_TAP_EN(&scu, (eSDMMC_CTL_OP_TAP_EN)0);\
+      setScu_SDMMC_CTL_IP_TAP_EN(&scu, (eSDMMC_CTL_IP_TAP_EN)0);\
+      setScu_SDMMC_CTL_OP_DEL_CTL(&scu, (unsigned long)Del_Ctl);\
+      setScu_SDMMC_CTL_OP_TAP_EN(&scu, (eSDMMC_CTL_OP_TAP_EN)op_tap_en);\
+      setScu_SDMMC_CTL_IP_TAP_EN(&scu, (eSDMMC_CTL_IP_TAP_EN)ip_tap_en);\
+    } \
+    break; \
+    case 2: \
+    if(Del_Ctl != getScu_SDIO_CTL_OP_DEL_CTL(&scu)) \
+    { \
+      eSDIO_CTL_OP_TAP_EN op_tap_en = getScu_SDIO_CTL_OP_TAP_EN(&scu);\
+      eSDIO_CTL_IP_TAP_EN ip_tap_en = getScu_SDIO_CTL_IP_TAP_EN(&scu);\
+      setScu_SDIO_CTL_OP_TAP_EN(&scu, (eSDIO_CTL_OP_TAP_EN)0);\
+      setScu_SDIO_CTL_IP_TAP_EN(&scu, (eSDIO_CTL_IP_TAP_EN)0);\
+      setScu_SDIO_CTL_OP_DEL_CTL(&scu, (unsigned long)Del_Ctl);\
+      setScu_SDIO_CTL_OP_TAP_EN(&scu, (eSDIO_CTL_OP_TAP_EN)op_tap_en);\
+      setScu_SDIO_CTL_IP_TAP_EN(&scu, (eSDIO_CTL_IP_TAP_EN)ip_tap_en);\
+    } \
+    break; \
+  } \
+}
+
+#define MMCSD_EXT_MEM_IF_MODIFY_PERF_DEMAND(a, b)  EMIF_ModifyPerfDemand(a, (T_EMIF_USER) b)
+#define MMCSD_EXT_MEM_IF_SET_PERF_DEMAND(a, b)     EMIF_SetPerfDemand(a, (T_EMIF_USER) b)
+#define MMCSD_EXT_MEM_IF_FREE_PERF_DEMAND(a)       EMIF_FreePerfDemand((T_EMIF_USER) a)
+#endif   //__MMCSD_VARIANT_DEF_H__
diff --git a/devices/mmc_sd/src/sofia3gx/sdmmc_reg.h b/devices/mmc_sd/src/sofia3gx/sdmmc_reg.h
new file mode 100644
index 0000000..51354be
--- /dev/null
+++ b/devices/mmc_sd/src/sofia3gx/sdmmc_reg.h
@@ -0,0 +1,5486 @@
+// =============================================================================
+// Copyright (C) 2012-2013 Intel Mobile Communications GmbH
+// 
+//      Sec Class: Intel Confidential (IC)
+//
+// This document contains proprietary information belonging to IMC.
+// Passing on and copying of this document, use and communication of its
+// contents is not permitted without prior written authorisation.
+//
+// Revision Information :
+//  $File name:  /mhw_drv_src/storage/mmcsd/src/board_xmm6310/sdmmc_reg.h $
+//   Responsible: 
+//   This file has been automatically generated from
+//       /vobs/xg631-doc-vob/06_Design_Verification/04_Chip_development/19_Essence/xml/emmc.xml
+//
+//   essemplate command line:
+//       essemplate -i /vobs/xg631-doc-vob/06_Design_Verification/04_Chip_development/19_Essence/xml/emmc.xml -t sg3hs_main.mako -o fwout/emmc_XG631_reg.log -DREGRESSION=false -DWORKAROUND=true -d ERROR -y DEBUG -DSEQFILTER=true -Dextpragma=true -Dversion=ES1
+//   essemplate tool directory:
+//       /opt/essence/2.1.18/bin
+//
+//   Essence Version : 2.1.18
+//   Checksum 6B87FB5C
+//
+// =============================================================================
+//
+// This file contains the register access for sdmmc
+//
+// =============================================================================
+//
+
+
+/*This file is automatically generated. Do not edit!!*/
+/*lint -e46 -e528 */
+
+#ifndef __SDMMC_HW_REG_H__
+#define __SDMMC_HW_REG_H__
+
+#ifdef SDMMC_REG_INLINE_DISABLED
+  #undef __HWREG_INLINE__
+  #define __HWREG_INLINE__ /*no inline*/
+#elif !defined(__HWREG_INLINE__)
+  #ifdef __GNUC__
+    #define __HWREG_INLINE__ static __inline
+  #else
+    #define __HWREG_INLINE__ static __forceinline
+  #endif
+#endif
+/*****************************************************************************/ 
+/* FUNCTION PROTOTYPES needed by include file emmc_XG631_reg.h               */ 
+/*                                                                           */
+/* Example code follows                                                      */
+/*                                                                           */
+/*****************************************************************************/ 
+/* Function:... Sdmmc_hwreg_assert                                        */
+/* Description: assert function, which is called by register access library  */
+/* functions.                                                                */
+/*****************************************************************************/ 
+
+/*********************** Example code start
+
+void Sdmmc_hwreg_assert(void)
+{
+  sdmmc_error(SDMMC_ERROR_REG_IDX_OUT_OF_RANGE, __LINE__, __FILE__);
+}
+
+************************ Example code end */
+
+/*****************************************************************************/ 
+/* Function:... sdmmc_error                      */
+/* Description: causes a trap with the trap number error_code.               */
+/*****************************************************************************/ 
+
+/*********************** Example code start
+
+void sdmmc_error(T_SDMMC_ERROR error_code, U32 line, S8* filename)
+{
+  U16 size;
+
+  if (error_code >= sizeof(sdmmc_error_name)/sizeof(char*))
+  {
+    size = strlen(sdmmc_error_name[0]);
+    trap_generate_sw_trap((U16)error_code, size + 1, (void*) sdmmc_error_name[0], line, filename );
+  }
+
+  sdmmc.error_code = error_code;
+  size = strlen(sdmmc_error_name[error_code]);
+  trap_generate_sw_trap((U16)error_code, size + 1, (void*) sdmmc_error_name[error_code], line, filename );
+}
+
+************************ Example code end */
+
+/*****************************************************************************/ 
+
+void Sdmmc_hwreg_assert(void);
+
+typedef struct _sSdmmc sSdmmc;
+
+#if defined(__arm)
+#pragma arm section zidata = "SDMMC1_REG"
+#endif // #if defined(__arm)
+extern volatile struct _sSdmmc sdmmc1;
+#if defined(__arm)
+#pragma arm section zidata
+#endif // #if defined(__arm)
+
+#if defined(__arm)
+#pragma arm section zidata = "SDMMC2_REG"
+#endif // #if defined(__arm)
+extern volatile struct _sSdmmc sdmmc2;
+#if defined(__arm)
+#pragma arm section zidata
+#endif // #if defined(__arm)
+
+#if defined(__arm)
+#pragma arm section zidata = "SDMMC3_REG"
+#endif // #if defined(__arm)
+extern volatile struct _sSdmmc sdmmc3;
+#if defined(__arm)
+#pragma arm section zidata
+#endif // #if defined(__arm)
+
+#ifdef HWREG_U32
+    #undef HWREG_U32
+#endif
+
+#ifdef HWREG_U16
+    #undef HWREG_U16
+#endif
+
+#ifdef HWREG_U8
+    #undef HWREG_U8
+#endif
+
+#define HWREG_U32 unsigned long
+#define HWREG_U16 unsigned short
+#define HWREG_U8 unsigned char
+
+
+
+/** @brief SDMA_SYSTEM_ADDR register description at address offset 0x0
+  *
+  *  SDMA system address register
+  */
+typedef struct
+{
+    HWREG_U32 SDMA_SYSTEM_ADDR :32; /**<  */
+} sSDMA_SYSTEM_ADDRStructure;
+
+
+/** @brief SDMA_SYSTEM_ADDR Bitfield widths 
+*/
+#define lenSDMA_SYSTEM_ADDR_SDMA_SYSTEM_ADDR 32
+
+typedef enum
+{
+    SDMA_SYSTEM_ADDR_LSB_SDMA_SYSTEM_ADDR = 0
+} eSDMA_SYSTEM_ADDRLsb;
+
+typedef union
+{
+    HWREG_U32 SDMA_SYSTEM_ADDR_Content;
+    sSDMA_SYSTEM_ADDRStructure SDMA_SYSTEM_ADDR_Structure;
+} uSDMA_SYSTEM_ADDR;
+
+__HWREG_INLINE__ void setSdmmc_SDMA_SYSTEM_ADDR(volatile sSdmmc *_sdmmc_, HWREG_U32 value); /** Set complete register SDMA_SYSTEM_ADDR */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_SDMA_SYSTEM_ADDR(volatile sSdmmc *_sdmmc_); /** Get complete register SDMA_SYSTEM_ADDR */
+__HWREG_INLINE__ void setSdmmc_SDMA_SYSTEM_ADDR_SDMA_SYSTEM_ADDR(volatile sSdmmc *_sdmmc_, HWREG_U32 value); /**< Set element SDMA_SYSTEM_ADDR of register SDMA_SYSTEM_ADDR */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_SDMA_SYSTEM_ADDR_SDMA_SYSTEM_ADDR(volatile sSdmmc *_sdmmc_); /**< Get element SDMA_SYSTEM_ADDR of register SDMA_SYSTEM_ADDR */
+
+
+/** @brief BLOCK_SIZE register description at address offset 0x4
+  *
+  *  Block size register
+  */
+typedef struct
+{
+    HWREG_U16 TX_BLOCK_SIZE :12; /**<  */
+    HWREG_U16 HOST_SDMA_BUF_SIZE :3; /**<  */
+    const HWREG_U16 Res0 :1; /**< Reserved bitfield */
+} sBLOCK_SIZEStructure;
+
+
+/** @brief BLOCK_SIZE Bitfield widths 
+*/
+#define lenBLOCK_SIZE_TX_BLOCK_SIZE 12
+#define lenBLOCK_SIZE_HOST_SDMA_BUF_SIZE 3
+
+typedef enum
+{
+    BLOCK_SIZE_LSB_TX_BLOCK_SIZE = 0,
+    BLOCK_SIZE_LSB_HOST_SDMA_BUF_SIZE = 12
+} eBLOCK_SIZELsb;
+
+typedef union
+{
+    HWREG_U16 BLOCK_SIZE_Content;
+    sBLOCK_SIZEStructure BLOCK_SIZE_Structure;
+} uBLOCK_SIZE;
+
+__HWREG_INLINE__ void setSdmmc_BLOCK_SIZE(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /** Set complete register BLOCK_SIZE */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_BLOCK_SIZE(volatile sSdmmc *_sdmmc_); /** Get complete register BLOCK_SIZE */
+__HWREG_INLINE__ void setSdmmc_BLOCK_SIZE_TX_BLOCK_SIZE(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element TX_BLOCK_SIZE of register BLOCK_SIZE */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_BLOCK_SIZE_TX_BLOCK_SIZE(volatile sSdmmc *_sdmmc_); /**< Get element TX_BLOCK_SIZE of register BLOCK_SIZE */
+__HWREG_INLINE__ void setSdmmc_BLOCK_SIZE_HOST_SDMA_BUF_SIZE(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element HOST_SDMA_BUF_SIZE of register BLOCK_SIZE */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_BLOCK_SIZE_HOST_SDMA_BUF_SIZE(volatile sSdmmc *_sdmmc_); /**< Get element HOST_SDMA_BUF_SIZE of register BLOCK_SIZE */
+
+
+/** @brief BLOCK_COUNT register description at address offset 0x6
+  *
+  *  Block count register
+  */
+typedef struct
+{
+    HWREG_U16 BLOCK_COUNT :16; /**<  */
+} sBLOCK_COUNTStructure;
+
+
+/** @brief BLOCK_COUNT Bitfield widths 
+*/
+#define lenBLOCK_COUNT_BLOCK_COUNT 16
+
+typedef enum
+{
+    BLOCK_COUNT_LSB_BLOCK_COUNT = 0
+} eBLOCK_COUNTLsb;
+
+typedef union
+{
+    HWREG_U16 BLOCK_COUNT_Content;
+    sBLOCK_COUNTStructure BLOCK_COUNT_Structure;
+} uBLOCK_COUNT;
+
+__HWREG_INLINE__ void setSdmmc_BLOCK_COUNT(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /** Set complete register BLOCK_COUNT */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_BLOCK_COUNT(volatile sSdmmc *_sdmmc_); /** Get complete register BLOCK_COUNT */
+__HWREG_INLINE__ void setSdmmc_BLOCK_COUNT_BLOCK_COUNT(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element BLOCK_COUNT of register BLOCK_COUNT */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_BLOCK_COUNT_BLOCK_COUNT(volatile sSdmmc *_sdmmc_); /**< Get element BLOCK_COUNT of register BLOCK_COUNT */
+
+
+/** @brief ARGUMENT1 register description at address offset 0x8
+  *
+  *  Argument register
+  */
+typedef struct
+{
+    HWREG_U32 ARGUMENT1 :32; /**<  */
+} sARGUMENT1Structure;
+
+
+/** @brief ARGUMENT1 Bitfield widths 
+*/
+#define lenARGUMENT1_ARGUMENT1 32
+
+typedef enum
+{
+    ARGUMENT1_LSB_ARGUMENT1 = 0
+} eARGUMENT1Lsb;
+
+typedef union
+{
+    HWREG_U32 ARGUMENT1_Content;
+    sARGUMENT1Structure ARGUMENT1_Structure;
+} uARGUMENT1;
+
+__HWREG_INLINE__ void setSdmmc_ARGUMENT1(volatile sSdmmc *_sdmmc_, HWREG_U32 value); /** Set complete register ARGUMENT1 */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_ARGUMENT1(volatile sSdmmc *_sdmmc_); /** Get complete register ARGUMENT1 */
+__HWREG_INLINE__ void setSdmmc_ARGUMENT1_ARGUMENT1(volatile sSdmmc *_sdmmc_, HWREG_U32 value); /**< Set element ARGUMENT1 of register ARGUMENT1 */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_ARGUMENT1_ARGUMENT1(volatile sSdmmc *_sdmmc_); /**< Get element ARGUMENT1 of register ARGUMENT1 */
+
+
+/** @brief TRANSFER_MODE register description at address offset 0xc
+  *
+  *  Transfer mode register
+  */
+typedef struct
+{
+    HWREG_U16 DMA_EN :1; /**<  */
+    HWREG_U16 BLOCK_COUNT_EN :1; /**<  */
+    HWREG_U16 ACMD_EN :2; /**<  */
+    HWREG_U16 TX_DIR_SELECT :1; /**<  */
+    HWREG_U16 MULTI_BLOCK_SELECT :1; /**<  */
+    HWREG_U16 CMD_COMP_ATA :1; /**<  */
+    const HWREG_U16 :9; /**< Unused bitfield */
+} sTRANSFER_MODEStructure;
+
+
+/** @brief TRANSFER_MODE Bitfield widths 
+*/
+#define lenTRANSFER_MODE_DMA_EN 1
+#define lenTRANSFER_MODE_BLOCK_COUNT_EN 1
+#define lenTRANSFER_MODE_ACMD_EN 2
+#define lenTRANSFER_MODE_TX_DIR_SELECT 1
+#define lenTRANSFER_MODE_MULTI_BLOCK_SELECT 1
+#define lenTRANSFER_MODE_CMD_COMP_ATA 1
+
+typedef enum
+{
+    TRANSFER_MODE_LSB_DMA_EN = 0,
+    TRANSFER_MODE_LSB_BLOCK_COUNT_EN = 1,
+    TRANSFER_MODE_LSB_ACMD_EN = 2,
+    TRANSFER_MODE_LSB_TX_DIR_SELECT = 4,
+    TRANSFER_MODE_LSB_MULTI_BLOCK_SELECT = 5,
+    TRANSFER_MODE_LSB_CMD_COMP_ATA = 6
+} eTRANSFER_MODELsb;
+
+typedef union
+{
+    HWREG_U16 TRANSFER_MODE_Content;
+    sTRANSFER_MODEStructure TRANSFER_MODE_Structure;
+} uTRANSFER_MODE;
+
+__HWREG_INLINE__ void setSdmmc_TRANSFER_MODE(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /** Set complete register TRANSFER_MODE */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_TRANSFER_MODE(volatile sSdmmc *_sdmmc_); /** Get complete register TRANSFER_MODE */
+__HWREG_INLINE__ void setSdmmc_TRANSFER_MODE_DMA_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element DMA_EN of register TRANSFER_MODE */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_TRANSFER_MODE_DMA_EN(volatile sSdmmc *_sdmmc_); /**< Get element DMA_EN of register TRANSFER_MODE */
+__HWREG_INLINE__ void setSdmmc_TRANSFER_MODE_BLOCK_COUNT_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element BLOCK_COUNT_EN of register TRANSFER_MODE */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_TRANSFER_MODE_BLOCK_COUNT_EN(volatile sSdmmc *_sdmmc_); /**< Get element BLOCK_COUNT_EN of register TRANSFER_MODE */
+__HWREG_INLINE__ void setSdmmc_TRANSFER_MODE_ACMD_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element ACMD_EN of register TRANSFER_MODE */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_TRANSFER_MODE_ACMD_EN(volatile sSdmmc *_sdmmc_); /**< Get element ACMD_EN of register TRANSFER_MODE */
+__HWREG_INLINE__ void setSdmmc_TRANSFER_MODE_TX_DIR_SELECT(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element TX_DIR_SELECT of register TRANSFER_MODE */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_TRANSFER_MODE_TX_DIR_SELECT(volatile sSdmmc *_sdmmc_); /**< Get element TX_DIR_SELECT of register TRANSFER_MODE */
+__HWREG_INLINE__ void setSdmmc_TRANSFER_MODE_MULTI_BLOCK_SELECT(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element MULTI_BLOCK_SELECT of register TRANSFER_MODE */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_TRANSFER_MODE_MULTI_BLOCK_SELECT(volatile sSdmmc *_sdmmc_); /**< Get element MULTI_BLOCK_SELECT of register TRANSFER_MODE */
+__HWREG_INLINE__ void setSdmmc_TRANSFER_MODE_CMD_COMP_ATA(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element CMD_COMP_ATA of register TRANSFER_MODE */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_TRANSFER_MODE_CMD_COMP_ATA(volatile sSdmmc *_sdmmc_); /**< Get element CMD_COMP_ATA of register TRANSFER_MODE */
+
+
+/** @brief COMMAND register description at address offset 0xe
+  *
+  *  SD Command register
+  */
+typedef struct
+{
+    HWREG_U16 RESP_TYPE_SELECT :2; /**<  */
+    const HWREG_U16 :1; /**< Unused bitfield */
+    HWREG_U16 CMD_CRC_CHECK_EN :1; /**<  */
+    HWREG_U16 CMD_IND_CHECK_EN :1; /**<  */
+    HWREG_U16 DATA_PRESENT_SELECT :1; /**<  */
+    HWREG_U16 CMD_TYPE :2; /**<  */
+    HWREG_U16 CMD_IND :6; /**<  */
+    const HWREG_U16 :2; /**< Unused bitfield */
+} sCOMMANDStructure;
+
+
+/** @brief COMMAND Bitfield widths 
+*/
+#define lenCOMMAND_RESP_TYPE_SELECT 2
+#define lenCOMMAND_CMD_CRC_CHECK_EN 1
+#define lenCOMMAND_CMD_IND_CHECK_EN 1
+#define lenCOMMAND_DATA_PRESENT_SELECT 1
+#define lenCOMMAND_CMD_TYPE 2
+#define lenCOMMAND_CMD_IND 6
+
+typedef enum
+{
+    COMMAND_LSB_RESP_TYPE_SELECT = 0,
+    COMMAND_LSB_CMD_CRC_CHECK_EN = 3,
+    COMMAND_LSB_CMD_IND_CHECK_EN = 4,
+    COMMAND_LSB_DATA_PRESENT_SELECT = 5,
+    COMMAND_LSB_CMD_TYPE = 6,
+    COMMAND_LSB_CMD_IND = 8
+} eCOMMANDLsb;
+
+typedef union
+{
+    HWREG_U16 COMMAND_Content;
+    sCOMMANDStructure COMMAND_Structure;
+} uCOMMAND;
+
+__HWREG_INLINE__ void setSdmmc_COMMAND(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /** Set complete register COMMAND */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_COMMAND(volatile sSdmmc *_sdmmc_); /** Get complete register COMMAND */
+__HWREG_INLINE__ void setSdmmc_COMMAND_RESP_TYPE_SELECT(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element RESP_TYPE_SELECT of register COMMAND */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_COMMAND_RESP_TYPE_SELECT(volatile sSdmmc *_sdmmc_); /**< Get element RESP_TYPE_SELECT of register COMMAND */
+__HWREG_INLINE__ void setSdmmc_COMMAND_CMD_CRC_CHECK_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element CMD_CRC_CHECK_EN of register COMMAND */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_COMMAND_CMD_CRC_CHECK_EN(volatile sSdmmc *_sdmmc_); /**< Get element CMD_CRC_CHECK_EN of register COMMAND */
+__HWREG_INLINE__ void setSdmmc_COMMAND_CMD_IND_CHECK_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element CMD_IND_CHECK_EN of register COMMAND */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_COMMAND_CMD_IND_CHECK_EN(volatile sSdmmc *_sdmmc_); /**< Get element CMD_IND_CHECK_EN of register COMMAND */
+__HWREG_INLINE__ void setSdmmc_COMMAND_DATA_PRESENT_SELECT(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element DATA_PRESENT_SELECT of register COMMAND */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_COMMAND_DATA_PRESENT_SELECT(volatile sSdmmc *_sdmmc_); /**< Get element DATA_PRESENT_SELECT of register COMMAND */
+__HWREG_INLINE__ void setSdmmc_COMMAND_CMD_TYPE(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element CMD_TYPE of register COMMAND */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_COMMAND_CMD_TYPE(volatile sSdmmc *_sdmmc_); /**< Get element CMD_TYPE of register COMMAND */
+__HWREG_INLINE__ void setSdmmc_COMMAND_CMD_IND(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element CMD_IND of register COMMAND */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_COMMAND_CMD_IND(volatile sSdmmc *_sdmmc_); /**< Get element CMD_IND of register COMMAND */
+
+
+/** @brief RESPONSE0 register description at address offset 0x10
+  *
+  *  Response 0 register
+  */
+typedef struct
+{
+    const HWREG_U32 RESPONSE0 :16; /**<  */
+    const HWREG_U32 RESPONSE1 :16; /**<  */
+} sRESPONSE0Structure;
+
+
+/** @brief RESPONSE0 Bitfield widths 
+*/
+#define lenRESPONSE0_RESPONSE0 16
+#define lenRESPONSE0_RESPONSE1 16
+
+typedef enum
+{
+    RESPONSE0_LSB_RESPONSE0 = 0,
+    RESPONSE0_LSB_RESPONSE1 = 16
+} eRESPONSE0Lsb;
+
+typedef union
+{
+    HWREG_U32 RESPONSE0_Content;
+    sRESPONSE0Structure RESPONSE0_Structure;
+} uRESPONSE0;
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_RESPONSE0(volatile sSdmmc *_sdmmc_); /** Get complete register RESPONSE0 */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_RESPONSE0_RESPONSE0(volatile sSdmmc *_sdmmc_); /**< Get element RESPONSE0 of register RESPONSE0 */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_RESPONSE0_RESPONSE1(volatile sSdmmc *_sdmmc_); /**< Get element RESPONSE1 of register RESPONSE0 */
+
+
+/** @brief RESPONSE2 register description at address offset 0x14
+  *
+  *  Response 2 register
+  */
+typedef struct
+{
+    const HWREG_U32 RESPONSE2 :16; /**<  */
+    const HWREG_U32 RESPONSE3 :16; /**<  */
+} sRESPONSE2Structure;
+
+
+/** @brief RESPONSE2 Bitfield widths 
+*/
+#define lenRESPONSE2_RESPONSE2 16
+#define lenRESPONSE2_RESPONSE3 16
+
+typedef enum
+{
+    RESPONSE2_LSB_RESPONSE2 = 0,
+    RESPONSE2_LSB_RESPONSE3 = 16
+} eRESPONSE2Lsb;
+
+typedef union
+{
+    HWREG_U32 RESPONSE2_Content;
+    sRESPONSE2Structure RESPONSE2_Structure;
+} uRESPONSE2;
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_RESPONSE2(volatile sSdmmc *_sdmmc_); /** Get complete register RESPONSE2 */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_RESPONSE2_RESPONSE2(volatile sSdmmc *_sdmmc_); /**< Get element RESPONSE2 of register RESPONSE2 */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_RESPONSE2_RESPONSE3(volatile sSdmmc *_sdmmc_); /**< Get element RESPONSE3 of register RESPONSE2 */
+
+
+/** @brief RESPONSE4 register description at address offset 0x18
+  *
+  *  Response 4 register
+  */
+typedef struct
+{
+    const HWREG_U32 RESPONSE4 :16; /**<  */
+    const HWREG_U32 RESPONSE5 :16; /**<  */
+} sRESPONSE4Structure;
+
+
+/** @brief RESPONSE4 Bitfield widths 
+*/
+#define lenRESPONSE4_RESPONSE4 16
+#define lenRESPONSE4_RESPONSE5 16
+
+typedef enum
+{
+    RESPONSE4_LSB_RESPONSE4 = 0,
+    RESPONSE4_LSB_RESPONSE5 = 16
+} eRESPONSE4Lsb;
+
+typedef union
+{
+    HWREG_U32 RESPONSE4_Content;
+    sRESPONSE4Structure RESPONSE4_Structure;
+} uRESPONSE4;
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_RESPONSE4(volatile sSdmmc *_sdmmc_); /** Get complete register RESPONSE4 */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_RESPONSE4_RESPONSE4(volatile sSdmmc *_sdmmc_); /**< Get element RESPONSE4 of register RESPONSE4 */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_RESPONSE4_RESPONSE5(volatile sSdmmc *_sdmmc_); /**< Get element RESPONSE5 of register RESPONSE4 */
+
+
+/** @brief RESPONSE6 register description at address offset 0x1c
+  *
+  *  Response 6 register
+  */
+typedef struct
+{
+    const HWREG_U32 RESPONSE6 :16; /**<  */
+    const HWREG_U32 RESPONSE7 :16; /**<  */
+} sRESPONSE6Structure;
+
+
+/** @brief RESPONSE6 Bitfield widths 
+*/
+#define lenRESPONSE6_RESPONSE6 16
+#define lenRESPONSE6_RESPONSE7 16
+
+typedef enum
+{
+    RESPONSE6_LSB_RESPONSE6 = 0,
+    RESPONSE6_LSB_RESPONSE7 = 16
+} eRESPONSE6Lsb;
+
+typedef union
+{
+    HWREG_U32 RESPONSE6_Content;
+    sRESPONSE6Structure RESPONSE6_Structure;
+} uRESPONSE6;
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_RESPONSE6(volatile sSdmmc *_sdmmc_); /** Get complete register RESPONSE6 */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_RESPONSE6_RESPONSE6(volatile sSdmmc *_sdmmc_); /**< Get element RESPONSE6 of register RESPONSE6 */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_RESPONSE6_RESPONSE7(volatile sSdmmc *_sdmmc_); /**< Get element RESPONSE7 of register RESPONSE6 */
+
+
+/** @brief DATA_BUFFER register description at address offset 0x20
+  *
+  *  Data buffer register
+  */
+typedef struct
+{
+    HWREG_U32 DATA_BUFFER :32; /**<  */
+} sDATA_BUFFERStructure;
+
+
+/** @brief DATA_BUFFER Bitfield widths 
+*/
+#define lenDATA_BUFFER_DATA_BUFFER 32
+
+typedef enum
+{
+    DATA_BUFFER_LSB_DATA_BUFFER = 0
+} eDATA_BUFFERLsb;
+
+typedef union
+{
+    HWREG_U32 DATA_BUFFER_Content;
+    sDATA_BUFFERStructure DATA_BUFFER_Structure;
+} uDATA_BUFFER;
+
+__HWREG_INLINE__ void setSdmmc_DATA_BUFFER(volatile sSdmmc *_sdmmc_, HWREG_U32 value); /** Set complete register DATA_BUFFER */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_DATA_BUFFER(volatile sSdmmc *_sdmmc_); /** Get complete register DATA_BUFFER */
+__HWREG_INLINE__ void setSdmmc_DATA_BUFFER_DATA_BUFFER(volatile sSdmmc *_sdmmc_, HWREG_U32 value); /**< Set element DATA_BUFFER of register DATA_BUFFER */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_DATA_BUFFER_DATA_BUFFER(volatile sSdmmc *_sdmmc_); /**< Get element DATA_BUFFER of register DATA_BUFFER */
+
+
+/** @brief PRESENT_STATE register description at address offset 0x24
+  *
+  *  Present state register
+  */
+typedef struct
+{
+    const HWREG_U32 COMMAND_INHIBIT_CMD :1; /**<  */
+    const HWREG_U32 COMMAND_INHIBIT_DAT :1; /**<  */
+    const HWREG_U32 DAT_LINE_ACTIVE :1; /**<  */
+    const HWREG_U32 RETUNING_REQUEST :1; /**<  */
+    const HWREG_U32 Res0 :4; /**< Reserved bitfield */
+    const HWREG_U32 WRITE_TRANSFER_ACTIVE :1; /**<  */
+    const HWREG_U32 READ_TRANSFER_ACTIVE :1; /**<  */
+    const HWREG_U32 BUFFER_WRITE_ENABLE :1; /**<  */
+    const HWREG_U32 BUFFER_READ_ENABLE :1; /**<  */
+    const HWREG_U32 Res1 :4; /**< Reserved bitfield */
+    const HWREG_U32 CARD_INSERTED :1; /**<  */
+    const HWREG_U32 CARD_STATE_STABLE :1; /**<  */
+    const HWREG_U32 CARD_DETECT_PIN_LEVEL :1; /**<  */
+    const HWREG_U32 WRITE_PROTECT_PIN_LEVEL :1; /**<  */
+    const HWREG_U32 DAT_3_0_PIN_LEVEL :4; /**<  */
+    const HWREG_U32 CMD_LINE_LEVEL :1; /**<  */
+    const HWREG_U32 DAT_7_4_PIN_LEVEL :4; /**<  */
+    const HWREG_U32 Res2 :3; /**< Reserved bitfield */
+} sPRESENT_STATEStructure;
+
+
+/** @brief PRESENT_STATE Bitfield widths 
+*/
+#define lenPRESENT_STATE_COMMAND_INHIBIT_CMD 1
+#define lenPRESENT_STATE_COMMAND_INHIBIT_DAT 1
+#define lenPRESENT_STATE_DAT_LINE_ACTIVE 1
+#define lenPRESENT_STATE_RETUNING_REQUEST 1
+#define lenPRESENT_STATE_WRITE_TRANSFER_ACTIVE 1
+#define lenPRESENT_STATE_READ_TRANSFER_ACTIVE 1
+#define lenPRESENT_STATE_BUFFER_WRITE_ENABLE 1
+#define lenPRESENT_STATE_BUFFER_READ_ENABLE 1
+#define lenPRESENT_STATE_CARD_INSERTED 1
+#define lenPRESENT_STATE_CARD_STATE_STABLE 1
+#define lenPRESENT_STATE_CARD_DETECT_PIN_LEVEL 1
+#define lenPRESENT_STATE_WRITE_PROTECT_PIN_LEVEL 1
+#define lenPRESENT_STATE_DAT_3_0_PIN_LEVEL 4
+#define lenPRESENT_STATE_CMD_LINE_LEVEL 1
+#define lenPRESENT_STATE_DAT_7_4_PIN_LEVEL 4
+
+typedef enum
+{
+    PRESENT_STATE_LSB_COMMAND_INHIBIT_CMD = 0,
+    PRESENT_STATE_LSB_COMMAND_INHIBIT_DAT = 1,
+    PRESENT_STATE_LSB_DAT_LINE_ACTIVE = 2,
+    PRESENT_STATE_LSB_RETUNING_REQUEST = 3,
+    PRESENT_STATE_LSB_WRITE_TRANSFER_ACTIVE = 8,
+    PRESENT_STATE_LSB_READ_TRANSFER_ACTIVE = 9,
+    PRESENT_STATE_LSB_BUFFER_WRITE_ENABLE = 10,
+    PRESENT_STATE_LSB_BUFFER_READ_ENABLE = 11,
+    PRESENT_STATE_LSB_CARD_INSERTED = 16,
+    PRESENT_STATE_LSB_CARD_STATE_STABLE = 17,
+    PRESENT_STATE_LSB_CARD_DETECT_PIN_LEVEL = 18,
+    PRESENT_STATE_LSB_WRITE_PROTECT_PIN_LEVEL = 19,
+    PRESENT_STATE_LSB_DAT_3_0_PIN_LEVEL = 20,
+    PRESENT_STATE_LSB_CMD_LINE_LEVEL = 24,
+    PRESENT_STATE_LSB_DAT_7_4_PIN_LEVEL = 25
+} ePRESENT_STATELsb;
+
+typedef union
+{
+    HWREG_U32 PRESENT_STATE_Content;
+    sPRESENT_STATEStructure PRESENT_STATE_Structure;
+} uPRESENT_STATE;
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_PRESENT_STATE(volatile sSdmmc *_sdmmc_); /** Get complete register PRESENT_STATE */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_PRESENT_STATE_COMMAND_INHIBIT_CMD(volatile sSdmmc *_sdmmc_); /**< Get element COMMAND_INHIBIT_CMD of register PRESENT_STATE */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_PRESENT_STATE_COMMAND_INHIBIT_DAT(volatile sSdmmc *_sdmmc_); /**< Get element COMMAND_INHIBIT_DAT of register PRESENT_STATE */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_PRESENT_STATE_DAT_LINE_ACTIVE(volatile sSdmmc *_sdmmc_); /**< Get element DAT_LINE_ACTIVE of register PRESENT_STATE */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_PRESENT_STATE_RETUNING_REQUEST(volatile sSdmmc *_sdmmc_); /**< Get element RETUNING_REQUEST of register PRESENT_STATE */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_PRESENT_STATE_WRITE_TRANSFER_ACTIVE(volatile sSdmmc *_sdmmc_); /**< Get element WRITE_TRANSFER_ACTIVE of register PRESENT_STATE */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_PRESENT_STATE_READ_TRANSFER_ACTIVE(volatile sSdmmc *_sdmmc_); /**< Get element READ_TRANSFER_ACTIVE of register PRESENT_STATE */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_PRESENT_STATE_BUFFER_WRITE_ENABLE(volatile sSdmmc *_sdmmc_); /**< Get element BUFFER_WRITE_ENABLE of register PRESENT_STATE */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_PRESENT_STATE_BUFFER_READ_ENABLE(volatile sSdmmc *_sdmmc_); /**< Get element BUFFER_READ_ENABLE of register PRESENT_STATE */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_PRESENT_STATE_CARD_INSERTED(volatile sSdmmc *_sdmmc_); /**< Get element CARD_INSERTED of register PRESENT_STATE */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_PRESENT_STATE_CARD_STATE_STABLE(volatile sSdmmc *_sdmmc_); /**< Get element CARD_STATE_STABLE of register PRESENT_STATE */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_PRESENT_STATE_CARD_DETECT_PIN_LEVEL(volatile sSdmmc *_sdmmc_); /**< Get element CARD_DETECT_PIN_LEVEL of register PRESENT_STATE */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_PRESENT_STATE_WRITE_PROTECT_PIN_LEVEL(volatile sSdmmc *_sdmmc_); /**< Get element WRITE_PROTECT_PIN_LEVEL of register PRESENT_STATE */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_PRESENT_STATE_DAT_3_0_PIN_LEVEL(volatile sSdmmc *_sdmmc_); /**< Get element DAT_3_0_PIN_LEVEL of register PRESENT_STATE */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_PRESENT_STATE_CMD_LINE_LEVEL(volatile sSdmmc *_sdmmc_); /**< Get element CMD_LINE_LEVEL of register PRESENT_STATE */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_PRESENT_STATE_DAT_7_4_PIN_LEVEL(volatile sSdmmc *_sdmmc_); /**< Get element DAT_7_4_PIN_LEVEL of register PRESENT_STATE */
+
+
+/** @brief HOST_CTRL register description at address offset 0x28
+  *
+  *  Host control register
+  */
+typedef struct
+{
+    HWREG_U8 LED_CTRL :1; /**<  */
+    HWREG_U8 DATA_TX_WIDTH :1; /**<  */
+    HWREG_U8 HIGH_SPEED_EN :1; /**<  */
+    HWREG_U8 DMA_SELECT :2; /**<  */
+    HWREG_U8 SD_8BIT_MODE :1; /**<  */
+    HWREG_U8 CARD_DETECT_TEST_LEVEL :1; /**<  */
+    HWREG_U8 CARD_DET_SIGNAL_DETECT :1; /**<  */
+} sHOST_CTRLStructure;
+
+
+/** @brief HOST_CTRL Bitfield widths 
+*/
+#define lenHOST_CTRL_LED_CTRL 1
+#define lenHOST_CTRL_DATA_TX_WIDTH 1
+#define lenHOST_CTRL_HIGH_SPEED_EN 1
+#define lenHOST_CTRL_DMA_SELECT 2
+#define lenHOST_CTRL_SD_8BIT_MODE 1
+#define lenHOST_CTRL_CARD_DETECT_TEST_LEVEL 1
+#define lenHOST_CTRL_CARD_DET_SIGNAL_DETECT 1
+
+typedef enum
+{
+    HOST_CTRL_LSB_LED_CTRL = 0,
+    HOST_CTRL_LSB_DATA_TX_WIDTH = 1,
+    HOST_CTRL_LSB_HIGH_SPEED_EN = 2,
+    HOST_CTRL_LSB_DMA_SELECT = 3,
+    HOST_CTRL_LSB_SD_8BIT_MODE = 5,
+    HOST_CTRL_LSB_CARD_DETECT_TEST_LEVEL = 6,
+    HOST_CTRL_LSB_CARD_DET_SIGNAL_DETECT = 7
+} eHOST_CTRLLsb;
+
+typedef union
+{
+    HWREG_U8 HOST_CTRL_Content;
+    sHOST_CTRLStructure HOST_CTRL_Structure;
+} uHOST_CTRL;
+
+__HWREG_INLINE__ void setSdmmc_HOST_CTRL(volatile sSdmmc *_sdmmc_, HWREG_U8 value); /** Set complete register HOST_CTRL */
+__HWREG_INLINE__ HWREG_U8 getSdmmc_HOST_CTRL(volatile sSdmmc *_sdmmc_); /** Get complete register HOST_CTRL */
+__HWREG_INLINE__ void setSdmmc_HOST_CTRL_LED_CTRL(volatile sSdmmc *_sdmmc_, HWREG_U8 value); /**< Set element LED_CTRL of register HOST_CTRL */
+__HWREG_INLINE__ HWREG_U8 getSdmmc_HOST_CTRL_LED_CTRL(volatile sSdmmc *_sdmmc_); /**< Get element LED_CTRL of register HOST_CTRL */
+__HWREG_INLINE__ void setSdmmc_HOST_CTRL_DATA_TX_WIDTH(volatile sSdmmc *_sdmmc_, HWREG_U8 value); /**< Set element DATA_TX_WIDTH of register HOST_CTRL */
+__HWREG_INLINE__ HWREG_U8 getSdmmc_HOST_CTRL_DATA_TX_WIDTH(volatile sSdmmc *_sdmmc_); /**< Get element DATA_TX_WIDTH of register HOST_CTRL */
+__HWREG_INLINE__ void setSdmmc_HOST_CTRL_HIGH_SPEED_EN(volatile sSdmmc *_sdmmc_, HWREG_U8 value); /**< Set element HIGH_SPEED_EN of register HOST_CTRL */
+__HWREG_INLINE__ HWREG_U8 getSdmmc_HOST_CTRL_HIGH_SPEED_EN(volatile sSdmmc *_sdmmc_); /**< Get element HIGH_SPEED_EN of register HOST_CTRL */
+__HWREG_INLINE__ void setSdmmc_HOST_CTRL_DMA_SELECT(volatile sSdmmc *_sdmmc_, HWREG_U8 value); /**< Set element DMA_SELECT of register HOST_CTRL */
+__HWREG_INLINE__ HWREG_U8 getSdmmc_HOST_CTRL_DMA_SELECT(volatile sSdmmc *_sdmmc_); /**< Get element DMA_SELECT of register HOST_CTRL */
+__HWREG_INLINE__ void setSdmmc_HOST_CTRL_SD_8BIT_MODE(volatile sSdmmc *_sdmmc_, HWREG_U8 value); /**< Set element SD_8BIT_MODE of register HOST_CTRL */
+__HWREG_INLINE__ HWREG_U8 getSdmmc_HOST_CTRL_SD_8BIT_MODE(volatile sSdmmc *_sdmmc_); /**< Get element SD_8BIT_MODE of register HOST_CTRL */
+__HWREG_INLINE__ void setSdmmc_HOST_CTRL_CARD_DETECT_TEST_LEVEL(volatile sSdmmc *_sdmmc_, HWREG_U8 value); /**< Set element CARD_DETECT_TEST_LEVEL of register HOST_CTRL */
+__HWREG_INLINE__ HWREG_U8 getSdmmc_HOST_CTRL_CARD_DETECT_TEST_LEVEL(volatile sSdmmc *_sdmmc_); /**< Get element CARD_DETECT_TEST_LEVEL of register HOST_CTRL */
+__HWREG_INLINE__ void setSdmmc_HOST_CTRL_CARD_DET_SIGNAL_DETECT(volatile sSdmmc *_sdmmc_, HWREG_U8 value); /**< Set element CARD_DET_SIGNAL_DETECT of register HOST_CTRL */
+__HWREG_INLINE__ HWREG_U8 getSdmmc_HOST_CTRL_CARD_DET_SIGNAL_DETECT(volatile sSdmmc *_sdmmc_); /**< Get element CARD_DET_SIGNAL_DETECT of register HOST_CTRL */
+
+
+/** @brief POWER_CTRL register description at address offset 0x29
+  *
+  *  power control register
+  */
+typedef struct
+{
+    HWREG_U8 SD_BUS_POWER :1; /**<  */
+    HWREG_U8 SD_BUS_VOLTAGE_SEL :3; /**<  */
+    HWREG_U8 HARDWARE_RESET :1; /**<  */
+    const HWREG_U8 Res3 :3; /**<  */
+} sPOWER_CTRLStructure;
+
+
+/** @brief POWER_CTRL Bitfield widths 
+*/
+#define lenPOWER_CTRL_SD_BUS_POWER 1
+#define lenPOWER_CTRL_SD_BUS_VOLTAGE_SEL 3
+#define lenPOWER_CTRL_HARDWARE_RESET 1
+#define lenPOWER_CTRL_RES3 3
+
+typedef enum
+{
+    POWER_CTRL_LSB_SD_BUS_POWER = 0,
+    POWER_CTRL_LSB_SD_BUS_VOLTAGE_SEL = 1,
+    POWER_CTRL_LSB_HARDWARE_RESET = 4,
+    POWER_CTRL_LSB_RES3 = 5
+} ePOWER_CTRLLsb;
+
+typedef union
+{
+    HWREG_U8 POWER_CTRL_Content;
+    sPOWER_CTRLStructure POWER_CTRL_Structure;
+} uPOWER_CTRL;
+
+__HWREG_INLINE__ void setSdmmc_POWER_CTRL(volatile sSdmmc *_sdmmc_, HWREG_U8 value); /** Set complete register POWER_CTRL */
+__HWREG_INLINE__ HWREG_U8 getSdmmc_POWER_CTRL(volatile sSdmmc *_sdmmc_); /** Get complete register POWER_CTRL */
+__HWREG_INLINE__ void setSdmmc_POWER_CTRL_SD_BUS_POWER(volatile sSdmmc *_sdmmc_, HWREG_U8 value); /**< Set element SD_BUS_POWER of register POWER_CTRL */
+__HWREG_INLINE__ HWREG_U8 getSdmmc_POWER_CTRL_SD_BUS_POWER(volatile sSdmmc *_sdmmc_); /**< Get element SD_BUS_POWER of register POWER_CTRL */
+__HWREG_INLINE__ void setSdmmc_POWER_CTRL_SD_BUS_VOLTAGE_SEL(volatile sSdmmc *_sdmmc_, HWREG_U8 value); /**< Set element SD_BUS_VOLTAGE_SEL of register POWER_CTRL */
+__HWREG_INLINE__ HWREG_U8 getSdmmc_POWER_CTRL_SD_BUS_VOLTAGE_SEL(volatile sSdmmc *_sdmmc_); /**< Get element SD_BUS_VOLTAGE_SEL of register POWER_CTRL */
+__HWREG_INLINE__ void setSdmmc_POWER_CTRL_HARDWARE_RESET(volatile sSdmmc *_sdmmc_, HWREG_U8 value); /**< Set element HARDWARE_RESET of register POWER_CTRL */
+__HWREG_INLINE__ HWREG_U8 getSdmmc_POWER_CTRL_HARDWARE_RESET(volatile sSdmmc *_sdmmc_); /**< Get element HARDWARE_RESET of register POWER_CTRL */
+__HWREG_INLINE__ HWREG_U8 getSdmmc_POWER_CTRL_Res3(volatile sSdmmc *_sdmmc_); /**< Get element Res3 of register POWER_CTRL */
+
+
+/** @brief BLOCK_GAP_CTRL register description at address offset 0x2a
+  *
+  *  block gap control register
+  */
+typedef struct
+{
+    HWREG_U8 STOP_AT_BLOCK_GAP :1; /**<  */
+    const HWREG_U8 CONTINUE_REQ :1; /**<  */
+    HWREG_U8 READ_WAIT_CTRL :1; /**<  */
+    HWREG_U8 INT_AT_BLOCK_GAP :1; /**<  */
+    HWREG_U8 SPI_MODE :1; /**<  */
+    HWREG_U8 BOOT_EN :1; /**<  */
+    HWREG_U8 ALT_BOOT_EN :1; /**<  */
+    HWREG_U8 BOOT_ACK_CHK :1; /**<  */
+} sBLOCK_GAP_CTRLStructure;
+
+
+/** @brief BLOCK_GAP_CTRL Bitfield widths 
+*/
+#define lenBLOCK_GAP_CTRL_STOP_AT_BLOCK_GAP 1
+#define lenBLOCK_GAP_CTRL_CONTINUE_REQ 1
+#define lenBLOCK_GAP_CTRL_READ_WAIT_CTRL 1
+#define lenBLOCK_GAP_CTRL_INT_AT_BLOCK_GAP 1
+#define lenBLOCK_GAP_CTRL_SPI_MODE 1
+#define lenBLOCK_GAP_CTRL_BOOT_EN 1
+#define lenBLOCK_GAP_CTRL_ALT_BOOT_EN 1
+#define lenBLOCK_GAP_CTRL_BOOT_ACK_CHK 1
+
+typedef enum
+{
+    BLOCK_GAP_CTRL_LSB_STOP_AT_BLOCK_GAP = 0,
+    BLOCK_GAP_CTRL_LSB_CONTINUE_REQ = 1,
+    BLOCK_GAP_CTRL_LSB_READ_WAIT_CTRL = 2,
+    BLOCK_GAP_CTRL_LSB_INT_AT_BLOCK_GAP = 3,
+    BLOCK_GAP_CTRL_LSB_SPI_MODE = 4,
+    BLOCK_GAP_CTRL_LSB_BOOT_EN = 5,
+    BLOCK_GAP_CTRL_LSB_ALT_BOOT_EN = 6,
+    BLOCK_GAP_CTRL_LSB_BOOT_ACK_CHK = 7
+} eBLOCK_GAP_CTRLLsb;
+
+typedef union
+{
+    HWREG_U8 BLOCK_GAP_CTRL_Content;
+    sBLOCK_GAP_CTRLStructure BLOCK_GAP_CTRL_Structure;
+} uBLOCK_GAP_CTRL;
+
+typedef enum
+{
+    BLOCK_GAP_CTRL_BOOT_ACK_CHK_DIRECT = 0,
+    BLOCK_GAP_CTRL_BOOT_ACK_CHK_WAIT4ACK = 1
+} eBLOCK_GAP_CTRL_BOOT_ACK_CHK;
+
+__HWREG_INLINE__ void setSdmmc_BLOCK_GAP_CTRL(volatile sSdmmc *_sdmmc_, HWREG_U8 value); /** Set complete register BLOCK_GAP_CTRL */
+__HWREG_INLINE__ HWREG_U8 getSdmmc_BLOCK_GAP_CTRL(volatile sSdmmc *_sdmmc_); /** Get complete register BLOCK_GAP_CTRL */
+__HWREG_INLINE__ void setSdmmc_BLOCK_GAP_CTRL_STOP_AT_BLOCK_GAP(volatile sSdmmc *_sdmmc_, HWREG_U8 value); /**< Set element STOP_AT_BLOCK_GAP of register BLOCK_GAP_CTRL */
+__HWREG_INLINE__ HWREG_U8 getSdmmc_BLOCK_GAP_CTRL_STOP_AT_BLOCK_GAP(volatile sSdmmc *_sdmmc_); /**< Get element STOP_AT_BLOCK_GAP of register BLOCK_GAP_CTRL */
+__HWREG_INLINE__ HWREG_U8 getSdmmc_BLOCK_GAP_CTRL_CONTINUE_REQ(volatile sSdmmc *_sdmmc_); /**< Get element CONTINUE_REQ of register BLOCK_GAP_CTRL */
+__HWREG_INLINE__ void setSdmmc_BLOCK_GAP_CTRL_READ_WAIT_CTRL(volatile sSdmmc *_sdmmc_, HWREG_U8 value); /**< Set element READ_WAIT_CTRL of register BLOCK_GAP_CTRL */
+__HWREG_INLINE__ HWREG_U8 getSdmmc_BLOCK_GAP_CTRL_READ_WAIT_CTRL(volatile sSdmmc *_sdmmc_); /**< Get element READ_WAIT_CTRL of register BLOCK_GAP_CTRL */
+__HWREG_INLINE__ void setSdmmc_BLOCK_GAP_CTRL_INT_AT_BLOCK_GAP(volatile sSdmmc *_sdmmc_, HWREG_U8 value); /**< Set element INT_AT_BLOCK_GAP of register BLOCK_GAP_CTRL */
+__HWREG_INLINE__ HWREG_U8 getSdmmc_BLOCK_GAP_CTRL_INT_AT_BLOCK_GAP(volatile sSdmmc *_sdmmc_); /**< Get element INT_AT_BLOCK_GAP of register BLOCK_GAP_CTRL */
+__HWREG_INLINE__ void setSdmmc_BLOCK_GAP_CTRL_SPI_MODE(volatile sSdmmc *_sdmmc_, HWREG_U8 value); /**< Set element SPI_MODE of register BLOCK_GAP_CTRL */
+__HWREG_INLINE__ HWREG_U8 getSdmmc_BLOCK_GAP_CTRL_SPI_MODE(volatile sSdmmc *_sdmmc_); /**< Get element SPI_MODE of register BLOCK_GAP_CTRL */
+__HWREG_INLINE__ void setSdmmc_BLOCK_GAP_CTRL_BOOT_EN(volatile sSdmmc *_sdmmc_, HWREG_U8 value); /**< Set element BOOT_EN of register BLOCK_GAP_CTRL */
+__HWREG_INLINE__ HWREG_U8 getSdmmc_BLOCK_GAP_CTRL_BOOT_EN(volatile sSdmmc *_sdmmc_); /**< Get element BOOT_EN of register BLOCK_GAP_CTRL */
+__HWREG_INLINE__ void setSdmmc_BLOCK_GAP_CTRL_ALT_BOOT_EN(volatile sSdmmc *_sdmmc_, HWREG_U8 value); /**< Set element ALT_BOOT_EN of register BLOCK_GAP_CTRL */
+__HWREG_INLINE__ HWREG_U8 getSdmmc_BLOCK_GAP_CTRL_ALT_BOOT_EN(volatile sSdmmc *_sdmmc_); /**< Get element ALT_BOOT_EN of register BLOCK_GAP_CTRL */
+__HWREG_INLINE__ void setSdmmc_BLOCK_GAP_CTRL_BOOT_ACK_CHK(volatile sSdmmc *_sdmmc_, eBLOCK_GAP_CTRL_BOOT_ACK_CHK value); /**< Set element BOOT_ACK_CHK of register BLOCK_GAP_CTRL */
+__HWREG_INLINE__ eBLOCK_GAP_CTRL_BOOT_ACK_CHK getSdmmc_BLOCK_GAP_CTRL_BOOT_ACK_CHK(volatile sSdmmc *_sdmmc_); /**< Get element BOOT_ACK_CHK of register BLOCK_GAP_CTRL */
+
+
+/** @brief WAKEUP_CTRL register description at address offset 0x2b
+  *
+  *  wake-up control register
+  */
+typedef struct
+{
+    HWREG_U8 WAKEUP_EVENT_EN_INT :1; /**<  */
+    HWREG_U8 WAKEUP_EVENT_EN_INS :1; /**<  */
+    HWREG_U8 WAKEUP_EVENT_EN_REM :1; /**<  */
+    const HWREG_U8 Res0 :5; /**< Reserved bitfield */
+} sWAKEUP_CTRLStructure;
+
+
+/** @brief WAKEUP_CTRL Bitfield widths 
+*/
+#define lenWAKEUP_CTRL_WAKEUP_EVENT_EN_INT 1
+#define lenWAKEUP_CTRL_WAKEUP_EVENT_EN_INS 1
+#define lenWAKEUP_CTRL_WAKEUP_EVENT_EN_REM 1
+
+typedef enum
+{
+    WAKEUP_CTRL_LSB_WAKEUP_EVENT_EN_INT = 0,
+    WAKEUP_CTRL_LSB_WAKEUP_EVENT_EN_INS = 1,
+    WAKEUP_CTRL_LSB_WAKEUP_EVENT_EN_REM = 2
+} eWAKEUP_CTRLLsb;
+
+typedef union
+{
+    HWREG_U8 WAKEUP_CTRL_Content;
+    sWAKEUP_CTRLStructure WAKEUP_CTRL_Structure;
+} uWAKEUP_CTRL;
+
+__HWREG_INLINE__ void setSdmmc_WAKEUP_CTRL(volatile sSdmmc *_sdmmc_, HWREG_U8 value); /** Set complete register WAKEUP_CTRL */
+__HWREG_INLINE__ HWREG_U8 getSdmmc_WAKEUP_CTRL(volatile sSdmmc *_sdmmc_); /** Get complete register WAKEUP_CTRL */
+__HWREG_INLINE__ void setSdmmc_WAKEUP_CTRL_WAKEUP_EVENT_EN_INT(volatile sSdmmc *_sdmmc_, HWREG_U8 value); /**< Set element WAKEUP_EVENT_EN_INT of register WAKEUP_CTRL */
+__HWREG_INLINE__ HWREG_U8 getSdmmc_WAKEUP_CTRL_WAKEUP_EVENT_EN_INT(volatile sSdmmc *_sdmmc_); /**< Get element WAKEUP_EVENT_EN_INT of register WAKEUP_CTRL */
+__HWREG_INLINE__ void setSdmmc_WAKEUP_CTRL_WAKEUP_EVENT_EN_INS(volatile sSdmmc *_sdmmc_, HWREG_U8 value); /**< Set element WAKEUP_EVENT_EN_INS of register WAKEUP_CTRL */
+__HWREG_INLINE__ HWREG_U8 getSdmmc_WAKEUP_CTRL_WAKEUP_EVENT_EN_INS(volatile sSdmmc *_sdmmc_); /**< Get element WAKEUP_EVENT_EN_INS of register WAKEUP_CTRL */
+__HWREG_INLINE__ void setSdmmc_WAKEUP_CTRL_WAKEUP_EVENT_EN_REM(volatile sSdmmc *_sdmmc_, HWREG_U8 value); /**< Set element WAKEUP_EVENT_EN_REM of register WAKEUP_CTRL */
+__HWREG_INLINE__ HWREG_U8 getSdmmc_WAKEUP_CTRL_WAKEUP_EVENT_EN_REM(volatile sSdmmc *_sdmmc_); /**< Get element WAKEUP_EVENT_EN_REM of register WAKEUP_CTRL */
+
+
+/** @brief CLOCK_CTRL register description at address offset 0x2c
+  *
+  *  Clock control register
+  */
+typedef struct
+{
+    HWREG_U16 INTERNAL_CLOCK_EN :1; /**<  */
+    const HWREG_U16 INTERNAL_CLOCK_STABLE :1; /**<  */
+    HWREG_U16 SDCLOCK_EN :1; /**<  */
+    const HWREG_U16 Res0 :2; /**< Reserved bitfield */
+    HWREG_U16 CLK_GEN_SEL :1; /**<  */
+    HWREG_U16 SDCLK_FREQ_SEL_H :2; /**<  */
+    HWREG_U16 SDCLK_FREQ_SEL :8; /**<  */
+} sCLOCK_CTRLStructure;
+
+
+/** @brief CLOCK_CTRL Bitfield widths 
+*/
+#define lenCLOCK_CTRL_INTERNAL_CLOCK_EN 1
+#define lenCLOCK_CTRL_INTERNAL_CLOCK_STABLE 1
+#define lenCLOCK_CTRL_SDCLOCK_EN 1
+#define lenCLOCK_CTRL_CLK_GEN_SEL 1
+#define lenCLOCK_CTRL_SDCLK_FREQ_SEL_H 2
+#define lenCLOCK_CTRL_SDCLK_FREQ_SEL 8
+
+typedef enum
+{
+    CLOCK_CTRL_LSB_INTERNAL_CLOCK_EN = 0,
+    CLOCK_CTRL_LSB_INTERNAL_CLOCK_STABLE = 1,
+    CLOCK_CTRL_LSB_SDCLOCK_EN = 2,
+    CLOCK_CTRL_LSB_CLK_GEN_SEL = 5,
+    CLOCK_CTRL_LSB_SDCLK_FREQ_SEL_H = 6,
+    CLOCK_CTRL_LSB_SDCLK_FREQ_SEL = 8
+} eCLOCK_CTRLLsb;
+
+typedef union
+{
+    HWREG_U16 CLOCK_CTRL_Content;
+    sCLOCK_CTRLStructure CLOCK_CTRL_Structure;
+} uCLOCK_CTRL;
+
+__HWREG_INLINE__ void setSdmmc_CLOCK_CTRL(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /** Set complete register CLOCK_CTRL */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_CLOCK_CTRL(volatile sSdmmc *_sdmmc_); /** Get complete register CLOCK_CTRL */
+__HWREG_INLINE__ void setSdmmc_CLOCK_CTRL_INTERNAL_CLOCK_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element INTERNAL_CLOCK_EN of register CLOCK_CTRL */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_CLOCK_CTRL_INTERNAL_CLOCK_EN(volatile sSdmmc *_sdmmc_); /**< Get element INTERNAL_CLOCK_EN of register CLOCK_CTRL */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_CLOCK_CTRL_INTERNAL_CLOCK_STABLE(volatile sSdmmc *_sdmmc_); /**< Get element INTERNAL_CLOCK_STABLE of register CLOCK_CTRL */
+__HWREG_INLINE__ void setSdmmc_CLOCK_CTRL_SDCLOCK_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element SDCLOCK_EN of register CLOCK_CTRL */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_CLOCK_CTRL_SDCLOCK_EN(volatile sSdmmc *_sdmmc_); /**< Get element SDCLOCK_EN of register CLOCK_CTRL */
+__HWREG_INLINE__ void setSdmmc_CLOCK_CTRL_CLK_GEN_SEL(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element CLK_GEN_SEL of register CLOCK_CTRL */
+__HWREG_INLINE__ void setSdmmc_CLOCK_CTRL_SDCLK_FREQ_SEL_H(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element SDCLK_FREQ_SEL_H of register CLOCK_CTRL */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_CLOCK_CTRL_SDCLK_FREQ_SEL_H(volatile sSdmmc *_sdmmc_); /**< Get element SDCLK_FREQ_SEL_H of register CLOCK_CTRL */
+__HWREG_INLINE__ void setSdmmc_CLOCK_CTRL_SDCLK_FREQ_SEL(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element SDCLK_FREQ_SEL of register CLOCK_CTRL */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_CLOCK_CTRL_SDCLK_FREQ_SEL(volatile sSdmmc *_sdmmc_); /**< Get element SDCLK_FREQ_SEL of register CLOCK_CTRL */
+
+
+/** @brief TIMEOUT_CTRL register description at address offset 0x2e
+  *
+  *  timeout control register
+  */
+typedef struct
+{
+    HWREG_U8 DAT_TIMEOUT_CNT_VAL :4; /**<  */
+    const HWREG_U8 Res2 :4; /**<  */
+} sTIMEOUT_CTRLStructure;
+
+
+/** @brief TIMEOUT_CTRL Bitfield widths 
+*/
+#define lenTIMEOUT_CTRL_DAT_TIMEOUT_CNT_VAL 4
+#define lenTIMEOUT_CTRL_RES2 4
+
+typedef enum
+{
+    TIMEOUT_CTRL_LSB_DAT_TIMEOUT_CNT_VAL = 0,
+    TIMEOUT_CTRL_LSB_RES2 = 4
+} eTIMEOUT_CTRLLsb;
+
+typedef union
+{
+    HWREG_U8 TIMEOUT_CTRL_Content;
+    sTIMEOUT_CTRLStructure TIMEOUT_CTRL_Structure;
+} uTIMEOUT_CTRL;
+
+__HWREG_INLINE__ void setSdmmc_TIMEOUT_CTRL(volatile sSdmmc *_sdmmc_, HWREG_U8 value); /** Set complete register TIMEOUT_CTRL */
+__HWREG_INLINE__ HWREG_U8 getSdmmc_TIMEOUT_CTRL(volatile sSdmmc *_sdmmc_); /** Get complete register TIMEOUT_CTRL */
+__HWREG_INLINE__ void setSdmmc_TIMEOUT_CTRL_DAT_TIMEOUT_CNT_VAL(volatile sSdmmc *_sdmmc_, HWREG_U8 value); /**< Set element DAT_TIMEOUT_CNT_VAL of register TIMEOUT_CTRL */
+__HWREG_INLINE__ HWREG_U8 getSdmmc_TIMEOUT_CTRL_DAT_TIMEOUT_CNT_VAL(volatile sSdmmc *_sdmmc_); /**< Get element DAT_TIMEOUT_CNT_VAL of register TIMEOUT_CTRL */
+__HWREG_INLINE__ HWREG_U8 getSdmmc_TIMEOUT_CTRL_Res2(volatile sSdmmc *_sdmmc_); /**< Get element Res2 of register TIMEOUT_CTRL */
+
+
+/** @brief SOFTWARE_RESET register description at address offset 0x2f
+  *
+  *  SW reset register
+  */
+typedef struct
+{
+    HWREG_U8 SW_RST_ALL :1; /**<  */
+    HWREG_U8 SW_RST_CMD_LINE :1; /**<  */
+    HWREG_U8 SW_RST_DAT_LINE :1; /**<  */
+    const HWREG_U8 Res0 :5; /**< Reserved bitfield */
+} sSW_RESETStructure;
+
+
+/** @brief SOFTWARE_RESET Bitfield widths 
+*/
+#define lenSW_RESET_SW_RST_ALL 1
+#define lenSW_RESET_SW_RST_CMD_LINE 1
+#define lenSW_RESET_SW_RST_DAT_LINE 1
+
+typedef enum
+{
+    SW_RESET_LSB_SW_RST_ALL = 0,
+    SW_RESET_LSB_SW_RST_CMD_LINE = 1,
+    SW_RESET_LSB_SW_RST_DAT_LINE = 2
+} eSW_RESETLsb;
+
+typedef union
+{
+    HWREG_U8 SW_RESET_Content;
+    sSW_RESETStructure SW_RESET_Structure;
+} uSW_RESET;
+
+__HWREG_INLINE__ void setSdmmc_SW_RESET(volatile sSdmmc *_sdmmc_, HWREG_U8 value); /** Set complete register SOFTWARE_RESET */
+__HWREG_INLINE__ HWREG_U8 getSdmmc_SW_RESET(volatile sSdmmc *_sdmmc_); /** Get complete register SOFTWARE_RESET */
+__HWREG_INLINE__ void setSdmmc_SW_RESET_SW_RST_ALL(volatile sSdmmc *_sdmmc_, HWREG_U8 value); /**< Set element SW_RST_ALL of register SOFTWARE_RESET */
+__HWREG_INLINE__ HWREG_U8 getSdmmc_SW_RESET_SW_RST_ALL(volatile sSdmmc *_sdmmc_); /**< Get element SW_RST_ALL of register SOFTWARE_RESET */
+__HWREG_INLINE__ void setSdmmc_SW_RESET_SW_RST_CMD_LINE(volatile sSdmmc *_sdmmc_, HWREG_U8 value); /**< Set element SW_RST_CMD_LINE of register SOFTWARE_RESET */
+__HWREG_INLINE__ HWREG_U8 getSdmmc_SW_RESET_SW_RST_CMD_LINE(volatile sSdmmc *_sdmmc_); /**< Get element SW_RST_CMD_LINE of register SOFTWARE_RESET */
+__HWREG_INLINE__ void setSdmmc_SW_RESET_SW_RST_DAT_LINE(volatile sSdmmc *_sdmmc_, HWREG_U8 value); /**< Set element SW_RST_DAT_LINE of register SOFTWARE_RESET */
+__HWREG_INLINE__ HWREG_U8 getSdmmc_SW_RESET_SW_RST_DAT_LINE(volatile sSdmmc *_sdmmc_); /**< Get element SW_RST_DAT_LINE of register SOFTWARE_RESET */
+
+
+/** @brief INT_STATUS_NORM register description at address offset 0x30
+  *
+  *  Normal  interrupt status register
+  */
+typedef struct
+{
+    HWREG_U16 CMD_COMPLETE :1; /**<  */
+    HWREG_U16 TX_COMPLETE :1; /**<  */
+    HWREG_U16 BLOCK_GAP_EVENT :1; /**<  */
+    HWREG_U16 DMA_INT :1; /**<  */
+    HWREG_U16 BUFF_WRITE_READY :1; /**<  */
+    HWREG_U16 BUFF_READ_READY :1; /**<  */
+    HWREG_U16 CARD_INS :1; /**<  */
+    HWREG_U16 CARD_REMOVAL :1; /**<  */
+    const HWREG_U16 CARD_INT :1; /**<  */
+    const HWREG_U16 INT_A :1; /**<  */
+    const HWREG_U16 INT_B :1; /**<  */
+    const HWREG_U16 INT_C :1; /**<  */
+    const HWREG_U16 RETUNING_EVENT :1; /**<  */
+    HWREG_U16 BOOT_ACK_RCV :1; /**<  */
+    HWREG_U16 BOOT_TERM_INT :1; /**<  */
+    const HWREG_U16 ERR_INT :1; /**<  */
+} sINT_STATUS_NORMStructure;
+
+
+/** @brief INT_STATUS_NORM Bitfield widths 
+*/
+#define lenINT_STATUS_NORM_CMD_COMPLETE 1
+#define lenINT_STATUS_NORM_TX_COMPLETE 1
+#define lenINT_STATUS_NORM_BLOCK_GAP_EVENT 1
+#define lenINT_STATUS_NORM_DMA_INT 1
+#define lenINT_STATUS_NORM_BUFF_WRITE_READY 1
+#define lenINT_STATUS_NORM_BUFF_READ_READY 1
+#define lenINT_STATUS_NORM_CARD_INS 1
+#define lenINT_STATUS_NORM_CARD_REMOVAL 1
+#define lenINT_STATUS_NORM_CARD_INT 1
+#define lenINT_STATUS_NORM_INT_A 1
+#define lenINT_STATUS_NORM_INT_B 1
+#define lenINT_STATUS_NORM_INT_C 1
+#define lenINT_STATUS_NORM_RETUNING_EVENT 1
+#define lenINT_STATUS_NORM_BOOT_ACK_RCV 1
+#define lenINT_STATUS_NORM_BOOT_TERM_INT 1
+#define lenINT_STATUS_NORM_ERR_INT 1
+
+typedef enum
+{
+    INT_STATUS_NORM_LSB_CMD_COMPLETE = 0,
+    INT_STATUS_NORM_LSB_TX_COMPLETE = 1,
+    INT_STATUS_NORM_LSB_BLOCK_GAP_EVENT = 2,
+    INT_STATUS_NORM_LSB_DMA_INT = 3,
+    INT_STATUS_NORM_LSB_BUFF_WRITE_READY = 4,
+    INT_STATUS_NORM_LSB_BUFF_READ_READY = 5,
+    INT_STATUS_NORM_LSB_CARD_INS = 6,
+    INT_STATUS_NORM_LSB_CARD_REMOVAL = 7,
+    INT_STATUS_NORM_LSB_CARD_INT = 8,
+    INT_STATUS_NORM_LSB_INT_A = 9,
+    INT_STATUS_NORM_LSB_INT_B = 10,
+    INT_STATUS_NORM_LSB_INT_C = 11,
+    INT_STATUS_NORM_LSB_RETUNING_EVENT = 12,
+    INT_STATUS_NORM_LSB_BOOT_ACK_RCV = 13,
+    INT_STATUS_NORM_LSB_BOOT_TERM_INT = 14,
+    INT_STATUS_NORM_LSB_ERR_INT = 15
+} eINT_STATUS_NORMLsb;
+
+typedef union
+{
+    HWREG_U16 INT_STATUS_NORM_Content;
+    sINT_STATUS_NORMStructure INT_STATUS_NORM_Structure;
+} uINT_STATUS_NORM;
+
+__HWREG_INLINE__ void setSdmmc_INT_STATUS_NORM(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /** Set complete register INT_STATUS_NORM */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_NORM(volatile sSdmmc *_sdmmc_); /** Get complete register INT_STATUS_NORM */
+__HWREG_INLINE__ void setSdmmc_INT_STATUS_NORM_CMD_COMPLETE(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element CMD_COMPLETE of register INT_STATUS_NORM */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_NORM_CMD_COMPLETE(volatile sSdmmc *_sdmmc_); /**< Get element CMD_COMPLETE of register INT_STATUS_NORM */
+__HWREG_INLINE__ void setSdmmc_INT_STATUS_NORM_TX_COMPLETE(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element TX_COMPLETE of register INT_STATUS_NORM */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_NORM_TX_COMPLETE(volatile sSdmmc *_sdmmc_); /**< Get element TX_COMPLETE of register INT_STATUS_NORM */
+__HWREG_INLINE__ void setSdmmc_INT_STATUS_NORM_BLOCK_GAP_EVENT(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element BLOCK_GAP_EVENT of register INT_STATUS_NORM */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_NORM_BLOCK_GAP_EVENT(volatile sSdmmc *_sdmmc_); /**< Get element BLOCK_GAP_EVENT of register INT_STATUS_NORM */
+__HWREG_INLINE__ void setSdmmc_INT_STATUS_NORM_DMA_INT(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element DMA_INT of register INT_STATUS_NORM */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_NORM_DMA_INT(volatile sSdmmc *_sdmmc_); /**< Get element DMA_INT of register INT_STATUS_NORM */
+__HWREG_INLINE__ void setSdmmc_INT_STATUS_NORM_BUFF_WRITE_READY(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element BUFF_WRITE_READY of register INT_STATUS_NORM */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_NORM_BUFF_WRITE_READY(volatile sSdmmc *_sdmmc_); /**< Get element BUFF_WRITE_READY of register INT_STATUS_NORM */
+__HWREG_INLINE__ void setSdmmc_INT_STATUS_NORM_BUFF_READ_READY(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element BUFF_READ_READY of register INT_STATUS_NORM */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_NORM_BUFF_READ_READY(volatile sSdmmc *_sdmmc_); /**< Get element BUFF_READ_READY of register INT_STATUS_NORM */
+__HWREG_INLINE__ void setSdmmc_INT_STATUS_NORM_CARD_INS(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element CARD_INS of register INT_STATUS_NORM */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_NORM_CARD_INS(volatile sSdmmc *_sdmmc_); /**< Get element CARD_INS of register INT_STATUS_NORM */
+__HWREG_INLINE__ void setSdmmc_INT_STATUS_NORM_CARD_REMOVAL(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element CARD_REMOVAL of register INT_STATUS_NORM */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_NORM_CARD_REMOVAL(volatile sSdmmc *_sdmmc_); /**< Get element CARD_REMOVAL of register INT_STATUS_NORM */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_NORM_CARD_INT(volatile sSdmmc *_sdmmc_); /**< Get element CARD_INT of register INT_STATUS_NORM */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_NORM_INT_A(volatile sSdmmc *_sdmmc_); /**< Get element INT_A of register INT_STATUS_NORM */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_NORM_INT_B(volatile sSdmmc *_sdmmc_); /**< Get element INT_B of register INT_STATUS_NORM */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_NORM_INT_C(volatile sSdmmc *_sdmmc_); /**< Get element INT_C of register INT_STATUS_NORM */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_NORM_RETUNING_EVENT(volatile sSdmmc *_sdmmc_); /**< Get element RETUNING_EVENT of register INT_STATUS_NORM */
+__HWREG_INLINE__ void setSdmmc_INT_STATUS_NORM_BOOT_ACK_RCV(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element BOOT_ACK_RCV of register INT_STATUS_NORM */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_NORM_BOOT_ACK_RCV(volatile sSdmmc *_sdmmc_); /**< Get element BOOT_ACK_RCV of register INT_STATUS_NORM */
+__HWREG_INLINE__ void setSdmmc_INT_STATUS_NORM_BOOT_TERM_INT(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element BOOT_TERM_INT of register INT_STATUS_NORM */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_NORM_BOOT_TERM_INT(volatile sSdmmc *_sdmmc_); /**< Get element BOOT_TERM_INT of register INT_STATUS_NORM */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_NORM_ERR_INT(volatile sSdmmc *_sdmmc_); /**< Get element ERR_INT of register INT_STATUS_NORM */
+
+
+/** @brief INT_STATUS_ERR register description at address offset 0x32
+  *
+  *  error interrupt status register
+  */
+typedef struct
+{
+    HWREG_U16 CMD_TIMEOUT_ERR :1; /**<  */
+    HWREG_U16 CMD_CRC_ERR :1; /**<  */
+    HWREG_U16 CMD_END_BIT_ERR :1; /**<  */
+    HWREG_U16 CMD_IND_ERR :1; /**<  */
+    HWREG_U16 DATA_TIMEOUT_ERR :1; /**<  */
+    HWREG_U16 DATA_CRC_ERR :1; /**<  */
+    HWREG_U16 DATA_END_BIT_ERR :1; /**<  */
+    HWREG_U16 CURRENT_LIMIT_ERR :1; /**<  */
+    HWREG_U16 ACMD_ERR :1; /**<  */
+    HWREG_U16 ADMA_ERR :1; /**<  */
+    HWREG_U16 TUNING_ERROR :1; /**<  */
+    const HWREG_U16 res11 :1; /**<  */
+    HWREG_U16 TARGET_RESP_ERR :1; /**<  */
+    HWREG_U16 CEATA_ERR :1; /**<  */
+    const HWREG_U16 VSES1514 :2; /**<  */
+} sINT_STATUS_ERRStructure;
+
+
+/** @brief INT_STATUS_ERR Bitfield widths 
+*/
+#define lenINT_STATUS_ERR_CMD_TIMEOUT_ERR 1
+#define lenINT_STATUS_ERR_CMD_CRC_ERR 1
+#define lenINT_STATUS_ERR_CMD_END_BIT_ERR 1
+#define lenINT_STATUS_ERR_CMD_IND_ERR 1
+#define lenINT_STATUS_ERR_DATA_TIMEOUT_ERR 1
+#define lenINT_STATUS_ERR_DATA_CRC_ERR 1
+#define lenINT_STATUS_ERR_DATA_END_BIT_ERR 1
+#define lenINT_STATUS_ERR_CURRENT_LIMIT_ERR 1
+#define lenINT_STATUS_ERR_ACMD_ERR 1
+#define lenINT_STATUS_ERR_ADMA_ERR 1
+#define lenINT_STATUS_ERR_TUNING_ERROR 1
+#define lenINT_STATUS_ERR_RES11 1
+#define lenINT_STATUS_ERR_TARGET_RESP_ERR 1
+#define lenINT_STATUS_ERR_CEATA_ERR 1
+#define lenINT_STATUS_ERR_VSES1514 2
+
+typedef enum
+{
+    INT_STATUS_ERR_LSB_CMD_TIMEOUT_ERR = 0,
+    INT_STATUS_ERR_LSB_CMD_CRC_ERR = 1,
+    INT_STATUS_ERR_LSB_CMD_END_BIT_ERR = 2,
+    INT_STATUS_ERR_LSB_CMD_IND_ERR = 3,
+    INT_STATUS_ERR_LSB_DATA_TIMEOUT_ERR = 4,
+    INT_STATUS_ERR_LSB_DATA_CRC_ERR = 5,
+    INT_STATUS_ERR_LSB_DATA_END_BIT_ERR = 6,
+    INT_STATUS_ERR_LSB_CURRENT_LIMIT_ERR = 7,
+    INT_STATUS_ERR_LSB_ACMD_ERR = 8,
+    INT_STATUS_ERR_LSB_ADMA_ERR = 9,
+    INT_STATUS_ERR_LSB_TUNING_ERROR = 10,
+    INT_STATUS_ERR_LSB_RES11 = 11,
+    INT_STATUS_ERR_LSB_TARGET_RESP_ERR = 12,
+    INT_STATUS_ERR_LSB_CEATA_ERR = 13,
+    INT_STATUS_ERR_LSB_VSES1514 = 14
+} eINT_STATUS_ERRLsb;
+
+typedef union
+{
+    HWREG_U16 INT_STATUS_ERR_Content;
+    sINT_STATUS_ERRStructure INT_STATUS_ERR_Structure;
+} uINT_STATUS_ERR;
+
+__HWREG_INLINE__ void setSdmmc_INT_STATUS_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /** Set complete register INT_STATUS_ERR */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_ERR(volatile sSdmmc *_sdmmc_); /** Get complete register INT_STATUS_ERR */
+__HWREG_INLINE__ void setSdmmc_INT_STATUS_ERR_CMD_TIMEOUT_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element CMD_TIMEOUT_ERR of register INT_STATUS_ERR */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_ERR_CMD_TIMEOUT_ERR(volatile sSdmmc *_sdmmc_); /**< Get element CMD_TIMEOUT_ERR of register INT_STATUS_ERR */
+__HWREG_INLINE__ void setSdmmc_INT_STATUS_ERR_CMD_CRC_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element CMD_CRC_ERR of register INT_STATUS_ERR */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_ERR_CMD_CRC_ERR(volatile sSdmmc *_sdmmc_); /**< Get element CMD_CRC_ERR of register INT_STATUS_ERR */
+__HWREG_INLINE__ void setSdmmc_INT_STATUS_ERR_CMD_END_BIT_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element CMD_END_BIT_ERR of register INT_STATUS_ERR */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_ERR_CMD_END_BIT_ERR(volatile sSdmmc *_sdmmc_); /**< Get element CMD_END_BIT_ERR of register INT_STATUS_ERR */
+__HWREG_INLINE__ void setSdmmc_INT_STATUS_ERR_CMD_IND_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element CMD_IND_ERR of register INT_STATUS_ERR */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_ERR_CMD_IND_ERR(volatile sSdmmc *_sdmmc_); /**< Get element CMD_IND_ERR of register INT_STATUS_ERR */
+__HWREG_INLINE__ void setSdmmc_INT_STATUS_ERR_DATA_TIMEOUT_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element DATA_TIMEOUT_ERR of register INT_STATUS_ERR */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_ERR_DATA_TIMEOUT_ERR(volatile sSdmmc *_sdmmc_); /**< Get element DATA_TIMEOUT_ERR of register INT_STATUS_ERR */
+__HWREG_INLINE__ void setSdmmc_INT_STATUS_ERR_DATA_CRC_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element DATA_CRC_ERR of register INT_STATUS_ERR */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_ERR_DATA_CRC_ERR(volatile sSdmmc *_sdmmc_); /**< Get element DATA_CRC_ERR of register INT_STATUS_ERR */
+__HWREG_INLINE__ void setSdmmc_INT_STATUS_ERR_DATA_END_BIT_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element DATA_END_BIT_ERR of register INT_STATUS_ERR */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_ERR_DATA_END_BIT_ERR(volatile sSdmmc *_sdmmc_); /**< Get element DATA_END_BIT_ERR of register INT_STATUS_ERR */
+__HWREG_INLINE__ void setSdmmc_INT_STATUS_ERR_CURRENT_LIMIT_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element CURRENT_LIMIT_ERR of register INT_STATUS_ERR */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_ERR_CURRENT_LIMIT_ERR(volatile sSdmmc *_sdmmc_); /**< Get element CURRENT_LIMIT_ERR of register INT_STATUS_ERR */
+__HWREG_INLINE__ void setSdmmc_INT_STATUS_ERR_ACMD_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element ACMD_ERR of register INT_STATUS_ERR */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_ERR_ACMD_ERR(volatile sSdmmc *_sdmmc_); /**< Get element ACMD_ERR of register INT_STATUS_ERR */
+__HWREG_INLINE__ void setSdmmc_INT_STATUS_ERR_ADMA_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element ADMA_ERR of register INT_STATUS_ERR */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_ERR_ADMA_ERR(volatile sSdmmc *_sdmmc_); /**< Get element ADMA_ERR of register INT_STATUS_ERR */
+__HWREG_INLINE__ void setSdmmc_INT_STATUS_ERR_TUNING_ERROR(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element TUNING_ERROR of register INT_STATUS_ERR */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_ERR_TUNING_ERROR(volatile sSdmmc *_sdmmc_); /**< Get element TUNING_ERROR of register INT_STATUS_ERR */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_ERR_res11(volatile sSdmmc *_sdmmc_); /**< Get element res11 of register INT_STATUS_ERR */
+__HWREG_INLINE__ void setSdmmc_INT_STATUS_ERR_TARGET_RESP_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element TARGET_RESP_ERR of register INT_STATUS_ERR */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_ERR_TARGET_RESP_ERR(volatile sSdmmc *_sdmmc_); /**< Get element TARGET_RESP_ERR of register INT_STATUS_ERR */
+__HWREG_INLINE__ void setSdmmc_INT_STATUS_ERR_CEATA_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element CEATA_ERR of register INT_STATUS_ERR */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_ERR_CEATA_ERR(volatile sSdmmc *_sdmmc_); /**< Get element CEATA_ERR of register INT_STATUS_ERR */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_ERR_VSES1514(volatile sSdmmc *_sdmmc_); /**< Get element VSES1514 of register INT_STATUS_ERR */
+
+
+/** @brief EN_INT_STATUS_NORM register description at address offset 0x34
+  *
+  *  normal Interrupt status enable register
+  */
+typedef struct
+{
+    HWREG_U16 CMD_COMPLETE_EN :1; /**<  */
+    HWREG_U16 TX_COMPLETE_EN :1; /**<  */
+    HWREG_U16 BLOCK_GAP_EVENT_EN :1; /**<  */
+    HWREG_U16 DMA_INT_EN :1; /**<  */
+    HWREG_U16 BUFF_WRITE_READY_EN :1; /**<  */
+    HWREG_U16 BUFF_READ_READY_EN :1; /**<  */
+    HWREG_U16 CARD_INS_EN :1; /**<  */
+    HWREG_U16 CARD_REMOVAL_EN :1; /**<  */
+    HWREG_U16 CARD_INT_EN :1; /**<  */
+    HWREG_U16 INT_A_EN :1; /**<  */
+    HWREG_U16 INT_B_EN :1; /**<  */
+    HWREG_U16 INT_C_EN :1; /**<  */
+    HWREG_U16 RETUNING_EVENT_EN :1; /**<  */
+    HWREG_U16 BOOT_ACK_RCV_EN :1; /**<  */
+    HWREG_U16 BOOT_TERM_INT_EN :1; /**<  */
+    const HWREG_U16 FIXED_TO_0 :1; /**<  */
+} sEN_INT_STATUS_NORMStructure;
+
+
+/** @brief EN_INT_STATUS_NORM Bitfield widths 
+*/
+#define lenEN_INT_STATUS_NORM_CMD_COMPLETE_EN 1
+#define lenEN_INT_STATUS_NORM_TX_COMPLETE_EN 1
+#define lenEN_INT_STATUS_NORM_BLOCK_GAP_EVENT_EN 1
+#define lenEN_INT_STATUS_NORM_DMA_INT_EN 1
+#define lenEN_INT_STATUS_NORM_BUFF_WRITE_READY_EN 1
+#define lenEN_INT_STATUS_NORM_BUFF_READ_READY_EN 1
+#define lenEN_INT_STATUS_NORM_CARD_INS_EN 1
+#define lenEN_INT_STATUS_NORM_CARD_REMOVAL_EN 1
+#define lenEN_INT_STATUS_NORM_CARD_INT_EN 1
+#define lenEN_INT_STATUS_NORM_INT_A_EN 1
+#define lenEN_INT_STATUS_NORM_INT_B_EN 1
+#define lenEN_INT_STATUS_NORM_INT_C_EN 1
+#define lenEN_INT_STATUS_NORM_RETUNING_EVENT_EN 1
+#define lenEN_INT_STATUS_NORM_BOOT_ACK_RCV_EN 1
+#define lenEN_INT_STATUS_NORM_BOOT_TERM_INT_EN 1
+#define lenEN_INT_STATUS_NORM_FIXED_TO_0 1
+
+typedef enum
+{
+    EN_INT_STATUS_NORM_LSB_CMD_COMPLETE_EN = 0,
+    EN_INT_STATUS_NORM_LSB_TX_COMPLETE_EN = 1,
+    EN_INT_STATUS_NORM_LSB_BLOCK_GAP_EVENT_EN = 2,
+    EN_INT_STATUS_NORM_LSB_DMA_INT_EN = 3,
+    EN_INT_STATUS_NORM_LSB_BUFF_WRITE_READY_EN = 4,
+    EN_INT_STATUS_NORM_LSB_BUFF_READ_READY_EN = 5,
+    EN_INT_STATUS_NORM_LSB_CARD_INS_EN = 6,
+    EN_INT_STATUS_NORM_LSB_CARD_REMOVAL_EN = 7,
+    EN_INT_STATUS_NORM_LSB_CARD_INT_EN = 8,
+    EN_INT_STATUS_NORM_LSB_INT_A_EN = 9,
+    EN_INT_STATUS_NORM_LSB_INT_B_EN = 10,
+    EN_INT_STATUS_NORM_LSB_INT_C_EN = 11,
+    EN_INT_STATUS_NORM_LSB_RETUNING_EVENT_EN = 12,
+    EN_INT_STATUS_NORM_LSB_BOOT_ACK_RCV_EN = 13,
+    EN_INT_STATUS_NORM_LSB_BOOT_TERM_INT_EN = 14,
+    EN_INT_STATUS_NORM_LSB_FIXED_TO_0 = 15
+} eEN_INT_STATUS_NORMLsb;
+
+typedef union
+{
+    HWREG_U16 EN_INT_STATUS_NORM_Content;
+    sEN_INT_STATUS_NORMStructure EN_INT_STATUS_NORM_Structure;
+} uEN_INT_STATUS_NORM;
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_NORM(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /** Set complete register EN_INT_STATUS_NORM */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_NORM(volatile sSdmmc *_sdmmc_); /** Get complete register EN_INT_STATUS_NORM */
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_NORM_CMD_COMPLETE_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element CMD_COMPLETE_EN of register EN_INT_STATUS_NORM */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_NORM_CMD_COMPLETE_EN(volatile sSdmmc *_sdmmc_); /**< Get element CMD_COMPLETE_EN of register EN_INT_STATUS_NORM */
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_NORM_TX_COMPLETE_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element TX_COMPLETE_EN of register EN_INT_STATUS_NORM */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_NORM_TX_COMPLETE_EN(volatile sSdmmc *_sdmmc_); /**< Get element TX_COMPLETE_EN of register EN_INT_STATUS_NORM */
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_NORM_BLOCK_GAP_EVENT_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element BLOCK_GAP_EVENT_EN of register EN_INT_STATUS_NORM */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_NORM_BLOCK_GAP_EVENT_EN(volatile sSdmmc *_sdmmc_); /**< Get element BLOCK_GAP_EVENT_EN of register EN_INT_STATUS_NORM */
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_NORM_DMA_INT_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element DMA_INT_EN of register EN_INT_STATUS_NORM */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_NORM_DMA_INT_EN(volatile sSdmmc *_sdmmc_); /**< Get element DMA_INT_EN of register EN_INT_STATUS_NORM */
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_NORM_BUFF_WRITE_READY_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element BUFF_WRITE_READY_EN of register EN_INT_STATUS_NORM */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_NORM_BUFF_WRITE_READY_EN(volatile sSdmmc *_sdmmc_); /**< Get element BUFF_WRITE_READY_EN of register EN_INT_STATUS_NORM */
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_NORM_BUFF_READ_READY_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element BUFF_READ_READY_EN of register EN_INT_STATUS_NORM */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_NORM_BUFF_READ_READY_EN(volatile sSdmmc *_sdmmc_); /**< Get element BUFF_READ_READY_EN of register EN_INT_STATUS_NORM */
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_NORM_CARD_INS_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element CARD_INS_EN of register EN_INT_STATUS_NORM */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_NORM_CARD_INS_EN(volatile sSdmmc *_sdmmc_); /**< Get element CARD_INS_EN of register EN_INT_STATUS_NORM */
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_NORM_CARD_REMOVAL_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element CARD_REMOVAL_EN of register EN_INT_STATUS_NORM */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_NORM_CARD_REMOVAL_EN(volatile sSdmmc *_sdmmc_); /**< Get element CARD_REMOVAL_EN of register EN_INT_STATUS_NORM */
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_NORM_CARD_INT_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element CARD_INT_EN of register EN_INT_STATUS_NORM */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_NORM_CARD_INT_EN(volatile sSdmmc *_sdmmc_); /**< Get element CARD_INT_EN of register EN_INT_STATUS_NORM */
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_NORM_INT_A_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element INT_A_EN of register EN_INT_STATUS_NORM */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_NORM_INT_A_EN(volatile sSdmmc *_sdmmc_); /**< Get element INT_A_EN of register EN_INT_STATUS_NORM */
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_NORM_INT_B_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element INT_B_EN of register EN_INT_STATUS_NORM */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_NORM_INT_B_EN(volatile sSdmmc *_sdmmc_); /**< Get element INT_B_EN of register EN_INT_STATUS_NORM */
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_NORM_INT_C_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element INT_C_EN of register EN_INT_STATUS_NORM */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_NORM_INT_C_EN(volatile sSdmmc *_sdmmc_); /**< Get element INT_C_EN of register EN_INT_STATUS_NORM */
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_NORM_RETUNING_EVENT_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element RETUNING_EVENT_EN of register EN_INT_STATUS_NORM */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_NORM_RETUNING_EVENT_EN(volatile sSdmmc *_sdmmc_); /**< Get element RETUNING_EVENT_EN of register EN_INT_STATUS_NORM */
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_NORM_BOOT_ACK_RCV_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element BOOT_ACK_RCV_EN of register EN_INT_STATUS_NORM */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_NORM_BOOT_ACK_RCV_EN(volatile sSdmmc *_sdmmc_); /**< Get element BOOT_ACK_RCV_EN of register EN_INT_STATUS_NORM */
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_NORM_BOOT_TERM_INT_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element BOOT_TERM_INT_EN of register EN_INT_STATUS_NORM */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_NORM_BOOT_TERM_INT_EN(volatile sSdmmc *_sdmmc_); /**< Get element BOOT_TERM_INT_EN of register EN_INT_STATUS_NORM */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_NORM_FIXED_TO_0(volatile sSdmmc *_sdmmc_); /**< Get element FIXED_TO_0 of register EN_INT_STATUS_NORM */
+
+
+/** @brief EN_INT_STATUS_ERR register description at address offset 0x36
+  *
+  *  error Interrupt status enable register
+  */
+typedef struct
+{
+    HWREG_U16 CMD_TIMEOUT_ERR_EN :1; /**<  */
+    HWREG_U16 CMD_CRC_ERR_EN :1; /**<  */
+    HWREG_U16 CMD_END_BIT_ERR_EN :1; /**<  */
+    HWREG_U16 CMD_IND_ERR_EN :1; /**<  */
+    HWREG_U16 DATA_TIMEOUT_ERR_EN :1; /**<  */
+    HWREG_U16 DATA_CRC_ERR_EN :1; /**<  */
+    HWREG_U16 DATA_END_BIT_ERR_EN :1; /**<  */
+    HWREG_U16 CURRENT_LIMIT_ERR_EN :1; /**<  */
+    HWREG_U16 ACMD_ERR_EN :1; /**<  */
+    HWREG_U16 ADMA_ERR_EN :1; /**<  */
+    HWREG_U16 TUNING_ERROR_EN :1; /**<  */
+    const HWREG_U16 res11 :1; /**<  */
+    HWREG_U16 TARGET_RESP_ERR_EN :1; /**<  */
+    HWREG_U16 CEATA_ERR_EN :1; /**<  */
+    const HWREG_U16 VSES1514_EN :2; /**<  */
+} sEN_INT_STATUS_ERRStructure;
+
+
+/** @brief EN_INT_STATUS_ERR Bitfield widths 
+*/
+#define lenEN_INT_STATUS_ERR_CMD_TIMEOUT_ERR_EN 1
+#define lenEN_INT_STATUS_ERR_CMD_CRC_ERR_EN 1
+#define lenEN_INT_STATUS_ERR_CMD_END_BIT_ERR_EN 1
+#define lenEN_INT_STATUS_ERR_CMD_IND_ERR_EN 1
+#define lenEN_INT_STATUS_ERR_DATA_TIMEOUT_ERR_EN 1
+#define lenEN_INT_STATUS_ERR_DATA_CRC_ERR_EN 1
+#define lenEN_INT_STATUS_ERR_DATA_END_BIT_ERR_EN 1
+#define lenEN_INT_STATUS_ERR_CURRENT_LIMIT_ERR_EN 1
+#define lenEN_INT_STATUS_ERR_ACMD_ERR_EN 1
+#define lenEN_INT_STATUS_ERR_ADMA_ERR_EN 1
+#define lenEN_INT_STATUS_ERR_TUNING_ERROR_EN 1
+#define lenEN_INT_STATUS_ERR_RES11 1
+#define lenEN_INT_STATUS_ERR_TARGET_RESP_ERR_EN 1
+#define lenEN_INT_STATUS_ERR_CEATA_ERR_EN 1
+#define lenEN_INT_STATUS_ERR_VSES1514_EN 2
+
+typedef enum
+{
+    EN_INT_STATUS_ERR_LSB_CMD_TIMEOUT_ERR_EN = 0,
+    EN_INT_STATUS_ERR_LSB_CMD_CRC_ERR_EN = 1,
+    EN_INT_STATUS_ERR_LSB_CMD_END_BIT_ERR_EN = 2,
+    EN_INT_STATUS_ERR_LSB_CMD_IND_ERR_EN = 3,
+    EN_INT_STATUS_ERR_LSB_DATA_TIMEOUT_ERR_EN = 4,
+    EN_INT_STATUS_ERR_LSB_DATA_CRC_ERR_EN = 5,
+    EN_INT_STATUS_ERR_LSB_DATA_END_BIT_ERR_EN = 6,
+    EN_INT_STATUS_ERR_LSB_CURRENT_LIMIT_ERR_EN = 7,
+    EN_INT_STATUS_ERR_LSB_ACMD_ERR_EN = 8,
+    EN_INT_STATUS_ERR_LSB_ADMA_ERR_EN = 9,
+    EN_INT_STATUS_ERR_LSB_TUNING_ERROR_EN = 10,
+    EN_INT_STATUS_ERR_LSB_RES11 = 11,
+    EN_INT_STATUS_ERR_LSB_TARGET_RESP_ERR_EN = 12,
+    EN_INT_STATUS_ERR_LSB_CEATA_ERR_EN = 13,
+    EN_INT_STATUS_ERR_LSB_VSES1514_EN = 14
+} eEN_INT_STATUS_ERRLsb;
+
+typedef union
+{
+    HWREG_U16 EN_INT_STATUS_ERR_Content;
+    sEN_INT_STATUS_ERRStructure EN_INT_STATUS_ERR_Structure;
+} uEN_INT_STATUS_ERR;
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /** Set complete register EN_INT_STATUS_ERR */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_ERR(volatile sSdmmc *_sdmmc_); /** Get complete register EN_INT_STATUS_ERR */
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_ERR_CMD_TIMEOUT_ERR_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element CMD_TIMEOUT_ERR_EN of register EN_INT_STATUS_ERR */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_ERR_CMD_TIMEOUT_ERR_EN(volatile sSdmmc *_sdmmc_); /**< Get element CMD_TIMEOUT_ERR_EN of register EN_INT_STATUS_ERR */
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_ERR_CMD_CRC_ERR_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element CMD_CRC_ERR_EN of register EN_INT_STATUS_ERR */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_ERR_CMD_CRC_ERR_EN(volatile sSdmmc *_sdmmc_); /**< Get element CMD_CRC_ERR_EN of register EN_INT_STATUS_ERR */
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_ERR_CMD_END_BIT_ERR_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element CMD_END_BIT_ERR_EN of register EN_INT_STATUS_ERR */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_ERR_CMD_END_BIT_ERR_EN(volatile sSdmmc *_sdmmc_); /**< Get element CMD_END_BIT_ERR_EN of register EN_INT_STATUS_ERR */
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_ERR_CMD_IND_ERR_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element CMD_IND_ERR_EN of register EN_INT_STATUS_ERR */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_ERR_CMD_IND_ERR_EN(volatile sSdmmc *_sdmmc_); /**< Get element CMD_IND_ERR_EN of register EN_INT_STATUS_ERR */
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_ERR_DATA_TIMEOUT_ERR_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element DATA_TIMEOUT_ERR_EN of register EN_INT_STATUS_ERR */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_ERR_DATA_TIMEOUT_ERR_EN(volatile sSdmmc *_sdmmc_); /**< Get element DATA_TIMEOUT_ERR_EN of register EN_INT_STATUS_ERR */
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_ERR_DATA_CRC_ERR_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element DATA_CRC_ERR_EN of register EN_INT_STATUS_ERR */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_ERR_DATA_CRC_ERR_EN(volatile sSdmmc *_sdmmc_); /**< Get element DATA_CRC_ERR_EN of register EN_INT_STATUS_ERR */
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_ERR_DATA_END_BIT_ERR_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element DATA_END_BIT_ERR_EN of register EN_INT_STATUS_ERR */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_ERR_DATA_END_BIT_ERR_EN(volatile sSdmmc *_sdmmc_); /**< Get element DATA_END_BIT_ERR_EN of register EN_INT_STATUS_ERR */
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_ERR_CURRENT_LIMIT_ERR_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element CURRENT_LIMIT_ERR_EN of register EN_INT_STATUS_ERR */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_ERR_CURRENT_LIMIT_ERR_EN(volatile sSdmmc *_sdmmc_); /**< Get element CURRENT_LIMIT_ERR_EN of register EN_INT_STATUS_ERR */
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_ERR_ACMD_ERR_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element ACMD_ERR_EN of register EN_INT_STATUS_ERR */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_ERR_ACMD_ERR_EN(volatile sSdmmc *_sdmmc_); /**< Get element ACMD_ERR_EN of register EN_INT_STATUS_ERR */
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_ERR_ADMA_ERR_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element ADMA_ERR_EN of register EN_INT_STATUS_ERR */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_ERR_ADMA_ERR_EN(volatile sSdmmc *_sdmmc_); /**< Get element ADMA_ERR_EN of register EN_INT_STATUS_ERR */
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_ERR_TUNING_ERROR_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element TUNING_ERROR_EN of register EN_INT_STATUS_ERR */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_ERR_TUNING_ERROR_EN(volatile sSdmmc *_sdmmc_); /**< Get element TUNING_ERROR_EN of register EN_INT_STATUS_ERR */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_ERR_res11(volatile sSdmmc *_sdmmc_); /**< Get element res11 of register EN_INT_STATUS_ERR */
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_ERR_TARGET_RESP_ERR_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element TARGET_RESP_ERR_EN of register EN_INT_STATUS_ERR */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_ERR_TARGET_RESP_ERR_EN(volatile sSdmmc *_sdmmc_); /**< Get element TARGET_RESP_ERR_EN of register EN_INT_STATUS_ERR */
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_ERR_CEATA_ERR_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element CEATA_ERR_EN of register EN_INT_STATUS_ERR */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_ERR_CEATA_ERR_EN(volatile sSdmmc *_sdmmc_); /**< Get element CEATA_ERR_EN of register EN_INT_STATUS_ERR */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_ERR_VSES1514_EN(volatile sSdmmc *_sdmmc_); /**< Get element VSES1514_EN of register EN_INT_STATUS_ERR */
+
+
+/** @brief EN_INT_SIGNAL_NORM register description at address offset 0x38
+  *
+  *  Normal interrupt signal enable
+  */
+typedef struct
+{
+    HWREG_U16 CMD_COMPLETE_EN :1; /**<  */
+    HWREG_U16 TX_COMPLETE_EN :1; /**<  */
+    HWREG_U16 BLOCK_GAP_EVENT_EN :1; /**<  */
+    HWREG_U16 DMA_INT_EN :1; /**<  */
+    HWREG_U16 BUFF_WRITE_READY_EN :1; /**<  */
+    HWREG_U16 BUFF_READ_READY_EN :1; /**<  */
+    HWREG_U16 CARD_INS_EN :1; /**<  */
+    HWREG_U16 CARD_REMOVAL_EN :1; /**<  */
+    HWREG_U16 CARD_INT_EN :1; /**<  */
+    HWREG_U16 INT_A_EN :1; /**<  */
+    HWREG_U16 INT_B_EN :1; /**<  */
+    HWREG_U16 INT_C_EN :1; /**<  */
+    HWREG_U16 RETUNING_EVENT_EN :1; /**<  */
+    HWREG_U16 BOOT_ACK_RCV_EN :1; /**<  */
+    HWREG_U16 BOOT_TERM_INT_EN :1; /**<  */
+    const HWREG_U16 FIXED_TO_0 :1; /**<  */
+} sEN_INT_SIGNAL_NORMStructure;
+
+
+/** @brief EN_INT_SIGNAL_NORM Bitfield widths 
+*/
+#define lenEN_INT_SIGNAL_NORM_CMD_COMPLETE_EN 1
+#define lenEN_INT_SIGNAL_NORM_TX_COMPLETE_EN 1
+#define lenEN_INT_SIGNAL_NORM_BLOCK_GAP_EVENT_EN 1
+#define lenEN_INT_SIGNAL_NORM_DMA_INT_EN 1
+#define lenEN_INT_SIGNAL_NORM_BUFF_WRITE_READY_EN 1
+#define lenEN_INT_SIGNAL_NORM_BUFF_READ_READY_EN 1
+#define lenEN_INT_SIGNAL_NORM_CARD_INS_EN 1
+#define lenEN_INT_SIGNAL_NORM_CARD_REMOVAL_EN 1
+#define lenEN_INT_SIGNAL_NORM_CARD_INT_EN 1
+#define lenEN_INT_SIGNAL_NORM_INT_A_EN 1
+#define lenEN_INT_SIGNAL_NORM_INT_B_EN 1
+#define lenEN_INT_SIGNAL_NORM_INT_C_EN 1
+#define lenEN_INT_SIGNAL_NORM_RETUNING_EVENT_EN 1
+#define lenEN_INT_SIGNAL_NORM_BOOT_ACK_RCV_EN 1
+#define lenEN_INT_SIGNAL_NORM_BOOT_TERM_INT_EN 1
+#define lenEN_INT_SIGNAL_NORM_FIXED_TO_0 1
+
+typedef enum
+{
+    EN_INT_SIGNAL_NORM_LSB_CMD_COMPLETE_EN = 0,
+    EN_INT_SIGNAL_NORM_LSB_TX_COMPLETE_EN = 1,
+    EN_INT_SIGNAL_NORM_LSB_BLOCK_GAP_EVENT_EN = 2,
+    EN_INT_SIGNAL_NORM_LSB_DMA_INT_EN = 3,
+    EN_INT_SIGNAL_NORM_LSB_BUFF_WRITE_READY_EN = 4,
+    EN_INT_SIGNAL_NORM_LSB_BUFF_READ_READY_EN = 5,
+    EN_INT_SIGNAL_NORM_LSB_CARD_INS_EN = 6,
+    EN_INT_SIGNAL_NORM_LSB_CARD_REMOVAL_EN = 7,
+    EN_INT_SIGNAL_NORM_LSB_CARD_INT_EN = 8,
+    EN_INT_SIGNAL_NORM_LSB_INT_A_EN = 9,
+    EN_INT_SIGNAL_NORM_LSB_INT_B_EN = 10,
+    EN_INT_SIGNAL_NORM_LSB_INT_C_EN = 11,
+    EN_INT_SIGNAL_NORM_LSB_RETUNING_EVENT_EN = 12,
+    EN_INT_SIGNAL_NORM_LSB_BOOT_ACK_RCV_EN = 13,
+    EN_INT_SIGNAL_NORM_LSB_BOOT_TERM_INT_EN = 14,
+    EN_INT_SIGNAL_NORM_LSB_FIXED_TO_0 = 15
+} eEN_INT_SIGNAL_NORMLsb;
+
+typedef union
+{
+    HWREG_U16 EN_INT_SIGNAL_NORM_Content;
+    sEN_INT_SIGNAL_NORMStructure EN_INT_SIGNAL_NORM_Structure;
+} uEN_INT_SIGNAL_NORM;
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_NORM(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /** Set complete register EN_INT_SIGNAL_NORM */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_NORM(volatile sSdmmc *_sdmmc_); /** Get complete register EN_INT_SIGNAL_NORM */
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_NORM_CMD_COMPLETE_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element CMD_COMPLETE_EN of register EN_INT_SIGNAL_NORM */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_NORM_CMD_COMPLETE_EN(volatile sSdmmc *_sdmmc_); /**< Get element CMD_COMPLETE_EN of register EN_INT_SIGNAL_NORM */
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_NORM_TX_COMPLETE_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element TX_COMPLETE_EN of register EN_INT_SIGNAL_NORM */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_NORM_TX_COMPLETE_EN(volatile sSdmmc *_sdmmc_); /**< Get element TX_COMPLETE_EN of register EN_INT_SIGNAL_NORM */
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_NORM_BLOCK_GAP_EVENT_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element BLOCK_GAP_EVENT_EN of register EN_INT_SIGNAL_NORM */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_NORM_BLOCK_GAP_EVENT_EN(volatile sSdmmc *_sdmmc_); /**< Get element BLOCK_GAP_EVENT_EN of register EN_INT_SIGNAL_NORM */
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_NORM_DMA_INT_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element DMA_INT_EN of register EN_INT_SIGNAL_NORM */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_NORM_DMA_INT_EN(volatile sSdmmc *_sdmmc_); /**< Get element DMA_INT_EN of register EN_INT_SIGNAL_NORM */
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_NORM_BUFF_WRITE_READY_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element BUFF_WRITE_READY_EN of register EN_INT_SIGNAL_NORM */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_NORM_BUFF_WRITE_READY_EN(volatile sSdmmc *_sdmmc_); /**< Get element BUFF_WRITE_READY_EN of register EN_INT_SIGNAL_NORM */
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_NORM_BUFF_READ_READY_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element BUFF_READ_READY_EN of register EN_INT_SIGNAL_NORM */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_NORM_BUFF_READ_READY_EN(volatile sSdmmc *_sdmmc_); /**< Get element BUFF_READ_READY_EN of register EN_INT_SIGNAL_NORM */
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_NORM_CARD_INS_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element CARD_INS_EN of register EN_INT_SIGNAL_NORM */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_NORM_CARD_INS_EN(volatile sSdmmc *_sdmmc_); /**< Get element CARD_INS_EN of register EN_INT_SIGNAL_NORM */
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_NORM_CARD_REMOVAL_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element CARD_REMOVAL_EN of register EN_INT_SIGNAL_NORM */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_NORM_CARD_REMOVAL_EN(volatile sSdmmc *_sdmmc_); /**< Get element CARD_REMOVAL_EN of register EN_INT_SIGNAL_NORM */
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_NORM_CARD_INT_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element CARD_INT_EN of register EN_INT_SIGNAL_NORM */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_NORM_CARD_INT_EN(volatile sSdmmc *_sdmmc_); /**< Get element CARD_INT_EN of register EN_INT_SIGNAL_NORM */
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_NORM_INT_A_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element INT_A_EN of register EN_INT_SIGNAL_NORM */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_NORM_INT_A_EN(volatile sSdmmc *_sdmmc_); /**< Get element INT_A_EN of register EN_INT_SIGNAL_NORM */
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_NORM_INT_B_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element INT_B_EN of register EN_INT_SIGNAL_NORM */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_NORM_INT_B_EN(volatile sSdmmc *_sdmmc_); /**< Get element INT_B_EN of register EN_INT_SIGNAL_NORM */
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_NORM_INT_C_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element INT_C_EN of register EN_INT_SIGNAL_NORM */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_NORM_INT_C_EN(volatile sSdmmc *_sdmmc_); /**< Get element INT_C_EN of register EN_INT_SIGNAL_NORM */
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_NORM_RETUNING_EVENT_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element RETUNING_EVENT_EN of register EN_INT_SIGNAL_NORM */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_NORM_RETUNING_EVENT_EN(volatile sSdmmc *_sdmmc_); /**< Get element RETUNING_EVENT_EN of register EN_INT_SIGNAL_NORM */
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_NORM_BOOT_ACK_RCV_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element BOOT_ACK_RCV_EN of register EN_INT_SIGNAL_NORM */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_NORM_BOOT_ACK_RCV_EN(volatile sSdmmc *_sdmmc_); /**< Get element BOOT_ACK_RCV_EN of register EN_INT_SIGNAL_NORM */
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_NORM_BOOT_TERM_INT_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element BOOT_TERM_INT_EN of register EN_INT_SIGNAL_NORM */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_NORM_BOOT_TERM_INT_EN(volatile sSdmmc *_sdmmc_); /**< Get element BOOT_TERM_INT_EN of register EN_INT_SIGNAL_NORM */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_NORM_FIXED_TO_0(volatile sSdmmc *_sdmmc_); /**< Get element FIXED_TO_0 of register EN_INT_SIGNAL_NORM */
+
+
+/** @brief EN_INT_SIGNAL_ERR register description at address offset 0x3a
+  *
+  *  Error interrupt signal enable
+  */
+typedef struct
+{
+    HWREG_U16 CMD_TIMEOUT_ERR_EN :1; /**<  */
+    HWREG_U16 CMD_CRC_ERR_EN :1; /**<  */
+    HWREG_U16 CMD_END_BIT_ERR_EN :1; /**<  */
+    HWREG_U16 CMD_IND_ERR_EN :1; /**<  */
+    HWREG_U16 DATA_TIMEOUT_ERR_EN :1; /**<  */
+    HWREG_U16 DATA_CRC_ERR_EN :1; /**<  */
+    HWREG_U16 DATA_END_BIT_ERR_EN :1; /**<  */
+    HWREG_U16 CURRENT_LIMIT_ERR_EN :1; /**<  */
+    HWREG_U16 ACMD_ERR_EN :1; /**<  */
+    HWREG_U16 ADMA_ERR_EN :1; /**<  */
+    HWREG_U16 TUNING_ERROR_SIG_EN :1; /**<  */
+    const HWREG_U16 res11 :1; /**<  */
+    HWREG_U16 TARGET_RESP_ERR_EN :1; /**<  */
+    HWREG_U16 CEATA_ERR_EN :1; /**<  */
+    const HWREG_U16 VSES1514_EN :2; /**<  */
+} sEN_INT_SIGNAL_ERRStructure;
+
+
+/** @brief EN_INT_SIGNAL_ERR Bitfield widths 
+*/
+#define lenEN_INT_SIGNAL_ERR_CMD_TIMEOUT_ERR_EN 1
+#define lenEN_INT_SIGNAL_ERR_CMD_CRC_ERR_EN 1
+#define lenEN_INT_SIGNAL_ERR_CMD_END_BIT_ERR_EN 1
+#define lenEN_INT_SIGNAL_ERR_CMD_IND_ERR_EN 1
+#define lenEN_INT_SIGNAL_ERR_DATA_TIMEOUT_ERR_EN 1
+#define lenEN_INT_SIGNAL_ERR_DATA_CRC_ERR_EN 1
+#define lenEN_INT_SIGNAL_ERR_DATA_END_BIT_ERR_EN 1
+#define lenEN_INT_SIGNAL_ERR_CURRENT_LIMIT_ERR_EN 1
+#define lenEN_INT_SIGNAL_ERR_ACMD_ERR_EN 1
+#define lenEN_INT_SIGNAL_ERR_ADMA_ERR_EN 1
+#define lenEN_INT_SIGNAL_ERR_TUNING_ERROR_SIG_EN 1
+#define lenEN_INT_SIGNAL_ERR_RES11 1
+#define lenEN_INT_SIGNAL_ERR_TARGET_RESP_ERR_EN 1
+#define lenEN_INT_SIGNAL_ERR_CEATA_ERR_EN 1
+#define lenEN_INT_SIGNAL_ERR_VSES1514_EN 2
+
+typedef enum
+{
+    EN_INT_SIGNAL_ERR_LSB_CMD_TIMEOUT_ERR_EN = 0,
+    EN_INT_SIGNAL_ERR_LSB_CMD_CRC_ERR_EN = 1,
+    EN_INT_SIGNAL_ERR_LSB_CMD_END_BIT_ERR_EN = 2,
+    EN_INT_SIGNAL_ERR_LSB_CMD_IND_ERR_EN = 3,
+    EN_INT_SIGNAL_ERR_LSB_DATA_TIMEOUT_ERR_EN = 4,
+    EN_INT_SIGNAL_ERR_LSB_DATA_CRC_ERR_EN = 5,
+    EN_INT_SIGNAL_ERR_LSB_DATA_END_BIT_ERR_EN = 6,
+    EN_INT_SIGNAL_ERR_LSB_CURRENT_LIMIT_ERR_EN = 7,
+    EN_INT_SIGNAL_ERR_LSB_ACMD_ERR_EN = 8,
+    EN_INT_SIGNAL_ERR_LSB_ADMA_ERR_EN = 9,
+    EN_INT_SIGNAL_ERR_LSB_TUNING_ERROR_SIG_EN = 10,
+    EN_INT_SIGNAL_ERR_LSB_RES11 = 11,
+    EN_INT_SIGNAL_ERR_LSB_TARGET_RESP_ERR_EN = 12,
+    EN_INT_SIGNAL_ERR_LSB_CEATA_ERR_EN = 13,
+    EN_INT_SIGNAL_ERR_LSB_VSES1514_EN = 14
+} eEN_INT_SIGNAL_ERRLsb;
+
+typedef union
+{
+    HWREG_U16 EN_INT_SIGNAL_ERR_Content;
+    sEN_INT_SIGNAL_ERRStructure EN_INT_SIGNAL_ERR_Structure;
+} uEN_INT_SIGNAL_ERR;
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /** Set complete register EN_INT_SIGNAL_ERR */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_ERR(volatile sSdmmc *_sdmmc_); /** Get complete register EN_INT_SIGNAL_ERR */
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_ERR_CMD_TIMEOUT_ERR_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element CMD_TIMEOUT_ERR_EN of register EN_INT_SIGNAL_ERR */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_ERR_CMD_TIMEOUT_ERR_EN(volatile sSdmmc *_sdmmc_); /**< Get element CMD_TIMEOUT_ERR_EN of register EN_INT_SIGNAL_ERR */
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_ERR_CMD_CRC_ERR_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element CMD_CRC_ERR_EN of register EN_INT_SIGNAL_ERR */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_ERR_CMD_CRC_ERR_EN(volatile sSdmmc *_sdmmc_); /**< Get element CMD_CRC_ERR_EN of register EN_INT_SIGNAL_ERR */
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_ERR_CMD_END_BIT_ERR_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element CMD_END_BIT_ERR_EN of register EN_INT_SIGNAL_ERR */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_ERR_CMD_END_BIT_ERR_EN(volatile sSdmmc *_sdmmc_); /**< Get element CMD_END_BIT_ERR_EN of register EN_INT_SIGNAL_ERR */
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_ERR_CMD_IND_ERR_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element CMD_IND_ERR_EN of register EN_INT_SIGNAL_ERR */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_ERR_CMD_IND_ERR_EN(volatile sSdmmc *_sdmmc_); /**< Get element CMD_IND_ERR_EN of register EN_INT_SIGNAL_ERR */
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_ERR_DATA_TIMEOUT_ERR_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element DATA_TIMEOUT_ERR_EN of register EN_INT_SIGNAL_ERR */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_ERR_DATA_TIMEOUT_ERR_EN(volatile sSdmmc *_sdmmc_); /**< Get element DATA_TIMEOUT_ERR_EN of register EN_INT_SIGNAL_ERR */
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_ERR_DATA_CRC_ERR_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element DATA_CRC_ERR_EN of register EN_INT_SIGNAL_ERR */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_ERR_DATA_CRC_ERR_EN(volatile sSdmmc *_sdmmc_); /**< Get element DATA_CRC_ERR_EN of register EN_INT_SIGNAL_ERR */
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_ERR_DATA_END_BIT_ERR_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element DATA_END_BIT_ERR_EN of register EN_INT_SIGNAL_ERR */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_ERR_DATA_END_BIT_ERR_EN(volatile sSdmmc *_sdmmc_); /**< Get element DATA_END_BIT_ERR_EN of register EN_INT_SIGNAL_ERR */
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_ERR_CURRENT_LIMIT_ERR_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element CURRENT_LIMIT_ERR_EN of register EN_INT_SIGNAL_ERR */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_ERR_CURRENT_LIMIT_ERR_EN(volatile sSdmmc *_sdmmc_); /**< Get element CURRENT_LIMIT_ERR_EN of register EN_INT_SIGNAL_ERR */
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_ERR_ACMD_ERR_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element ACMD_ERR_EN of register EN_INT_SIGNAL_ERR */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_ERR_ACMD_ERR_EN(volatile sSdmmc *_sdmmc_); /**< Get element ACMD_ERR_EN of register EN_INT_SIGNAL_ERR */
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_ERR_ADMA_ERR_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element ADMA_ERR_EN of register EN_INT_SIGNAL_ERR */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_ERR_ADMA_ERR_EN(volatile sSdmmc *_sdmmc_); /**< Get element ADMA_ERR_EN of register EN_INT_SIGNAL_ERR */
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_ERR_TUNING_ERROR_SIG_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element TUNING_ERROR_SIG_EN of register EN_INT_SIGNAL_ERR */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_ERR_TUNING_ERROR_SIG_EN(volatile sSdmmc *_sdmmc_); /**< Get element TUNING_ERROR_SIG_EN of register EN_INT_SIGNAL_ERR */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_ERR_res11(volatile sSdmmc *_sdmmc_); /**< Get element res11 of register EN_INT_SIGNAL_ERR */
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_ERR_TARGET_RESP_ERR_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element TARGET_RESP_ERR_EN of register EN_INT_SIGNAL_ERR */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_ERR_TARGET_RESP_ERR_EN(volatile sSdmmc *_sdmmc_); /**< Get element TARGET_RESP_ERR_EN of register EN_INT_SIGNAL_ERR */
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_ERR_CEATA_ERR_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element CEATA_ERR_EN of register EN_INT_SIGNAL_ERR */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_ERR_CEATA_ERR_EN(volatile sSdmmc *_sdmmc_); /**< Get element CEATA_ERR_EN of register EN_INT_SIGNAL_ERR */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_ERR_VSES1514_EN(volatile sSdmmc *_sdmmc_); /**< Get element VSES1514_EN of register EN_INT_SIGNAL_ERR */
+
+
+/** @brief ACMD12_ERR_STATUS register description at address offset 0x3c
+  *
+  *  ACMD12 Error status register
+  */
+typedef struct
+{
+    const HWREG_U16 ACMD12_NOT_EXEC_ERR :1; /**<  */
+    const HWREG_U16 ACMD12_TIMEOUT_ERR :1; /**<  */
+    const HWREG_U16 ACMD12_CRC_ERR :1; /**<  */
+    const HWREG_U16 ACMD12_END_BIT_ERR :1; /**<  */
+    const HWREG_U16 ACMD12_IND_ERR :1; /**<  */
+    const HWREG_U16 res0605 :2; /**<  */
+    const HWREG_U16 CMD_NOT_ISSUED_BY_ACMD12_ERR :1; /**<  */
+    const HWREG_U16 res1508 :8; /**<  */
+} sACMD12_ERR_STATUSStructure;
+
+
+/** @brief ACMD12_ERR_STATUS Bitfield widths 
+*/
+#define lenACMD12_ERR_STATUS_ACMD12_NOT_EXEC_ERR 1
+#define lenACMD12_ERR_STATUS_ACMD12_TIMEOUT_ERR 1
+#define lenACMD12_ERR_STATUS_ACMD12_CRC_ERR 1
+#define lenACMD12_ERR_STATUS_ACMD12_END_BIT_ERR 1
+#define lenACMD12_ERR_STATUS_ACMD12_IND_ERR 1
+#define lenACMD12_ERR_STATUS_RES0605 2
+#define lenACMD12_ERR_STATUS_CMD_NOT_ISSUED_BY_ACMD12_ERR 1
+#define lenACMD12_ERR_STATUS_RES1508 8
+
+typedef enum
+{
+    ACMD12_ERR_STATUS_LSB_ACMD12_NOT_EXEC_ERR = 0,
+    ACMD12_ERR_STATUS_LSB_ACMD12_TIMEOUT_ERR = 1,
+    ACMD12_ERR_STATUS_LSB_ACMD12_CRC_ERR = 2,
+    ACMD12_ERR_STATUS_LSB_ACMD12_END_BIT_ERR = 3,
+    ACMD12_ERR_STATUS_LSB_ACMD12_IND_ERR = 4,
+    ACMD12_ERR_STATUS_LSB_RES0605 = 5,
+    ACMD12_ERR_STATUS_LSB_CMD_NOT_ISSUED_BY_ACMD12_ERR = 7,
+    ACMD12_ERR_STATUS_LSB_RES1508 = 8
+} eACMD12_ERR_STATUSLsb;
+
+typedef union
+{
+    HWREG_U16 ACMD12_ERR_STATUS_Content;
+    sACMD12_ERR_STATUSStructure ACMD12_ERR_STATUS_Structure;
+} uACMD12_ERR_STATUS;
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_ACMD12_ERR_STATUS(volatile sSdmmc *_sdmmc_); /** Get complete register ACMD12_ERR_STATUS */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_ACMD12_ERR_STATUS_ACMD12_NOT_EXEC_ERR(volatile sSdmmc *_sdmmc_); /**< Get element ACMD12_NOT_EXEC_ERR of register ACMD12_ERR_STATUS */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_ACMD12_ERR_STATUS_ACMD12_TIMEOUT_ERR(volatile sSdmmc *_sdmmc_); /**< Get element ACMD12_TIMEOUT_ERR of register ACMD12_ERR_STATUS */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_ACMD12_ERR_STATUS_ACMD12_CRC_ERR(volatile sSdmmc *_sdmmc_); /**< Get element ACMD12_CRC_ERR of register ACMD12_ERR_STATUS */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_ACMD12_ERR_STATUS_ACMD12_END_BIT_ERR(volatile sSdmmc *_sdmmc_); /**< Get element ACMD12_END_BIT_ERR of register ACMD12_ERR_STATUS */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_ACMD12_ERR_STATUS_ACMD12_IND_ERR(volatile sSdmmc *_sdmmc_); /**< Get element ACMD12_IND_ERR of register ACMD12_ERR_STATUS */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_ACMD12_ERR_STATUS_res0605(volatile sSdmmc *_sdmmc_); /**< Get element res0605 of register ACMD12_ERR_STATUS */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_ACMD12_ERR_STATUS_CMD_NOT_ISSUED_BY_ACMD12_ERR(volatile sSdmmc *_sdmmc_); /**< Get element CMD_NOT_ISSUED_BY_ACMD12_ERR of register ACMD12_ERR_STATUS */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_ACMD12_ERR_STATUS_res1508(volatile sSdmmc *_sdmmc_); /**< Get element res1508 of register ACMD12_ERR_STATUS */
+
+
+/** @brief HOST_CTRL2 register description at address offset 0x3e
+  *
+  *  Host control 2 register
+  */
+typedef struct
+{
+    HWREG_U16 UHS_MODE_SEL :3; /**<  */
+    HWREG_U16 SIG18_EN :1; /**<  */
+    HWREG_U16 DRV_STR_SEL :2; /**<  */
+    HWREG_U16 EXECUTE_TUNING :1; /**<  */
+    HWREG_U16 SAMPLING_CLK_SEL :1; /**<  */
+    const HWREG_U16 res1308 :6; /**<  */
+    HWREG_U16 ASYNC_INT_EN :1; /**<  */
+    HWREG_U16 PRESET_VAL_EN :1; /**<  */
+} sHOST_CTRL2Structure;
+
+
+/** @brief HOST_CTRL2 Bitfield widths 
+*/
+#define lenHOST_CTRL2_UHS_MODE_SEL 3
+#define lenHOST_CTRL2_SIG18_EN 1
+#define lenHOST_CTRL2_DRV_STR_SEL 2
+#define lenHOST_CTRL2_EXECUTE_TUNING 1
+#define lenHOST_CTRL2_SAMPLING_CLK_SEL 1
+#define lenHOST_CTRL2_RES1308 6
+#define lenHOST_CTRL2_ASYNC_INT_EN 1
+#define lenHOST_CTRL2_PRESET_VAL_EN 1
+
+typedef enum
+{
+    HOST_CTRL2_LSB_UHS_MODE_SEL = 0,
+    HOST_CTRL2_LSB_SIG18_EN = 3,
+    HOST_CTRL2_LSB_DRV_STR_SEL = 4,
+    HOST_CTRL2_LSB_EXECUTE_TUNING = 6,
+    HOST_CTRL2_LSB_SAMPLING_CLK_SEL = 7,
+    HOST_CTRL2_LSB_RES1308 = 8,
+    HOST_CTRL2_LSB_ASYNC_INT_EN = 14,
+    HOST_CTRL2_LSB_PRESET_VAL_EN = 15
+} eHOST_CTRL2Lsb;
+
+typedef union
+{
+    HWREG_U16 HOST_CTRL2_Content;
+    sHOST_CTRL2Structure HOST_CTRL2_Structure;
+} uHOST_CTRL2;
+
+__HWREG_INLINE__ void setSdmmc_HOST_CTRL2(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /** Set complete register HOST_CTRL2 */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_HOST_CTRL2(volatile sSdmmc *_sdmmc_); /** Get complete register HOST_CTRL2 */
+__HWREG_INLINE__ void setSdmmc_HOST_CTRL2_UHS_MODE_SEL(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element UHS_MODE_SEL of register HOST_CTRL2 */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_HOST_CTRL2_UHS_MODE_SEL(volatile sSdmmc *_sdmmc_); /**< Get element UHS_MODE_SEL of register HOST_CTRL2 */
+__HWREG_INLINE__ void setSdmmc_HOST_CTRL2_SIG18_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element SIG18_EN of register HOST_CTRL2 */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_HOST_CTRL2_SIG18_EN(volatile sSdmmc *_sdmmc_); /**< Get element SIG18_EN of register HOST_CTRL2 */
+__HWREG_INLINE__ void setSdmmc_HOST_CTRL2_DRV_STR_SEL(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element DRV_STR_SEL of register HOST_CTRL2 */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_HOST_CTRL2_DRV_STR_SEL(volatile sSdmmc *_sdmmc_); /**< Get element DRV_STR_SEL of register HOST_CTRL2 */
+__HWREG_INLINE__ void setSdmmc_HOST_CTRL2_EXECUTE_TUNING(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element EXECUTE_TUNING of register HOST_CTRL2 */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_HOST_CTRL2_EXECUTE_TUNING(volatile sSdmmc *_sdmmc_); /**< Get element EXECUTE_TUNING of register HOST_CTRL2 */
+__HWREG_INLINE__ void setSdmmc_HOST_CTRL2_SAMPLING_CLK_SEL(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element SAMPLING_CLK_SEL of register HOST_CTRL2 */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_HOST_CTRL2_SAMPLING_CLK_SEL(volatile sSdmmc *_sdmmc_); /**< Get element SAMPLING_CLK_SEL of register HOST_CTRL2 */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_HOST_CTRL2_res1308(volatile sSdmmc *_sdmmc_); /**< Get element res1308 of register HOST_CTRL2 */
+__HWREG_INLINE__ void setSdmmc_HOST_CTRL2_ASYNC_INT_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element ASYNC_INT_EN of register HOST_CTRL2 */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_HOST_CTRL2_ASYNC_INT_EN(volatile sSdmmc *_sdmmc_); /**< Get element ASYNC_INT_EN of register HOST_CTRL2 */
+__HWREG_INLINE__ void setSdmmc_HOST_CTRL2_PRESET_VAL_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element PRESET_VAL_EN of register HOST_CTRL2 */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_HOST_CTRL2_PRESET_VAL_EN(volatile sSdmmc *_sdmmc_); /**< Get element PRESET_VAL_EN of register HOST_CTRL2 */
+
+
+/** @brief CAPABILITIES register description at address offset 0x40
+  *
+  *  Capabilities Register
+  */
+typedef struct
+{
+    const HWREG_U32 TIMEOUT_CLOCK_FREQ :6; /**<  */
+    const HWREG_U32 :1; /**< Unused bitfield */
+    const HWREG_U32 TIMEOUT_CLOCK_UNIT :1; /**<  */
+    const HWREG_U32 BASE_SD_CLOCK_FREQ :8; /**<  */
+    const HWREG_U32 MAX_BLOCK_LENGTH :2; /**<  */
+    const HWREG_U32 EXT_MEDIA_BUS_SUPPORT :1; /**<  */
+    const HWREG_U32 ADMA2_SUPPORT :1; /**<  */
+    const HWREG_U32 :1; /**< Unused bitfield */
+    const HWREG_U32 HIGH_SPEED_SUPPORT :1; /**<  */
+    const HWREG_U32 SDMA_SUPPORT :1; /**<  */
+    const HWREG_U32 SUSPEND_RESUME_SUPPORT :1; /**<  */
+    const HWREG_U32 VOLTAGE_SUPPORT_3_3V :1; /**<  */
+    const HWREG_U32 VOLTAGE_SUPPORT_3V :1; /**<  */
+    const HWREG_U32 VOLTAGE_SUPPORT_1_8V :1; /**<  */
+    const HWREG_U32 :1; /**< Unused bitfield */
+    const HWREG_U32 SYSBUS_64_SUPPORT :1; /**<  */
+    const HWREG_U32 ASYNC_INT_SUPPORT :1; /**<  */
+    const HWREG_U32 SLOT_TYPE :2; /**<  */
+} sCAPABILITIESStructure;
+
+
+/** @brief CAPABILITIES Bitfield widths 
+*/
+#define lenCAPABILITIES_TIMEOUT_CLOCK_FREQ 6
+#define lenCAPABILITIES_TIMEOUT_CLOCK_UNIT 1
+#define lenCAPABILITIES_BASE_SD_CLOCK_FREQ 8
+#define lenCAPABILITIES_MAX_BLOCK_LENGTH 2
+#define lenCAPABILITIES_EXT_MEDIA_BUS_SUPPORT 1
+#define lenCAPABILITIES_ADMA2_SUPPORT 1
+#define lenCAPABILITIES_HIGH_SPEED_SUPPORT 1
+#define lenCAPABILITIES_SDMA_SUPPORT 1
+#define lenCAPABILITIES_SUSPEND_RESUME_SUPPORT 1
+#define lenCAPABILITIES_VOLTAGE_SUPPORT_3_3V 1
+#define lenCAPABILITIES_VOLTAGE_SUPPORT_3V 1
+#define lenCAPABILITIES_VOLTAGE_SUPPORT_1_8V 1
+#define lenCAPABILITIES_SYSBUS_64_SUPPORT 1
+#define lenCAPABILITIES_ASYNC_INT_SUPPORT 1
+#define lenCAPABILITIES_SLOT_TYPE 2
+
+typedef enum
+{
+    CAPABILITIES_LSB_TIMEOUT_CLOCK_FREQ = 0,
+    CAPABILITIES_LSB_TIMEOUT_CLOCK_UNIT = 7,
+    CAPABILITIES_LSB_BASE_SD_CLOCK_FREQ = 8,
+    CAPABILITIES_LSB_MAX_BLOCK_LENGTH = 16,
+    CAPABILITIES_LSB_EXT_MEDIA_BUS_SUPPORT = 18,
+    CAPABILITIES_LSB_ADMA2_SUPPORT = 19,
+    CAPABILITIES_LSB_HIGH_SPEED_SUPPORT = 21,
+    CAPABILITIES_LSB_SDMA_SUPPORT = 22,
+    CAPABILITIES_LSB_SUSPEND_RESUME_SUPPORT = 23,
+    CAPABILITIES_LSB_VOLTAGE_SUPPORT_3_3V = 24,
+    CAPABILITIES_LSB_VOLTAGE_SUPPORT_3V = 25,
+    CAPABILITIES_LSB_VOLTAGE_SUPPORT_1_8V = 26,
+    CAPABILITIES_LSB_SYSBUS_64_SUPPORT = 28,
+    CAPABILITIES_LSB_ASYNC_INT_SUPPORT = 29,
+    CAPABILITIES_LSB_SLOT_TYPE = 30
+} eCAPABILITIESLsb;
+
+typedef union
+{
+    HWREG_U32 CAPABILITIES_Content;
+    sCAPABILITIESStructure CAPABILITIES_Structure;
+} uCAPABILITIES;
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_CAPABILITIES(volatile sSdmmc *_sdmmc_); /** Get complete register CAPABILITIES */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_CAPABILITIES_TIMEOUT_CLOCK_FREQ(volatile sSdmmc *_sdmmc_); /**< Get element TIMEOUT_CLOCK_FREQ of register CAPABILITIES */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_CAPABILITIES_TIMEOUT_CLOCK_UNIT(volatile sSdmmc *_sdmmc_); /**< Get element TIMEOUT_CLOCK_UNIT of register CAPABILITIES */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_CAPABILITIES_BASE_SD_CLOCK_FREQ(volatile sSdmmc *_sdmmc_); /**< Get element BASE_SD_CLOCK_FREQ of register CAPABILITIES */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_CAPABILITIES_MAX_BLOCK_LENGTH(volatile sSdmmc *_sdmmc_); /**< Get element MAX_BLOCK_LENGTH of register CAPABILITIES */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_CAPABILITIES_EXT_MEDIA_BUS_SUPPORT(volatile sSdmmc *_sdmmc_); /**< Get element EXT_MEDIA_BUS_SUPPORT of register CAPABILITIES */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_CAPABILITIES_ADMA2_SUPPORT(volatile sSdmmc *_sdmmc_); /**< Get element ADMA2_SUPPORT of register CAPABILITIES */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_CAPABILITIES_HIGH_SPEED_SUPPORT(volatile sSdmmc *_sdmmc_); /**< Get element HIGH_SPEED_SUPPORT of register CAPABILITIES */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_CAPABILITIES_SDMA_SUPPORT(volatile sSdmmc *_sdmmc_); /**< Get element SDMA_SUPPORT of register CAPABILITIES */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_CAPABILITIES_SUSPEND_RESUME_SUPPORT(volatile sSdmmc *_sdmmc_); /**< Get element SUSPEND_RESUME_SUPPORT of register CAPABILITIES */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_CAPABILITIES_VOLTAGE_SUPPORT_3_3V(volatile sSdmmc *_sdmmc_); /**< Get element VOLTAGE_SUPPORT_3_3V of register CAPABILITIES */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_CAPABILITIES_VOLTAGE_SUPPORT_3V(volatile sSdmmc *_sdmmc_); /**< Get element VOLTAGE_SUPPORT_3V of register CAPABILITIES */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_CAPABILITIES_VOLTAGE_SUPPORT_1_8V(volatile sSdmmc *_sdmmc_); /**< Get element VOLTAGE_SUPPORT_1_8V of register CAPABILITIES */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_CAPABILITIES_SYSBUS_64_SUPPORT(volatile sSdmmc *_sdmmc_); /**< Get element SYSBUS_64_SUPPORT of register CAPABILITIES */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_CAPABILITIES_ASYNC_INT_SUPPORT(volatile sSdmmc *_sdmmc_); /**< Get element ASYNC_INT_SUPPORT of register CAPABILITIES */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_CAPABILITIES_SLOT_TYPE(volatile sSdmmc *_sdmmc_); /**< Get element SLOT_TYPE of register CAPABILITIES */
+
+
+/** @brief CAPABILITIES_HI register description at address offset 0x44
+  *
+  *  Capabilities Register hi
+  */
+typedef struct
+{
+    const HWREG_U32 SDR50_SUPPORT :1; /**<  */
+    const HWREG_U32 SDR104_SUPPORT :1; /**<  */
+    const HWREG_U32 DDR50_SUPPORT :1; /**<  */
+    const HWREG_U32 :1; /**< Unused bitfield */
+    const HWREG_U32 DRV_A_SUPPORT :1; /**<  */
+    const HWREG_U32 DRV_C_SUPPORT :1; /**<  */
+    const HWREG_U32 DRV_D_SUPPORT :1; /**<  */
+    const HWREG_U32 :1; /**< Unused bitfield */
+    const HWREG_U32 TIM_CNT_RETUNE :4; /**<  */
+    const HWREG_U32 :1; /**< Unused bitfield */
+    const HWREG_U32 USE_TUNING_SDR50 :1; /**<  */
+    const HWREG_U32 RE_TUNING_MODES :2; /**<  */
+    const HWREG_U32 CLK_MULT :8; /**<  */
+    const HWREG_U32 SPI_MODE_SUP :1; /**<  */
+    const HWREG_U32 SPI_BLOCK_MODE_SUP :1; /**<  */
+    const HWREG_U32 :6; /**< Unused bitfield */
+} sCAPABILITIES_HIStructure;
+
+
+/** @brief CAPABILITIES_HI Bitfield widths 
+*/
+#define lenCAPABILITIES_HI_SDR50_SUPPORT 1
+#define lenCAPABILITIES_HI_SDR104_SUPPORT 1
+#define lenCAPABILITIES_HI_DDR50_SUPPORT 1
+#define lenCAPABILITIES_HI_DRV_A_SUPPORT 1
+#define lenCAPABILITIES_HI_DRV_C_SUPPORT 1
+#define lenCAPABILITIES_HI_DRV_D_SUPPORT 1
+#define lenCAPABILITIES_HI_TIM_CNT_RETUNE 4
+#define lenCAPABILITIES_HI_USE_TUNING_SDR50 1
+#define lenCAPABILITIES_HI_RE_TUNING_MODES 2
+#define lenCAPABILITIES_HI_CLK_MULT 8
+#define lenCAPABILITIES_HI_SPI_MODE_SUP 1
+#define lenCAPABILITIES_HI_SPI_BLOCK_MODE_SUP 1
+
+typedef enum
+{
+    CAPABILITIES_HI_LSB_SDR50_SUPPORT = 0,
+    CAPABILITIES_HI_LSB_SDR104_SUPPORT = 1,
+    CAPABILITIES_HI_LSB_DDR50_SUPPORT = 2,
+    CAPABILITIES_HI_LSB_DRV_A_SUPPORT = 4,
+    CAPABILITIES_HI_LSB_DRV_C_SUPPORT = 5,
+    CAPABILITIES_HI_LSB_DRV_D_SUPPORT = 6,
+    CAPABILITIES_HI_LSB_TIM_CNT_RETUNE = 8,
+    CAPABILITIES_HI_LSB_USE_TUNING_SDR50 = 13,
+    CAPABILITIES_HI_LSB_RE_TUNING_MODES = 14,
+    CAPABILITIES_HI_LSB_CLK_MULT = 16,
+    CAPABILITIES_HI_LSB_SPI_MODE_SUP = 24,
+    CAPABILITIES_HI_LSB_SPI_BLOCK_MODE_SUP = 25
+} eCAPABILITIES_HILsb;
+
+typedef union
+{
+    HWREG_U32 CAPABILITIES_HI_Content;
+    sCAPABILITIES_HIStructure CAPABILITIES_HI_Structure;
+} uCAPABILITIES_HI;
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_CAPABILITIES_HI(volatile sSdmmc *_sdmmc_); /** Get complete register CAPABILITIES_HI */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_CAPABILITIES_HI_SDR50_SUPPORT(volatile sSdmmc *_sdmmc_); /**< Get element SDR50_SUPPORT of register CAPABILITIES_HI */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_CAPABILITIES_HI_SDR104_SUPPORT(volatile sSdmmc *_sdmmc_); /**< Get element SDR104_SUPPORT of register CAPABILITIES_HI */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_CAPABILITIES_HI_DDR50_SUPPORT(volatile sSdmmc *_sdmmc_); /**< Get element DDR50_SUPPORT of register CAPABILITIES_HI */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_CAPABILITIES_HI_DRV_A_SUPPORT(volatile sSdmmc *_sdmmc_); /**< Get element DRV_A_SUPPORT of register CAPABILITIES_HI */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_CAPABILITIES_HI_DRV_C_SUPPORT(volatile sSdmmc *_sdmmc_); /**< Get element DRV_C_SUPPORT of register CAPABILITIES_HI */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_CAPABILITIES_HI_DRV_D_SUPPORT(volatile sSdmmc *_sdmmc_); /**< Get element DRV_D_SUPPORT of register CAPABILITIES_HI */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_CAPABILITIES_HI_TIM_CNT_RETUNE(volatile sSdmmc *_sdmmc_); /**< Get element TIM_CNT_RETUNE of register CAPABILITIES_HI */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_CAPABILITIES_HI_USE_TUNING_SDR50(volatile sSdmmc *_sdmmc_); /**< Get element USE_TUNING_SDR50 of register CAPABILITIES_HI */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_CAPABILITIES_HI_RE_TUNING_MODES(volatile sSdmmc *_sdmmc_); /**< Get element RE_TUNING_MODES of register CAPABILITIES_HI */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_CAPABILITIES_HI_CLK_MULT(volatile sSdmmc *_sdmmc_); /**< Get element CLK_MULT of register CAPABILITIES_HI */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_CAPABILITIES_HI_SPI_MODE_SUP(volatile sSdmmc *_sdmmc_); /**< Get element SPI_MODE_SUP of register CAPABILITIES_HI */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_CAPABILITIES_HI_SPI_BLOCK_MODE_SUP(volatile sSdmmc *_sdmmc_); /**< Get element SPI_BLOCK_MODE_SUP of register CAPABILITIES_HI */
+
+
+/** @brief MAX_CURRENT_CAP register description at address offset 0x48
+  *
+  *  
+  */
+typedef struct
+{
+    const HWREG_U32 MAX_CURRENT_FOR_3_3V :8; /**<  */
+    const HWREG_U32 MAX_CURRENT_FOR_3_0V :8; /**<  */
+    const HWREG_U32 MAX_CURRENT_FOR_1_8V :8; /**<  */
+    const HWREG_U32 :8; /**< Unused bitfield */
+} sMAX_CURRENT_CAPStructure;
+
+
+/** @brief MAX_CURRENT_CAP Bitfield widths 
+*/
+#define lenMAX_CURRENT_CAP_MAX_CURRENT_FOR_3_3V 8
+#define lenMAX_CURRENT_CAP_MAX_CURRENT_FOR_3_0V 8
+#define lenMAX_CURRENT_CAP_MAX_CURRENT_FOR_1_8V 8
+
+typedef enum
+{
+    MAX_CURRENT_CAP_LSB_MAX_CURRENT_FOR_3_3V = 0,
+    MAX_CURRENT_CAP_LSB_MAX_CURRENT_FOR_3_0V = 8,
+    MAX_CURRENT_CAP_LSB_MAX_CURRENT_FOR_1_8V = 16
+} eMAX_CURRENT_CAPLsb;
+
+typedef union
+{
+    HWREG_U32 MAX_CURRENT_CAP_Content;
+    sMAX_CURRENT_CAPStructure MAX_CURRENT_CAP_Structure;
+} uMAX_CURRENT_CAP;
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_MAX_CURRENT_CAP(volatile sSdmmc *_sdmmc_); /** Get complete register MAX_CURRENT_CAP */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_MAX_CURRENT_CAP_MAX_CURRENT_FOR_3_3V(volatile sSdmmc *_sdmmc_); /**< Get element MAX_CURRENT_FOR_3_3V of register MAX_CURRENT_CAP */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_MAX_CURRENT_CAP_MAX_CURRENT_FOR_3_0V(volatile sSdmmc *_sdmmc_); /**< Get element MAX_CURRENT_FOR_3_0V of register MAX_CURRENT_CAP */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_MAX_CURRENT_CAP_MAX_CURRENT_FOR_1_8V(volatile sSdmmc *_sdmmc_); /**< Get element MAX_CURRENT_FOR_1_8V of register MAX_CURRENT_CAP */
+
+
+/** @brief MAX_CURRENT_CAP_res register description at address offset 0x4c
+  *
+  *  
+  */
+typedef struct
+{
+    const HWREG_U32 res :32; /**<  */
+} sMAX_CURRENT_CAP_resStructure;
+
+
+/** @brief MAX_CURRENT_CAP_RES Bitfield widths 
+*/
+#define lenMAX_CURRENT_CAP_RES_RES 32
+
+typedef enum
+{
+    MAX_CURRENT_CAP_RES_LSB_RES = 0
+} eMAX_CURRENT_CAP_resLsb;
+
+typedef union
+{
+    HWREG_U32 MAX_CURRENT_CAP_res_Content;
+    sMAX_CURRENT_CAP_resStructure MAX_CURRENT_CAP_res_Structure;
+} uMAX_CURRENT_CAP_res;
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_MAX_CURRENT_CAP_res(volatile sSdmmc *_sdmmc_); /** Get complete register MAX_CURRENT_CAP_res */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_MAX_CURRENT_CAP_res_res(volatile sSdmmc *_sdmmc_); /**< Get element res of register MAX_CURRENT_CAP_res */
+
+
+/** @brief FORCE_EVENT_ACMD_ERR_STATUS register description at address offset 0x50
+  *
+  *  
+  */
+typedef struct
+{
+    HWREG_U16 FE_ACMD12_NOT_EXEC :1; /**<  */
+    HWREG_U16 FE_ACMD12_TIMEOUT_ERR :1; /**<  */
+    HWREG_U16 FE_ACMD12_CRC_ERR :1; /**<  */
+    HWREG_U16 FE_ACMD12_END_BIT_ERR :1; /**<  */
+    HWREG_U16 FE_ACMD12_IND_ERR :1; /**<  */
+    const HWREG_U16 res0605 :2; /**<  */
+    HWREG_U16 FE_CMD_NOT_ISSUED_ACMD12_ERR :1; /**<  */
+    const HWREG_U16 res0815 :8; /**<  */
+} sFORCE_EVENT_ACMD_ERR_STATUSStructure;
+
+
+/** @brief FORCE_EVENT_ACMD_ERR_STATUS Bitfield widths 
+*/
+#define lenFORCE_EVENT_ACMD_ERR_STATUS_FE_ACMD12_NOT_EXEC 1
+#define lenFORCE_EVENT_ACMD_ERR_STATUS_FE_ACMD12_TIMEOUT_ERR 1
+#define lenFORCE_EVENT_ACMD_ERR_STATUS_FE_ACMD12_CRC_ERR 1
+#define lenFORCE_EVENT_ACMD_ERR_STATUS_FE_ACMD12_END_BIT_ERR 1
+#define lenFORCE_EVENT_ACMD_ERR_STATUS_FE_ACMD12_IND_ERR 1
+#define lenFORCE_EVENT_ACMD_ERR_STATUS_RES0605 2
+#define lenFORCE_EVENT_ACMD_ERR_STATUS_FE_CMD_NOT_ISSUED_ACMD12_ERR 1
+#define lenFORCE_EVENT_ACMD_ERR_STATUS_RES0815 8
+
+typedef enum
+{
+    FORCE_EVENT_ACMD_ERR_STATUS_LSB_FE_ACMD12_NOT_EXEC = 0,
+    FORCE_EVENT_ACMD_ERR_STATUS_LSB_FE_ACMD12_TIMEOUT_ERR = 1,
+    FORCE_EVENT_ACMD_ERR_STATUS_LSB_FE_ACMD12_CRC_ERR = 2,
+    FORCE_EVENT_ACMD_ERR_STATUS_LSB_FE_ACMD12_END_BIT_ERR = 3,
+    FORCE_EVENT_ACMD_ERR_STATUS_LSB_FE_ACMD12_IND_ERR = 4,
+    FORCE_EVENT_ACMD_ERR_STATUS_LSB_RES0605 = 5,
+    FORCE_EVENT_ACMD_ERR_STATUS_LSB_FE_CMD_NOT_ISSUED_ACMD12_ERR = 7,
+    FORCE_EVENT_ACMD_ERR_STATUS_LSB_RES0815 = 8
+} eFORCE_EVENT_ACMD_ERR_STATUSLsb;
+
+typedef union
+{
+    HWREG_U16 FORCE_EVENT_ACMD_ERR_STATUS_Content;
+    sFORCE_EVENT_ACMD_ERR_STATUSStructure FORCE_EVENT_ACMD_ERR_STATUS_Structure;
+} uFORCE_EVENT_ACMD_ERR_STATUS;
+
+__HWREG_INLINE__ void setSdmmc_FORCE_EVENT_ACMD_ERR_STATUS(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /** Set complete register FORCE_EVENT_ACMD_ERR_STATUS */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_FORCE_EVENT_ACMD_ERR_STATUS(volatile sSdmmc *_sdmmc_); /** Get complete register FORCE_EVENT_ACMD_ERR_STATUS */
+__HWREG_INLINE__ void setSdmmc_FORCE_EVENT_ACMD_ERR_STATUS_FE_ACMD12_NOT_EXEC(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element FE_ACMD12_NOT_EXEC of register FORCE_EVENT_ACMD_ERR_STATUS */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_FORCE_EVENT_ACMD_ERR_STATUS_FE_ACMD12_NOT_EXEC(volatile sSdmmc *_sdmmc_); /**< Get element FE_ACMD12_NOT_EXEC of register FORCE_EVENT_ACMD_ERR_STATUS */
+__HWREG_INLINE__ void setSdmmc_FORCE_EVENT_ACMD_ERR_STATUS_FE_ACMD12_TIMEOUT_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element FE_ACMD12_TIMEOUT_ERR of register FORCE_EVENT_ACMD_ERR_STATUS */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_FORCE_EVENT_ACMD_ERR_STATUS_FE_ACMD12_TIMEOUT_ERR(volatile sSdmmc *_sdmmc_); /**< Get element FE_ACMD12_TIMEOUT_ERR of register FORCE_EVENT_ACMD_ERR_STATUS */
+__HWREG_INLINE__ void setSdmmc_FORCE_EVENT_ACMD_ERR_STATUS_FE_ACMD12_CRC_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element FE_ACMD12_CRC_ERR of register FORCE_EVENT_ACMD_ERR_STATUS */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_FORCE_EVENT_ACMD_ERR_STATUS_FE_ACMD12_CRC_ERR(volatile sSdmmc *_sdmmc_); /**< Get element FE_ACMD12_CRC_ERR of register FORCE_EVENT_ACMD_ERR_STATUS */
+__HWREG_INLINE__ void setSdmmc_FORCE_EVENT_ACMD_ERR_STATUS_FE_ACMD12_END_BIT_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element FE_ACMD12_END_BIT_ERR of register FORCE_EVENT_ACMD_ERR_STATUS */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_FORCE_EVENT_ACMD_ERR_STATUS_FE_ACMD12_END_BIT_ERR(volatile sSdmmc *_sdmmc_); /**< Get element FE_ACMD12_END_BIT_ERR of register FORCE_EVENT_ACMD_ERR_STATUS */
+__HWREG_INLINE__ void setSdmmc_FORCE_EVENT_ACMD_ERR_STATUS_FE_ACMD12_IND_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element FE_ACMD12_IND_ERR of register FORCE_EVENT_ACMD_ERR_STATUS */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_FORCE_EVENT_ACMD_ERR_STATUS_FE_ACMD12_IND_ERR(volatile sSdmmc *_sdmmc_); /**< Get element FE_ACMD12_IND_ERR of register FORCE_EVENT_ACMD_ERR_STATUS */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_FORCE_EVENT_ACMD_ERR_STATUS_res0605(volatile sSdmmc *_sdmmc_); /**< Get element res0605 of register FORCE_EVENT_ACMD_ERR_STATUS */
+__HWREG_INLINE__ void setSdmmc_FORCE_EVENT_ACMD_ERR_STATUS_FE_CMD_NOT_ISSUED_ACMD12_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element FE_CMD_NOT_ISSUED_ACMD12_ERR of register FORCE_EVENT_ACMD_ERR_STATUS */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_FORCE_EVENT_ACMD_ERR_STATUS_FE_CMD_NOT_ISSUED_ACMD12_ERR(volatile sSdmmc *_sdmmc_); /**< Get element FE_CMD_NOT_ISSUED_ACMD12_ERR of register FORCE_EVENT_ACMD_ERR_STATUS */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_FORCE_EVENT_ACMD_ERR_STATUS_res0815(volatile sSdmmc *_sdmmc_); /**< Get element res0815 of register FORCE_EVENT_ACMD_ERR_STATUS */
+
+
+/** @brief FORCE_EVENT_ERR_STATUS register description at address offset 0x52
+  *
+  *  
+  */
+typedef struct
+{
+    HWREG_U16 FE_CMD_TIMEOUT_ERR :1; /**<  */
+    HWREG_U16 FE_CMD_CRC_ERR :1; /**<  */
+    HWREG_U16 FE_CMD_END_BIT_ERR :1; /**<  */
+    HWREG_U16 FE_CMD_IND_ERR :1; /**<  */
+    HWREG_U16 FE_DATA_TIMEOUT_ERR :1; /**<  */
+    HWREG_U16 FE_DATA_CRC_ERR :1; /**<  */
+    HWREG_U16 FE_DATA_END_BIT_ERR :1; /**<  */
+    HWREG_U16 FE_CURRENT_LIMIT_ERR :1; /**<  */
+    HWREG_U16 FE_ACMD12_ERR :1; /**<  */
+    HWREG_U16 FE_ADMA_ERR :1; /**<  */
+    const HWREG_U16 res1110 :2; /**<  */
+    HWREG_U16 FE_TARGET_RESPONSE_ERR :1; /**<  */
+    HWREG_U16 FE_CEATA_ERR :1; /**<  */
+    const HWREG_U16 FE_VENDOR_SPECIFIC_ERR_STATUS :2; /**<  */
+} sFORCE_EVENT_ERR_STATUSStructure;
+
+
+/** @brief FORCE_EVENT_ERR_STATUS Bitfield widths 
+*/
+#define lenFORCE_EVENT_ERR_STATUS_FE_CMD_TIMEOUT_ERR 1
+#define lenFORCE_EVENT_ERR_STATUS_FE_CMD_CRC_ERR 1
+#define lenFORCE_EVENT_ERR_STATUS_FE_CMD_END_BIT_ERR 1
+#define lenFORCE_EVENT_ERR_STATUS_FE_CMD_IND_ERR 1
+#define lenFORCE_EVENT_ERR_STATUS_FE_DATA_TIMEOUT_ERR 1
+#define lenFORCE_EVENT_ERR_STATUS_FE_DATA_CRC_ERR 1
+#define lenFORCE_EVENT_ERR_STATUS_FE_DATA_END_BIT_ERR 1
+#define lenFORCE_EVENT_ERR_STATUS_FE_CURRENT_LIMIT_ERR 1
+#define lenFORCE_EVENT_ERR_STATUS_FE_ACMD12_ERR 1
+#define lenFORCE_EVENT_ERR_STATUS_FE_ADMA_ERR 1
+#define lenFORCE_EVENT_ERR_STATUS_RES1110 2
+#define lenFORCE_EVENT_ERR_STATUS_FE_TARGET_RESPONSE_ERR 1
+#define lenFORCE_EVENT_ERR_STATUS_FE_CEATA_ERR 1
+#define lenFORCE_EVENT_ERR_STATUS_FE_VENDOR_SPECIFIC_ERR_STATUS 2
+
+typedef enum
+{
+    FORCE_EVENT_ERR_STATUS_LSB_FE_CMD_TIMEOUT_ERR = 0,
+    FORCE_EVENT_ERR_STATUS_LSB_FE_CMD_CRC_ERR = 1,
+    FORCE_EVENT_ERR_STATUS_LSB_FE_CMD_END_BIT_ERR = 2,
+    FORCE_EVENT_ERR_STATUS_LSB_FE_CMD_IND_ERR = 3,
+    FORCE_EVENT_ERR_STATUS_LSB_FE_DATA_TIMEOUT_ERR = 4,
+    FORCE_EVENT_ERR_STATUS_LSB_FE_DATA_CRC_ERR = 5,
+    FORCE_EVENT_ERR_STATUS_LSB_FE_DATA_END_BIT_ERR = 6,
+    FORCE_EVENT_ERR_STATUS_LSB_FE_CURRENT_LIMIT_ERR = 7,
+    FORCE_EVENT_ERR_STATUS_LSB_FE_ACMD12_ERR = 8,
+    FORCE_EVENT_ERR_STATUS_LSB_FE_ADMA_ERR = 9,
+    FORCE_EVENT_ERR_STATUS_LSB_RES1110 = 10,
+    FORCE_EVENT_ERR_STATUS_LSB_FE_TARGET_RESPONSE_ERR = 12,
+    FORCE_EVENT_ERR_STATUS_LSB_FE_CEATA_ERR = 13,
+    FORCE_EVENT_ERR_STATUS_LSB_FE_VENDOR_SPECIFIC_ERR_STATUS = 14
+} eFORCE_EVENT_ERR_STATUSLsb;
+
+typedef union
+{
+    HWREG_U16 FORCE_EVENT_ERR_STATUS_Content;
+    sFORCE_EVENT_ERR_STATUSStructure FORCE_EVENT_ERR_STATUS_Structure;
+} uFORCE_EVENT_ERR_STATUS;
+
+__HWREG_INLINE__ void setSdmmc_FORCE_EVENT_ERR_STATUS(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /** Set complete register FORCE_EVENT_ERR_STATUS */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_FORCE_EVENT_ERR_STATUS(volatile sSdmmc *_sdmmc_); /** Get complete register FORCE_EVENT_ERR_STATUS */
+__HWREG_INLINE__ void setSdmmc_FORCE_EVENT_ERR_STATUS_FE_CMD_TIMEOUT_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element FE_CMD_TIMEOUT_ERR of register FORCE_EVENT_ERR_STATUS */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_FORCE_EVENT_ERR_STATUS_FE_CMD_TIMEOUT_ERR(volatile sSdmmc *_sdmmc_); /**< Get element FE_CMD_TIMEOUT_ERR of register FORCE_EVENT_ERR_STATUS */
+__HWREG_INLINE__ void setSdmmc_FORCE_EVENT_ERR_STATUS_FE_CMD_CRC_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element FE_CMD_CRC_ERR of register FORCE_EVENT_ERR_STATUS */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_FORCE_EVENT_ERR_STATUS_FE_CMD_CRC_ERR(volatile sSdmmc *_sdmmc_); /**< Get element FE_CMD_CRC_ERR of register FORCE_EVENT_ERR_STATUS */
+__HWREG_INLINE__ void setSdmmc_FORCE_EVENT_ERR_STATUS_FE_CMD_END_BIT_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element FE_CMD_END_BIT_ERR of register FORCE_EVENT_ERR_STATUS */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_FORCE_EVENT_ERR_STATUS_FE_CMD_END_BIT_ERR(volatile sSdmmc *_sdmmc_); /**< Get element FE_CMD_END_BIT_ERR of register FORCE_EVENT_ERR_STATUS */
+__HWREG_INLINE__ void setSdmmc_FORCE_EVENT_ERR_STATUS_FE_CMD_IND_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element FE_CMD_IND_ERR of register FORCE_EVENT_ERR_STATUS */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_FORCE_EVENT_ERR_STATUS_FE_CMD_IND_ERR(volatile sSdmmc *_sdmmc_); /**< Get element FE_CMD_IND_ERR of register FORCE_EVENT_ERR_STATUS */
+__HWREG_INLINE__ void setSdmmc_FORCE_EVENT_ERR_STATUS_FE_DATA_TIMEOUT_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element FE_DATA_TIMEOUT_ERR of register FORCE_EVENT_ERR_STATUS */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_FORCE_EVENT_ERR_STATUS_FE_DATA_TIMEOUT_ERR(volatile sSdmmc *_sdmmc_); /**< Get element FE_DATA_TIMEOUT_ERR of register FORCE_EVENT_ERR_STATUS */
+__HWREG_INLINE__ void setSdmmc_FORCE_EVENT_ERR_STATUS_FE_DATA_CRC_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element FE_DATA_CRC_ERR of register FORCE_EVENT_ERR_STATUS */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_FORCE_EVENT_ERR_STATUS_FE_DATA_CRC_ERR(volatile sSdmmc *_sdmmc_); /**< Get element FE_DATA_CRC_ERR of register FORCE_EVENT_ERR_STATUS */
+__HWREG_INLINE__ void setSdmmc_FORCE_EVENT_ERR_STATUS_FE_DATA_END_BIT_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element FE_DATA_END_BIT_ERR of register FORCE_EVENT_ERR_STATUS */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_FORCE_EVENT_ERR_STATUS_FE_DATA_END_BIT_ERR(volatile sSdmmc *_sdmmc_); /**< Get element FE_DATA_END_BIT_ERR of register FORCE_EVENT_ERR_STATUS */
+__HWREG_INLINE__ void setSdmmc_FORCE_EVENT_ERR_STATUS_FE_CURRENT_LIMIT_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element FE_CURRENT_LIMIT_ERR of register FORCE_EVENT_ERR_STATUS */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_FORCE_EVENT_ERR_STATUS_FE_CURRENT_LIMIT_ERR(volatile sSdmmc *_sdmmc_); /**< Get element FE_CURRENT_LIMIT_ERR of register FORCE_EVENT_ERR_STATUS */
+__HWREG_INLINE__ void setSdmmc_FORCE_EVENT_ERR_STATUS_FE_ACMD12_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element FE_ACMD12_ERR of register FORCE_EVENT_ERR_STATUS */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_FORCE_EVENT_ERR_STATUS_FE_ACMD12_ERR(volatile sSdmmc *_sdmmc_); /**< Get element FE_ACMD12_ERR of register FORCE_EVENT_ERR_STATUS */
+__HWREG_INLINE__ void setSdmmc_FORCE_EVENT_ERR_STATUS_FE_ADMA_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element FE_ADMA_ERR of register FORCE_EVENT_ERR_STATUS */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_FORCE_EVENT_ERR_STATUS_FE_ADMA_ERR(volatile sSdmmc *_sdmmc_); /**< Get element FE_ADMA_ERR of register FORCE_EVENT_ERR_STATUS */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_FORCE_EVENT_ERR_STATUS_res1110(volatile sSdmmc *_sdmmc_); /**< Get element res1110 of register FORCE_EVENT_ERR_STATUS */
+__HWREG_INLINE__ void setSdmmc_FORCE_EVENT_ERR_STATUS_FE_TARGET_RESPONSE_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element FE_TARGET_RESPONSE_ERR of register FORCE_EVENT_ERR_STATUS */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_FORCE_EVENT_ERR_STATUS_FE_TARGET_RESPONSE_ERR(volatile sSdmmc *_sdmmc_); /**< Get element FE_TARGET_RESPONSE_ERR of register FORCE_EVENT_ERR_STATUS */
+__HWREG_INLINE__ void setSdmmc_FORCE_EVENT_ERR_STATUS_FE_CEATA_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value); /**< Set element FE_CEATA_ERR of register FORCE_EVENT_ERR_STATUS */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_FORCE_EVENT_ERR_STATUS_FE_CEATA_ERR(volatile sSdmmc *_sdmmc_); /**< Get element FE_CEATA_ERR of register FORCE_EVENT_ERR_STATUS */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_FORCE_EVENT_ERR_STATUS_FE_VENDOR_SPECIFIC_ERR_STATUS(volatile sSdmmc *_sdmmc_); /**< Get element FE_VENDOR_SPECIFIC_ERR_STATUS of register FORCE_EVENT_ERR_STATUS */
+
+
+/** @brief ADMA_ERR_STATUS register description at address offset 0x54
+  *
+  *  
+  */
+typedef struct
+{
+    const HWREG_U8 ADMA_ERR_STATE :2; /**<  */
+    HWREG_U8 ADMA_LENGTH_MISMATCH :1; /**<  */
+    const HWREG_U8 res73 :5; /**<  */
+} sADMA_ERR_STATUSStructure;
+
+
+/** @brief ADMA_ERR_STATUS Bitfield widths 
+*/
+#define lenADMA_ERR_STATUS_ADMA_ERR_STATE 2
+#define lenADMA_ERR_STATUS_ADMA_LENGTH_MISMATCH 1
+#define lenADMA_ERR_STATUS_RES73 5
+
+typedef enum
+{
+    ADMA_ERR_STATUS_LSB_ADMA_ERR_STATE = 0,
+    ADMA_ERR_STATUS_LSB_ADMA_LENGTH_MISMATCH = 2,
+    ADMA_ERR_STATUS_LSB_RES73 = 3
+} eADMA_ERR_STATUSLsb;
+
+typedef union
+{
+    HWREG_U8 ADMA_ERR_STATUS_Content;
+    sADMA_ERR_STATUSStructure ADMA_ERR_STATUS_Structure;
+} uADMA_ERR_STATUS;
+
+__HWREG_INLINE__ void setSdmmc_ADMA_ERR_STATUS(volatile sSdmmc *_sdmmc_, HWREG_U8 value); /** Set complete register ADMA_ERR_STATUS */
+__HWREG_INLINE__ HWREG_U8 getSdmmc_ADMA_ERR_STATUS(volatile sSdmmc *_sdmmc_); /** Get complete register ADMA_ERR_STATUS */
+__HWREG_INLINE__ HWREG_U8 getSdmmc_ADMA_ERR_STATUS_ADMA_ERR_STATE(volatile sSdmmc *_sdmmc_); /**< Get element ADMA_ERR_STATE of register ADMA_ERR_STATUS */
+__HWREG_INLINE__ void setSdmmc_ADMA_ERR_STATUS_ADMA_LENGTH_MISMATCH(volatile sSdmmc *_sdmmc_, HWREG_U8 value); /**< Set element ADMA_LENGTH_MISMATCH of register ADMA_ERR_STATUS */
+__HWREG_INLINE__ HWREG_U8 getSdmmc_ADMA_ERR_STATUS_ADMA_LENGTH_MISMATCH(volatile sSdmmc *_sdmmc_); /**< Get element ADMA_LENGTH_MISMATCH of register ADMA_ERR_STATUS */
+__HWREG_INLINE__ HWREG_U8 getSdmmc_ADMA_ERR_STATUS_res73(volatile sSdmmc *_sdmmc_); /**< Get element res73 of register ADMA_ERR_STATUS */
+
+
+/** @brief ADMA_ADDR_LOW register description at address offset 0x58
+  *
+  *  
+  */
+typedef struct
+{
+    HWREG_U32 ADMA_ADDR_LOW :32; /**<  */
+} sADMA_ADDR_LOWStructure;
+
+
+/** @brief ADMA_ADDR_LOW Bitfield widths 
+*/
+#define lenADMA_ADDR_LOW_ADMA_ADDR_LOW 32
+
+typedef enum
+{
+    ADMA_ADDR_LOW_LSB_ADMA_ADDR_LOW = 0
+} eADMA_ADDR_LOWLsb;
+
+typedef union
+{
+    HWREG_U32 ADMA_ADDR_LOW_Content;
+    sADMA_ADDR_LOWStructure ADMA_ADDR_LOW_Structure;
+} uADMA_ADDR_LOW;
+
+__HWREG_INLINE__ void setSdmmc_ADMA_ADDR_LOW(volatile sSdmmc *_sdmmc_, HWREG_U32 value); /** Set complete register ADMA_ADDR_LOW */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_ADMA_ADDR_LOW(volatile sSdmmc *_sdmmc_); /** Get complete register ADMA_ADDR_LOW */
+__HWREG_INLINE__ void setSdmmc_ADMA_ADDR_LOW_ADMA_ADDR_LOW(volatile sSdmmc *_sdmmc_, HWREG_U32 value); /**< Set element ADMA_ADDR_LOW of register ADMA_ADDR_LOW */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_ADMA_ADDR_LOW_ADMA_ADDR_LOW(volatile sSdmmc *_sdmmc_); /**< Get element ADMA_ADDR_LOW of register ADMA_ADDR_LOW */
+
+
+/** @brief ADMA_ADDR_HIGH register description at address offset 0x5c
+  *
+  *  
+  */
+typedef struct
+{
+    const HWREG_U32 Res0 :32; /**< Reserved bitfield */
+} sADMA_ADDR_HIGHStructure;
+
+
+/** @brief ADMA_ADDR_HIGH Bitfield widths 
+*/
+
+
+typedef union
+{
+    HWREG_U32 ADMA_ADDR_HIGH_Content;
+    sADMA_ADDR_HIGHStructure ADMA_ADDR_HIGH_Structure;
+} uADMA_ADDR_HIGH;
+
+
+
+/** @brief PRESET_VAL_REG_INIT register description at address offset 0x60
+  *
+  *  Preset Value for Initialization
+  */
+typedef struct
+{
+    const HWREG_U16 SDCLK_Frequency_Select_Value :10; /**<  */
+    const HWREG_U16 Clock_Generator_Select_Value :1; /**<  */
+    const HWREG_U16 :3; /**< Unused bitfield */
+    const HWREG_U16 Driver_Strength_Select_Value :2; /**<  */
+} sPRESET_VAL_REG_INITStructure;
+
+
+/** @brief PRESET_VAL_REG_INIT Bitfield widths 
+*/
+#define lenPRESET_VAL_REG_INIT_SDCLK_FREQUENCY_SELECT_VALUE 10
+#define lenPRESET_VAL_REG_INIT_CLOCK_GENERATOR_SELECT_VALUE 1
+#define lenPRESET_VAL_REG_INIT_DRIVER_STRENGTH_SELECT_VALUE 2
+
+typedef enum
+{
+    PRESET_VAL_REG_INIT_LSB_SDCLK_FREQUENCY_SELECT_VALUE = 0,
+    PRESET_VAL_REG_INIT_LSB_CLOCK_GENERATOR_SELECT_VALUE = 10,
+    PRESET_VAL_REG_INIT_LSB_DRIVER_STRENGTH_SELECT_VALUE = 14
+} ePRESET_VAL_REG_INITLsb;
+
+typedef union
+{
+    HWREG_U16 PRESET_VAL_REG_INIT_Content;
+    sPRESET_VAL_REG_INITStructure PRESET_VAL_REG_INIT_Structure;
+} uPRESET_VAL_REG_INIT;
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_INIT(volatile sSdmmc *_sdmmc_); /** Get complete register PRESET_VAL_REG_INIT */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_INIT_SDCLK_Frequency_Select_Value(volatile sSdmmc *_sdmmc_); /**< Get element SDCLK_Frequency_Select_Value of register PRESET_VAL_REG_INIT */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_INIT_Clock_Generator_Select_Value(volatile sSdmmc *_sdmmc_); /**< Get element Clock_Generator_Select_Value of register PRESET_VAL_REG_INIT */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_INIT_Driver_Strength_Select_Value(volatile sSdmmc *_sdmmc_); /**< Get element Driver_Strength_Select_Value of register PRESET_VAL_REG_INIT */
+
+
+/** @brief PRESET_VAL_REG_DEF_SPEED register description at address offset 0x62
+  *
+  *  Preset Value for Default Speed
+  */
+typedef struct
+{
+    const HWREG_U16 SDCLK_Frequency_Select_Value :10; /**<  */
+    const HWREG_U16 Clock_Generator_Select_Value :1; /**<  */
+    const HWREG_U16 :3; /**< Unused bitfield */
+    const HWREG_U16 Driver_Strength_Select_Value :2; /**<  */
+} sPRESET_VAL_REG_DEF_SPEEDStructure;
+
+
+/** @brief PRESET_VAL_REG_DEF_SPEED Bitfield widths 
+*/
+#define lenPRESET_VAL_REG_DEF_SPEED_SDCLK_FREQUENCY_SELECT_VALUE 10
+#define lenPRESET_VAL_REG_DEF_SPEED_CLOCK_GENERATOR_SELECT_VALUE 1
+#define lenPRESET_VAL_REG_DEF_SPEED_DRIVER_STRENGTH_SELECT_VALUE 2
+
+typedef enum
+{
+    PRESET_VAL_REG_DEF_SPEED_LSB_SDCLK_FREQUENCY_SELECT_VALUE = 0,
+    PRESET_VAL_REG_DEF_SPEED_LSB_CLOCK_GENERATOR_SELECT_VALUE = 10,
+    PRESET_VAL_REG_DEF_SPEED_LSB_DRIVER_STRENGTH_SELECT_VALUE = 14
+} ePRESET_VAL_REG_DEF_SPEEDLsb;
+
+typedef union
+{
+    HWREG_U16 PRESET_VAL_REG_DEF_SPEED_Content;
+    sPRESET_VAL_REG_DEF_SPEEDStructure PRESET_VAL_REG_DEF_SPEED_Structure;
+} uPRESET_VAL_REG_DEF_SPEED;
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_DEF_SPEED(volatile sSdmmc *_sdmmc_); /** Get complete register PRESET_VAL_REG_DEF_SPEED */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_DEF_SPEED_SDCLK_Frequency_Select_Value(volatile sSdmmc *_sdmmc_); /**< Get element SDCLK_Frequency_Select_Value of register PRESET_VAL_REG_DEF_SPEED */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_DEF_SPEED_Clock_Generator_Select_Value(volatile sSdmmc *_sdmmc_); /**< Get element Clock_Generator_Select_Value of register PRESET_VAL_REG_DEF_SPEED */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_DEF_SPEED_Driver_Strength_Select_Value(volatile sSdmmc *_sdmmc_); /**< Get element Driver_Strength_Select_Value of register PRESET_VAL_REG_DEF_SPEED */
+
+
+/** @brief PRESET_VAL_REG_HI_SPEED register description at address offset 0x64
+  *
+  *  Preset Value for High Speed
+  */
+typedef struct
+{
+    const HWREG_U16 SDCLK_Frequency_Select_Value :10; /**<  */
+    const HWREG_U16 Clock_Generator_Select_Value :1; /**<  */
+    const HWREG_U16 :3; /**< Unused bitfield */
+    const HWREG_U16 Driver_Strength_Select_Value :2; /**<  */
+} sPRESET_VAL_REG_HI_SPEEDStructure;
+
+
+/** @brief PRESET_VAL_REG_HI_SPEED Bitfield widths 
+*/
+#define lenPRESET_VAL_REG_HI_SPEED_SDCLK_FREQUENCY_SELECT_VALUE 10
+#define lenPRESET_VAL_REG_HI_SPEED_CLOCK_GENERATOR_SELECT_VALUE 1
+#define lenPRESET_VAL_REG_HI_SPEED_DRIVER_STRENGTH_SELECT_VALUE 2
+
+typedef enum
+{
+    PRESET_VAL_REG_HI_SPEED_LSB_SDCLK_FREQUENCY_SELECT_VALUE = 0,
+    PRESET_VAL_REG_HI_SPEED_LSB_CLOCK_GENERATOR_SELECT_VALUE = 10,
+    PRESET_VAL_REG_HI_SPEED_LSB_DRIVER_STRENGTH_SELECT_VALUE = 14
+} ePRESET_VAL_REG_HI_SPEEDLsb;
+
+typedef union
+{
+    HWREG_U16 PRESET_VAL_REG_HI_SPEED_Content;
+    sPRESET_VAL_REG_HI_SPEEDStructure PRESET_VAL_REG_HI_SPEED_Structure;
+} uPRESET_VAL_REG_HI_SPEED;
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_HI_SPEED(volatile sSdmmc *_sdmmc_); /** Get complete register PRESET_VAL_REG_HI_SPEED */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_HI_SPEED_SDCLK_Frequency_Select_Value(volatile sSdmmc *_sdmmc_); /**< Get element SDCLK_Frequency_Select_Value of register PRESET_VAL_REG_HI_SPEED */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_HI_SPEED_Clock_Generator_Select_Value(volatile sSdmmc *_sdmmc_); /**< Get element Clock_Generator_Select_Value of register PRESET_VAL_REG_HI_SPEED */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_HI_SPEED_Driver_Strength_Select_Value(volatile sSdmmc *_sdmmc_); /**< Get element Driver_Strength_Select_Value of register PRESET_VAL_REG_HI_SPEED */
+
+
+/** @brief PRESET_VAL_REG_SDR12 register description at address offset 0x66
+  *
+  *  Preset Value for SDR12
+  */
+typedef struct
+{
+    const HWREG_U16 SDCLK_Frequency_Select_Value :10; /**<  */
+    const HWREG_U16 Clock_Generator_Select_Value :1; /**<  */
+    const HWREG_U16 :3; /**< Unused bitfield */
+    const HWREG_U16 Driver_Strength_Select_Value :2; /**<  */
+} sPRESET_VAL_REG_SDR12Structure;
+
+
+/** @brief PRESET_VAL_REG_SDR12 Bitfield widths 
+*/
+#define lenPRESET_VAL_REG_SDR12_SDCLK_FREQUENCY_SELECT_VALUE 10
+#define lenPRESET_VAL_REG_SDR12_CLOCK_GENERATOR_SELECT_VALUE 1
+#define lenPRESET_VAL_REG_SDR12_DRIVER_STRENGTH_SELECT_VALUE 2
+
+typedef enum
+{
+    PRESET_VAL_REG_SDR12_LSB_SDCLK_FREQUENCY_SELECT_VALUE = 0,
+    PRESET_VAL_REG_SDR12_LSB_CLOCK_GENERATOR_SELECT_VALUE = 10,
+    PRESET_VAL_REG_SDR12_LSB_DRIVER_STRENGTH_SELECT_VALUE = 14
+} ePRESET_VAL_REG_SDR12Lsb;
+
+typedef union
+{
+    HWREG_U16 PRESET_VAL_REG_SDR12_Content;
+    sPRESET_VAL_REG_SDR12Structure PRESET_VAL_REG_SDR12_Structure;
+} uPRESET_VAL_REG_SDR12;
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_SDR12(volatile sSdmmc *_sdmmc_); /** Get complete register PRESET_VAL_REG_SDR12 */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_SDR12_SDCLK_Frequency_Select_Value(volatile sSdmmc *_sdmmc_); /**< Get element SDCLK_Frequency_Select_Value of register PRESET_VAL_REG_SDR12 */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_SDR12_Clock_Generator_Select_Value(volatile sSdmmc *_sdmmc_); /**< Get element Clock_Generator_Select_Value of register PRESET_VAL_REG_SDR12 */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_SDR12_Driver_Strength_Select_Value(volatile sSdmmc *_sdmmc_); /**< Get element Driver_Strength_Select_Value of register PRESET_VAL_REG_SDR12 */
+
+
+/** @brief PRESET_VAL_REG_SDR25 register description at address offset 0x68
+  *
+  *  Preset Value for SDR25
+  */
+typedef struct
+{
+    const HWREG_U16 SDCLK_Frequency_Select_Value :10; /**<  */
+    const HWREG_U16 Clock_Generator_Select_Value :1; /**<  */
+    const HWREG_U16 :3; /**< Unused bitfield */
+    const HWREG_U16 Driver_Strength_Select_Value :2; /**<  */
+} sPRESET_VAL_REG_SDR25Structure;
+
+
+/** @brief PRESET_VAL_REG_SDR25 Bitfield widths 
+*/
+#define lenPRESET_VAL_REG_SDR25_SDCLK_FREQUENCY_SELECT_VALUE 10
+#define lenPRESET_VAL_REG_SDR25_CLOCK_GENERATOR_SELECT_VALUE 1
+#define lenPRESET_VAL_REG_SDR25_DRIVER_STRENGTH_SELECT_VALUE 2
+
+typedef enum
+{
+    PRESET_VAL_REG_SDR25_LSB_SDCLK_FREQUENCY_SELECT_VALUE = 0,
+    PRESET_VAL_REG_SDR25_LSB_CLOCK_GENERATOR_SELECT_VALUE = 10,
+    PRESET_VAL_REG_SDR25_LSB_DRIVER_STRENGTH_SELECT_VALUE = 14
+} ePRESET_VAL_REG_SDR25Lsb;
+
+typedef union
+{
+    HWREG_U16 PRESET_VAL_REG_SDR25_Content;
+    sPRESET_VAL_REG_SDR25Structure PRESET_VAL_REG_SDR25_Structure;
+} uPRESET_VAL_REG_SDR25;
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_SDR25(volatile sSdmmc *_sdmmc_); /** Get complete register PRESET_VAL_REG_SDR25 */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_SDR25_SDCLK_Frequency_Select_Value(volatile sSdmmc *_sdmmc_); /**< Get element SDCLK_Frequency_Select_Value of register PRESET_VAL_REG_SDR25 */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_SDR25_Clock_Generator_Select_Value(volatile sSdmmc *_sdmmc_); /**< Get element Clock_Generator_Select_Value of register PRESET_VAL_REG_SDR25 */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_SDR25_Driver_Strength_Select_Value(volatile sSdmmc *_sdmmc_); /**< Get element Driver_Strength_Select_Value of register PRESET_VAL_REG_SDR25 */
+
+
+/** @brief PRESET_VAL_REG_SDR50 register description at address offset 0x6a
+  *
+  *  Preset Value for SDR50
+  */
+typedef struct
+{
+    const HWREG_U16 SDCLK_Frequency_Select_Value :10; /**<  */
+    const HWREG_U16 Clock_Generator_Select_Value :1; /**<  */
+    const HWREG_U16 :3; /**< Unused bitfield */
+    const HWREG_U16 Driver_Strength_Select_Value :2; /**<  */
+} sPRESET_VAL_REG_SDR50Structure;
+
+
+/** @brief PRESET_VAL_REG_SDR50 Bitfield widths 
+*/
+#define lenPRESET_VAL_REG_SDR50_SDCLK_FREQUENCY_SELECT_VALUE 10
+#define lenPRESET_VAL_REG_SDR50_CLOCK_GENERATOR_SELECT_VALUE 1
+#define lenPRESET_VAL_REG_SDR50_DRIVER_STRENGTH_SELECT_VALUE 2
+
+typedef enum
+{
+    PRESET_VAL_REG_SDR50_LSB_SDCLK_FREQUENCY_SELECT_VALUE = 0,
+    PRESET_VAL_REG_SDR50_LSB_CLOCK_GENERATOR_SELECT_VALUE = 10,
+    PRESET_VAL_REG_SDR50_LSB_DRIVER_STRENGTH_SELECT_VALUE = 14
+} ePRESET_VAL_REG_SDR50Lsb;
+
+typedef union
+{
+    HWREG_U16 PRESET_VAL_REG_SDR50_Content;
+    sPRESET_VAL_REG_SDR50Structure PRESET_VAL_REG_SDR50_Structure;
+} uPRESET_VAL_REG_SDR50;
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_SDR50(volatile sSdmmc *_sdmmc_); /** Get complete register PRESET_VAL_REG_SDR50 */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_SDR50_SDCLK_Frequency_Select_Value(volatile sSdmmc *_sdmmc_); /**< Get element SDCLK_Frequency_Select_Value of register PRESET_VAL_REG_SDR50 */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_SDR50_Clock_Generator_Select_Value(volatile sSdmmc *_sdmmc_); /**< Get element Clock_Generator_Select_Value of register PRESET_VAL_REG_SDR50 */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_SDR50_Driver_Strength_Select_Value(volatile sSdmmc *_sdmmc_); /**< Get element Driver_Strength_Select_Value of register PRESET_VAL_REG_SDR50 */
+
+
+/** @brief PRESET_VAL_REG_SDR104 register description at address offset 0x6c
+  *
+  *  Preset Value for SDR104
+  */
+typedef struct
+{
+    const HWREG_U16 SDCLK_Frequency_Select_Value :10; /**<  */
+    const HWREG_U16 Clock_Generator_Select_Value :1; /**<  */
+    const HWREG_U16 :3; /**< Unused bitfield */
+    const HWREG_U16 Driver_Strength_Select_Value :2; /**<  */
+} sPRESET_VAL_REG_SDR104Structure;
+
+
+/** @brief PRESET_VAL_REG_SDR104 Bitfield widths 
+*/
+#define lenPRESET_VAL_REG_SDR104_SDCLK_FREQUENCY_SELECT_VALUE 10
+#define lenPRESET_VAL_REG_SDR104_CLOCK_GENERATOR_SELECT_VALUE 1
+#define lenPRESET_VAL_REG_SDR104_DRIVER_STRENGTH_SELECT_VALUE 2
+
+typedef enum
+{
+    PRESET_VAL_REG_SDR104_LSB_SDCLK_FREQUENCY_SELECT_VALUE = 0,
+    PRESET_VAL_REG_SDR104_LSB_CLOCK_GENERATOR_SELECT_VALUE = 10,
+    PRESET_VAL_REG_SDR104_LSB_DRIVER_STRENGTH_SELECT_VALUE = 14
+} ePRESET_VAL_REG_SDR104Lsb;
+
+typedef union
+{
+    HWREG_U16 PRESET_VAL_REG_SDR104_Content;
+    sPRESET_VAL_REG_SDR104Structure PRESET_VAL_REG_SDR104_Structure;
+} uPRESET_VAL_REG_SDR104;
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_SDR104(volatile sSdmmc *_sdmmc_); /** Get complete register PRESET_VAL_REG_SDR104 */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_SDR104_SDCLK_Frequency_Select_Value(volatile sSdmmc *_sdmmc_); /**< Get element SDCLK_Frequency_Select_Value of register PRESET_VAL_REG_SDR104 */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_SDR104_Clock_Generator_Select_Value(volatile sSdmmc *_sdmmc_); /**< Get element Clock_Generator_Select_Value of register PRESET_VAL_REG_SDR104 */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_SDR104_Driver_Strength_Select_Value(volatile sSdmmc *_sdmmc_); /**< Get element Driver_Strength_Select_Value of register PRESET_VAL_REG_SDR104 */
+
+
+/** @brief PRESET_VAL_REG_DDR50 register description at address offset 0x6e
+  *
+  *  Preset Value for DDR50
+  */
+typedef struct
+{
+    const HWREG_U16 SDCLK_Frequency_Select_Value :10; /**<  */
+    const HWREG_U16 Clock_Generator_Select_Value :1; /**<  */
+    const HWREG_U16 :3; /**< Unused bitfield */
+    const HWREG_U16 Driver_Strength_Select_Value :2; /**<  */
+} sPRESET_VAL_REG_DDR50Structure;
+
+
+/** @brief PRESET_VAL_REG_DDR50 Bitfield widths 
+*/
+#define lenPRESET_VAL_REG_DDR50_SDCLK_FREQUENCY_SELECT_VALUE 10
+#define lenPRESET_VAL_REG_DDR50_CLOCK_GENERATOR_SELECT_VALUE 1
+#define lenPRESET_VAL_REG_DDR50_DRIVER_STRENGTH_SELECT_VALUE 2
+
+typedef enum
+{
+    PRESET_VAL_REG_DDR50_LSB_SDCLK_FREQUENCY_SELECT_VALUE = 0,
+    PRESET_VAL_REG_DDR50_LSB_CLOCK_GENERATOR_SELECT_VALUE = 10,
+    PRESET_VAL_REG_DDR50_LSB_DRIVER_STRENGTH_SELECT_VALUE = 14
+} ePRESET_VAL_REG_DDR50Lsb;
+
+typedef union
+{
+    HWREG_U16 PRESET_VAL_REG_DDR50_Content;
+    sPRESET_VAL_REG_DDR50Structure PRESET_VAL_REG_DDR50_Structure;
+} uPRESET_VAL_REG_DDR50;
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_DDR50(volatile sSdmmc *_sdmmc_); /** Get complete register PRESET_VAL_REG_DDR50 */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_DDR50_SDCLK_Frequency_Select_Value(volatile sSdmmc *_sdmmc_); /**< Get element SDCLK_Frequency_Select_Value of register PRESET_VAL_REG_DDR50 */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_DDR50_Clock_Generator_Select_Value(volatile sSdmmc *_sdmmc_); /**< Get element Clock_Generator_Select_Value of register PRESET_VAL_REG_DDR50 */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_DDR50_Driver_Strength_Select_Value(volatile sSdmmc *_sdmmc_); /**< Get element Driver_Strength_Select_Value of register PRESET_VAL_REG_DDR50 */
+
+
+/** @brief BOOT_DATA_TO_CTRL register description at address offset 0x70
+  *
+  *  
+  */
+typedef struct
+{
+    HWREG_U32 BOOT_DATA_TO_COUNT :32; /**<  */
+} sBOOT_DATA_TO_CTRLStructure;
+
+
+/** @brief BOOT_DATA_TO_CTRL Bitfield widths 
+*/
+#define lenBOOT_DATA_TO_CTRL_BOOT_DATA_TO_COUNT 32
+
+typedef enum
+{
+    BOOT_DATA_TO_CTRL_LSB_BOOT_DATA_TO_COUNT = 0
+} eBOOT_DATA_TO_CTRLLsb;
+
+typedef union
+{
+    HWREG_U32 BOOT_DATA_TO_CTRL_Content;
+    sBOOT_DATA_TO_CTRLStructure BOOT_DATA_TO_CTRL_Structure;
+} uBOOT_DATA_TO_CTRL;
+
+__HWREG_INLINE__ void setSdmmc_BOOT_DATA_TO_CTRL(volatile sSdmmc *_sdmmc_, HWREG_U32 value); /** Set complete register BOOT_DATA_TO_CTRL */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_BOOT_DATA_TO_CTRL(volatile sSdmmc *_sdmmc_); /** Get complete register BOOT_DATA_TO_CTRL */
+__HWREG_INLINE__ void setSdmmc_BOOT_DATA_TO_CTRL_BOOT_DATA_TO_COUNT(volatile sSdmmc *_sdmmc_, HWREG_U32 value); /**< Set element BOOT_DATA_TO_COUNT of register BOOT_DATA_TO_CTRL */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_BOOT_DATA_TO_CTRL_BOOT_DATA_TO_COUNT(volatile sSdmmc *_sdmmc_); /**< Get element BOOT_DATA_TO_COUNT of register BOOT_DATA_TO_CTRL */
+
+
+/** @brief DEBUG_SEL register description at address offset 0x74
+  *
+  *  
+  */
+typedef struct
+{
+    HWREG_U32 DEBUG_SEL :1; /**<  */
+    const HWREG_U32 :31; /**< Unused bitfield */
+} sDEBUG_SELStructure;
+
+
+/** @brief DEBUG_SEL Bitfield widths 
+*/
+#define lenDEBUG_SEL_DEBUG_SEL 1
+
+typedef enum
+{
+    DEBUG_SEL_LSB_DEBUG_SEL = 0
+} eDEBUG_SELLsb;
+
+typedef union
+{
+    HWREG_U32 DEBUG_SEL_Content;
+    sDEBUG_SELStructure DEBUG_SEL_Structure;
+} uDEBUG_SEL;
+
+__HWREG_INLINE__ void setSdmmc_DEBUG_SEL(volatile sSdmmc *_sdmmc_, HWREG_U32 value); /** Set complete register DEBUG_SEL */
+__HWREG_INLINE__ void setSdmmc_DEBUG_SEL_DEBUG_SEL(volatile sSdmmc *_sdmmc_, HWREG_U32 value); /**< Set element DEBUG_SEL of register DEBUG_SEL */
+
+
+/** @brief SHARED_BUS_CTRL register description at address offset 0xe0
+  *
+  *  
+  */
+typedef struct
+{
+    const HWREG_U32 NUM_CLK_PIN :3; /**<  */
+    const HWREG_U32 res3 :1; /**<  */
+    const HWREG_U32 NUM_INT_PIN :2; /**<  */
+    const HWREG_U32 res0607 :2; /**<  */
+    const HWREG_U32 BUS_WIDTH_PRESET :7; /**<  */
+    const HWREG_U32 res15 :1; /**<  */
+    HWREG_U32 CLK_PIN_SEL :3; /**<  */
+    const HWREG_U32 res19 :1; /**<  */
+    HWREG_U32 INT_PIN_SEL :3; /**<  */
+    const HWREG_U32 res23 :1; /**<  */
+    HWREG_U32 BACKEND_PWR_CTRL :7; /**<  */
+    const HWREG_U32 res31 :1; /**<  */
+} sSHARED_BUS_CTRLStructure;
+
+
+/** @brief SHARED_BUS_CTRL Bitfield widths 
+*/
+#define lenSHARED_BUS_CTRL_NUM_CLK_PIN 3
+#define lenSHARED_BUS_CTRL_RES3 1
+#define lenSHARED_BUS_CTRL_NUM_INT_PIN 2
+#define lenSHARED_BUS_CTRL_RES0607 2
+#define lenSHARED_BUS_CTRL_BUS_WIDTH_PRESET 7
+#define lenSHARED_BUS_CTRL_RES15 1
+#define lenSHARED_BUS_CTRL_CLK_PIN_SEL 3
+#define lenSHARED_BUS_CTRL_RES19 1
+#define lenSHARED_BUS_CTRL_INT_PIN_SEL 3
+#define lenSHARED_BUS_CTRL_RES23 1
+#define lenSHARED_BUS_CTRL_BACKEND_PWR_CTRL 7
+#define lenSHARED_BUS_CTRL_RES31 1
+
+typedef enum
+{
+    SHARED_BUS_CTRL_LSB_NUM_CLK_PIN = 0,
+    SHARED_BUS_CTRL_LSB_RES3 = 3,
+    SHARED_BUS_CTRL_LSB_NUM_INT_PIN = 4,
+    SHARED_BUS_CTRL_LSB_RES0607 = 6,
+    SHARED_BUS_CTRL_LSB_BUS_WIDTH_PRESET = 8,
+    SHARED_BUS_CTRL_LSB_RES15 = 15,
+    SHARED_BUS_CTRL_LSB_CLK_PIN_SEL = 16,
+    SHARED_BUS_CTRL_LSB_RES19 = 19,
+    SHARED_BUS_CTRL_LSB_INT_PIN_SEL = 20,
+    SHARED_BUS_CTRL_LSB_RES23 = 23,
+    SHARED_BUS_CTRL_LSB_BACKEND_PWR_CTRL = 24,
+    SHARED_BUS_CTRL_LSB_RES31 = 31
+} eSHARED_BUS_CTRLLsb;
+
+typedef union
+{
+    HWREG_U32 SHARED_BUS_CTRL_Content;
+    sSHARED_BUS_CTRLStructure SHARED_BUS_CTRL_Structure;
+} uSHARED_BUS_CTRL;
+
+__HWREG_INLINE__ void setSdmmc_SHARED_BUS_CTRL(volatile sSdmmc *_sdmmc_, HWREG_U32 value); /** Set complete register SHARED_BUS_CTRL */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_SHARED_BUS_CTRL(volatile sSdmmc *_sdmmc_); /** Get complete register SHARED_BUS_CTRL */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_SHARED_BUS_CTRL_NUM_CLK_PIN(volatile sSdmmc *_sdmmc_); /**< Get element NUM_CLK_PIN of register SHARED_BUS_CTRL */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_SHARED_BUS_CTRL_res3(volatile sSdmmc *_sdmmc_); /**< Get element res3 of register SHARED_BUS_CTRL */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_SHARED_BUS_CTRL_NUM_INT_PIN(volatile sSdmmc *_sdmmc_); /**< Get element NUM_INT_PIN of register SHARED_BUS_CTRL */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_SHARED_BUS_CTRL_res0607(volatile sSdmmc *_sdmmc_); /**< Get element res0607 of register SHARED_BUS_CTRL */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_SHARED_BUS_CTRL_BUS_WIDTH_PRESET(volatile sSdmmc *_sdmmc_); /**< Get element BUS_WIDTH_PRESET of register SHARED_BUS_CTRL */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_SHARED_BUS_CTRL_res15(volatile sSdmmc *_sdmmc_); /**< Get element res15 of register SHARED_BUS_CTRL */
+__HWREG_INLINE__ void setSdmmc_SHARED_BUS_CTRL_CLK_PIN_SEL(volatile sSdmmc *_sdmmc_, HWREG_U32 value); /**< Set element CLK_PIN_SEL of register SHARED_BUS_CTRL */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_SHARED_BUS_CTRL_CLK_PIN_SEL(volatile sSdmmc *_sdmmc_); /**< Get element CLK_PIN_SEL of register SHARED_BUS_CTRL */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_SHARED_BUS_CTRL_res19(volatile sSdmmc *_sdmmc_); /**< Get element res19 of register SHARED_BUS_CTRL */
+__HWREG_INLINE__ void setSdmmc_SHARED_BUS_CTRL_INT_PIN_SEL(volatile sSdmmc *_sdmmc_, HWREG_U32 value); /**< Set element INT_PIN_SEL of register SHARED_BUS_CTRL */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_SHARED_BUS_CTRL_INT_PIN_SEL(volatile sSdmmc *_sdmmc_); /**< Get element INT_PIN_SEL of register SHARED_BUS_CTRL */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_SHARED_BUS_CTRL_res23(volatile sSdmmc *_sdmmc_); /**< Get element res23 of register SHARED_BUS_CTRL */
+__HWREG_INLINE__ void setSdmmc_SHARED_BUS_CTRL_BACKEND_PWR_CTRL(volatile sSdmmc *_sdmmc_, HWREG_U32 value); /**< Set element BACKEND_PWR_CTRL of register SHARED_BUS_CTRL */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_SHARED_BUS_CTRL_BACKEND_PWR_CTRL(volatile sSdmmc *_sdmmc_); /**< Get element BACKEND_PWR_CTRL of register SHARED_BUS_CTRL */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_SHARED_BUS_CTRL_res31(volatile sSdmmc *_sdmmc_); /**< Get element res31 of register SHARED_BUS_CTRL */
+
+
+/** @brief SPI register description at address offset 0xf0
+  *
+  *  
+  */
+typedef struct
+{
+    HWREG_U32 SPI_INT_SUPPORT :8; /**<  */
+    const HWREG_U32 :24; /**< Unused bitfield */
+} sSPIStructure;
+
+
+/** @brief SPI Bitfield widths 
+*/
+#define lenSPI_SPI_INT_SUPPORT 8
+
+typedef enum
+{
+    SPI_LSB_SPI_INT_SUPPORT = 0
+} eSPILsb;
+
+typedef union
+{
+    HWREG_U32 SPI_Content;
+    sSPIStructure SPI_Structure;
+} uSPI;
+
+__HWREG_INLINE__ void setSdmmc_SPI(volatile sSdmmc *_sdmmc_, HWREG_U32 value); /** Set complete register SPI */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_SPI(volatile sSdmmc *_sdmmc_); /** Get complete register SPI */
+__HWREG_INLINE__ void setSdmmc_SPI_SPI_INT_SUPPORT(volatile sSdmmc *_sdmmc_, HWREG_U32 value); /**< Set element SPI_INT_SUPPORT of register SPI */
+__HWREG_INLINE__ HWREG_U32 getSdmmc_SPI_SPI_INT_SUPPORT(volatile sSdmmc *_sdmmc_); /**< Get element SPI_INT_SUPPORT of register SPI */
+
+
+/** @brief SLOT_INT_STATUS register description at address offset 0xfc
+  *
+  *  
+  */
+typedef struct
+{
+    const HWREG_U16 SLOT_INT_STATUS :8; /**<  */
+    const HWREG_U16 :8; /**< Unused bitfield */
+} sSLOT_INT_STATUSStructure;
+
+
+/** @brief SLOT_INT_STATUS Bitfield widths 
+*/
+#define lenSLOT_INT_STATUS_SLOT_INT_STATUS 8
+
+typedef enum
+{
+    SLOT_INT_STATUS_LSB_SLOT_INT_STATUS = 0
+} eSLOT_INT_STATUSLsb;
+
+typedef union
+{
+    HWREG_U16 SLOT_INT_STATUS_Content;
+    sSLOT_INT_STATUSStructure SLOT_INT_STATUS_Structure;
+} uSLOT_INT_STATUS;
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_SLOT_INT_STATUS(volatile sSdmmc *_sdmmc_); /** Get complete register SLOT_INT_STATUS */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_SLOT_INT_STATUS_SLOT_INT_STATUS(volatile sSdmmc *_sdmmc_); /**< Get element SLOT_INT_STATUS of register SLOT_INT_STATUS */
+
+
+/** @brief HOST_CTRL_VERS register description at address offset 0xfe
+  *
+  *  
+  */
+typedef struct
+{
+    const HWREG_U16 SPEC_VERS :8; /**<  */
+    const HWREG_U16 VENDOR_VERS :8; /**<  */
+} sHOST_CTRL_VERSStructure;
+
+
+/** @brief HOST_CTRL_VERS Bitfield widths 
+*/
+#define lenHOST_CTRL_VERS_SPEC_VERS 8
+#define lenHOST_CTRL_VERS_VENDOR_VERS 8
+
+typedef enum
+{
+    HOST_CTRL_VERS_LSB_SPEC_VERS = 0,
+    HOST_CTRL_VERS_LSB_VENDOR_VERS = 8
+} eHOST_CTRL_VERSLsb;
+
+typedef union
+{
+    HWREG_U16 HOST_CTRL_VERS_Content;
+    sHOST_CTRL_VERSStructure HOST_CTRL_VERS_Structure;
+} uHOST_CTRL_VERS;
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_HOST_CTRL_VERS(volatile sSdmmc *_sdmmc_); /** Get complete register HOST_CTRL_VERS */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_HOST_CTRL_VERS_SPEC_VERS(volatile sSdmmc *_sdmmc_); /**< Get element SPEC_VERS of register HOST_CTRL_VERS */
+__HWREG_INLINE__ HWREG_U16 getSdmmc_HOST_CTRL_VERS_VENDOR_VERS(volatile sSdmmc *_sdmmc_); /**< Get element VENDOR_VERS of register HOST_CTRL_VERS */
+
+
+struct _sSdmmc
+{
+    uSDMA_SYSTEM_ADDR SDMA_SYSTEM_ADDR; /*< Address offset = 0x0 */
+    uBLOCK_SIZE BLOCK_SIZE; /*< Address offset = 0x4 */
+    uBLOCK_COUNT BLOCK_COUNT; /*< Address offset = 0x6 */
+    uARGUMENT1 ARGUMENT1; /*< Address offset = 0x8 */
+    uTRANSFER_MODE TRANSFER_MODE; /*< Address offset = 0xc */
+    uCOMMAND COMMAND; /*< Address offset = 0xe */
+    uRESPONSE0 RESPONSE0; /*< Address offset = 0x10 */
+    uRESPONSE2 RESPONSE2; /*< Address offset = 0x14 */
+    uRESPONSE4 RESPONSE4; /*< Address offset = 0x18 */
+    uRESPONSE6 RESPONSE6; /*< Address offset = 0x1c */
+    uDATA_BUFFER DATA_BUFFER; /*< Address offset = 0x20 */
+    uPRESENT_STATE PRESENT_STATE; /*< Address offset = 0x24 */
+    uHOST_CTRL HOST_CTRL; /*< Address offset = 0x28 */
+    uPOWER_CTRL POWER_CTRL; /*< Address offset = 0x29 */
+    uBLOCK_GAP_CTRL BLOCK_GAP_CTRL; /*< Address offset = 0x2a */
+    uWAKEUP_CTRL WAKEUP_CTRL; /*< Address offset = 0x2b */
+    uCLOCK_CTRL CLOCK_CTRL; /*< Address offset = 0x2c */
+    uTIMEOUT_CTRL TIMEOUT_CTRL; /*< Address offset = 0x2e */
+    uSW_RESET SOFTWARE_RESET; /*< Address offset = 0x2f */
+    uINT_STATUS_NORM INT_STATUS_NORM; /*< Address offset = 0x30 */
+    uINT_STATUS_ERR INT_STATUS_ERR; /*< Address offset = 0x32 */
+    uEN_INT_STATUS_NORM EN_INT_STATUS_NORM; /*< Address offset = 0x34 */
+    uEN_INT_STATUS_ERR EN_INT_STATUS_ERR; /*< Address offset = 0x36 */
+    uEN_INT_SIGNAL_NORM EN_INT_SIGNAL_NORM; /*< Address offset = 0x38 */
+    uEN_INT_SIGNAL_ERR EN_INT_SIGNAL_ERR; /*< Address offset = 0x3a */
+    uACMD12_ERR_STATUS ACMD12_ERR_STATUS; /*< Address offset = 0x3c */
+    uHOST_CTRL2 HOST_CTRL2; /*< Address offset = 0x3e */
+    uCAPABILITIES CAPABILITIES; /*< Address offset = 0x40 */
+    uCAPABILITIES_HI CAPABILITIES_HI; /*< Address offset = 0x44 */
+    uMAX_CURRENT_CAP MAX_CURRENT_CAP; /*< Address offset = 0x48 */
+    uMAX_CURRENT_CAP_res MAX_CURRENT_CAP_res; /*< Address offset = 0x4c */
+    uFORCE_EVENT_ACMD_ERR_STATUS FORCE_EVENT_ACMD_ERR_STATUS; /*< Address offset = 0x50 */
+    uFORCE_EVENT_ERR_STATUS FORCE_EVENT_ERR_STATUS; /*< Address offset = 0x52 */
+    uADMA_ERR_STATUS ADMA_ERR_STATUS; /*< Address offset = 0x54 */
+    const HWREG_U8 reservedArea0 [3]; /*< Address offset = 0x55 */
+    uADMA_ADDR_LOW ADMA_ADDR_LOW; /*< Address offset = 0x58 */
+    uADMA_ADDR_HIGH ADMA_ADDR_HIGH; /*< Address offset = 0x5c */
+    uPRESET_VAL_REG_INIT PRESET_VAL_REG_INIT; /*< Address offset = 0x60 */
+    uPRESET_VAL_REG_DEF_SPEED PRESET_VAL_REG_DEF_SPEED; /*< Address offset = 0x62 */
+    uPRESET_VAL_REG_HI_SPEED PRESET_VAL_REG_HI_SPEED; /*< Address offset = 0x64 */
+    uPRESET_VAL_REG_SDR12 PRESET_VAL_REG_SDR12; /*< Address offset = 0x66 */
+    uPRESET_VAL_REG_SDR25 PRESET_VAL_REG_SDR25; /*< Address offset = 0x68 */
+    uPRESET_VAL_REG_SDR50 PRESET_VAL_REG_SDR50; /*< Address offset = 0x6a */
+    uPRESET_VAL_REG_SDR104 PRESET_VAL_REG_SDR104; /*< Address offset = 0x6c */
+    uPRESET_VAL_REG_DDR50 PRESET_VAL_REG_DDR50; /*< Address offset = 0x6e */
+    uBOOT_DATA_TO_CTRL BOOT_DATA_TO_CTRL; /*< Address offset = 0x70 */
+    uDEBUG_SEL DEBUG_SEL; /*< Address offset = 0x74 */
+    const HWREG_U8 reservedArea1 [104]; /*< Address offset = 0x78 */
+    uSHARED_BUS_CTRL SHARED_BUS_CTRL; /*< Address offset = 0xe0 */
+    const HWREG_U8 reservedArea2 [12]; /*< Address offset = 0xe4 */
+    uSPI SPI; /*< Address offset = 0xf0 */
+    const HWREG_U8 reservedArea3 [8]; /*< Address offset = 0xf4 */
+    uSLOT_INT_STATUS SLOT_INT_STATUS; /*< Address offset = 0xfc */
+    uHOST_CTRL_VERS HOST_CTRL_VERS; /*< Address offset = 0xfe */
+};
+
+
+typedef enum _sSdmmcResetValues
+{
+    SDMA_SYSTEM_ADDR_RESET_VALUE = (int)0x0,
+    BLOCK_SIZE_RESET_VALUE = (int)0x0,
+    BLOCK_COUNT_RESET_VALUE = (int)0x0,
+    ARGUMENT1_RESET_VALUE = (int)0x0,
+    TRANSFER_MODE_RESET_VALUE = (int)0x0,
+    COMMAND_RESET_VALUE = (int)0x0,
+    RESPONSE0_RESET_VALUE = (int)0x0,
+    RESPONSE2_RESET_VALUE = (int)0x0,
+    RESPONSE4_RESET_VALUE = (int)0x0,
+    RESPONSE6_RESET_VALUE = (int)0x0,
+    DATA_BUFFER_RESET_VALUE = (int)0x0,
+    PRESENT_STATE_RESET_VALUE = (int)0x1ffa0000,
+    HOST_CTRL_RESET_VALUE = (int)0x0,
+    POWER_CTRL_RESET_VALUE = (int)0x0,
+    BLOCK_GAP_CTRL_RESET_VALUE = (int)0x0,
+    WAKEUP_CTRL_RESET_VALUE = (int)0x0,
+    CLOCK_CTRL_RESET_VALUE = (int)0x0,
+    TIMEOUT_CTRL_RESET_VALUE = (int)0x0,
+    SW_RESET_RESET_VALUE = (int)0x0,
+    INT_STATUS_NORM_RESET_VALUE = (int)0x0,
+    INT_STATUS_ERR_RESET_VALUE = (int)0x0,
+    EN_INT_STATUS_NORM_RESET_VALUE = (int)0x0,
+    EN_INT_STATUS_ERR_RESET_VALUE = (int)0x0,
+    EN_INT_SIGNAL_NORM_RESET_VALUE = (int)0x0,
+    EN_INT_SIGNAL_ERR_RESET_VALUE = (int)0x0,
+    ACMD12_ERR_STATUS_RESET_VALUE = (int)0x0,
+    HOST_CTRL2_RESET_VALUE = (int)0x0,
+    CAPABILITIES_RESET_VALUE = (int)0x7e86080,
+    CAPABILITIES_HI_RESET_VALUE = (int)0x3002105,
+    MAX_CURRENT_CAP_RESET_VALUE = (int)0x1,
+    MAX_CURRENT_CAP_RES_RESET_VALUE = (int)0x0,
+    FORCE_EVENT_ACMD_ERR_STATUS_RESET_VALUE = (int)0x0,
+    FORCE_EVENT_ERR_STATUS_RESET_VALUE = (int)0x0,
+    ADMA_ERR_STATUS_RESET_VALUE = (int)0x0,
+    ADMA_ADDR_LOW_RESET_VALUE = (int)0x0,
+    ADMA_ADDR_HIGH_RESET_VALUE = (int)0x0,
+    PRESET_VAL_REG_INIT_RESET_VALUE = (int)0x0,
+    PRESET_VAL_REG_DEF_SPEED_RESET_VALUE = (int)0x0,
+    PRESET_VAL_REG_HI_SPEED_RESET_VALUE = (int)0x0,
+    PRESET_VAL_REG_SDR12_RESET_VALUE = (int)0x0,
+    PRESET_VAL_REG_SDR25_RESET_VALUE = (int)0x0,
+    PRESET_VAL_REG_SDR50_RESET_VALUE = (int)0x0,
+    PRESET_VAL_REG_SDR104_RESET_VALUE = (int)0x0,
+    PRESET_VAL_REG_DDR50_RESET_VALUE = (int)0x0,
+    BOOT_DATA_TO_CTRL_RESET_VALUE = (int)0x0,
+    DEBUG_SEL_RESET_VALUE = (int)0x0,
+    SHARED_BUS_CTRL_RESET_VALUE = (int)0x0,
+    SPI_RESET_VALUE = (int)0x0,
+    SLOT_INT_STATUS_RESET_VALUE = (int)0x0,
+    HOST_CTRL_VERS_RESET_VALUE = (int)0x9902
+} eSdmmcResetValues;
+
+
+#if !defined(SDMMC_REG_INLINE_DISABLED) || defined(__SDMMC_HW_REG_C__)
+
+__HWREG_INLINE__ void setSdmmc_SDMA_SYSTEM_ADDR(volatile sSdmmc *_sdmmc_, HWREG_U32 value)
+{
+    _sdmmc_->SDMA_SYSTEM_ADDR.SDMA_SYSTEM_ADDR_Content = value;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_SDMA_SYSTEM_ADDR(volatile sSdmmc *_sdmmc_)
+{
+    return _sdmmc_->SDMA_SYSTEM_ADDR.SDMA_SYSTEM_ADDR_Content;
+}
+
+__HWREG_INLINE__ void setSdmmc_SDMA_SYSTEM_ADDR_SDMA_SYSTEM_ADDR(volatile sSdmmc *_sdmmc_, HWREG_U32 value)
+{
+    _sdmmc_->SDMA_SYSTEM_ADDR.SDMA_SYSTEM_ADDR_Structure.SDMA_SYSTEM_ADDR = value;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_SDMA_SYSTEM_ADDR_SDMA_SYSTEM_ADDR(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->SDMA_SYSTEM_ADDR.SDMA_SYSTEM_ADDR_Structure.SDMA_SYSTEM_ADDR;
+}
+
+
+__HWREG_INLINE__ void setSdmmc_BLOCK_SIZE(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->BLOCK_SIZE.BLOCK_SIZE_Content = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_BLOCK_SIZE(volatile sSdmmc *_sdmmc_)
+{
+    return _sdmmc_->BLOCK_SIZE.BLOCK_SIZE_Content;
+}
+
+__HWREG_INLINE__ void setSdmmc_BLOCK_SIZE_TX_BLOCK_SIZE(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->BLOCK_SIZE.BLOCK_SIZE_Structure.TX_BLOCK_SIZE = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_BLOCK_SIZE_TX_BLOCK_SIZE(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->BLOCK_SIZE.BLOCK_SIZE_Structure.TX_BLOCK_SIZE;
+}
+
+__HWREG_INLINE__ void setSdmmc_BLOCK_SIZE_HOST_SDMA_BUF_SIZE(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->BLOCK_SIZE.BLOCK_SIZE_Structure.HOST_SDMA_BUF_SIZE = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_BLOCK_SIZE_HOST_SDMA_BUF_SIZE(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->BLOCK_SIZE.BLOCK_SIZE_Structure.HOST_SDMA_BUF_SIZE;
+}
+
+
+__HWREG_INLINE__ void setSdmmc_BLOCK_COUNT(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->BLOCK_COUNT.BLOCK_COUNT_Content = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_BLOCK_COUNT(volatile sSdmmc *_sdmmc_)
+{
+    return _sdmmc_->BLOCK_COUNT.BLOCK_COUNT_Content;
+}
+
+__HWREG_INLINE__ void setSdmmc_BLOCK_COUNT_BLOCK_COUNT(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->BLOCK_COUNT.BLOCK_COUNT_Structure.BLOCK_COUNT = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_BLOCK_COUNT_BLOCK_COUNT(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->BLOCK_COUNT.BLOCK_COUNT_Structure.BLOCK_COUNT;
+}
+
+
+__HWREG_INLINE__ void setSdmmc_ARGUMENT1(volatile sSdmmc *_sdmmc_, HWREG_U32 value)
+{
+    _sdmmc_->ARGUMENT1.ARGUMENT1_Content = value;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_ARGUMENT1(volatile sSdmmc *_sdmmc_)
+{
+    return _sdmmc_->ARGUMENT1.ARGUMENT1_Content;
+}
+
+__HWREG_INLINE__ void setSdmmc_ARGUMENT1_ARGUMENT1(volatile sSdmmc *_sdmmc_, HWREG_U32 value)
+{
+    _sdmmc_->ARGUMENT1.ARGUMENT1_Structure.ARGUMENT1 = value;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_ARGUMENT1_ARGUMENT1(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->ARGUMENT1.ARGUMENT1_Structure.ARGUMENT1;
+}
+
+
+__HWREG_INLINE__ void setSdmmc_TRANSFER_MODE(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->TRANSFER_MODE.TRANSFER_MODE_Content = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_TRANSFER_MODE(volatile sSdmmc *_sdmmc_)
+{
+    return _sdmmc_->TRANSFER_MODE.TRANSFER_MODE_Content;
+}
+
+__HWREG_INLINE__ void setSdmmc_TRANSFER_MODE_DMA_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->TRANSFER_MODE.TRANSFER_MODE_Structure.DMA_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_TRANSFER_MODE_DMA_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->TRANSFER_MODE.TRANSFER_MODE_Structure.DMA_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_TRANSFER_MODE_BLOCK_COUNT_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->TRANSFER_MODE.TRANSFER_MODE_Structure.BLOCK_COUNT_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_TRANSFER_MODE_BLOCK_COUNT_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->TRANSFER_MODE.TRANSFER_MODE_Structure.BLOCK_COUNT_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_TRANSFER_MODE_ACMD_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->TRANSFER_MODE.TRANSFER_MODE_Structure.ACMD_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_TRANSFER_MODE_ACMD_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->TRANSFER_MODE.TRANSFER_MODE_Structure.ACMD_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_TRANSFER_MODE_TX_DIR_SELECT(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->TRANSFER_MODE.TRANSFER_MODE_Structure.TX_DIR_SELECT = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_TRANSFER_MODE_TX_DIR_SELECT(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->TRANSFER_MODE.TRANSFER_MODE_Structure.TX_DIR_SELECT;
+}
+
+__HWREG_INLINE__ void setSdmmc_TRANSFER_MODE_MULTI_BLOCK_SELECT(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->TRANSFER_MODE.TRANSFER_MODE_Structure.MULTI_BLOCK_SELECT = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_TRANSFER_MODE_MULTI_BLOCK_SELECT(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->TRANSFER_MODE.TRANSFER_MODE_Structure.MULTI_BLOCK_SELECT;
+}
+
+__HWREG_INLINE__ void setSdmmc_TRANSFER_MODE_CMD_COMP_ATA(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->TRANSFER_MODE.TRANSFER_MODE_Structure.CMD_COMP_ATA = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_TRANSFER_MODE_CMD_COMP_ATA(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->TRANSFER_MODE.TRANSFER_MODE_Structure.CMD_COMP_ATA;
+}
+
+
+__HWREG_INLINE__ void setSdmmc_COMMAND(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->COMMAND.COMMAND_Content = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_COMMAND(volatile sSdmmc *_sdmmc_)
+{
+    return _sdmmc_->COMMAND.COMMAND_Content;
+}
+
+__HWREG_INLINE__ void setSdmmc_COMMAND_RESP_TYPE_SELECT(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->COMMAND.COMMAND_Structure.RESP_TYPE_SELECT = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_COMMAND_RESP_TYPE_SELECT(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->COMMAND.COMMAND_Structure.RESP_TYPE_SELECT;
+}
+
+__HWREG_INLINE__ void setSdmmc_COMMAND_CMD_CRC_CHECK_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->COMMAND.COMMAND_Structure.CMD_CRC_CHECK_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_COMMAND_CMD_CRC_CHECK_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->COMMAND.COMMAND_Structure.CMD_CRC_CHECK_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_COMMAND_CMD_IND_CHECK_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->COMMAND.COMMAND_Structure.CMD_IND_CHECK_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_COMMAND_CMD_IND_CHECK_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->COMMAND.COMMAND_Structure.CMD_IND_CHECK_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_COMMAND_DATA_PRESENT_SELECT(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->COMMAND.COMMAND_Structure.DATA_PRESENT_SELECT = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_COMMAND_DATA_PRESENT_SELECT(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->COMMAND.COMMAND_Structure.DATA_PRESENT_SELECT;
+}
+
+__HWREG_INLINE__ void setSdmmc_COMMAND_CMD_TYPE(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->COMMAND.COMMAND_Structure.CMD_TYPE = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_COMMAND_CMD_TYPE(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->COMMAND.COMMAND_Structure.CMD_TYPE;
+}
+
+__HWREG_INLINE__ void setSdmmc_COMMAND_CMD_IND(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->COMMAND.COMMAND_Structure.CMD_IND = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_COMMAND_CMD_IND(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->COMMAND.COMMAND_Structure.CMD_IND;
+}
+
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_RESPONSE0(volatile sSdmmc *_sdmmc_)
+{
+    return _sdmmc_->RESPONSE0.RESPONSE0_Content;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_RESPONSE0_RESPONSE0(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->RESPONSE0.RESPONSE0_Structure.RESPONSE0;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_RESPONSE0_RESPONSE1(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->RESPONSE0.RESPONSE0_Structure.RESPONSE1;
+}
+
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_RESPONSE2(volatile sSdmmc *_sdmmc_)
+{
+    return _sdmmc_->RESPONSE2.RESPONSE2_Content;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_RESPONSE2_RESPONSE2(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->RESPONSE2.RESPONSE2_Structure.RESPONSE2;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_RESPONSE2_RESPONSE3(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->RESPONSE2.RESPONSE2_Structure.RESPONSE3;
+}
+
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_RESPONSE4(volatile sSdmmc *_sdmmc_)
+{
+    return _sdmmc_->RESPONSE4.RESPONSE4_Content;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_RESPONSE4_RESPONSE4(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->RESPONSE4.RESPONSE4_Structure.RESPONSE4;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_RESPONSE4_RESPONSE5(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->RESPONSE4.RESPONSE4_Structure.RESPONSE5;
+}
+
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_RESPONSE6(volatile sSdmmc *_sdmmc_)
+{
+    return _sdmmc_->RESPONSE6.RESPONSE6_Content;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_RESPONSE6_RESPONSE6(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->RESPONSE6.RESPONSE6_Structure.RESPONSE6;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_RESPONSE6_RESPONSE7(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->RESPONSE6.RESPONSE6_Structure.RESPONSE7;
+}
+
+
+__HWREG_INLINE__ void setSdmmc_DATA_BUFFER(volatile sSdmmc *_sdmmc_, HWREG_U32 value)
+{
+    _sdmmc_->DATA_BUFFER.DATA_BUFFER_Content = value;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_DATA_BUFFER(volatile sSdmmc *_sdmmc_)
+{
+    return _sdmmc_->DATA_BUFFER.DATA_BUFFER_Content;
+}
+
+__HWREG_INLINE__ void setSdmmc_DATA_BUFFER_DATA_BUFFER(volatile sSdmmc *_sdmmc_, HWREG_U32 value)
+{
+    _sdmmc_->DATA_BUFFER.DATA_BUFFER_Structure.DATA_BUFFER = value;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_DATA_BUFFER_DATA_BUFFER(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->DATA_BUFFER.DATA_BUFFER_Structure.DATA_BUFFER;
+}
+
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_PRESENT_STATE(volatile sSdmmc *_sdmmc_)
+{
+    return _sdmmc_->PRESENT_STATE.PRESENT_STATE_Content;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_PRESENT_STATE_COMMAND_INHIBIT_CMD(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->PRESENT_STATE.PRESENT_STATE_Structure.COMMAND_INHIBIT_CMD;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_PRESENT_STATE_COMMAND_INHIBIT_DAT(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->PRESENT_STATE.PRESENT_STATE_Structure.COMMAND_INHIBIT_DAT;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_PRESENT_STATE_DAT_LINE_ACTIVE(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->PRESENT_STATE.PRESENT_STATE_Structure.DAT_LINE_ACTIVE;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_PRESENT_STATE_RETUNING_REQUEST(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->PRESENT_STATE.PRESENT_STATE_Structure.RETUNING_REQUEST;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_PRESENT_STATE_WRITE_TRANSFER_ACTIVE(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->PRESENT_STATE.PRESENT_STATE_Structure.WRITE_TRANSFER_ACTIVE;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_PRESENT_STATE_READ_TRANSFER_ACTIVE(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->PRESENT_STATE.PRESENT_STATE_Structure.READ_TRANSFER_ACTIVE;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_PRESENT_STATE_BUFFER_WRITE_ENABLE(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->PRESENT_STATE.PRESENT_STATE_Structure.BUFFER_WRITE_ENABLE;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_PRESENT_STATE_BUFFER_READ_ENABLE(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->PRESENT_STATE.PRESENT_STATE_Structure.BUFFER_READ_ENABLE;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_PRESENT_STATE_CARD_INSERTED(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->PRESENT_STATE.PRESENT_STATE_Structure.CARD_INSERTED;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_PRESENT_STATE_CARD_STATE_STABLE(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->PRESENT_STATE.PRESENT_STATE_Structure.CARD_STATE_STABLE;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_PRESENT_STATE_CARD_DETECT_PIN_LEVEL(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->PRESENT_STATE.PRESENT_STATE_Structure.CARD_DETECT_PIN_LEVEL;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_PRESENT_STATE_WRITE_PROTECT_PIN_LEVEL(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->PRESENT_STATE.PRESENT_STATE_Structure.WRITE_PROTECT_PIN_LEVEL;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_PRESENT_STATE_DAT_3_0_PIN_LEVEL(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->PRESENT_STATE.PRESENT_STATE_Structure.DAT_3_0_PIN_LEVEL;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_PRESENT_STATE_CMD_LINE_LEVEL(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->PRESENT_STATE.PRESENT_STATE_Structure.CMD_LINE_LEVEL;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_PRESENT_STATE_DAT_7_4_PIN_LEVEL(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->PRESENT_STATE.PRESENT_STATE_Structure.DAT_7_4_PIN_LEVEL;
+}
+
+
+__HWREG_INLINE__ void setSdmmc_HOST_CTRL(volatile sSdmmc *_sdmmc_, HWREG_U8 value)
+{
+    _sdmmc_->HOST_CTRL.HOST_CTRL_Content = value;
+}
+
+__HWREG_INLINE__ HWREG_U8 getSdmmc_HOST_CTRL(volatile sSdmmc *_sdmmc_)
+{
+    return _sdmmc_->HOST_CTRL.HOST_CTRL_Content;
+}
+
+__HWREG_INLINE__ void setSdmmc_HOST_CTRL_LED_CTRL(volatile sSdmmc *_sdmmc_, HWREG_U8 value)
+{
+    _sdmmc_->HOST_CTRL.HOST_CTRL_Structure.LED_CTRL = value;
+}
+
+__HWREG_INLINE__ HWREG_U8 getSdmmc_HOST_CTRL_LED_CTRL(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U8)_sdmmc_->HOST_CTRL.HOST_CTRL_Structure.LED_CTRL;
+}
+
+__HWREG_INLINE__ void setSdmmc_HOST_CTRL_DATA_TX_WIDTH(volatile sSdmmc *_sdmmc_, HWREG_U8 value)
+{
+    _sdmmc_->HOST_CTRL.HOST_CTRL_Structure.DATA_TX_WIDTH = value;
+}
+
+__HWREG_INLINE__ HWREG_U8 getSdmmc_HOST_CTRL_DATA_TX_WIDTH(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U8)_sdmmc_->HOST_CTRL.HOST_CTRL_Structure.DATA_TX_WIDTH;
+}
+
+__HWREG_INLINE__ void setSdmmc_HOST_CTRL_HIGH_SPEED_EN(volatile sSdmmc *_sdmmc_, HWREG_U8 value)
+{
+    _sdmmc_->HOST_CTRL.HOST_CTRL_Structure.HIGH_SPEED_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U8 getSdmmc_HOST_CTRL_HIGH_SPEED_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U8)_sdmmc_->HOST_CTRL.HOST_CTRL_Structure.HIGH_SPEED_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_HOST_CTRL_DMA_SELECT(volatile sSdmmc *_sdmmc_, HWREG_U8 value)
+{
+    _sdmmc_->HOST_CTRL.HOST_CTRL_Structure.DMA_SELECT = value;
+}
+
+__HWREG_INLINE__ HWREG_U8 getSdmmc_HOST_CTRL_DMA_SELECT(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U8)_sdmmc_->HOST_CTRL.HOST_CTRL_Structure.DMA_SELECT;
+}
+
+__HWREG_INLINE__ void setSdmmc_HOST_CTRL_SD_8BIT_MODE(volatile sSdmmc *_sdmmc_, HWREG_U8 value)
+{
+    _sdmmc_->HOST_CTRL.HOST_CTRL_Structure.SD_8BIT_MODE = value;
+}
+
+__HWREG_INLINE__ HWREG_U8 getSdmmc_HOST_CTRL_SD_8BIT_MODE(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U8)_sdmmc_->HOST_CTRL.HOST_CTRL_Structure.SD_8BIT_MODE;
+}
+
+__HWREG_INLINE__ void setSdmmc_HOST_CTRL_CARD_DETECT_TEST_LEVEL(volatile sSdmmc *_sdmmc_, HWREG_U8 value)
+{
+    _sdmmc_->HOST_CTRL.HOST_CTRL_Structure.CARD_DETECT_TEST_LEVEL = value;
+}
+
+__HWREG_INLINE__ HWREG_U8 getSdmmc_HOST_CTRL_CARD_DETECT_TEST_LEVEL(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U8)_sdmmc_->HOST_CTRL.HOST_CTRL_Structure.CARD_DETECT_TEST_LEVEL;
+}
+
+__HWREG_INLINE__ void setSdmmc_HOST_CTRL_CARD_DET_SIGNAL_DETECT(volatile sSdmmc *_sdmmc_, HWREG_U8 value)
+{
+    _sdmmc_->HOST_CTRL.HOST_CTRL_Structure.CARD_DET_SIGNAL_DETECT = value;
+}
+
+__HWREG_INLINE__ HWREG_U8 getSdmmc_HOST_CTRL_CARD_DET_SIGNAL_DETECT(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U8)_sdmmc_->HOST_CTRL.HOST_CTRL_Structure.CARD_DET_SIGNAL_DETECT;
+}
+
+
+__HWREG_INLINE__ void setSdmmc_POWER_CTRL(volatile sSdmmc *_sdmmc_, HWREG_U8 value)
+{
+    _sdmmc_->POWER_CTRL.POWER_CTRL_Content = value;
+}
+
+__HWREG_INLINE__ HWREG_U8 getSdmmc_POWER_CTRL(volatile sSdmmc *_sdmmc_)
+{
+    return _sdmmc_->POWER_CTRL.POWER_CTRL_Content;
+}
+
+__HWREG_INLINE__ void setSdmmc_POWER_CTRL_SD_BUS_POWER(volatile sSdmmc *_sdmmc_, HWREG_U8 value)
+{
+    _sdmmc_->POWER_CTRL.POWER_CTRL_Structure.SD_BUS_POWER = value;
+}
+
+__HWREG_INLINE__ HWREG_U8 getSdmmc_POWER_CTRL_SD_BUS_POWER(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U8)_sdmmc_->POWER_CTRL.POWER_CTRL_Structure.SD_BUS_POWER;
+}
+
+__HWREG_INLINE__ void setSdmmc_POWER_CTRL_SD_BUS_VOLTAGE_SEL(volatile sSdmmc *_sdmmc_, HWREG_U8 value)
+{
+    _sdmmc_->POWER_CTRL.POWER_CTRL_Structure.SD_BUS_VOLTAGE_SEL = value;
+}
+
+__HWREG_INLINE__ HWREG_U8 getSdmmc_POWER_CTRL_SD_BUS_VOLTAGE_SEL(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U8)_sdmmc_->POWER_CTRL.POWER_CTRL_Structure.SD_BUS_VOLTAGE_SEL;
+}
+
+__HWREG_INLINE__ void setSdmmc_POWER_CTRL_HARDWARE_RESET(volatile sSdmmc *_sdmmc_, HWREG_U8 value)
+{
+    _sdmmc_->POWER_CTRL.POWER_CTRL_Structure.HARDWARE_RESET = value;
+}
+
+__HWREG_INLINE__ HWREG_U8 getSdmmc_POWER_CTRL_HARDWARE_RESET(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U8)_sdmmc_->POWER_CTRL.POWER_CTRL_Structure.HARDWARE_RESET;
+}
+
+__HWREG_INLINE__ HWREG_U8 getSdmmc_POWER_CTRL_Res3(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U8)_sdmmc_->POWER_CTRL.POWER_CTRL_Structure.Res3;
+}
+
+
+__HWREG_INLINE__ void setSdmmc_BLOCK_GAP_CTRL(volatile sSdmmc *_sdmmc_, HWREG_U8 value)
+{
+    _sdmmc_->BLOCK_GAP_CTRL.BLOCK_GAP_CTRL_Content = value;
+}
+
+__HWREG_INLINE__ HWREG_U8 getSdmmc_BLOCK_GAP_CTRL(volatile sSdmmc *_sdmmc_)
+{
+    return _sdmmc_->BLOCK_GAP_CTRL.BLOCK_GAP_CTRL_Content;
+}
+
+__HWREG_INLINE__ void setSdmmc_BLOCK_GAP_CTRL_STOP_AT_BLOCK_GAP(volatile sSdmmc *_sdmmc_, HWREG_U8 value)
+{
+    _sdmmc_->BLOCK_GAP_CTRL.BLOCK_GAP_CTRL_Structure.STOP_AT_BLOCK_GAP = value;
+}
+
+__HWREG_INLINE__ HWREG_U8 getSdmmc_BLOCK_GAP_CTRL_STOP_AT_BLOCK_GAP(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U8)_sdmmc_->BLOCK_GAP_CTRL.BLOCK_GAP_CTRL_Structure.STOP_AT_BLOCK_GAP;
+}
+
+__HWREG_INLINE__ HWREG_U8 getSdmmc_BLOCK_GAP_CTRL_CONTINUE_REQ(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U8)_sdmmc_->BLOCK_GAP_CTRL.BLOCK_GAP_CTRL_Structure.CONTINUE_REQ;
+}
+
+__HWREG_INLINE__ void setSdmmc_BLOCK_GAP_CTRL_READ_WAIT_CTRL(volatile sSdmmc *_sdmmc_, HWREG_U8 value)
+{
+    _sdmmc_->BLOCK_GAP_CTRL.BLOCK_GAP_CTRL_Structure.READ_WAIT_CTRL = value;
+}
+
+__HWREG_INLINE__ HWREG_U8 getSdmmc_BLOCK_GAP_CTRL_READ_WAIT_CTRL(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U8)_sdmmc_->BLOCK_GAP_CTRL.BLOCK_GAP_CTRL_Structure.READ_WAIT_CTRL;
+}
+
+__HWREG_INLINE__ void setSdmmc_BLOCK_GAP_CTRL_INT_AT_BLOCK_GAP(volatile sSdmmc *_sdmmc_, HWREG_U8 value)
+{
+    _sdmmc_->BLOCK_GAP_CTRL.BLOCK_GAP_CTRL_Structure.INT_AT_BLOCK_GAP = value;
+}
+
+__HWREG_INLINE__ HWREG_U8 getSdmmc_BLOCK_GAP_CTRL_INT_AT_BLOCK_GAP(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U8)_sdmmc_->BLOCK_GAP_CTRL.BLOCK_GAP_CTRL_Structure.INT_AT_BLOCK_GAP;
+}
+
+__HWREG_INLINE__ void setSdmmc_BLOCK_GAP_CTRL_SPI_MODE(volatile sSdmmc *_sdmmc_, HWREG_U8 value)
+{
+    _sdmmc_->BLOCK_GAP_CTRL.BLOCK_GAP_CTRL_Structure.SPI_MODE = value;
+}
+
+__HWREG_INLINE__ HWREG_U8 getSdmmc_BLOCK_GAP_CTRL_SPI_MODE(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U8)_sdmmc_->BLOCK_GAP_CTRL.BLOCK_GAP_CTRL_Structure.SPI_MODE;
+}
+
+__HWREG_INLINE__ void setSdmmc_BLOCK_GAP_CTRL_BOOT_EN(volatile sSdmmc *_sdmmc_, HWREG_U8 value)
+{
+    _sdmmc_->BLOCK_GAP_CTRL.BLOCK_GAP_CTRL_Structure.BOOT_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U8 getSdmmc_BLOCK_GAP_CTRL_BOOT_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U8)_sdmmc_->BLOCK_GAP_CTRL.BLOCK_GAP_CTRL_Structure.BOOT_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_BLOCK_GAP_CTRL_ALT_BOOT_EN(volatile sSdmmc *_sdmmc_, HWREG_U8 value)
+{
+    _sdmmc_->BLOCK_GAP_CTRL.BLOCK_GAP_CTRL_Structure.ALT_BOOT_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U8 getSdmmc_BLOCK_GAP_CTRL_ALT_BOOT_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U8)_sdmmc_->BLOCK_GAP_CTRL.BLOCK_GAP_CTRL_Structure.ALT_BOOT_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_BLOCK_GAP_CTRL_BOOT_ACK_CHK(volatile sSdmmc *_sdmmc_, eBLOCK_GAP_CTRL_BOOT_ACK_CHK value)
+{
+    _sdmmc_->BLOCK_GAP_CTRL.BLOCK_GAP_CTRL_Structure.BOOT_ACK_CHK = value;
+}
+
+__HWREG_INLINE__ eBLOCK_GAP_CTRL_BOOT_ACK_CHK getSdmmc_BLOCK_GAP_CTRL_BOOT_ACK_CHK(volatile sSdmmc *_sdmmc_)
+{
+    return (eBLOCK_GAP_CTRL_BOOT_ACK_CHK)_sdmmc_->BLOCK_GAP_CTRL.BLOCK_GAP_CTRL_Structure.BOOT_ACK_CHK;
+}
+
+
+__HWREG_INLINE__ void setSdmmc_WAKEUP_CTRL(volatile sSdmmc *_sdmmc_, HWREG_U8 value)
+{
+    _sdmmc_->WAKEUP_CTRL.WAKEUP_CTRL_Content = value;
+}
+
+__HWREG_INLINE__ HWREG_U8 getSdmmc_WAKEUP_CTRL(volatile sSdmmc *_sdmmc_)
+{
+    return _sdmmc_->WAKEUP_CTRL.WAKEUP_CTRL_Content;
+}
+
+__HWREG_INLINE__ void setSdmmc_WAKEUP_CTRL_WAKEUP_EVENT_EN_INT(volatile sSdmmc *_sdmmc_, HWREG_U8 value)
+{
+    _sdmmc_->WAKEUP_CTRL.WAKEUP_CTRL_Structure.WAKEUP_EVENT_EN_INT = value;
+}
+
+__HWREG_INLINE__ HWREG_U8 getSdmmc_WAKEUP_CTRL_WAKEUP_EVENT_EN_INT(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U8)_sdmmc_->WAKEUP_CTRL.WAKEUP_CTRL_Structure.WAKEUP_EVENT_EN_INT;
+}
+
+__HWREG_INLINE__ void setSdmmc_WAKEUP_CTRL_WAKEUP_EVENT_EN_INS(volatile sSdmmc *_sdmmc_, HWREG_U8 value)
+{
+    _sdmmc_->WAKEUP_CTRL.WAKEUP_CTRL_Structure.WAKEUP_EVENT_EN_INS = value;
+}
+
+__HWREG_INLINE__ HWREG_U8 getSdmmc_WAKEUP_CTRL_WAKEUP_EVENT_EN_INS(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U8)_sdmmc_->WAKEUP_CTRL.WAKEUP_CTRL_Structure.WAKEUP_EVENT_EN_INS;
+}
+
+__HWREG_INLINE__ void setSdmmc_WAKEUP_CTRL_WAKEUP_EVENT_EN_REM(volatile sSdmmc *_sdmmc_, HWREG_U8 value)
+{
+    _sdmmc_->WAKEUP_CTRL.WAKEUP_CTRL_Structure.WAKEUP_EVENT_EN_REM = value;
+}
+
+__HWREG_INLINE__ HWREG_U8 getSdmmc_WAKEUP_CTRL_WAKEUP_EVENT_EN_REM(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U8)_sdmmc_->WAKEUP_CTRL.WAKEUP_CTRL_Structure.WAKEUP_EVENT_EN_REM;
+}
+
+
+__HWREG_INLINE__ void setSdmmc_CLOCK_CTRL(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->CLOCK_CTRL.CLOCK_CTRL_Content = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_CLOCK_CTRL(volatile sSdmmc *_sdmmc_)
+{
+    return _sdmmc_->CLOCK_CTRL.CLOCK_CTRL_Content;
+}
+
+__HWREG_INLINE__ void setSdmmc_CLOCK_CTRL_INTERNAL_CLOCK_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->CLOCK_CTRL.CLOCK_CTRL_Structure.INTERNAL_CLOCK_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_CLOCK_CTRL_INTERNAL_CLOCK_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->CLOCK_CTRL.CLOCK_CTRL_Structure.INTERNAL_CLOCK_EN;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_CLOCK_CTRL_INTERNAL_CLOCK_STABLE(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->CLOCK_CTRL.CLOCK_CTRL_Structure.INTERNAL_CLOCK_STABLE;
+}
+
+__HWREG_INLINE__ void setSdmmc_CLOCK_CTRL_SDCLOCK_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->CLOCK_CTRL.CLOCK_CTRL_Structure.SDCLOCK_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_CLOCK_CTRL_SDCLOCK_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->CLOCK_CTRL.CLOCK_CTRL_Structure.SDCLOCK_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_CLOCK_CTRL_CLK_GEN_SEL(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->CLOCK_CTRL.CLOCK_CTRL_Structure.CLK_GEN_SEL = value;
+}
+
+__HWREG_INLINE__ void setSdmmc_CLOCK_CTRL_SDCLK_FREQ_SEL_H(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->CLOCK_CTRL.CLOCK_CTRL_Structure.SDCLK_FREQ_SEL_H = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_CLOCK_CTRL_SDCLK_FREQ_SEL_H(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->CLOCK_CTRL.CLOCK_CTRL_Structure.SDCLK_FREQ_SEL_H;
+}
+
+__HWREG_INLINE__ void setSdmmc_CLOCK_CTRL_SDCLK_FREQ_SEL(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->CLOCK_CTRL.CLOCK_CTRL_Structure.SDCLK_FREQ_SEL = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_CLOCK_CTRL_SDCLK_FREQ_SEL(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->CLOCK_CTRL.CLOCK_CTRL_Structure.SDCLK_FREQ_SEL;
+}
+
+
+__HWREG_INLINE__ void setSdmmc_TIMEOUT_CTRL(volatile sSdmmc *_sdmmc_, HWREG_U8 value)
+{
+    _sdmmc_->TIMEOUT_CTRL.TIMEOUT_CTRL_Content = value;
+}
+
+__HWREG_INLINE__ HWREG_U8 getSdmmc_TIMEOUT_CTRL(volatile sSdmmc *_sdmmc_)
+{
+    return _sdmmc_->TIMEOUT_CTRL.TIMEOUT_CTRL_Content;
+}
+
+__HWREG_INLINE__ void setSdmmc_TIMEOUT_CTRL_DAT_TIMEOUT_CNT_VAL(volatile sSdmmc *_sdmmc_, HWREG_U8 value)
+{
+    _sdmmc_->TIMEOUT_CTRL.TIMEOUT_CTRL_Structure.DAT_TIMEOUT_CNT_VAL = value;
+}
+
+__HWREG_INLINE__ HWREG_U8 getSdmmc_TIMEOUT_CTRL_DAT_TIMEOUT_CNT_VAL(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U8)_sdmmc_->TIMEOUT_CTRL.TIMEOUT_CTRL_Structure.DAT_TIMEOUT_CNT_VAL;
+}
+
+__HWREG_INLINE__ HWREG_U8 getSdmmc_TIMEOUT_CTRL_Res2(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U8)_sdmmc_->TIMEOUT_CTRL.TIMEOUT_CTRL_Structure.Res2;
+}
+
+
+__HWREG_INLINE__ void setSdmmc_SW_RESET(volatile sSdmmc *_sdmmc_, HWREG_U8 value)
+{
+    _sdmmc_->SOFTWARE_RESET.SW_RESET_Content = value;
+}
+
+__HWREG_INLINE__ HWREG_U8 getSdmmc_SW_RESET(volatile sSdmmc *_sdmmc_)
+{
+    return _sdmmc_->SOFTWARE_RESET.SW_RESET_Content;
+}
+
+__HWREG_INLINE__ void setSdmmc_SW_RESET_SW_RST_ALL(volatile sSdmmc *_sdmmc_, HWREG_U8 value)
+{
+    _sdmmc_->SOFTWARE_RESET.SW_RESET_Structure.SW_RST_ALL = value;
+}
+
+__HWREG_INLINE__ HWREG_U8 getSdmmc_SW_RESET_SW_RST_ALL(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U8)_sdmmc_->SOFTWARE_RESET.SW_RESET_Structure.SW_RST_ALL;
+}
+
+__HWREG_INLINE__ void setSdmmc_SW_RESET_SW_RST_CMD_LINE(volatile sSdmmc *_sdmmc_, HWREG_U8 value)
+{
+    _sdmmc_->SOFTWARE_RESET.SW_RESET_Structure.SW_RST_CMD_LINE = value;
+}
+
+__HWREG_INLINE__ HWREG_U8 getSdmmc_SW_RESET_SW_RST_CMD_LINE(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U8)_sdmmc_->SOFTWARE_RESET.SW_RESET_Structure.SW_RST_CMD_LINE;
+}
+
+__HWREG_INLINE__ void setSdmmc_SW_RESET_SW_RST_DAT_LINE(volatile sSdmmc *_sdmmc_, HWREG_U8 value)
+{
+    _sdmmc_->SOFTWARE_RESET.SW_RESET_Structure.SW_RST_DAT_LINE = value;
+}
+
+__HWREG_INLINE__ HWREG_U8 getSdmmc_SW_RESET_SW_RST_DAT_LINE(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U8)_sdmmc_->SOFTWARE_RESET.SW_RESET_Structure.SW_RST_DAT_LINE;
+}
+
+
+__HWREG_INLINE__ void setSdmmc_INT_STATUS_NORM(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->INT_STATUS_NORM.INT_STATUS_NORM_Content = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_NORM(volatile sSdmmc *_sdmmc_)
+{
+    return _sdmmc_->INT_STATUS_NORM.INT_STATUS_NORM_Content;
+}
+
+__HWREG_INLINE__ void setSdmmc_INT_STATUS_NORM_CMD_COMPLETE(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->INT_STATUS_NORM.INT_STATUS_NORM_Structure.CMD_COMPLETE = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_NORM_CMD_COMPLETE(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->INT_STATUS_NORM.INT_STATUS_NORM_Structure.CMD_COMPLETE;
+}
+
+__HWREG_INLINE__ void setSdmmc_INT_STATUS_NORM_TX_COMPLETE(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->INT_STATUS_NORM.INT_STATUS_NORM_Structure.TX_COMPLETE = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_NORM_TX_COMPLETE(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->INT_STATUS_NORM.INT_STATUS_NORM_Structure.TX_COMPLETE;
+}
+
+__HWREG_INLINE__ void setSdmmc_INT_STATUS_NORM_BLOCK_GAP_EVENT(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->INT_STATUS_NORM.INT_STATUS_NORM_Structure.BLOCK_GAP_EVENT = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_NORM_BLOCK_GAP_EVENT(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->INT_STATUS_NORM.INT_STATUS_NORM_Structure.BLOCK_GAP_EVENT;
+}
+
+__HWREG_INLINE__ void setSdmmc_INT_STATUS_NORM_DMA_INT(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->INT_STATUS_NORM.INT_STATUS_NORM_Structure.DMA_INT = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_NORM_DMA_INT(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->INT_STATUS_NORM.INT_STATUS_NORM_Structure.DMA_INT;
+}
+
+__HWREG_INLINE__ void setSdmmc_INT_STATUS_NORM_BUFF_WRITE_READY(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->INT_STATUS_NORM.INT_STATUS_NORM_Structure.BUFF_WRITE_READY = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_NORM_BUFF_WRITE_READY(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->INT_STATUS_NORM.INT_STATUS_NORM_Structure.BUFF_WRITE_READY;
+}
+
+__HWREG_INLINE__ void setSdmmc_INT_STATUS_NORM_BUFF_READ_READY(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->INT_STATUS_NORM.INT_STATUS_NORM_Structure.BUFF_READ_READY = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_NORM_BUFF_READ_READY(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->INT_STATUS_NORM.INT_STATUS_NORM_Structure.BUFF_READ_READY;
+}
+
+__HWREG_INLINE__ void setSdmmc_INT_STATUS_NORM_CARD_INS(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->INT_STATUS_NORM.INT_STATUS_NORM_Structure.CARD_INS = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_NORM_CARD_INS(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->INT_STATUS_NORM.INT_STATUS_NORM_Structure.CARD_INS;
+}
+
+__HWREG_INLINE__ void setSdmmc_INT_STATUS_NORM_CARD_REMOVAL(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->INT_STATUS_NORM.INT_STATUS_NORM_Structure.CARD_REMOVAL = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_NORM_CARD_REMOVAL(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->INT_STATUS_NORM.INT_STATUS_NORM_Structure.CARD_REMOVAL;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_NORM_CARD_INT(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->INT_STATUS_NORM.INT_STATUS_NORM_Structure.CARD_INT;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_NORM_INT_A(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->INT_STATUS_NORM.INT_STATUS_NORM_Structure.INT_A;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_NORM_INT_B(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->INT_STATUS_NORM.INT_STATUS_NORM_Structure.INT_B;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_NORM_INT_C(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->INT_STATUS_NORM.INT_STATUS_NORM_Structure.INT_C;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_NORM_RETUNING_EVENT(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->INT_STATUS_NORM.INT_STATUS_NORM_Structure.RETUNING_EVENT;
+}
+
+__HWREG_INLINE__ void setSdmmc_INT_STATUS_NORM_BOOT_ACK_RCV(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->INT_STATUS_NORM.INT_STATUS_NORM_Structure.BOOT_ACK_RCV = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_NORM_BOOT_ACK_RCV(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->INT_STATUS_NORM.INT_STATUS_NORM_Structure.BOOT_ACK_RCV;
+}
+
+__HWREG_INLINE__ void setSdmmc_INT_STATUS_NORM_BOOT_TERM_INT(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->INT_STATUS_NORM.INT_STATUS_NORM_Structure.BOOT_TERM_INT = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_NORM_BOOT_TERM_INT(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->INT_STATUS_NORM.INT_STATUS_NORM_Structure.BOOT_TERM_INT;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_NORM_ERR_INT(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->INT_STATUS_NORM.INT_STATUS_NORM_Structure.ERR_INT;
+}
+
+
+__HWREG_INLINE__ void setSdmmc_INT_STATUS_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->INT_STATUS_ERR.INT_STATUS_ERR_Content = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_ERR(volatile sSdmmc *_sdmmc_)
+{
+    return _sdmmc_->INT_STATUS_ERR.INT_STATUS_ERR_Content;
+}
+
+__HWREG_INLINE__ void setSdmmc_INT_STATUS_ERR_CMD_TIMEOUT_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->INT_STATUS_ERR.INT_STATUS_ERR_Structure.CMD_TIMEOUT_ERR = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_ERR_CMD_TIMEOUT_ERR(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->INT_STATUS_ERR.INT_STATUS_ERR_Structure.CMD_TIMEOUT_ERR;
+}
+
+__HWREG_INLINE__ void setSdmmc_INT_STATUS_ERR_CMD_CRC_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->INT_STATUS_ERR.INT_STATUS_ERR_Structure.CMD_CRC_ERR = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_ERR_CMD_CRC_ERR(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->INT_STATUS_ERR.INT_STATUS_ERR_Structure.CMD_CRC_ERR;
+}
+
+__HWREG_INLINE__ void setSdmmc_INT_STATUS_ERR_CMD_END_BIT_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->INT_STATUS_ERR.INT_STATUS_ERR_Structure.CMD_END_BIT_ERR = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_ERR_CMD_END_BIT_ERR(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->INT_STATUS_ERR.INT_STATUS_ERR_Structure.CMD_END_BIT_ERR;
+}
+
+__HWREG_INLINE__ void setSdmmc_INT_STATUS_ERR_CMD_IND_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->INT_STATUS_ERR.INT_STATUS_ERR_Structure.CMD_IND_ERR = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_ERR_CMD_IND_ERR(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->INT_STATUS_ERR.INT_STATUS_ERR_Structure.CMD_IND_ERR;
+}
+
+__HWREG_INLINE__ void setSdmmc_INT_STATUS_ERR_DATA_TIMEOUT_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->INT_STATUS_ERR.INT_STATUS_ERR_Structure.DATA_TIMEOUT_ERR = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_ERR_DATA_TIMEOUT_ERR(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->INT_STATUS_ERR.INT_STATUS_ERR_Structure.DATA_TIMEOUT_ERR;
+}
+
+__HWREG_INLINE__ void setSdmmc_INT_STATUS_ERR_DATA_CRC_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->INT_STATUS_ERR.INT_STATUS_ERR_Structure.DATA_CRC_ERR = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_ERR_DATA_CRC_ERR(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->INT_STATUS_ERR.INT_STATUS_ERR_Structure.DATA_CRC_ERR;
+}
+
+__HWREG_INLINE__ void setSdmmc_INT_STATUS_ERR_DATA_END_BIT_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->INT_STATUS_ERR.INT_STATUS_ERR_Structure.DATA_END_BIT_ERR = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_ERR_DATA_END_BIT_ERR(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->INT_STATUS_ERR.INT_STATUS_ERR_Structure.DATA_END_BIT_ERR;
+}
+
+__HWREG_INLINE__ void setSdmmc_INT_STATUS_ERR_CURRENT_LIMIT_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->INT_STATUS_ERR.INT_STATUS_ERR_Structure.CURRENT_LIMIT_ERR = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_ERR_CURRENT_LIMIT_ERR(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->INT_STATUS_ERR.INT_STATUS_ERR_Structure.CURRENT_LIMIT_ERR;
+}
+
+__HWREG_INLINE__ void setSdmmc_INT_STATUS_ERR_ACMD_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->INT_STATUS_ERR.INT_STATUS_ERR_Structure.ACMD_ERR = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_ERR_ACMD_ERR(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->INT_STATUS_ERR.INT_STATUS_ERR_Structure.ACMD_ERR;
+}
+
+__HWREG_INLINE__ void setSdmmc_INT_STATUS_ERR_ADMA_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->INT_STATUS_ERR.INT_STATUS_ERR_Structure.ADMA_ERR = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_ERR_ADMA_ERR(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->INT_STATUS_ERR.INT_STATUS_ERR_Structure.ADMA_ERR;
+}
+
+__HWREG_INLINE__ void setSdmmc_INT_STATUS_ERR_TUNING_ERROR(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->INT_STATUS_ERR.INT_STATUS_ERR_Structure.TUNING_ERROR = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_ERR_TUNING_ERROR(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->INT_STATUS_ERR.INT_STATUS_ERR_Structure.TUNING_ERROR;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_ERR_res11(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->INT_STATUS_ERR.INT_STATUS_ERR_Structure.res11;
+}
+
+__HWREG_INLINE__ void setSdmmc_INT_STATUS_ERR_TARGET_RESP_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->INT_STATUS_ERR.INT_STATUS_ERR_Structure.TARGET_RESP_ERR = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_ERR_TARGET_RESP_ERR(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->INT_STATUS_ERR.INT_STATUS_ERR_Structure.TARGET_RESP_ERR;
+}
+
+__HWREG_INLINE__ void setSdmmc_INT_STATUS_ERR_CEATA_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->INT_STATUS_ERR.INT_STATUS_ERR_Structure.CEATA_ERR = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_ERR_CEATA_ERR(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->INT_STATUS_ERR.INT_STATUS_ERR_Structure.CEATA_ERR;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_INT_STATUS_ERR_VSES1514(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->INT_STATUS_ERR.INT_STATUS_ERR_Structure.VSES1514;
+}
+
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_NORM(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_STATUS_NORM.EN_INT_STATUS_NORM_Content = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_NORM(volatile sSdmmc *_sdmmc_)
+{
+    return _sdmmc_->EN_INT_STATUS_NORM.EN_INT_STATUS_NORM_Content;
+}
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_NORM_CMD_COMPLETE_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_STATUS_NORM.EN_INT_STATUS_NORM_Structure.CMD_COMPLETE_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_NORM_CMD_COMPLETE_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_STATUS_NORM.EN_INT_STATUS_NORM_Structure.CMD_COMPLETE_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_NORM_TX_COMPLETE_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_STATUS_NORM.EN_INT_STATUS_NORM_Structure.TX_COMPLETE_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_NORM_TX_COMPLETE_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_STATUS_NORM.EN_INT_STATUS_NORM_Structure.TX_COMPLETE_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_NORM_BLOCK_GAP_EVENT_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_STATUS_NORM.EN_INT_STATUS_NORM_Structure.BLOCK_GAP_EVENT_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_NORM_BLOCK_GAP_EVENT_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_STATUS_NORM.EN_INT_STATUS_NORM_Structure.BLOCK_GAP_EVENT_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_NORM_DMA_INT_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_STATUS_NORM.EN_INT_STATUS_NORM_Structure.DMA_INT_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_NORM_DMA_INT_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_STATUS_NORM.EN_INT_STATUS_NORM_Structure.DMA_INT_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_NORM_BUFF_WRITE_READY_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_STATUS_NORM.EN_INT_STATUS_NORM_Structure.BUFF_WRITE_READY_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_NORM_BUFF_WRITE_READY_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_STATUS_NORM.EN_INT_STATUS_NORM_Structure.BUFF_WRITE_READY_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_NORM_BUFF_READ_READY_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_STATUS_NORM.EN_INT_STATUS_NORM_Structure.BUFF_READ_READY_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_NORM_BUFF_READ_READY_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_STATUS_NORM.EN_INT_STATUS_NORM_Structure.BUFF_READ_READY_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_NORM_CARD_INS_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_STATUS_NORM.EN_INT_STATUS_NORM_Structure.CARD_INS_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_NORM_CARD_INS_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_STATUS_NORM.EN_INT_STATUS_NORM_Structure.CARD_INS_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_NORM_CARD_REMOVAL_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_STATUS_NORM.EN_INT_STATUS_NORM_Structure.CARD_REMOVAL_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_NORM_CARD_REMOVAL_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_STATUS_NORM.EN_INT_STATUS_NORM_Structure.CARD_REMOVAL_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_NORM_CARD_INT_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_STATUS_NORM.EN_INT_STATUS_NORM_Structure.CARD_INT_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_NORM_CARD_INT_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_STATUS_NORM.EN_INT_STATUS_NORM_Structure.CARD_INT_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_NORM_INT_A_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_STATUS_NORM.EN_INT_STATUS_NORM_Structure.INT_A_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_NORM_INT_A_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_STATUS_NORM.EN_INT_STATUS_NORM_Structure.INT_A_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_NORM_INT_B_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_STATUS_NORM.EN_INT_STATUS_NORM_Structure.INT_B_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_NORM_INT_B_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_STATUS_NORM.EN_INT_STATUS_NORM_Structure.INT_B_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_NORM_INT_C_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_STATUS_NORM.EN_INT_STATUS_NORM_Structure.INT_C_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_NORM_INT_C_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_STATUS_NORM.EN_INT_STATUS_NORM_Structure.INT_C_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_NORM_RETUNING_EVENT_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_STATUS_NORM.EN_INT_STATUS_NORM_Structure.RETUNING_EVENT_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_NORM_RETUNING_EVENT_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_STATUS_NORM.EN_INT_STATUS_NORM_Structure.RETUNING_EVENT_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_NORM_BOOT_ACK_RCV_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_STATUS_NORM.EN_INT_STATUS_NORM_Structure.BOOT_ACK_RCV_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_NORM_BOOT_ACK_RCV_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_STATUS_NORM.EN_INT_STATUS_NORM_Structure.BOOT_ACK_RCV_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_NORM_BOOT_TERM_INT_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_STATUS_NORM.EN_INT_STATUS_NORM_Structure.BOOT_TERM_INT_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_NORM_BOOT_TERM_INT_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_STATUS_NORM.EN_INT_STATUS_NORM_Structure.BOOT_TERM_INT_EN;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_NORM_FIXED_TO_0(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_STATUS_NORM.EN_INT_STATUS_NORM_Structure.FIXED_TO_0;
+}
+
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_STATUS_ERR.EN_INT_STATUS_ERR_Content = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_ERR(volatile sSdmmc *_sdmmc_)
+{
+    return _sdmmc_->EN_INT_STATUS_ERR.EN_INT_STATUS_ERR_Content;
+}
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_ERR_CMD_TIMEOUT_ERR_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_STATUS_ERR.EN_INT_STATUS_ERR_Structure.CMD_TIMEOUT_ERR_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_ERR_CMD_TIMEOUT_ERR_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_STATUS_ERR.EN_INT_STATUS_ERR_Structure.CMD_TIMEOUT_ERR_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_ERR_CMD_CRC_ERR_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_STATUS_ERR.EN_INT_STATUS_ERR_Structure.CMD_CRC_ERR_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_ERR_CMD_CRC_ERR_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_STATUS_ERR.EN_INT_STATUS_ERR_Structure.CMD_CRC_ERR_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_ERR_CMD_END_BIT_ERR_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_STATUS_ERR.EN_INT_STATUS_ERR_Structure.CMD_END_BIT_ERR_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_ERR_CMD_END_BIT_ERR_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_STATUS_ERR.EN_INT_STATUS_ERR_Structure.CMD_END_BIT_ERR_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_ERR_CMD_IND_ERR_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_STATUS_ERR.EN_INT_STATUS_ERR_Structure.CMD_IND_ERR_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_ERR_CMD_IND_ERR_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_STATUS_ERR.EN_INT_STATUS_ERR_Structure.CMD_IND_ERR_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_ERR_DATA_TIMEOUT_ERR_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_STATUS_ERR.EN_INT_STATUS_ERR_Structure.DATA_TIMEOUT_ERR_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_ERR_DATA_TIMEOUT_ERR_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_STATUS_ERR.EN_INT_STATUS_ERR_Structure.DATA_TIMEOUT_ERR_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_ERR_DATA_CRC_ERR_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_STATUS_ERR.EN_INT_STATUS_ERR_Structure.DATA_CRC_ERR_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_ERR_DATA_CRC_ERR_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_STATUS_ERR.EN_INT_STATUS_ERR_Structure.DATA_CRC_ERR_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_ERR_DATA_END_BIT_ERR_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_STATUS_ERR.EN_INT_STATUS_ERR_Structure.DATA_END_BIT_ERR_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_ERR_DATA_END_BIT_ERR_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_STATUS_ERR.EN_INT_STATUS_ERR_Structure.DATA_END_BIT_ERR_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_ERR_CURRENT_LIMIT_ERR_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_STATUS_ERR.EN_INT_STATUS_ERR_Structure.CURRENT_LIMIT_ERR_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_ERR_CURRENT_LIMIT_ERR_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_STATUS_ERR.EN_INT_STATUS_ERR_Structure.CURRENT_LIMIT_ERR_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_ERR_ACMD_ERR_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_STATUS_ERR.EN_INT_STATUS_ERR_Structure.ACMD_ERR_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_ERR_ACMD_ERR_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_STATUS_ERR.EN_INT_STATUS_ERR_Structure.ACMD_ERR_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_ERR_ADMA_ERR_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_STATUS_ERR.EN_INT_STATUS_ERR_Structure.ADMA_ERR_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_ERR_ADMA_ERR_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_STATUS_ERR.EN_INT_STATUS_ERR_Structure.ADMA_ERR_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_ERR_TUNING_ERROR_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_STATUS_ERR.EN_INT_STATUS_ERR_Structure.TUNING_ERROR_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_ERR_TUNING_ERROR_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_STATUS_ERR.EN_INT_STATUS_ERR_Structure.TUNING_ERROR_EN;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_ERR_res11(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_STATUS_ERR.EN_INT_STATUS_ERR_Structure.res11;
+}
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_ERR_TARGET_RESP_ERR_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_STATUS_ERR.EN_INT_STATUS_ERR_Structure.TARGET_RESP_ERR_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_ERR_TARGET_RESP_ERR_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_STATUS_ERR.EN_INT_STATUS_ERR_Structure.TARGET_RESP_ERR_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_STATUS_ERR_CEATA_ERR_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_STATUS_ERR.EN_INT_STATUS_ERR_Structure.CEATA_ERR_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_ERR_CEATA_ERR_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_STATUS_ERR.EN_INT_STATUS_ERR_Structure.CEATA_ERR_EN;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_STATUS_ERR_VSES1514_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_STATUS_ERR.EN_INT_STATUS_ERR_Structure.VSES1514_EN;
+}
+
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_NORM(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_SIGNAL_NORM.EN_INT_SIGNAL_NORM_Content = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_NORM(volatile sSdmmc *_sdmmc_)
+{
+    return _sdmmc_->EN_INT_SIGNAL_NORM.EN_INT_SIGNAL_NORM_Content;
+}
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_NORM_CMD_COMPLETE_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_SIGNAL_NORM.EN_INT_SIGNAL_NORM_Structure.CMD_COMPLETE_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_NORM_CMD_COMPLETE_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_SIGNAL_NORM.EN_INT_SIGNAL_NORM_Structure.CMD_COMPLETE_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_NORM_TX_COMPLETE_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_SIGNAL_NORM.EN_INT_SIGNAL_NORM_Structure.TX_COMPLETE_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_NORM_TX_COMPLETE_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_SIGNAL_NORM.EN_INT_SIGNAL_NORM_Structure.TX_COMPLETE_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_NORM_BLOCK_GAP_EVENT_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_SIGNAL_NORM.EN_INT_SIGNAL_NORM_Structure.BLOCK_GAP_EVENT_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_NORM_BLOCK_GAP_EVENT_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_SIGNAL_NORM.EN_INT_SIGNAL_NORM_Structure.BLOCK_GAP_EVENT_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_NORM_DMA_INT_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_SIGNAL_NORM.EN_INT_SIGNAL_NORM_Structure.DMA_INT_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_NORM_DMA_INT_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_SIGNAL_NORM.EN_INT_SIGNAL_NORM_Structure.DMA_INT_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_NORM_BUFF_WRITE_READY_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_SIGNAL_NORM.EN_INT_SIGNAL_NORM_Structure.BUFF_WRITE_READY_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_NORM_BUFF_WRITE_READY_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_SIGNAL_NORM.EN_INT_SIGNAL_NORM_Structure.BUFF_WRITE_READY_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_NORM_BUFF_READ_READY_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_SIGNAL_NORM.EN_INT_SIGNAL_NORM_Structure.BUFF_READ_READY_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_NORM_BUFF_READ_READY_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_SIGNAL_NORM.EN_INT_SIGNAL_NORM_Structure.BUFF_READ_READY_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_NORM_CARD_INS_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_SIGNAL_NORM.EN_INT_SIGNAL_NORM_Structure.CARD_INS_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_NORM_CARD_INS_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_SIGNAL_NORM.EN_INT_SIGNAL_NORM_Structure.CARD_INS_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_NORM_CARD_REMOVAL_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_SIGNAL_NORM.EN_INT_SIGNAL_NORM_Structure.CARD_REMOVAL_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_NORM_CARD_REMOVAL_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_SIGNAL_NORM.EN_INT_SIGNAL_NORM_Structure.CARD_REMOVAL_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_NORM_CARD_INT_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_SIGNAL_NORM.EN_INT_SIGNAL_NORM_Structure.CARD_INT_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_NORM_CARD_INT_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_SIGNAL_NORM.EN_INT_SIGNAL_NORM_Structure.CARD_INT_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_NORM_INT_A_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_SIGNAL_NORM.EN_INT_SIGNAL_NORM_Structure.INT_A_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_NORM_INT_A_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_SIGNAL_NORM.EN_INT_SIGNAL_NORM_Structure.INT_A_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_NORM_INT_B_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_SIGNAL_NORM.EN_INT_SIGNAL_NORM_Structure.INT_B_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_NORM_INT_B_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_SIGNAL_NORM.EN_INT_SIGNAL_NORM_Structure.INT_B_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_NORM_INT_C_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_SIGNAL_NORM.EN_INT_SIGNAL_NORM_Structure.INT_C_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_NORM_INT_C_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_SIGNAL_NORM.EN_INT_SIGNAL_NORM_Structure.INT_C_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_NORM_RETUNING_EVENT_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_SIGNAL_NORM.EN_INT_SIGNAL_NORM_Structure.RETUNING_EVENT_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_NORM_RETUNING_EVENT_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_SIGNAL_NORM.EN_INT_SIGNAL_NORM_Structure.RETUNING_EVENT_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_NORM_BOOT_ACK_RCV_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_SIGNAL_NORM.EN_INT_SIGNAL_NORM_Structure.BOOT_ACK_RCV_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_NORM_BOOT_ACK_RCV_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_SIGNAL_NORM.EN_INT_SIGNAL_NORM_Structure.BOOT_ACK_RCV_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_NORM_BOOT_TERM_INT_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_SIGNAL_NORM.EN_INT_SIGNAL_NORM_Structure.BOOT_TERM_INT_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_NORM_BOOT_TERM_INT_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_SIGNAL_NORM.EN_INT_SIGNAL_NORM_Structure.BOOT_TERM_INT_EN;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_NORM_FIXED_TO_0(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_SIGNAL_NORM.EN_INT_SIGNAL_NORM_Structure.FIXED_TO_0;
+}
+
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_SIGNAL_ERR.EN_INT_SIGNAL_ERR_Content = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_ERR(volatile sSdmmc *_sdmmc_)
+{
+    return _sdmmc_->EN_INT_SIGNAL_ERR.EN_INT_SIGNAL_ERR_Content;
+}
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_ERR_CMD_TIMEOUT_ERR_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_SIGNAL_ERR.EN_INT_SIGNAL_ERR_Structure.CMD_TIMEOUT_ERR_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_ERR_CMD_TIMEOUT_ERR_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_SIGNAL_ERR.EN_INT_SIGNAL_ERR_Structure.CMD_TIMEOUT_ERR_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_ERR_CMD_CRC_ERR_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_SIGNAL_ERR.EN_INT_SIGNAL_ERR_Structure.CMD_CRC_ERR_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_ERR_CMD_CRC_ERR_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_SIGNAL_ERR.EN_INT_SIGNAL_ERR_Structure.CMD_CRC_ERR_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_ERR_CMD_END_BIT_ERR_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_SIGNAL_ERR.EN_INT_SIGNAL_ERR_Structure.CMD_END_BIT_ERR_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_ERR_CMD_END_BIT_ERR_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_SIGNAL_ERR.EN_INT_SIGNAL_ERR_Structure.CMD_END_BIT_ERR_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_ERR_CMD_IND_ERR_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_SIGNAL_ERR.EN_INT_SIGNAL_ERR_Structure.CMD_IND_ERR_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_ERR_CMD_IND_ERR_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_SIGNAL_ERR.EN_INT_SIGNAL_ERR_Structure.CMD_IND_ERR_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_ERR_DATA_TIMEOUT_ERR_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_SIGNAL_ERR.EN_INT_SIGNAL_ERR_Structure.DATA_TIMEOUT_ERR_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_ERR_DATA_TIMEOUT_ERR_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_SIGNAL_ERR.EN_INT_SIGNAL_ERR_Structure.DATA_TIMEOUT_ERR_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_ERR_DATA_CRC_ERR_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_SIGNAL_ERR.EN_INT_SIGNAL_ERR_Structure.DATA_CRC_ERR_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_ERR_DATA_CRC_ERR_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_SIGNAL_ERR.EN_INT_SIGNAL_ERR_Structure.DATA_CRC_ERR_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_ERR_DATA_END_BIT_ERR_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_SIGNAL_ERR.EN_INT_SIGNAL_ERR_Structure.DATA_END_BIT_ERR_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_ERR_DATA_END_BIT_ERR_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_SIGNAL_ERR.EN_INT_SIGNAL_ERR_Structure.DATA_END_BIT_ERR_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_ERR_CURRENT_LIMIT_ERR_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_SIGNAL_ERR.EN_INT_SIGNAL_ERR_Structure.CURRENT_LIMIT_ERR_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_ERR_CURRENT_LIMIT_ERR_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_SIGNAL_ERR.EN_INT_SIGNAL_ERR_Structure.CURRENT_LIMIT_ERR_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_ERR_ACMD_ERR_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_SIGNAL_ERR.EN_INT_SIGNAL_ERR_Structure.ACMD_ERR_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_ERR_ACMD_ERR_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_SIGNAL_ERR.EN_INT_SIGNAL_ERR_Structure.ACMD_ERR_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_ERR_ADMA_ERR_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_SIGNAL_ERR.EN_INT_SIGNAL_ERR_Structure.ADMA_ERR_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_ERR_ADMA_ERR_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_SIGNAL_ERR.EN_INT_SIGNAL_ERR_Structure.ADMA_ERR_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_ERR_TUNING_ERROR_SIG_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_SIGNAL_ERR.EN_INT_SIGNAL_ERR_Structure.TUNING_ERROR_SIG_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_ERR_TUNING_ERROR_SIG_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_SIGNAL_ERR.EN_INT_SIGNAL_ERR_Structure.TUNING_ERROR_SIG_EN;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_ERR_res11(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_SIGNAL_ERR.EN_INT_SIGNAL_ERR_Structure.res11;
+}
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_ERR_TARGET_RESP_ERR_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_SIGNAL_ERR.EN_INT_SIGNAL_ERR_Structure.TARGET_RESP_ERR_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_ERR_TARGET_RESP_ERR_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_SIGNAL_ERR.EN_INT_SIGNAL_ERR_Structure.TARGET_RESP_ERR_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_EN_INT_SIGNAL_ERR_CEATA_ERR_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->EN_INT_SIGNAL_ERR.EN_INT_SIGNAL_ERR_Structure.CEATA_ERR_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_ERR_CEATA_ERR_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_SIGNAL_ERR.EN_INT_SIGNAL_ERR_Structure.CEATA_ERR_EN;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_EN_INT_SIGNAL_ERR_VSES1514_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->EN_INT_SIGNAL_ERR.EN_INT_SIGNAL_ERR_Structure.VSES1514_EN;
+}
+
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_ACMD12_ERR_STATUS(volatile sSdmmc *_sdmmc_)
+{
+    return _sdmmc_->ACMD12_ERR_STATUS.ACMD12_ERR_STATUS_Content;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_ACMD12_ERR_STATUS_ACMD12_NOT_EXEC_ERR(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->ACMD12_ERR_STATUS.ACMD12_ERR_STATUS_Structure.ACMD12_NOT_EXEC_ERR;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_ACMD12_ERR_STATUS_ACMD12_TIMEOUT_ERR(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->ACMD12_ERR_STATUS.ACMD12_ERR_STATUS_Structure.ACMD12_TIMEOUT_ERR;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_ACMD12_ERR_STATUS_ACMD12_CRC_ERR(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->ACMD12_ERR_STATUS.ACMD12_ERR_STATUS_Structure.ACMD12_CRC_ERR;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_ACMD12_ERR_STATUS_ACMD12_END_BIT_ERR(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->ACMD12_ERR_STATUS.ACMD12_ERR_STATUS_Structure.ACMD12_END_BIT_ERR;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_ACMD12_ERR_STATUS_ACMD12_IND_ERR(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->ACMD12_ERR_STATUS.ACMD12_ERR_STATUS_Structure.ACMD12_IND_ERR;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_ACMD12_ERR_STATUS_res0605(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->ACMD12_ERR_STATUS.ACMD12_ERR_STATUS_Structure.res0605;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_ACMD12_ERR_STATUS_CMD_NOT_ISSUED_BY_ACMD12_ERR(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->ACMD12_ERR_STATUS.ACMD12_ERR_STATUS_Structure.CMD_NOT_ISSUED_BY_ACMD12_ERR;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_ACMD12_ERR_STATUS_res1508(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->ACMD12_ERR_STATUS.ACMD12_ERR_STATUS_Structure.res1508;
+}
+
+
+__HWREG_INLINE__ void setSdmmc_HOST_CTRL2(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->HOST_CTRL2.HOST_CTRL2_Content = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_HOST_CTRL2(volatile sSdmmc *_sdmmc_)
+{
+    return _sdmmc_->HOST_CTRL2.HOST_CTRL2_Content;
+}
+
+__HWREG_INLINE__ void setSdmmc_HOST_CTRL2_UHS_MODE_SEL(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->HOST_CTRL2.HOST_CTRL2_Structure.UHS_MODE_SEL = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_HOST_CTRL2_UHS_MODE_SEL(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->HOST_CTRL2.HOST_CTRL2_Structure.UHS_MODE_SEL;
+}
+
+__HWREG_INLINE__ void setSdmmc_HOST_CTRL2_SIG18_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->HOST_CTRL2.HOST_CTRL2_Structure.SIG18_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_HOST_CTRL2_SIG18_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->HOST_CTRL2.HOST_CTRL2_Structure.SIG18_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_HOST_CTRL2_DRV_STR_SEL(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->HOST_CTRL2.HOST_CTRL2_Structure.DRV_STR_SEL = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_HOST_CTRL2_DRV_STR_SEL(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->HOST_CTRL2.HOST_CTRL2_Structure.DRV_STR_SEL;
+}
+
+__HWREG_INLINE__ void setSdmmc_HOST_CTRL2_EXECUTE_TUNING(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->HOST_CTRL2.HOST_CTRL2_Structure.EXECUTE_TUNING = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_HOST_CTRL2_EXECUTE_TUNING(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->HOST_CTRL2.HOST_CTRL2_Structure.EXECUTE_TUNING;
+}
+
+__HWREG_INLINE__ void setSdmmc_HOST_CTRL2_SAMPLING_CLK_SEL(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->HOST_CTRL2.HOST_CTRL2_Structure.SAMPLING_CLK_SEL = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_HOST_CTRL2_SAMPLING_CLK_SEL(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->HOST_CTRL2.HOST_CTRL2_Structure.SAMPLING_CLK_SEL;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_HOST_CTRL2_res1308(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->HOST_CTRL2.HOST_CTRL2_Structure.res1308;
+}
+
+__HWREG_INLINE__ void setSdmmc_HOST_CTRL2_ASYNC_INT_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->HOST_CTRL2.HOST_CTRL2_Structure.ASYNC_INT_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_HOST_CTRL2_ASYNC_INT_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->HOST_CTRL2.HOST_CTRL2_Structure.ASYNC_INT_EN;
+}
+
+__HWREG_INLINE__ void setSdmmc_HOST_CTRL2_PRESET_VAL_EN(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->HOST_CTRL2.HOST_CTRL2_Structure.PRESET_VAL_EN = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_HOST_CTRL2_PRESET_VAL_EN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->HOST_CTRL2.HOST_CTRL2_Structure.PRESET_VAL_EN;
+}
+
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_CAPABILITIES(volatile sSdmmc *_sdmmc_)
+{
+    return _sdmmc_->CAPABILITIES.CAPABILITIES_Content;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_CAPABILITIES_TIMEOUT_CLOCK_FREQ(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->CAPABILITIES.CAPABILITIES_Structure.TIMEOUT_CLOCK_FREQ;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_CAPABILITIES_TIMEOUT_CLOCK_UNIT(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->CAPABILITIES.CAPABILITIES_Structure.TIMEOUT_CLOCK_UNIT;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_CAPABILITIES_BASE_SD_CLOCK_FREQ(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->CAPABILITIES.CAPABILITIES_Structure.BASE_SD_CLOCK_FREQ;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_CAPABILITIES_MAX_BLOCK_LENGTH(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->CAPABILITIES.CAPABILITIES_Structure.MAX_BLOCK_LENGTH;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_CAPABILITIES_EXT_MEDIA_BUS_SUPPORT(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->CAPABILITIES.CAPABILITIES_Structure.EXT_MEDIA_BUS_SUPPORT;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_CAPABILITIES_ADMA2_SUPPORT(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->CAPABILITIES.CAPABILITIES_Structure.ADMA2_SUPPORT;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_CAPABILITIES_HIGH_SPEED_SUPPORT(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->CAPABILITIES.CAPABILITIES_Structure.HIGH_SPEED_SUPPORT;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_CAPABILITIES_SDMA_SUPPORT(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->CAPABILITIES.CAPABILITIES_Structure.SDMA_SUPPORT;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_CAPABILITIES_SUSPEND_RESUME_SUPPORT(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->CAPABILITIES.CAPABILITIES_Structure.SUSPEND_RESUME_SUPPORT;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_CAPABILITIES_VOLTAGE_SUPPORT_3_3V(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->CAPABILITIES.CAPABILITIES_Structure.VOLTAGE_SUPPORT_3_3V;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_CAPABILITIES_VOLTAGE_SUPPORT_3V(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->CAPABILITIES.CAPABILITIES_Structure.VOLTAGE_SUPPORT_3V;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_CAPABILITIES_VOLTAGE_SUPPORT_1_8V(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->CAPABILITIES.CAPABILITIES_Structure.VOLTAGE_SUPPORT_1_8V;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_CAPABILITIES_SYSBUS_64_SUPPORT(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->CAPABILITIES.CAPABILITIES_Structure.SYSBUS_64_SUPPORT;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_CAPABILITIES_ASYNC_INT_SUPPORT(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->CAPABILITIES.CAPABILITIES_Structure.ASYNC_INT_SUPPORT;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_CAPABILITIES_SLOT_TYPE(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->CAPABILITIES.CAPABILITIES_Structure.SLOT_TYPE;
+}
+
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_CAPABILITIES_HI(volatile sSdmmc *_sdmmc_)
+{
+    return _sdmmc_->CAPABILITIES_HI.CAPABILITIES_HI_Content;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_CAPABILITIES_HI_SDR50_SUPPORT(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->CAPABILITIES_HI.CAPABILITIES_HI_Structure.SDR50_SUPPORT;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_CAPABILITIES_HI_SDR104_SUPPORT(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->CAPABILITIES_HI.CAPABILITIES_HI_Structure.SDR104_SUPPORT;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_CAPABILITIES_HI_DDR50_SUPPORT(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->CAPABILITIES_HI.CAPABILITIES_HI_Structure.DDR50_SUPPORT;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_CAPABILITIES_HI_DRV_A_SUPPORT(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->CAPABILITIES_HI.CAPABILITIES_HI_Structure.DRV_A_SUPPORT;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_CAPABILITIES_HI_DRV_C_SUPPORT(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->CAPABILITIES_HI.CAPABILITIES_HI_Structure.DRV_C_SUPPORT;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_CAPABILITIES_HI_DRV_D_SUPPORT(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->CAPABILITIES_HI.CAPABILITIES_HI_Structure.DRV_D_SUPPORT;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_CAPABILITIES_HI_TIM_CNT_RETUNE(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->CAPABILITIES_HI.CAPABILITIES_HI_Structure.TIM_CNT_RETUNE;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_CAPABILITIES_HI_USE_TUNING_SDR50(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->CAPABILITIES_HI.CAPABILITIES_HI_Structure.USE_TUNING_SDR50;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_CAPABILITIES_HI_RE_TUNING_MODES(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->CAPABILITIES_HI.CAPABILITIES_HI_Structure.RE_TUNING_MODES;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_CAPABILITIES_HI_CLK_MULT(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->CAPABILITIES_HI.CAPABILITIES_HI_Structure.CLK_MULT;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_CAPABILITIES_HI_SPI_MODE_SUP(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->CAPABILITIES_HI.CAPABILITIES_HI_Structure.SPI_MODE_SUP;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_CAPABILITIES_HI_SPI_BLOCK_MODE_SUP(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->CAPABILITIES_HI.CAPABILITIES_HI_Structure.SPI_BLOCK_MODE_SUP;
+}
+
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_MAX_CURRENT_CAP(volatile sSdmmc *_sdmmc_)
+{
+    return _sdmmc_->MAX_CURRENT_CAP.MAX_CURRENT_CAP_Content;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_MAX_CURRENT_CAP_MAX_CURRENT_FOR_3_3V(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->MAX_CURRENT_CAP.MAX_CURRENT_CAP_Structure.MAX_CURRENT_FOR_3_3V;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_MAX_CURRENT_CAP_MAX_CURRENT_FOR_3_0V(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->MAX_CURRENT_CAP.MAX_CURRENT_CAP_Structure.MAX_CURRENT_FOR_3_0V;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_MAX_CURRENT_CAP_MAX_CURRENT_FOR_1_8V(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->MAX_CURRENT_CAP.MAX_CURRENT_CAP_Structure.MAX_CURRENT_FOR_1_8V;
+}
+
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_MAX_CURRENT_CAP_res(volatile sSdmmc *_sdmmc_)
+{
+    return _sdmmc_->MAX_CURRENT_CAP_res.MAX_CURRENT_CAP_res_Content;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_MAX_CURRENT_CAP_res_res(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->MAX_CURRENT_CAP_res.MAX_CURRENT_CAP_res_Structure.res;
+}
+
+
+__HWREG_INLINE__ void setSdmmc_FORCE_EVENT_ACMD_ERR_STATUS(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->FORCE_EVENT_ACMD_ERR_STATUS.FORCE_EVENT_ACMD_ERR_STATUS_Content = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_FORCE_EVENT_ACMD_ERR_STATUS(volatile sSdmmc *_sdmmc_)
+{
+    return _sdmmc_->FORCE_EVENT_ACMD_ERR_STATUS.FORCE_EVENT_ACMD_ERR_STATUS_Content;
+}
+
+__HWREG_INLINE__ void setSdmmc_FORCE_EVENT_ACMD_ERR_STATUS_FE_ACMD12_NOT_EXEC(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->FORCE_EVENT_ACMD_ERR_STATUS.FORCE_EVENT_ACMD_ERR_STATUS_Structure.FE_ACMD12_NOT_EXEC = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_FORCE_EVENT_ACMD_ERR_STATUS_FE_ACMD12_NOT_EXEC(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->FORCE_EVENT_ACMD_ERR_STATUS.FORCE_EVENT_ACMD_ERR_STATUS_Structure.FE_ACMD12_NOT_EXEC;
+}
+
+__HWREG_INLINE__ void setSdmmc_FORCE_EVENT_ACMD_ERR_STATUS_FE_ACMD12_TIMEOUT_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->FORCE_EVENT_ACMD_ERR_STATUS.FORCE_EVENT_ACMD_ERR_STATUS_Structure.FE_ACMD12_TIMEOUT_ERR = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_FORCE_EVENT_ACMD_ERR_STATUS_FE_ACMD12_TIMEOUT_ERR(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->FORCE_EVENT_ACMD_ERR_STATUS.FORCE_EVENT_ACMD_ERR_STATUS_Structure.FE_ACMD12_TIMEOUT_ERR;
+}
+
+__HWREG_INLINE__ void setSdmmc_FORCE_EVENT_ACMD_ERR_STATUS_FE_ACMD12_CRC_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->FORCE_EVENT_ACMD_ERR_STATUS.FORCE_EVENT_ACMD_ERR_STATUS_Structure.FE_ACMD12_CRC_ERR = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_FORCE_EVENT_ACMD_ERR_STATUS_FE_ACMD12_CRC_ERR(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->FORCE_EVENT_ACMD_ERR_STATUS.FORCE_EVENT_ACMD_ERR_STATUS_Structure.FE_ACMD12_CRC_ERR;
+}
+
+__HWREG_INLINE__ void setSdmmc_FORCE_EVENT_ACMD_ERR_STATUS_FE_ACMD12_END_BIT_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->FORCE_EVENT_ACMD_ERR_STATUS.FORCE_EVENT_ACMD_ERR_STATUS_Structure.FE_ACMD12_END_BIT_ERR = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_FORCE_EVENT_ACMD_ERR_STATUS_FE_ACMD12_END_BIT_ERR(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->FORCE_EVENT_ACMD_ERR_STATUS.FORCE_EVENT_ACMD_ERR_STATUS_Structure.FE_ACMD12_END_BIT_ERR;
+}
+
+__HWREG_INLINE__ void setSdmmc_FORCE_EVENT_ACMD_ERR_STATUS_FE_ACMD12_IND_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->FORCE_EVENT_ACMD_ERR_STATUS.FORCE_EVENT_ACMD_ERR_STATUS_Structure.FE_ACMD12_IND_ERR = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_FORCE_EVENT_ACMD_ERR_STATUS_FE_ACMD12_IND_ERR(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->FORCE_EVENT_ACMD_ERR_STATUS.FORCE_EVENT_ACMD_ERR_STATUS_Structure.FE_ACMD12_IND_ERR;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_FORCE_EVENT_ACMD_ERR_STATUS_res0605(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->FORCE_EVENT_ACMD_ERR_STATUS.FORCE_EVENT_ACMD_ERR_STATUS_Structure.res0605;
+}
+
+__HWREG_INLINE__ void setSdmmc_FORCE_EVENT_ACMD_ERR_STATUS_FE_CMD_NOT_ISSUED_ACMD12_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->FORCE_EVENT_ACMD_ERR_STATUS.FORCE_EVENT_ACMD_ERR_STATUS_Structure.FE_CMD_NOT_ISSUED_ACMD12_ERR = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_FORCE_EVENT_ACMD_ERR_STATUS_FE_CMD_NOT_ISSUED_ACMD12_ERR(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->FORCE_EVENT_ACMD_ERR_STATUS.FORCE_EVENT_ACMD_ERR_STATUS_Structure.FE_CMD_NOT_ISSUED_ACMD12_ERR;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_FORCE_EVENT_ACMD_ERR_STATUS_res0815(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->FORCE_EVENT_ACMD_ERR_STATUS.FORCE_EVENT_ACMD_ERR_STATUS_Structure.res0815;
+}
+
+
+__HWREG_INLINE__ void setSdmmc_FORCE_EVENT_ERR_STATUS(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->FORCE_EVENT_ERR_STATUS.FORCE_EVENT_ERR_STATUS_Content = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_FORCE_EVENT_ERR_STATUS(volatile sSdmmc *_sdmmc_)
+{
+    return _sdmmc_->FORCE_EVENT_ERR_STATUS.FORCE_EVENT_ERR_STATUS_Content;
+}
+
+__HWREG_INLINE__ void setSdmmc_FORCE_EVENT_ERR_STATUS_FE_CMD_TIMEOUT_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->FORCE_EVENT_ERR_STATUS.FORCE_EVENT_ERR_STATUS_Structure.FE_CMD_TIMEOUT_ERR = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_FORCE_EVENT_ERR_STATUS_FE_CMD_TIMEOUT_ERR(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->FORCE_EVENT_ERR_STATUS.FORCE_EVENT_ERR_STATUS_Structure.FE_CMD_TIMEOUT_ERR;
+}
+
+__HWREG_INLINE__ void setSdmmc_FORCE_EVENT_ERR_STATUS_FE_CMD_CRC_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->FORCE_EVENT_ERR_STATUS.FORCE_EVENT_ERR_STATUS_Structure.FE_CMD_CRC_ERR = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_FORCE_EVENT_ERR_STATUS_FE_CMD_CRC_ERR(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->FORCE_EVENT_ERR_STATUS.FORCE_EVENT_ERR_STATUS_Structure.FE_CMD_CRC_ERR;
+}
+
+__HWREG_INLINE__ void setSdmmc_FORCE_EVENT_ERR_STATUS_FE_CMD_END_BIT_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->FORCE_EVENT_ERR_STATUS.FORCE_EVENT_ERR_STATUS_Structure.FE_CMD_END_BIT_ERR = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_FORCE_EVENT_ERR_STATUS_FE_CMD_END_BIT_ERR(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->FORCE_EVENT_ERR_STATUS.FORCE_EVENT_ERR_STATUS_Structure.FE_CMD_END_BIT_ERR;
+}
+
+__HWREG_INLINE__ void setSdmmc_FORCE_EVENT_ERR_STATUS_FE_CMD_IND_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->FORCE_EVENT_ERR_STATUS.FORCE_EVENT_ERR_STATUS_Structure.FE_CMD_IND_ERR = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_FORCE_EVENT_ERR_STATUS_FE_CMD_IND_ERR(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->FORCE_EVENT_ERR_STATUS.FORCE_EVENT_ERR_STATUS_Structure.FE_CMD_IND_ERR;
+}
+
+__HWREG_INLINE__ void setSdmmc_FORCE_EVENT_ERR_STATUS_FE_DATA_TIMEOUT_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->FORCE_EVENT_ERR_STATUS.FORCE_EVENT_ERR_STATUS_Structure.FE_DATA_TIMEOUT_ERR = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_FORCE_EVENT_ERR_STATUS_FE_DATA_TIMEOUT_ERR(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->FORCE_EVENT_ERR_STATUS.FORCE_EVENT_ERR_STATUS_Structure.FE_DATA_TIMEOUT_ERR;
+}
+
+__HWREG_INLINE__ void setSdmmc_FORCE_EVENT_ERR_STATUS_FE_DATA_CRC_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->FORCE_EVENT_ERR_STATUS.FORCE_EVENT_ERR_STATUS_Structure.FE_DATA_CRC_ERR = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_FORCE_EVENT_ERR_STATUS_FE_DATA_CRC_ERR(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->FORCE_EVENT_ERR_STATUS.FORCE_EVENT_ERR_STATUS_Structure.FE_DATA_CRC_ERR;
+}
+
+__HWREG_INLINE__ void setSdmmc_FORCE_EVENT_ERR_STATUS_FE_DATA_END_BIT_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->FORCE_EVENT_ERR_STATUS.FORCE_EVENT_ERR_STATUS_Structure.FE_DATA_END_BIT_ERR = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_FORCE_EVENT_ERR_STATUS_FE_DATA_END_BIT_ERR(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->FORCE_EVENT_ERR_STATUS.FORCE_EVENT_ERR_STATUS_Structure.FE_DATA_END_BIT_ERR;
+}
+
+__HWREG_INLINE__ void setSdmmc_FORCE_EVENT_ERR_STATUS_FE_CURRENT_LIMIT_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->FORCE_EVENT_ERR_STATUS.FORCE_EVENT_ERR_STATUS_Structure.FE_CURRENT_LIMIT_ERR = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_FORCE_EVENT_ERR_STATUS_FE_CURRENT_LIMIT_ERR(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->FORCE_EVENT_ERR_STATUS.FORCE_EVENT_ERR_STATUS_Structure.FE_CURRENT_LIMIT_ERR;
+}
+
+__HWREG_INLINE__ void setSdmmc_FORCE_EVENT_ERR_STATUS_FE_ACMD12_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->FORCE_EVENT_ERR_STATUS.FORCE_EVENT_ERR_STATUS_Structure.FE_ACMD12_ERR = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_FORCE_EVENT_ERR_STATUS_FE_ACMD12_ERR(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->FORCE_EVENT_ERR_STATUS.FORCE_EVENT_ERR_STATUS_Structure.FE_ACMD12_ERR;
+}
+
+__HWREG_INLINE__ void setSdmmc_FORCE_EVENT_ERR_STATUS_FE_ADMA_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->FORCE_EVENT_ERR_STATUS.FORCE_EVENT_ERR_STATUS_Structure.FE_ADMA_ERR = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_FORCE_EVENT_ERR_STATUS_FE_ADMA_ERR(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->FORCE_EVENT_ERR_STATUS.FORCE_EVENT_ERR_STATUS_Structure.FE_ADMA_ERR;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_FORCE_EVENT_ERR_STATUS_res1110(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->FORCE_EVENT_ERR_STATUS.FORCE_EVENT_ERR_STATUS_Structure.res1110;
+}
+
+__HWREG_INLINE__ void setSdmmc_FORCE_EVENT_ERR_STATUS_FE_TARGET_RESPONSE_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->FORCE_EVENT_ERR_STATUS.FORCE_EVENT_ERR_STATUS_Structure.FE_TARGET_RESPONSE_ERR = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_FORCE_EVENT_ERR_STATUS_FE_TARGET_RESPONSE_ERR(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->FORCE_EVENT_ERR_STATUS.FORCE_EVENT_ERR_STATUS_Structure.FE_TARGET_RESPONSE_ERR;
+}
+
+__HWREG_INLINE__ void setSdmmc_FORCE_EVENT_ERR_STATUS_FE_CEATA_ERR(volatile sSdmmc *_sdmmc_, HWREG_U16 value)
+{
+    _sdmmc_->FORCE_EVENT_ERR_STATUS.FORCE_EVENT_ERR_STATUS_Structure.FE_CEATA_ERR = value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_FORCE_EVENT_ERR_STATUS_FE_CEATA_ERR(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->FORCE_EVENT_ERR_STATUS.FORCE_EVENT_ERR_STATUS_Structure.FE_CEATA_ERR;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_FORCE_EVENT_ERR_STATUS_FE_VENDOR_SPECIFIC_ERR_STATUS(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->FORCE_EVENT_ERR_STATUS.FORCE_EVENT_ERR_STATUS_Structure.FE_VENDOR_SPECIFIC_ERR_STATUS;
+}
+
+
+__HWREG_INLINE__ void setSdmmc_ADMA_ERR_STATUS(volatile sSdmmc *_sdmmc_, HWREG_U8 value)
+{
+    _sdmmc_->ADMA_ERR_STATUS.ADMA_ERR_STATUS_Content = value;
+}
+
+__HWREG_INLINE__ HWREG_U8 getSdmmc_ADMA_ERR_STATUS(volatile sSdmmc *_sdmmc_)
+{
+    return _sdmmc_->ADMA_ERR_STATUS.ADMA_ERR_STATUS_Content;
+}
+
+__HWREG_INLINE__ HWREG_U8 getSdmmc_ADMA_ERR_STATUS_ADMA_ERR_STATE(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U8)_sdmmc_->ADMA_ERR_STATUS.ADMA_ERR_STATUS_Structure.ADMA_ERR_STATE;
+}
+
+__HWREG_INLINE__ void setSdmmc_ADMA_ERR_STATUS_ADMA_LENGTH_MISMATCH(volatile sSdmmc *_sdmmc_, HWREG_U8 value)
+{
+    _sdmmc_->ADMA_ERR_STATUS.ADMA_ERR_STATUS_Structure.ADMA_LENGTH_MISMATCH = value;
+}
+
+__HWREG_INLINE__ HWREG_U8 getSdmmc_ADMA_ERR_STATUS_ADMA_LENGTH_MISMATCH(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U8)_sdmmc_->ADMA_ERR_STATUS.ADMA_ERR_STATUS_Structure.ADMA_LENGTH_MISMATCH;
+}
+
+__HWREG_INLINE__ HWREG_U8 getSdmmc_ADMA_ERR_STATUS_res73(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U8)_sdmmc_->ADMA_ERR_STATUS.ADMA_ERR_STATUS_Structure.res73;
+}
+
+
+__HWREG_INLINE__ void setSdmmc_ADMA_ADDR_LOW(volatile sSdmmc *_sdmmc_, HWREG_U32 value)
+{
+    _sdmmc_->ADMA_ADDR_LOW.ADMA_ADDR_LOW_Content = value;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_ADMA_ADDR_LOW(volatile sSdmmc *_sdmmc_)
+{
+    return _sdmmc_->ADMA_ADDR_LOW.ADMA_ADDR_LOW_Content;
+}
+
+__HWREG_INLINE__ void setSdmmc_ADMA_ADDR_LOW_ADMA_ADDR_LOW(volatile sSdmmc *_sdmmc_, HWREG_U32 value)
+{
+    _sdmmc_->ADMA_ADDR_LOW.ADMA_ADDR_LOW_Structure.ADMA_ADDR_LOW = value;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_ADMA_ADDR_LOW_ADMA_ADDR_LOW(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->ADMA_ADDR_LOW.ADMA_ADDR_LOW_Structure.ADMA_ADDR_LOW;
+}
+
+
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_INIT(volatile sSdmmc *_sdmmc_)
+{
+    return _sdmmc_->PRESET_VAL_REG_INIT.PRESET_VAL_REG_INIT_Content;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_INIT_SDCLK_Frequency_Select_Value(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->PRESET_VAL_REG_INIT.PRESET_VAL_REG_INIT_Structure.SDCLK_Frequency_Select_Value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_INIT_Clock_Generator_Select_Value(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->PRESET_VAL_REG_INIT.PRESET_VAL_REG_INIT_Structure.Clock_Generator_Select_Value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_INIT_Driver_Strength_Select_Value(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->PRESET_VAL_REG_INIT.PRESET_VAL_REG_INIT_Structure.Driver_Strength_Select_Value;
+}
+
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_DEF_SPEED(volatile sSdmmc *_sdmmc_)
+{
+    return _sdmmc_->PRESET_VAL_REG_DEF_SPEED.PRESET_VAL_REG_DEF_SPEED_Content;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_DEF_SPEED_SDCLK_Frequency_Select_Value(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->PRESET_VAL_REG_DEF_SPEED.PRESET_VAL_REG_DEF_SPEED_Structure.SDCLK_Frequency_Select_Value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_DEF_SPEED_Clock_Generator_Select_Value(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->PRESET_VAL_REG_DEF_SPEED.PRESET_VAL_REG_DEF_SPEED_Structure.Clock_Generator_Select_Value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_DEF_SPEED_Driver_Strength_Select_Value(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->PRESET_VAL_REG_DEF_SPEED.PRESET_VAL_REG_DEF_SPEED_Structure.Driver_Strength_Select_Value;
+}
+
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_HI_SPEED(volatile sSdmmc *_sdmmc_)
+{
+    return _sdmmc_->PRESET_VAL_REG_HI_SPEED.PRESET_VAL_REG_HI_SPEED_Content;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_HI_SPEED_SDCLK_Frequency_Select_Value(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->PRESET_VAL_REG_HI_SPEED.PRESET_VAL_REG_HI_SPEED_Structure.SDCLK_Frequency_Select_Value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_HI_SPEED_Clock_Generator_Select_Value(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->PRESET_VAL_REG_HI_SPEED.PRESET_VAL_REG_HI_SPEED_Structure.Clock_Generator_Select_Value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_HI_SPEED_Driver_Strength_Select_Value(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->PRESET_VAL_REG_HI_SPEED.PRESET_VAL_REG_HI_SPEED_Structure.Driver_Strength_Select_Value;
+}
+
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_SDR12(volatile sSdmmc *_sdmmc_)
+{
+    return _sdmmc_->PRESET_VAL_REG_SDR12.PRESET_VAL_REG_SDR12_Content;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_SDR12_SDCLK_Frequency_Select_Value(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->PRESET_VAL_REG_SDR12.PRESET_VAL_REG_SDR12_Structure.SDCLK_Frequency_Select_Value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_SDR12_Clock_Generator_Select_Value(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->PRESET_VAL_REG_SDR12.PRESET_VAL_REG_SDR12_Structure.Clock_Generator_Select_Value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_SDR12_Driver_Strength_Select_Value(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->PRESET_VAL_REG_SDR12.PRESET_VAL_REG_SDR12_Structure.Driver_Strength_Select_Value;
+}
+
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_SDR25(volatile sSdmmc *_sdmmc_)
+{
+    return _sdmmc_->PRESET_VAL_REG_SDR25.PRESET_VAL_REG_SDR25_Content;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_SDR25_SDCLK_Frequency_Select_Value(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->PRESET_VAL_REG_SDR25.PRESET_VAL_REG_SDR25_Structure.SDCLK_Frequency_Select_Value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_SDR25_Clock_Generator_Select_Value(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->PRESET_VAL_REG_SDR25.PRESET_VAL_REG_SDR25_Structure.Clock_Generator_Select_Value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_SDR25_Driver_Strength_Select_Value(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->PRESET_VAL_REG_SDR25.PRESET_VAL_REG_SDR25_Structure.Driver_Strength_Select_Value;
+}
+
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_SDR50(volatile sSdmmc *_sdmmc_)
+{
+    return _sdmmc_->PRESET_VAL_REG_SDR50.PRESET_VAL_REG_SDR50_Content;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_SDR50_SDCLK_Frequency_Select_Value(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->PRESET_VAL_REG_SDR50.PRESET_VAL_REG_SDR50_Structure.SDCLK_Frequency_Select_Value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_SDR50_Clock_Generator_Select_Value(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->PRESET_VAL_REG_SDR50.PRESET_VAL_REG_SDR50_Structure.Clock_Generator_Select_Value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_SDR50_Driver_Strength_Select_Value(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->PRESET_VAL_REG_SDR50.PRESET_VAL_REG_SDR50_Structure.Driver_Strength_Select_Value;
+}
+
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_SDR104(volatile sSdmmc *_sdmmc_)
+{
+    return _sdmmc_->PRESET_VAL_REG_SDR104.PRESET_VAL_REG_SDR104_Content;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_SDR104_SDCLK_Frequency_Select_Value(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->PRESET_VAL_REG_SDR104.PRESET_VAL_REG_SDR104_Structure.SDCLK_Frequency_Select_Value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_SDR104_Clock_Generator_Select_Value(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->PRESET_VAL_REG_SDR104.PRESET_VAL_REG_SDR104_Structure.Clock_Generator_Select_Value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_SDR104_Driver_Strength_Select_Value(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->PRESET_VAL_REG_SDR104.PRESET_VAL_REG_SDR104_Structure.Driver_Strength_Select_Value;
+}
+
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_DDR50(volatile sSdmmc *_sdmmc_)
+{
+    return _sdmmc_->PRESET_VAL_REG_DDR50.PRESET_VAL_REG_DDR50_Content;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_DDR50_SDCLK_Frequency_Select_Value(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->PRESET_VAL_REG_DDR50.PRESET_VAL_REG_DDR50_Structure.SDCLK_Frequency_Select_Value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_DDR50_Clock_Generator_Select_Value(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->PRESET_VAL_REG_DDR50.PRESET_VAL_REG_DDR50_Structure.Clock_Generator_Select_Value;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_PRESET_VAL_REG_DDR50_Driver_Strength_Select_Value(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->PRESET_VAL_REG_DDR50.PRESET_VAL_REG_DDR50_Structure.Driver_Strength_Select_Value;
+}
+
+
+__HWREG_INLINE__ void setSdmmc_BOOT_DATA_TO_CTRL(volatile sSdmmc *_sdmmc_, HWREG_U32 value)
+{
+    _sdmmc_->BOOT_DATA_TO_CTRL.BOOT_DATA_TO_CTRL_Content = value;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_BOOT_DATA_TO_CTRL(volatile sSdmmc *_sdmmc_)
+{
+    return _sdmmc_->BOOT_DATA_TO_CTRL.BOOT_DATA_TO_CTRL_Content;
+}
+
+__HWREG_INLINE__ void setSdmmc_BOOT_DATA_TO_CTRL_BOOT_DATA_TO_COUNT(volatile sSdmmc *_sdmmc_, HWREG_U32 value)
+{
+    _sdmmc_->BOOT_DATA_TO_CTRL.BOOT_DATA_TO_CTRL_Structure.BOOT_DATA_TO_COUNT = value;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_BOOT_DATA_TO_CTRL_BOOT_DATA_TO_COUNT(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->BOOT_DATA_TO_CTRL.BOOT_DATA_TO_CTRL_Structure.BOOT_DATA_TO_COUNT;
+}
+
+
+__HWREG_INLINE__ void setSdmmc_DEBUG_SEL(volatile sSdmmc *_sdmmc_, HWREG_U32 value)
+{
+    _sdmmc_->DEBUG_SEL.DEBUG_SEL_Content = value;
+}
+
+__HWREG_INLINE__ void setSdmmc_DEBUG_SEL_DEBUG_SEL(volatile sSdmmc *_sdmmc_, HWREG_U32 value)
+{
+    _sdmmc_->DEBUG_SEL.DEBUG_SEL_Content = value << DEBUG_SEL_LSB_DEBUG_SEL;
+}
+
+
+__HWREG_INLINE__ void setSdmmc_SHARED_BUS_CTRL(volatile sSdmmc *_sdmmc_, HWREG_U32 value)
+{
+    _sdmmc_->SHARED_BUS_CTRL.SHARED_BUS_CTRL_Content = value;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_SHARED_BUS_CTRL(volatile sSdmmc *_sdmmc_)
+{
+    return _sdmmc_->SHARED_BUS_CTRL.SHARED_BUS_CTRL_Content;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_SHARED_BUS_CTRL_NUM_CLK_PIN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->SHARED_BUS_CTRL.SHARED_BUS_CTRL_Structure.NUM_CLK_PIN;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_SHARED_BUS_CTRL_res3(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->SHARED_BUS_CTRL.SHARED_BUS_CTRL_Structure.res3;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_SHARED_BUS_CTRL_NUM_INT_PIN(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->SHARED_BUS_CTRL.SHARED_BUS_CTRL_Structure.NUM_INT_PIN;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_SHARED_BUS_CTRL_res0607(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->SHARED_BUS_CTRL.SHARED_BUS_CTRL_Structure.res0607;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_SHARED_BUS_CTRL_BUS_WIDTH_PRESET(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->SHARED_BUS_CTRL.SHARED_BUS_CTRL_Structure.BUS_WIDTH_PRESET;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_SHARED_BUS_CTRL_res15(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->SHARED_BUS_CTRL.SHARED_BUS_CTRL_Structure.res15;
+}
+
+__HWREG_INLINE__ void setSdmmc_SHARED_BUS_CTRL_CLK_PIN_SEL(volatile sSdmmc *_sdmmc_, HWREG_U32 value)
+{
+    _sdmmc_->SHARED_BUS_CTRL.SHARED_BUS_CTRL_Structure.CLK_PIN_SEL = value;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_SHARED_BUS_CTRL_CLK_PIN_SEL(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->SHARED_BUS_CTRL.SHARED_BUS_CTRL_Structure.CLK_PIN_SEL;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_SHARED_BUS_CTRL_res19(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->SHARED_BUS_CTRL.SHARED_BUS_CTRL_Structure.res19;
+}
+
+__HWREG_INLINE__ void setSdmmc_SHARED_BUS_CTRL_INT_PIN_SEL(volatile sSdmmc *_sdmmc_, HWREG_U32 value)
+{
+    _sdmmc_->SHARED_BUS_CTRL.SHARED_BUS_CTRL_Structure.INT_PIN_SEL = value;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_SHARED_BUS_CTRL_INT_PIN_SEL(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->SHARED_BUS_CTRL.SHARED_BUS_CTRL_Structure.INT_PIN_SEL;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_SHARED_BUS_CTRL_res23(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->SHARED_BUS_CTRL.SHARED_BUS_CTRL_Structure.res23;
+}
+
+__HWREG_INLINE__ void setSdmmc_SHARED_BUS_CTRL_BACKEND_PWR_CTRL(volatile sSdmmc *_sdmmc_, HWREG_U32 value)
+{
+    _sdmmc_->SHARED_BUS_CTRL.SHARED_BUS_CTRL_Structure.BACKEND_PWR_CTRL = value;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_SHARED_BUS_CTRL_BACKEND_PWR_CTRL(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->SHARED_BUS_CTRL.SHARED_BUS_CTRL_Structure.BACKEND_PWR_CTRL;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_SHARED_BUS_CTRL_res31(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->SHARED_BUS_CTRL.SHARED_BUS_CTRL_Structure.res31;
+}
+
+
+__HWREG_INLINE__ void setSdmmc_SPI(volatile sSdmmc *_sdmmc_, HWREG_U32 value)
+{
+    _sdmmc_->SPI.SPI_Content = value;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_SPI(volatile sSdmmc *_sdmmc_)
+{
+    return _sdmmc_->SPI.SPI_Content;
+}
+
+__HWREG_INLINE__ void setSdmmc_SPI_SPI_INT_SUPPORT(volatile sSdmmc *_sdmmc_, HWREG_U32 value)
+{
+    _sdmmc_->SPI.SPI_Structure.SPI_INT_SUPPORT = value;
+}
+
+__HWREG_INLINE__ HWREG_U32 getSdmmc_SPI_SPI_INT_SUPPORT(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U32)_sdmmc_->SPI.SPI_Structure.SPI_INT_SUPPORT;
+}
+
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_SLOT_INT_STATUS(volatile sSdmmc *_sdmmc_)
+{
+    return _sdmmc_->SLOT_INT_STATUS.SLOT_INT_STATUS_Content;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_SLOT_INT_STATUS_SLOT_INT_STATUS(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->SLOT_INT_STATUS.SLOT_INT_STATUS_Structure.SLOT_INT_STATUS;
+}
+
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_HOST_CTRL_VERS(volatile sSdmmc *_sdmmc_)
+{
+    return _sdmmc_->HOST_CTRL_VERS.HOST_CTRL_VERS_Content;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_HOST_CTRL_VERS_SPEC_VERS(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->HOST_CTRL_VERS.HOST_CTRL_VERS_Structure.SPEC_VERS;
+}
+
+__HWREG_INLINE__ HWREG_U16 getSdmmc_HOST_CTRL_VERS_VENDOR_VERS(volatile sSdmmc *_sdmmc_)
+{
+    return (HWREG_U16)_sdmmc_->HOST_CTRL_VERS.HOST_CTRL_VERS_Structure.VENDOR_VERS;
+}
+
+
+
+#endif
+
+
+#endif
+
diff --git a/devices/noc_qos/src/sofia3gx b/devices/noc_qos/src/sofia3gx
new file mode 120000
index 0000000..00d525b
--- /dev/null
+++ b/devices/noc_qos/src/sofia3gx
@@ -0,0 +1 @@
+sofia3gr
\ No newline at end of file
diff --git a/devices/pcl/src/sofia3gx b/devices/pcl/src/sofia3gx
new file mode 120000
index 0000000..00d525b
--- /dev/null
+++ b/devices/pcl/src/sofia3gx
@@ -0,0 +1 @@
+sofia3gr
\ No newline at end of file
diff --git a/devices/pm/inc/power_control/board_sf_3gx b/devices/pm/inc/power_control/board_sf_3gx
new file mode 120000
index 0000000..70c4b86
--- /dev/null
+++ b/devices/pm/inc/power_control/board_sf_3gx
@@ -0,0 +1 @@
+board_sf_3gr
\ No newline at end of file
diff --git a/devices/pm/inc/power_management/board_sf_3gx b/devices/pm/inc/power_management/board_sf_3gx
new file mode 120000
index 0000000..70c4b86
--- /dev/null
+++ b/devices/pm/inc/power_management/board_sf_3gx
@@ -0,0 +1 @@
+board_sf_3gr
\ No newline at end of file
diff --git a/devices/pm/pm_device.c b/devices/pm/pm_device.c
index 8eb196e..b6ffb19 100644
--- a/devices/pm/pm_device.c
+++ b/devices/pm/pm_device.c
@@ -28,7 +28,7 @@ void pm_dev_init(void)
   pm_init();
   pal_pm_set_pm_owner();
   pal_pm_power_hook_init();
-#if defined(SF_3G_TAB_EXTPMIC) || defined(SF3GR_GARNET_VCPU_I2C_CTRL)
+#if defined(SF_3G_TAB_EXTPMIC) || defined(SF3GR_GARNET_VCPU_I2C_CTRL) || defined(SF3GX_VCPU_I2C_CTRL)
   ext_pmic_init();
 #endif
 
diff --git a/devices/pm/power_control/cpu/make/board_sf_3gx b/devices/pm/power_control/cpu/make/board_sf_3gx
new file mode 120000
index 0000000..70c4b86
--- /dev/null
+++ b/devices/pm/power_control/cpu/make/board_sf_3gx
@@ -0,0 +1 @@
+board_sf_3gr
\ No newline at end of file
diff --git a/devices/pm/power_control/cpu/src/board_sf_3gx b/devices/pm/power_control/cpu/src/board_sf_3gx
new file mode 120000
index 0000000..70c4b86
--- /dev/null
+++ b/devices/pm/power_control/cpu/src/board_sf_3gx
@@ -0,0 +1 @@
+board_sf_3gr
\ No newline at end of file
diff --git a/devices/pm/power_control/emif/make/board_sf_3gx b/devices/pm/power_control/emif/make/board_sf_3gx
new file mode 120000
index 0000000..70c4b86
--- /dev/null
+++ b/devices/pm/power_control/emif/make/board_sf_3gx
@@ -0,0 +1 @@
+board_sf_3gr
\ No newline at end of file
diff --git a/devices/pm/power_control/emif/src/board_sf_3gx/emic_generated_cfg.h b/devices/pm/power_control/emif/src/board_sf_3gx/emic_generated_cfg.h
new file mode 100644
index 0000000..da8108f
--- /dev/null
+++ b/devices/pm/power_control/emif/src/board_sf_3gx/emic_generated_cfg.h
@@ -0,0 +1,38 @@
+/*  -------------------------------------------------------------------------
+    Copyright (C) 2013 Intel Mobile Communications GmbH
+    
+         Sec Class: Intel Confidential (IC)
+    
+    ------------------------------------------------------------------------
+
+    This document contains proprietary information belonging to IMC.
+    Passing on and copying of this document, use and communication of
+    its contents is not permitted without prior written authorisation.
+
+    ----------------------------------------------------------------------
+     Revision Information:
+       $$File name:  /mhw_drv_src/power_control/emif/src/board_xmm6320a1/emic_generated_cfg.h $
+       $$CC-Version: .../oint_drv_power_ctrl_02/3 $
+       $$Date:       2013-06-23    12:01:36 UTC $
+     ---------------------------------------------------------------------- */
+
+/*
+ * Declare the maximum number of elements in the denali settings array
+ */
+#define MAX_DENALI_REG_ARRAY_SIZE_CTL                                   215
+#define MAX_DWC_REG_ARRAY_SIZE_PHY                                   	182
+
+#if defined (FEAT_POW_EMIF_MAX_DDR2_FREQ_533)
+#include <emic_generated_sdram_ctl_26_156_533MHZ.h>
+#include <emic_generated_sdram_phy_26_156_533MHZ.h>
+
+#elif defined (FEAT_POW_EMIF_MAX_DDR2_FREQ_312)
+#include <emic_generated_sdram_ctl_26_156_312MHZ.h>
+
+#elif defined (FEAT_POW_EMIF_MAX_DDR2_FREQ_400)
+#include <emic_generated_sdram_ctl_26_156_400MHZ.h>
+
+#else	/* FEAT_POW_EMIF_MAX_DDR2_FREQ_234 */
+#error "FEAT_POW_EMIF_MAX_DDR2_FREQ_xxx not defined"
+
+#endif
diff --git a/devices/pm/power_control/emif/src/board_sf_3gx/emic_generated_sdram_ctl_26_156_312MHZ.h b/devices/pm/power_control/emif/src/board_sf_3gx/emic_generated_sdram_ctl_26_156_312MHZ.h
new file mode 100644
index 0000000..be114bd
--- /dev/null
+++ b/devices/pm/power_control/emif/src/board_sf_3gx/emic_generated_sdram_ctl_26_156_312MHZ.h
@@ -0,0 +1,332 @@
+//  BEGIN CCCT SECTION
+/*  -------------------------------------------------------------------------
+    Copyright (C) 2013 Intel Mobile Communications GmbH
+
+         Sec Class: Intel Confidential (IC)
+    ----------------------------------------------------------------------
+    Revision Information:
+       $File name:  /mhw_drv_src/power_control/emif/src/board_xmm6321/emic_generated_sdram_ctl_26_156_400MHZ.h $
+       $CC-Version: .../oint_drv_power_ctrl_02/2 $
+       $Date:       2013-11-28    12:17:22 UTC $
+    ----------------------------------------------------------------------
+    by CCCT (0.12c)
+    ---------------------------------------------------------------------- */
+//  END CCCT SECTION
+
+/*
+ * The following array structure holds two element. The first one represents
+ * the Denali register to which the second elemnent (the register value) is
+ * to be written.
+ */
+#ifndef _EMIC_GENERATED_SDRAM_CTL_26_156_312_MHZ_H_
+#define _EMIC_GENERATED_SDRAM_CTL_26_156_312_MHZ_H_
+#pragma arm section zidata = "INT_RWDATA",  rwdata = "INT_RWDATA"
+
+#if 0
+//F0 312M;F1 156M;F2 26M
+const U32 syno_PHY_F0[][2] = {
+    {0x00000010, 0x00f00331},    //PHY_PGCR2
+    {0x00000020, 0xa00b8000},    //PHY_PLLCR
+    {0x00000024, 0x27013810},    //PHY_PTR0
+    {0x00000028, 0x79e00af8},    //PHY_PTR1
+    {0x00000030, 0x07126160},    //PHY_PTR3
+    {0x00000034, 0x04e0f3c0},    //PHY_PTR4
+    {0x00000084, 0x002c649a},    //PHY_DSGCR
+    {0x00000088, 0x00000409},    //PHY_DCR
+    {0x0000008c, 0x190e0744},    //PHY_DTPR0
+    {0x00000090, 0x3cd21200},    //PHY_DTPR1
+    {0x00000094, 0x00100c45},    //PHY_DTPR2
+    {0x00000098, 0x00286551},    //PHY_DTPR3
+    {0x0000009c, 0x00000000},    //PHY_MR0
+    {0x000000a0, 0x00000063},    //PHY_MR1
+    {0x000000a4, 0x00000004},    //PHY_MR2
+    {0x000000a8, 0x00000001},    //PHY_MR3
+    {0x000001a0, 0x00000003},    //PHY_BISTRR
+    {0x000000ec, 0x00090754},    //PHY_DQSDR
+    {0x000000f0, 0x0201aaaa},    //PHY_DTMR0
+    {0x00000280, 0x7c080285},    //PHY_DX0GCR0
+    {0x00000300, 0x7c080285},    //PHY_DX1GCR0
+    {0x00000380, 0x7c080285},    //PHY_DX2GCR0
+    {0x00000400, 0x7c080285},    //PHY_DX3GCR0
+    {0x00000288, 0x0000aaaa},    //PHY_DX0GCR2  DQ0-7 dis ODT
+    {0x0000028c, 0x00002000},    //PHY_DX0GCR3  DM dis ODT
+    {0x00000308, 0x0000aaaa},    //PHY_DX1GCR2  DQ8-15 dis ODT
+    {0x0000030c, 0x00002000},    //PHY_DX1GCR3  DM dis ODT
+    {0x00000388, 0x0000aaaa},    //PHY_DX2GCR2  DQ16-23 dis ODT
+    {0x0000038c, 0x00002000},    //PHY_DX2GCR3  DM dis ODT
+    {0x00000408, 0x0000aaaa},    //PHY_DX3GCR2  DQ24-31 dis ODT
+    {0x0000040c, 0x00002000},    //PHY_DX3GCR3  DM dis ODT
+};
+
+const U32 syno_PHY_F1[][2] = {
+    {0x00000010, 0x00f000d1},    //PHY_PGCR2
+    {0x00000020, 0xa01b8000},    //PHY_PLLCR
+    {0x00000024, 0x13809c10},    //PHY_PTR0
+    {0x00000028, 0x3cf0057c},    //PHY_PTR1
+    {0x00000030, 0x039130b0},    //PHY_PTR3
+    {0x00000034, 0x027079e0},    //PHY_PTR4
+    {0x00000084, 0x002c649a},    //PHY_DSGCR
+    {0x00000088, 0x00000409},    //PHY_DCR
+    {0x0000008c, 0x0c870444},    //PHY_DTPR0
+    {0x00000090, 0xf0710900},    //PHY_DTPR1
+    {0x00000094, 0x00100c23},    //PHY_DTPR2
+    {0x00000098, 0x002862d1},    //PHY_DTPR3
+    {0x0000009c, 0x00000000},    //PHY_MR0
+    {0x000000a0, 0x00000043},    //PHY_MR1
+    {0x000000a4, 0x00000001},    //PHY_MR2
+    {0x000000a8, 0x00000001},    //PHY_MR3
+    {0x000001a0, 0x00000000},    //PHY_BISTRR
+    {0x000000ec, 0x00060454},    //PHY_DQSDR
+    {0x000000f0, 0x0201aaaa},    //PHY_DTMR0
+    {0x00000280, 0x7c080285},    //PHY_DX0GCR0
+    {0x00000300, 0x7c080285},    //PHY_DX1GCR0
+    {0x00000380, 0x7c080285},    //PHY_DX2GCR0
+    {0x00000400, 0x7c080285},    //PHY_DX3GCR0
+};
+
+const U32 syno_PHY_F2[][2] = {
+    {0x00000010, 0x00f00001},    //PHY_PGCR2
+    {0x00000020, 0xa01b8000},    //PHY_PLLCR
+    {0x00000024, 0x03401a10},    //PHY_PTR0
+    {0x00000028, 0x0a2800ea},    //PHY_PTR1
+    {0x00000030, 0x00a032c8},    //PHY_PTR3
+    {0x00000034, 0x00681450},    //PHY_PTR4
+    {0x00000084, 0x002c649a},    //PHY_DSGCR
+    {0x00000088, 0x00000409},    //PHY_DCR
+    {0x0000008c, 0x0c830344},    //PHY_DTPR0
+    {0x00000090, 0xe4203100},    //PHY_DTPR1
+    {0x00000094, 0x00100c06},    //PHY_DTPR2
+    {0x00000098, 0x00286191},    //PHY_DTPR3
+    {0x0000009c, 0x00000000},    //PHY_MR0
+    {0x000000a0, 0x00000043},    //PHY_MR1
+    {0x000000a4, 0x00000001},    //PHY_MR2
+    {0x000000a8, 0x00000001},    //PHY_MR3
+    {0x000001a0, 0x00000000},    //PHY_BISTRR
+    {0x000000ec, 0x00030154},    //PHY_DQSDR
+    {0x000000f0, 0x0201aaaa},    //PHY_DTMR0
+    {0x00000280, 0x7c080285},    //PHY_DX0GCR0
+    {0x00000300, 0x7c080285},    //PHY_DX1GCR0
+    {0x00000380, 0x7c080285},    //PHY_DX2GCR0
+    {0x00000400, 0x7c080285},    //PHY_DX3GCR0
+};
+#endif
+
+const U32 denaliSdram_CTL[] = {
+    0x00000700,     // CTL_00
+    0x00000000,     // CTL_01
+    0x00000000,     // CTL_02
+    0x00000020,     // CTL_03
+    0x0000f3c0,     // CTL_04
+    0x00000138,     // CTL_05
+    0x00000c30,     // CTL_06
+    0x00000010,     // CTL_07
+    0x000079e0,     // CTL_08
+    0x0000009c,     // CTL_09
+    0x00000618,     // CTL_10
+    0x00000003,     // CTL_11
+    0x00001450,     // CTL_12
+    0x0000001a,     // CTL_13
+    0x00000104,     // CTL_14
+    0x00000000,     // CTL_15
+    0x00000000,     // CTL_16
+    0x00000000,     // CTL_17
+    0x00000000,     // CTL_18
+    0x00030c00,     // CTL_19
+    0x06000106,     // CTL_20
+    0x04000001,     // CTL_21
+    0x040e1504,     // CTL_22
+    0x0b021007,     // CTL_23
+    0x08040407,     // CTL_24
+    0x04030602,     // CTL_25
+    0x0a040803,     // CTL_26
+    0x00555000,     // CTL_27
+    0x0a040503,     // CTL_28
+    0x002aa800,     // CTL_29
+    0x0a040303,     // CTL_30
+    0x00071c00,     // CTL_31
+    0x06000303,     // CTL_32
+    0x03040305,     // CTL_33
+    0x0a0a0404,     // CTL_34
+    0x010a0a14,     // CTL_35
+    0x01000101,     // CTL_36
+    0x07080c01,     // CTL_37
+    0x03040703,     // CTL_38
+    0x00030407,     // CTL_39
+    0x01000000,     // CTL_40
+    0x04c10042,     // CTL_41
+    0x02610021,     // CTL_42
+    0x00660006,     // CTL_43
+    0x00000000,     // CTL_44
+    0x00030003,     // CTL_45
+    0x00000003,     // CTL_46
+    0x00000000,     // CTL_47
+    0x00030306,     // CTL_48
+    0x00450045,     // CTL_49
+    0x00230023,     // CTL_50
+    0x00060006,     // CTL_51
+    0x00000001,     // CTL_52
+    0x02020200,     // CTL_53
+    0x02020202,     // CTL_54
+    0x04030200,     // CTL_55
+    0x04030200,     // CTL_56
+    0x04030200,     // CTL_57
+    0x00000300,     // CTL_58
+    0x00070004,     // CTL_59
+    0x03050500,     // CTL_60
+    0x0a000004,     // CTL_61
+    0x20000100,     // CTL_62
+    0x00200400,     // CTL_63
+    0x00200400,     // CTL_64
+    0x00000400,     // CTL_65
+    0x00000100,     // CTL_66
+    0x00000000,     // CTL_67
+    0x00000001,     // CTL_68
+    0x00000002,     // CTL_69
+    0x00000000,     // CTL_70
+    0x00000000,     // CTL_71
+    0x00000000,     // CTL_72
+    0x00000000,     // CTL_73
+    0x00000000,     // CTL_74
+    0x00000000,     // CTL_75
+    0x00630000,     // CTL_76
+    0x00000004,     // CTL_77
+    0x00010043,     // CTL_78
+    0x00430000,     // CTL_79
+    0x00000001,     // CTL_80
+    0x00010001,     // CTL_81
+    0x03000001,     // CTL_82
+    0x00000000,     // CTL_83
+    0x00630000,     // CTL_84
+    0x00000004,     // CTL_85
+    0x00010043,     // CTL_86
+    0x00430000,     // CTL_87
+    0x00000001,     // CTL_88
+    0x00010001,     // CTL_89
+    0x03000001,     // CTL_90
+    0x00000000,     // CTL_91
+    0x00000000,     // CTL_92
+    0x00000101,     // CTL_93
+    0x00000000,     // CTL_94
+    0x00000000,     // CTL_95
+    0x00000000,     // CTL_96
+    0x0001381f,     // CTL_97
+    0x001d0071,     // CTL_98
+    0x0039009c,     // CTL_99
+    0x001a000f,     // CTL_100
+    0x0003000a,     // CTL_101
+    0x00000000,     // CTL_102
+    0x00000000,     // CTL_103
+    0x00001000,     // CTL_104
+    0x00030008,     // CTL_105
+    0x00000100,     // CTL_106
+    0x01010101,     // CTL_107
+    0xffff0000,     // CTL_108
+    0xffff1fff,     // CTL_109
+    0xff0a0000,     // CTL_110
+    0x010101ff,     // CTL_111
+    0x01010101,     // CTL_112
+    0x03010101,     // CTL_113
+    0x01000001,     // CTL_114
+    0x00000000,     // CTL_115
+    0x00000000,     // CTL_116
+    0x00010000,     // CTL_117
+    0x00000000,     // CTL_118
+    0x00000000,     // CTL_119
+    0x00000000,     // CTL_120
+    0xffffffff,     // CTL_121
+    0x00000000,     // CTL_122
+    0x00000000,     // CTL_123
+    0x00000000,     // CTL_124
+    0x00000000,     // CTL_125
+    0x00000000,     // CTL_126
+    0x00000000,     // CTL_127
+    0x00000000,     // CTL_128
+    0x00010000,     // CTL_129
+    0x02020302,     // CTL_130
+    0x00010202,     // CTL_131
+    0x02020101,     // CTL_132
+    0x02020202,     // CTL_133
+    0x01010201,     // CTL_134
+    0x01020201,     // CTL_135
+    0x01020201,     // CTL_136
+    0x02020200,     // CTL_137
+    0x00020000,     // CTL_138
+    0x00010001,     // CTL_139
+    0x00000000,     // CTL_140
+    0x00000000,     // CTL_141
+    0x08000000,     // CTL_142
+    0x0000000d,     // CTL_143
+    0x00000001,     // CTL_144
+    0x00030001,     // CTL_145
+    0x00000000,     // CTL_146
+    0x00010100,     // CTL_147
+    0x01000000,     // CTL_148
+    0x01000000,     // CTL_149
+    0x00000001,     // CTL_150
+    0x000556aa,     // CTL_151
+    0x000aa955,     // CTL_152
+    0x000aa955,     // CTL_153
+    0x000556aa,     // CTL_154
+    0x000556aa,     // CTL_155
+    0x000aa955,     // CTL_156
+    0x000aa955,     // CTL_157
+    0x000556aa,     // CTL_158
+    0x00010300,     // CTL_159
+    0x03000100,     // CTL_160
+    0x00014203,     // CTL_161
+    0x42000142,     // CTL_162
+    0x00000001,     // CTL_163
+    0x00000000,     // CTL_164
+    0x0f0f0f00,     // CTL_165
+    0x00000000,     // CTL_166
+    0x02001024,     // CTL_167
+    0x02000200,     // CTL_168
+    0x10240200,     // CTL_169
+    0x000050b4,     // CTL_170
+    0x0c200006,     // CTL_171
+    0x02000200,     // CTL_172
+    0x02000200,     // CTL_173
+    0x00000c20,     // CTL_174
+    0x00003ca0,     // CTL_175
+    0xfffffe02,     // CTL_176
+    0x02000200,     // CTL_177
+    0x02000200,     // CTL_178
+    0x00000644,     // CTL_179
+    0x00001f54,     // CTL_180
+    0xfffffe02,     // CTL_181
+    0x0a010002,     // CTL_182
+    0x0000000a,     // CTL_183
+    0x00000000,     // CTL_184
+    0x00000000,     // CTL_185
+    0x00000f0a,     // CTL_186
+    0x00000000,     // CTL_187
+    0x00000000,     // CTL_188
+    0x00000000,     // CTL_189
+    0x00000000,     // CTL_190
+    0x00030000,     // CTL_191
+    0x00130010,     // CTL_192
+    0x000f0010,     // CTL_193
+    0x000b0010,     // CTL_194
+    0x00000000,     // CTL_195
+    0x00000000,     // CTL_196
+    0x00000000,     // CTL_197
+    0x00000000,     // CTL_198
+    0x02050307,     // CTL_199
+    0x00000003,     // CTL_200
+    0x000f0f0f,     // CTL_201
+    0x04040000,     // CTL_202
+    0x00010000,     // CTL_203
+    0x00000000,     // CTL_204
+    0x0000010a,     // CTL_205
+    0x000000c8,     // CTL_206
+    0x00000068,     // CTL_207
+    0x00000003,     // CTL_208
+    0x00000000,     // CTL_209
+    0x00000000,     // CTL_210
+    0x00000000,     // CTL_211
+    0x00000000,     // CTL_212
+    0x00000000,     // CTL_213
+    0x00000000,     // CTL_214
+};
+#pragma arm section zidata ,  rwdata
+#endif /* _REG_EMIC_H_ */
diff --git a/devices/pm/power_control/emif/src/board_sf_3gx/emic_generated_sdram_ctl_26_156_400MHZ.h b/devices/pm/power_control/emif/src/board_sf_3gx/emic_generated_sdram_ctl_26_156_400MHZ.h
new file mode 100644
index 0000000..b18c154
--- /dev/null
+++ b/devices/pm/power_control/emif/src/board_sf_3gx/emic_generated_sdram_ctl_26_156_400MHZ.h
@@ -0,0 +1,332 @@
+//  BEGIN CCCT SECTION
+/*  -------------------------------------------------------------------------
+    Copyright (C) 2013 Intel Mobile Communications GmbH
+
+         Sec Class: Intel Confidential (IC)
+    ----------------------------------------------------------------------
+    Revision Information:
+       $File name:  /mhw_drv_src/power_control/emif/src/board_xmm6321/emic_generated_sdram_ctl_26_156_400MHZ.h $
+       $CC-Version: .../oint_drv_power_ctrl_02/2 $
+       $Date:       2013-11-28    12:17:22 UTC $
+    ----------------------------------------------------------------------
+    by CCCT (0.12c)
+    ---------------------------------------------------------------------- */
+//  END CCCT SECTION
+
+/*
+ * The following array structure holds two element. The first one represents
+ * the Denali register to which the second elemnent (the register value) is
+ * to be written.
+ */
+#ifndef _EMIC_GENERATED_SDRAM_CTL_26_156_400_MHZ_H_
+#define _EMIC_GENERATED_SDRAM_CTL_26_156_400_MHZ_H_
+#pragma arm section zidata = "INT_RWDATA",  rwdata = "INT_RWDATA"
+
+#if 0
+//F0 400M;F1 312M;F2 26M
+const U32 syno_PHY_F0[][2] = {
+    {0x00000010, 0x00f00488},    //PHY_PGCR2
+    {0x00000020, 0xa00b8000},    //PHY_PLLCR
+    {0x00000024, 0x32019010},    //PHY_PTR0
+    {0x00000028, 0x9c400e10},    //PHY_PTR1
+    {0x00000030, 0x09030d40},    //PHY_PTR3
+    {0x00000034, 0x06413880},    //PHY_PTR4
+    {0x00000084, 0x002c649a},    //PHY_DSGCR
+    {0x00000088, 0x00000409},    //PHY_DCR
+    {0x0000008c, 0x21110944},    //PHY_DTPR0
+    {0x00000090, 0x3d02a280},    //PHY_DTPR1
+    {0x00000094, 0x00100c58},    //PHY_DTPR2
+    {0x00000098, 0x0028669a},    //PHY_DTPR3
+    {0x0000009c, 0x00000000},    //PHY_MR0
+    {0x000000a0, 0x00000083},    //PHY_MR1
+    {0x000000a4, 0x00000004},    //PHY_MR2
+    {0x000000a8, 0x00000001},    //PHY_MR3
+    {0x000001a0, 0x00000003},    //PHY_BISTRR
+    {0x000000ec, 0x000d0b54},    //PHY_DQSDR
+    {0x000000f0, 0x0202aaaa},    //PHY_DTMR0
+    {0x00000280, 0x7c080285},    //PHY_DX0GCR0
+    {0x00000300, 0x7c080285},    //PHY_DX1GCR0
+    {0x00000380, 0x7c080285},    //PHY_DX2GCR0
+    {0x00000400, 0x7c080285},    //PHY_DX3GCR0
+    {0x00000288, 0x0000aaaa},    //PHY_DX0GCR2  DQ0-7 dis ODT
+    {0x0000028c, 0x00002000},    //PHY_DX0GCR3  DM dis ODT
+    {0x00000308, 0x0000aaaa},    //PHY_DX1GCR2  DQ8-15 dis ODT
+    {0x0000030c, 0x00002000},    //PHY_DX1GCR3  DM dis ODT
+    {0x00000388, 0x0000aaaa},    //PHY_DX2GCR2  DQ16-23 dis ODT
+    {0x0000038c, 0x00002000},    //PHY_DX2GCR3  DM dis ODT
+    {0x00000408, 0x0000aaaa},    //PHY_DX3GCR2  DQ24-31 dis ODT
+    {0x0000040c, 0x00002000},    //PHY_DX3GCR3  DM dis ODT
+};
+
+const U32 syno_PHY_F1[][2] = {
+    {0x00000010, 0x00f00331},    //PHY_PGCR2
+    {0x00000020, 0xa00b8000},    //PHY_PLLCR
+    {0x00000024, 0x27013810},    //PHY_PTR0
+    {0x00000028, 0x79e00af8},    //PHY_PTR1
+    {0x00000030, 0x07126160},    //PHY_PTR3
+    {0x00000034, 0x04e0f3c0},    //PHY_PTR4
+    {0x00000084, 0x002c649a},    //PHY_DSGCR
+    {0x00000088, 0x00000409},    //PHY_DCR
+    {0x0000008c, 0x190e0744},    //PHY_DTPR0
+    {0x00000090, 0x3cd21200},    //PHY_DTPR1
+    {0x00000094, 0x00100c45},    //PHY_DTPR2
+    {0x00000098, 0x00286551},    //PHY_DTPR3
+    {0x0000009c, 0x00000000},    //PHY_MR0
+    {0x000000a0, 0x00000063},    //PHY_MR1
+    {0x000000a4, 0x00000004},    //PHY_MR2
+    {0x000000a8, 0x00000001},    //PHY_MR3
+    {0x000001a0, 0x00000003},    //PHY_BISTRR
+    {0x000000ec, 0x00090754},    //PHY_DQSDR
+    {0x000000f0, 0x0201aaaa},    //PHY_DTMR0
+    {0x00000280, 0x7c080285},    //PHY_DX0GCR0
+    {0x00000300, 0x7c080285},    //PHY_DX1GCR0
+    {0x00000380, 0x7c080285},    //PHY_DX2GCR0
+    {0x00000400, 0x7c080285},    //PHY_DX3GCR0
+};
+
+const U32 syno_PHY_F2[][2] = {
+    {0x00000010, 0x00f00001},    //PHY_PGCR2
+    {0x00000020, 0xa01b8000},    //PHY_PLLCR
+    {0x00000024, 0x03401a10},    //PHY_PTR0
+    {0x00000028, 0x0a2800ea},    //PHY_PTR1
+    {0x00000030, 0x00a032c8},    //PHY_PTR3
+    {0x00000034, 0x00681450},    //PHY_PTR4
+    {0x00000084, 0x002c649a},    //PHY_DSGCR
+    {0x00000088, 0x00000409},    //PHY_DCR
+    {0x0000008c, 0x0c830344},    //PHY_DTPR0
+    {0x00000090, 0xe4203100},    //PHY_DTPR1
+    {0x00000094, 0x00100c06},    //PHY_DTPR2
+    {0x00000098, 0x00286191},    //PHY_DTPR3
+    {0x0000009c, 0x00000000},    //PHY_MR0
+    {0x000000a0, 0x00000043},    //PHY_MR1
+    {0x000000a4, 0x00000001},    //PHY_MR2
+    {0x000000a8, 0x00000001},    //PHY_MR3
+    {0x000001a0, 0x00000000},    //PHY_BISTRR
+    {0x000000ec, 0x00030154},    //PHY_DQSDR
+    {0x000000f0, 0x0201aaaa},    //PHY_DTMR0
+    {0x00000280, 0x7c080285},    //PHY_DX0GCR0
+    {0x00000300, 0x7c080285},    //PHY_DX1GCR0
+    {0x00000380, 0x7c080285},    //PHY_DX2GCR0
+    {0x00000400, 0x7c080285},    //PHY_DX3GCR0
+};
+#endif
+
+const U32 denaliSdram_CTL[] = {
+    0x00000700,     // CTL_00
+    0x00000000,     // CTL_01
+    0x00000000,     // CTL_02
+    0x00000028,     // CTL_03
+    0x00013880,     // CTL_04
+    0x00000190,     // CTL_05
+    0x00000fa0,     // CTL_06
+    0x00000020,     // CTL_07
+    0x0000f3c0,     // CTL_08
+    0x00000138,     // CTL_09
+    0x00000c30,     // CTL_10
+    0x00000003,     // CTL_11
+    0x00001450,     // CTL_12
+    0x0000001a,     // CTL_13
+    0x00000104,     // CTL_14
+    0x00000000,     // CTL_15
+    0x00000000,     // CTL_16
+    0x00000000,     // CTL_17
+    0x00000000,     // CTL_18
+    0x00030c00,     // CTL_19
+    0x0600030c,     // CTL_20
+    0x04000001,     // CTL_21
+    0x04111a04,     // CTL_22
+    0x15041409,     // CTL_23
+    0x1007040e,     // CTL_24
+    0x04030602,     // CTL_25
+    0x0a040803,     // CTL_26
+    0x006d6000,     // CTL_27
+    0x0a040603,     // CTL_28
+    0x00555000,     // CTL_29
+    0x0a040503,     // CTL_30
+    0x00071c00,     // CTL_31
+    0x08000303,     // CTL_32
+    0x03050606,     // CTL_33
+    0x0a0a0404,     // CTL_34
+    0x020a0a14,     // CTL_35
+    0x01000101,     // CTL_36
+    0x070c0f01,     // CTL_37
+    0x03070903,     // CTL_38
+    0x00030709,     // CTL_39
+    0x01000000,     // CTL_40
+    0x06180054,     // CTL_41
+    0x04c10042,     // CTL_42
+    0x00660006,     // CTL_43
+    0x00000000,     // CTL_44
+    0x00030003,     // CTL_45
+    0x00000003,     // CTL_46
+    0x00000000,     // CTL_47
+    0x00030608,     // CTL_48
+    0x00580058,     // CTL_49
+    0x00450045,     // CTL_50
+    0x00060006,     // CTL_51
+    0x00000001,     // CTL_52
+    0x02020200,     // CTL_53
+    0x02020202,     // CTL_54
+    0x04030200,     // CTL_55
+    0x04030200,     // CTL_56
+    0x04030200,     // CTL_57
+    0x00000300,     // CTL_58
+    0x00070004,     // CTL_59
+    0x03050500,     // CTL_60
+    0x0a000004,     // CTL_61
+    0x20000100,     // CTL_62
+    0x00200400,     // CTL_63
+    0x00200400,     // CTL_64
+    0x00000400,     // CTL_65
+    0x00000100,     // CTL_66
+    0x00000000,     // CTL_67
+    0x00000001,     // CTL_68
+    0x00000002,     // CTL_69
+    0x00000000,     // CTL_70
+    0x00000000,     // CTL_71
+    0x00000000,     // CTL_72
+    0x00000000,     // CTL_73
+    0x00000000,     // CTL_74
+    0x00000000,     // CTL_75
+    0x00830000,     // CTL_76
+    0x00000004,     // CTL_77
+    0x00040063,     // CTL_78
+    0x00430000,     // CTL_79
+    0x00000001,     // CTL_80
+    0x00010001,     // CTL_81
+    0x03000001,     // CTL_82
+    0x00000003,     // CTL_83
+    0x00830000,     // CTL_84
+    0x00000004,     // CTL_85
+    0x00040063,     // CTL_86
+    0x00430000,     // CTL_87
+    0x00000001,     // CTL_88
+    0x00010001,     // CTL_89
+    0x03000001,     // CTL_90
+    0x00000003,     // CTL_91
+    0x00000000,     // CTL_92
+    0x00000101,     // CTL_93
+    0x00000000,     // CTL_94
+    0x00000000,     // CTL_95
+    0x00000000,     // CTL_96
+    0x0002151f,     // CTL_97
+    0x00240090,     // CTL_98
+    0x00710138,     // CTL_99
+    0x001a001d,     // CTL_100
+    0x0003000a,     // CTL_101
+    0x00000000,     // CTL_102
+    0x00000000,     // CTL_103
+    0x00001400,     // CTL_104
+    0x00030010,     // CTL_105
+    0x00000100,     // CTL_106
+    0x01010101,     // CTL_107
+    0xffff0000,     // CTL_108
+    0xffff1fff,     // CTL_109
+    0xff0a0000,     // CTL_110
+    0x010101ff,     // CTL_111
+    0x01010101,     // CTL_112
+    0x03010101,     // CTL_113
+    0x01000001,     // CTL_114
+    0x00000000,     // CTL_115
+    0x00000000,     // CTL_116
+    0x00010000,     // CTL_117
+    0x00000000,     // CTL_118
+    0x00000000,     // CTL_119
+    0x00000000,     // CTL_120
+    0xffffffff,     // CTL_121
+    0x00000000,     // CTL_122
+    0x00000000,     // CTL_123
+    0x00000000,     // CTL_124
+    0x00000000,     // CTL_125
+    0x00000000,     // CTL_126
+    0x00000000,     // CTL_127
+    0x00000000,     // CTL_128
+    0x00010000,     // CTL_129
+    0x02030302,     // CTL_130
+    0x00010202,     // CTL_131
+    0x02020101,     // CTL_132
+    0x02020202,     // CTL_133
+    0x01010201,     // CTL_134
+    0x01020201,     // CTL_135
+    0x01020201,     // CTL_136
+    0x02020200,     // CTL_137
+    0x01030000,     // CTL_138
+    0x00010002,     // CTL_139
+    0x00000000,     // CTL_140
+    0x00000000,     // CTL_141
+    0x0a000000,     // CTL_142
+    0x00000010,     // CTL_143
+    0x00000001,     // CTL_144
+    0x00030001,     // CTL_145
+    0x00000000,     // CTL_146
+    0x00010100,     // CTL_147
+    0x01000000,     // CTL_148
+    0x01000000,     // CTL_149
+    0x00000001,     // CTL_150
+    0x000556aa,     // CTL_151
+    0x000aa955,     // CTL_152
+    0x000aa955,     // CTL_153
+    0x000556aa,     // CTL_154
+    0x000556aa,     // CTL_155
+    0x000aa955,     // CTL_156
+    0x000aa955,     // CTL_157
+    0x000556aa,     // CTL_158
+    0x00010300,     // CTL_159
+    0x03000100,     // CTL_160
+    0x00014203,     // CTL_161
+    0x42000142,     // CTL_162
+    0x00000001,     // CTL_163
+    0x00000000,     // CTL_164
+    0x0f0f0f00,     // CTL_165
+    0x00000000,     // CTL_166
+    0x02001024,     // CTL_167
+    0x02000200,     // CTL_168
+    0x10240200,     // CTL_169
+    0x000050b4,     // CTL_170
+    0x0c200006,     // CTL_171
+    0x02000200,     // CTL_172
+    0x02000200,     // CTL_173
+    0x00000c20,     // CTL_174
+    0x00003ca0,     // CTL_175
+    0x06440006,     // CTL_176
+    0x02000200,     // CTL_177
+    0x02000200,     // CTL_178
+    0x00000644,     // CTL_179
+    0x00001f54,     // CTL_180
+    0xfffffe02,     // CTL_181
+    0x0a010002,     // CTL_182
+    0x0000000a,     // CTL_183
+    0x00000000,     // CTL_184
+    0x00000000,     // CTL_185
+    0x00000f0a,     // CTL_186
+    0x00000000,     // CTL_187
+    0x00000000,     // CTL_188
+    0x00000000,     // CTL_189
+    0x00000000,     // CTL_190
+    0x00030000,     // CTL_191
+    0x00130010,     // CTL_192
+    0x000f0010,     // CTL_193
+    0x000b0010,     // CTL_194
+    0x00000000,     // CTL_195
+    0x00000000,     // CTL_196
+    0x00000000,     // CTL_197
+    0x00000000,     // CTL_198
+    0x02050307,     // CTL_199
+    0x00000003,     // CTL_200
+    0x000f0f0f,     // CTL_201
+    0x04040000,     // CTL_202
+    0x00010000,     // CTL_203
+    0x00000000,     // CTL_204
+    0x0000010a,     // CTL_205
+    0x000000c8,     // CTL_206
+    0x00000068,     // CTL_207
+    0x00000003,     // CTL_208
+    0x00000000,     // CTL_209
+    0x00000000,     // CTL_210
+    0x00000000,     // CTL_211
+    0x00000000,     // CTL_212
+    0x00000000,     // CTL_213
+    0x00000000,     // CTL_214
+};
+#pragma arm section zidata ,  rwdata
+#endif /* _REG_EMIC_H_ */
diff --git a/devices/pm/power_control/emif/src/board_sf_3gx/emic_generated_sdram_ctl_26_156_533MHZ.h b/devices/pm/power_control/emif/src/board_sf_3gx/emic_generated_sdram_ctl_26_156_533MHZ.h
new file mode 100644
index 0000000..b71d48e
--- /dev/null
+++ b/devices/pm/power_control/emif/src/board_sf_3gx/emic_generated_sdram_ctl_26_156_533MHZ.h
@@ -0,0 +1,251 @@
+//  BEGIN CCCT SECTION
+/*  -------------------------------------------------------------------------
+    Copyright (C) 2013 Intel Mobile Communications GmbH
+
+         Sec Class: Intel Confidential (IC)
+    ----------------------------------------------------------------------
+    Revision Information:
+       $File name:  /mhw_drv_src/power_control/emif/src/board_xmm6321/emic_generated_sdram_ctl_26_156_400MHZ.h $
+       $CC-Version: .../oint_drv_power_ctrl_02/2 $
+       $Date:       2013-11-28    12:17:22 UTC $
+    ----------------------------------------------------------------------
+    by CCCT (0.12c)
+    ---------------------------------------------------------------------- */
+//  END CCCT SECTION
+
+/*
+ * The following array structure holds two element. The first one represents
+ * the Denali register to which the second elemnent (the register value) is
+ * to be written.
+ */
+#ifndef _EMIC_GENERATED_SDRAM_CTL_26_156_533_MHZ_H_
+#define _EMIC_GENERATED_SDRAM_CTL_26_156_533_MHZ_H_
+
+#if defined (__ICC) || defined (__GCC)
+__attribute__(( aligned(16), section("BOOTCORE_POWER_RAM_DATA"))) const U32 denaliSdram_CTL[];
+#endif
+
+//F0 533M;F1 156M;F2 26M
+const U32 Fn_freq_MHz[3] = {533, 156, 26};
+
+const U32 denaliSdram_CTL[] = {
+	0x00000700,     // CTL_00
+	0x00000000,     // CTL_01
+	0x00000000,     // CTL_02
+	0x00000036,     // CTL_03
+	0x0001a068,     // CTL_04
+	0x00000215,     // CTL_05
+	0x000014d2,     // CTL_06
+	0x00000010,     // CTL_07
+	0x000079e0,     // CTL_08
+	0x0000009c,     // CTL_09
+	0x00000618,     // CTL_10
+	0x00000003,     // CTL_11
+	0x00001450,     // CTL_12
+	0x0000001a,     // CTL_13
+	0x00000104,     // CTL_14
+	0x00000000,     // CTL_15
+	0x00000000,     // CTL_16
+	0x00000000,     // CTL_17
+	0x00000000,     // CTL_18
+	0x00041000,     // CTL_19
+	0x06000106,     // CTL_20
+        0x04000001,     // CTL_21
+	0x04172306,     // CTL_22
+	0x0b021b0c,     // CTL_23
+	0x08040407,     // CTL_24
+	0x04030602,     // CTL_25
+	0x0a040803,     // CTL_26
+	0x0091be00,     // CTL_27
+	0x0a040804,     // CTL_28
+	0x002aa800,     // CTL_29
+	0x0a040303,     // CTL_30
+	0x00071c00,     // CTL_31
+	0x0a000303,     // CTL_32
+	0x03040308,     // CTL_33
+	0x0a0a0404,     // CTL_34
+	0x020a0a14,     // CTL_35
+	0x01000101,     // CTL_36
+	0x07081401,     // CTL_37
+	0x03040c03,     // CTL_38
+	0x0003040c,     // CTL_39
+	0x01000000,     // CTL_40
+	0x081f0070,     // CTL_41
+	0x02610021,     // CTL_42
+	0x00660006,     // CTL_43
+	0x00000000,     // CTL_44
+	0x00030004,     // CTL_45
+	0x00000003,     // CTL_46
+	0x00000000,     // CTL_47
+	0x0003030a,     // CTL_48
+	0x00760076,     // CTL_49
+	0x00230023,     // CTL_50
+	0x00060006,     // CTL_51
+	0x00000001,     // CTL_52
+	0x02020200,     // CTL_53
+	0x02020202,     // CTL_54
+	0x04030200,     // CTL_55
+	0x04030200,     // CTL_56
+	0x04030200,     // CTL_57
+	0x00000300,     // CTL_58
+	0x00070004,     // CTL_59
+	0x03070500,     // CTL_60
+	//0x01000020,     // CTL_61
+	0x00000000,     // CTL_61
+	0x20000100,     // CTL_62
+	0x00200400,     // CTL_63
+	0x00200400,     // CTL_64
+	0x00000400,     // CTL_65
+	0x00000100,     // CTL_66
+	0x00000000,     // CTL_67
+	0x00000001,     // CTL_68
+	0x00000002,     // CTL_69
+	0x00000000,     // CTL_70
+	0x00000000,     // CTL_71
+	0x00000000,     // CTL_72
+	0x00000000,     // CTL_73
+	0x00000000,     // CTL_74
+	0x00000000,     // CTL_75
+	0x00c30000,     // CTL_76
+	0x00000006,     // CTL_77
+	0x00010043,     // CTL_78
+	0x00430000,     // CTL_79
+	0x00000001,     // CTL_80
+	0x00010001,     // CTL_81
+	0x00000001,     // CTL_82
+	0x00000000,     // CTL_83
+	0x00c30000,     // CTL_84
+	0x00000006,     // CTL_85
+	0x00010043,     // CTL_86
+	0x00430000,     // CTL_87
+	0x00000001,     // CTL_88
+	0x00010001,     // CTL_89
+	0x00000001,     // CTL_90
+	0x00000000,     // CTL_91
+	0x00000000,     // CTL_92
+	0x00000101,     // CTL_93
+	0x00000000,     // CTL_94
+	0x00000000,     // CTL_95
+	0x00000000,     // CTL_96
+	//0x00021500,     // CTL_97
+	0x00021400,     // CTL_97
+	0x003000c0,     // CTL_98
+	0x0039009c,     // CTL_99
+	0x001a000f,     // CTL_100
+	0x0003000a,     // CTL_101
+	0x00000000,     // CTL_102
+	0x00000000,     // CTL_103
+	0x00001b00,     // CTL_104
+	0x00030008,     // CTL_105
+	0x00000100,     // CTL_106
+	0x01010101,     // CTL_107
+	0xffff0000,     // CTL_108
+	0xffff1fff,     // CTL_109
+	0xff0a0000,     // CTL_110
+	0x010101ff,     // CTL_111
+	0x01010101,     // CTL_112
+	0x03010101,     // CTL_113
+	0x01000001,     // CTL_114
+	0x00000000,     // CTL_115
+	0x00000000,     // CTL_116
+	0x00010000,     // CTL_117
+	0x00000000,     // CTL_118
+	0x00000000,     // CTL_119
+	0x00000000,     // CTL_120
+	0xffffffff,     // CTL_121
+	0x00000000,     // CTL_122
+	0x00000000,     // CTL_123
+	0x00000000,     // CTL_124
+	0x00000000,     // CTL_125
+	0x00000000,     // CTL_126
+	0x00000000,     // CTL_127
+	0x00000000,     // CTL_128
+	0x00010000,     // CTL_129
+	0x02020302,     // CTL_130
+	0x00000303,     // CTL_131
+	0x02030101,     // CTL_132
+	0x02020302,     // CTL_133
+	0x01010201,     // CTL_134
+	0x01020201,     // CTL_135
+	0x01020201,     // CTL_136
+	0x02020200,     // CTL_137
+	0x01030000,     // CTL_138
+	0x00010001,     // CTL_139
+	0x00000000,     // CTL_140
+	0x00000000,     // CTL_141
+	0x0e000000,     // CTL_142
+	0x00000016,     // CTL_143
+	0x00000001,     // CTL_144
+	0x00030001,     // CTL_145
+	0x00000000,     // CTL_146
+	0x00010100,     // CTL_147
+	0x01000000,     // CTL_148
+	0x01000000,     // CTL_149
+	0x00000001,     // CTL_150
+	0x000556aa,     // CTL_151
+	0x000aa955,     // CTL_152
+	0x000aa955,     // CTL_153
+	0x000556aa,     // CTL_154
+	0x000556aa,     // CTL_155
+	0x000aa955,     // CTL_156
+	0x000aa955,     // CTL_157
+	0x000556aa,     // CTL_158
+	0x00010300,     // CTL_159
+	0x03000100,     // CTL_160
+	0x00014203,     // CTL_161
+	0x42000142,     // CTL_162
+	0x00000001,     // CTL_163
+	0x00000000,     // CTL_164
+	0x0f0f0f00,     // CTL_165
+	0x00000000,     // CTL_166
+	0x02001024,     // CTL_167
+	0x02000200,     // CTL_168
+	0x10240200,     // CTL_169
+	0x000050b4,     // CTL_170
+	0x0c200208,     // CTL_171
+	0x02000200,     // CTL_172
+	0x02000200,     // CTL_173
+	0x00000c20,     // CTL_174
+	0x00003ca0,     // CTL_175
+	0xfffffe02,     // CTL_176
+	0x02000200,     // CTL_177
+	0x02000200,     // CTL_178
+	0x00000644,     // CTL_179
+	0x00001f54,     // CTL_180
+	0xfffffe02,     // CTL_181
+	0x0a010002,     // CTL_182
+	0x0000000a,     // CTL_183
+	0x00000000,     // CTL_184
+	0x00000000,     // CTL_185
+	0x00000f0a,     // CTL_186
+	0x00000000,     // CTL_187
+	0x00000000,     // CTL_188
+	0x00000000,     // CTL_189
+	0x00000000,     // CTL_190
+	0x00030000,     // CTL_191
+	0x00130010,     // CTL_192
+	0x000f0010,     // CTL_193
+	0x000b0010,     // CTL_194
+	0x00000000,     // CTL_195
+	0x00000000,     // CTL_196
+	0x00000000,     // CTL_197
+	0x00000000,     // CTL_198
+	0x02050307,     // CTL_199
+	0x00000003,     // CTL_200
+	0x000f0f0f,     // CTL_201
+	0x04040000,     // CTL_202
+	0x00010000,     // CTL_203
+	0x00000000,     // CTL_204
+	0x0000010a,     // CTL_205
+	0x000000c8,     // CTL_206
+	0x00000068,     // CTL_207
+	0x00000003,     // CTL_208
+	0x00000000,     // CTL_209
+	0x00000000,     // CTL_210
+	0x00000000,     // CTL_211
+	0x00000000,     // CTL_212
+	0x00000000,     // CTL_213
+	0x00000000,     // CTL_214
+
+};
+#endif /* _REG_EMIC_H_ */
diff --git a/devices/pm/power_control/emif/src/board_sf_3gx/emic_generated_sdram_phy_26_156_533MHZ.h b/devices/pm/power_control/emif/src/board_sf_3gx/emic_generated_sdram_phy_26_156_533MHZ.h
new file mode 100644
index 0000000..e955c1f
--- /dev/null
+++ b/devices/pm/power_control/emif/src/board_sf_3gx/emic_generated_sdram_phy_26_156_533MHZ.h
@@ -0,0 +1,57 @@
+//  BEGIN CCCT SECTION
+/*  -------------------------------------------------------------------------
+    Copyright (C) 2013 Intel Mobile Communications GmbH
+
+         Sec Class: Intel Confidential (IC)
+    ----------------------------------------------------------------------
+    Revision Information:
+       $File name:  /mhw_drv_src/power_control/emif/src/board_xmm6321/emic_generated_sdram_ctl_26_156_400MHZ.h $
+       $CC-Version: .../oint_drv_power_ctrl_02/2 $
+       $Date:       2013-11-28    12:17:22 UTC $
+    ----------------------------------------------------------------------
+    by CCCT (0.12c)
+    ---------------------------------------------------------------------- */
+//  END CCCT SECTION
+
+/*
+ * The following array structure holds two element. The first one represents
+ * the Denali register to which the second elemnent (the register value) is
+ * to be written.
+ */
+#if defined (__ICC) || defined (__GCC)
+__attribute__(( aligned(16), section("BOOTCORE_POWER_RAM_DATA"))) const U32 snpsSdram_PHY[][2];
+#endif
+
+const U32 snpsSdram_PHY[][2] = {
+        {0x00000010, 0x00f0068f},
+        {0x00000020, 0x000b8000},
+        {0x00000024, 0x42a21510},
+        {0x00000028, 0xd03412bd},
+        {0x00000030, 0x0c041104},
+        {0x00000034, 0x0855a068},
+        {0x00000084, 0x002864da},
+        {0x00000088, 0x00000409},
+        {0x0000008c, 0x29970c44},
+        {0x00000090, 0x3d638360},
+        {0x00000094, 0x00101076},
+        {0x00000098, 0x002888e2},
+        {0x0000009c, 0x00000000},
+        {0x000000a0, 0x000000c3},
+        {0x000000a4, 0x00000006},
+        {0x000000a8, 0x00000001},
+        {0x000001a0, 0x00000000},
+#if defined (DISABLE_ODT)
+        {0x00000288, 0x0000aaaa},
+        {0x0000028c, 0x00002000},
+        {0x00000308, 0x0000aaaa},
+        {0x0000030c, 0x00002000},
+        {0x00000388, 0x0000aaaa},
+        {0x0000038c, 0x00002000},
+        {0x00000408, 0x0000aaaa},
+        {0x0000040c, 0x00002000},
+#endif
+        {0x000000ec, 0x000d0b54},
+        {0x000000f0, 0x0202aaaa},
+};
+
+#define SNPS_PHY_ENTRIES ( sizeof(snpsSdram_PHY) / (sizeof(int)*2) )
diff --git a/devices/pm/power_control/emif/src/board_sf_3gx/emic_mem_cfg.h b/devices/pm/power_control/emif/src/board_sf_3gx/emic_mem_cfg.h
new file mode 120000
index 0000000..b6c0e92
--- /dev/null
+++ b/devices/pm/power_control/emif/src/board_sf_3gx/emic_mem_cfg.h
@@ -0,0 +1 @@
+../board_sf_3g/emic_mem_cfg.h
\ No newline at end of file
diff --git a/devices/pm/power_control/inc/board_sf_3gx/pow_driverif_board.h b/devices/pm/power_control/inc/board_sf_3gx/pow_driverif_board.h
new file mode 100644
index 0000000..4a35923
--- /dev/null
+++ b/devices/pm/power_control/inc/board_sf_3gx/pow_driverif_board.h
@@ -0,0 +1,537 @@
+/* =============================================================================
+ * Copyright (C) 2013-2014 Intel Mobile Communications GmbH
+ *
+ *      Sec Class: Intel Confidential (IC)
+ *
+ * =============================================================================
+ *
+ * This document contains proprietary information belonging to IMC.
+ * Passing on and copying of this document, use and communication of
+ * its contents is not permitted without prior written authorisation.
+ *
+ * =============================================================================
+ * Revision Information :
+ *   $File name:  /mhw_drv_src/power_control/inc/board_xmm6321/pow_driverif_board.h $
+ *   Responsible: asselal
+ *   Comment:
+ *     Created
+ * =============================================================================
+ *
+ * This file contains all power control board sub component internal definitions
+ *
+ * =============================================================================
+ *
+ * Date         Author             Comment
+ * -----------------------------------------------------------------------------
+ *
+ * 2012-04-19  Heinz Keilholz      created
+ * ===========================================================================*/
+
+#ifndef _POW_DRIVERIF_BOARD_H_
+#define _POW_DRIVERIF_BOARD_H_
+
+#include <bastypes.h>
+#include <opm.h>
+#include <uta_os.h>
+#include <uta_common_return_codes.h>
+#include <uta_common_types.h>
+
+#if defined(__cplusplus)
+    extern "C" {
+#endif
+
+/*----------------------------------------------*/
+/* This file is only included by pow_driverif.h */
+/*----------------------------------------------*/
+/*----------------------------------------------*/
+/* TYPE DEFINITIONS                             */
+/*----------------------------------------------*/
+
+/*----------------------------------------------*/
+/* DEFINITIONS FOR VOLTAGE HANDLING             */
+/*----------------------------------------------*/
+
+/* deprecated VDD_CORE power sub_domain in XMM6360
+ * Backward compatibility defines mapping old names to new ones.
+ * Changes are only made to make things clearer.
+ */
+
+#define POW_CONTROL_VDDP_USB_HSIC_PHY       POW_CONTROL_VDDP_USB_HSIC_PHY_P
+
+/** @brief Defines the POW_CONTROL_VOLTAGE_ID_T domain types.
+  * @ingroup POW_enums
+  *
+  * The voltage domain names are derived from the X-GOLD636 specification, chapter Power Supply Concept.
+  *
+  * The following domains / regulators are not requestable because of the fact that these regulators are kept on or
+  * switched automatically .
+  * @li VRTC automatic switched via connecting VBAT
+  * @li VSD1 automatic switched via SPCU control
+  * @li VSD2 automatic switched via SPCU control
+  * @li VSD3 automatic switched via SPCU control
+  * @li VDD_PLL automatic switched via SPCU control
+  *
+  */
+// CODEGEN_BEGIN(POW_CONTROL_VOLTAGE_ID_T) begin of automated generated source by tool, don't remove this line
+typedef enum
+{
+   POW_CONTROL_VDD_FIRST,
+   POW_CONTROL_VDDP_MMC = POW_CONTROL_VDD_FIRST,            /**< Pad supply and possibly the supply for the SD MMC card */
+   POW_CONTROL_VDDP_MMC_TD,                                 /**< Pad supply and possibly the supply for the trace and debugger */
+   POW_CONTROL_VDD_VEMMC,                                   /**<  */
+   POW_CONTROL_VDD_SDIO,                                    /**< Supply for SDIO */
+   POW_CONTROL_VDD_TOUCHSCREEN,                             /**< Supply voltage for Touchscreen(TP) - 1V8 */
+   POW_CONTROL_VDD_EMIC_1V8_IO,                             /**< Supply for RX */
+   POW_CONTROL_VDD_MIPI_CSI,                                /**< Supply for MIPI CSI */
+   POW_CONTROL_VDD_MIPI_DSI,                                /**< Supply for MIPI DSI */
+   POW_CONTROL_VDD_DIGRF1,                                  /**< Supply for DIGRF V3.0.9 */
+   POW_CONTROL_VDD_USB_1V1,                                 /**< Supply for USB HS PHY 1,1V domain */
+   POW_CONTROL_VDD_EMIC_CORE,                               /**< Supply for EMIC_CORE */
+   POW_CONTROL_VDD_EMIC_DLL,                                /**< Supply for EMIC DLL */
+   POW_CONTROL_VDD_IDI_RX,                                  /**< Supply for IDI receiver */
+   POW_CONTROL_VDD_USB_3V3,                                 /**< Supply for USB HS I/O, USB PLL */
+   POW_CONTROL_VDDP_SIM,                                    /**< Supply voltage for SIM generated from VSIM PMU regulator */
+   POW_CONTROL_VDDP_SIM2,                                   /**< Supply voltage for SIM2 generated from VSIM PMU regulator */
+   POW_CONTROL_VDD_PLL,                                     /**< Supply for PLL */
+   POW_CONTROL_VDD_IO_VOLT_TOUCH_SENSOR,                    /**< io voltage for TOUCH_SENSOR */
+   POW_CONTROL_VDD_IO_VOLT_PROXIMITY_SENSOR,                /**< io voltage for PROXIMITY_SENSOR */
+   POW_CONTROL_VDD_IO_VOLT_ACCELEROMETER,                   /**< io voltage for ACCELEROMETER */
+   POW_CONTROL_VDD_IO_VOLT_MAGNETOMETER,                    /**< io voltage for MAGNETOMETER */
+   POW_CONTROL_VDD_IO_VOLT_GYROSCOPE,                       /**< io voltage for GYROSCOPE */
+   POW_CONTROL_VDD_CAM_PRIM_ANALOG,                         /**<  */
+   POW_CONTROL_VDD_CAM_SEC_ANALOG,                          /**<  */
+   POW_CONTROL_VDD_PRIM_DISPLAY,                            /**<  */
+   POW_CONTROL_VDD_TOUCH_SENSOR,                            /**< Supply voltage for TOUCH_SENSOR */
+   POW_CONTROL_VDD_PROXIMITY_SENSOR,                        /**< Supply voltage for PROXIMITY_SENSOR */
+   POW_CONTROL_VDD_ACCELEROMETER,                           /**< Supply voltage for ACCELEROMETER */
+   POW_CONTROL_VDD_MAGNETOMETER,                            /**< Supply voltage for MAGNETOMETER */
+   POW_CONTROL_VDD_GYROSCOPE,                               /**< Supply voltage for GYROSCOPE */
+   POW_CONTROL_VDD_EMIC_IO,                                 /**< Supply for TX */
+   POW_CONTROL_VDD_ABB_GNSS_TCXO_LDO,                       /**<  */
+   POW_CONTROL_VDDP_VEMMC_P,                                /**<  */
+   POW_CONTROL_VDD_CAM_PRIM_DIGITAL,                        /**<  */
+   POW_CONTROL_VDD_CAM_PRIM_IO,                             /**<  */
+   POW_CONTROL_VDD_CAM_PRIM_AF,                             /**<  */
+   POW_CONTROL_VDD_CAM_SEC_DIGITAL,                         /**<  */
+   POW_CONTROL_VDD_CAM_SEC_IO,                              /**<  */
+   POW_CONTROL_VDD_CAM_SEC_AF,                              /**<  */
+   POW_CONTROL_VDD_PRIM_DISP_BACKLIGHT,                     /**<  */
+   POW_CONTROL_VDD_SD_CARD,
+   POW_CONTROL_VDD_EMMC,
+   POW_CONTROL_VDD_VCPU,                                    /**< Supply voltage for CPU domain */
+   POW_CONTROL_VDD_GPU,                                     /**< Supply voltage for GPU domain */
+   POW_CONTROL_VDD_DEPRECATED,                              /**<  */
+   POW_CONTROL_NUM_VOLTAGE_ID,                              /**< number of available voltage IDs */
+   POW_CONTROL_MAX_VOLTAGE_ID = 0x7FFFFFFF
+
+}POW_CONTROL_VOLTAGE_ID_T;
+// CODEGEN_END(POW_CONTROL_VOLTAGE_ID_T) end of automated generated source by tool, don't remove this line
+
+
+/***************************************************************************************************
+* IMPORTANT: Any modification to this enumeration should be accompanied with corresponding change
+* in GTI table gti_pow_volt_enum[]. If mismatched the system would trap.
+* Also modification to this enumeration has a dependancy on the Power trace tooling based
+* on Mobile Analyzer. If this enumeration is being modified, please raise a ticket against the Mobile
+* Analyzer to adapt your modification also to the MA tool.
+****************************************************************************************************/
+
+/** @brief Defines the POW_CONTROL_VOLTAGE_T
+  * @ingroup POW_enums
+  *
+  * Here the possible voltages are specified. A lot of regulators / domains can only be switched on / off.
+  * For this only POW_CONTROL_VOLTAGE_ON shall be used as voltage level.
+  */
+/* Update also voltage_map_pow_to_internal_pmu! */
+// CODEGEN_BEGIN(POW_CONTROL_VOLTAGE_T) begin of automated generated source by tool, don't remove this line
+typedef enum
+{
+    POW_CONTROL_VOLTAGE_ON,                  /**< shall be used if only one voltage is available and voltage can't be modified, hard coded value */
+    POW_CONTROL_VOLTAGE_0V87,                /**< 0.87 Volts */
+    POW_CONTROL_VOLTAGE_1V00,                /**< 1.00 Volts */
+    POW_CONTROL_VOLTAGE_1V02,                /**< 1.02 Volts */
+    POW_CONTROL_VOLTAGE_1V10,                /**< 1.10 Volts */
+    POW_CONTROL_VOLTAGE_1V12,                /**< 1.12 Volts */
+    POW_CONTROL_VOLTAGE_1V14,                /**< 1.14 Volts */
+    POW_CONTROL_VOLTAGE_1V16,                /**< 1.16 Volts */
+    POW_CONTROL_VOLTAGE_1V17,                /**< 1.17 Volts */
+    POW_CONTROL_VOLTAGE_1V20,                /**< 1.20 Volts */
+    POW_CONTROL_VOLTAGE_1V22,                /**< 1.22 Volts */
+    POW_CONTROL_VOLTAGE_1V226,               /**< 1.226 Volts */
+    POW_CONTROL_VOLTAGE_1V25,                /**< 1.25 Volts */
+    POW_CONTROL_VOLTAGE_1V30,                /**< 1.30 Volts */
+    POW_CONTROL_VOLTAGE_1V32,                /**< 1.32 Volts */
+    POW_CONTROL_VOLTAGE_1V8,                 /**< 1.80 Volts */
+    POW_CONTROL_VOLTAGE_2V05,                /**< 2.05 Volts */
+    POW_CONTROL_VOLTAGE_2V3,                 /**< 2.30 Volts */
+    POW_CONTROL_VOLTAGE_2V5,                 /**< 2.50 Volts */
+    POW_CONTROL_VOLTAGE_2V8,                 /**< 2.80 Volts */
+    POW_CONTROL_VOLTAGE_2V85,                /**< 2.85 Volts */
+    POW_CONTROL_VOLTAGE_2V9,                 /**< 2.90 Volts */
+    POW_CONTROL_VOLTAGE_2V91,                /**< 2.91 Volts */
+    POW_CONTROL_VOLTAGE_3V00,
+    POW_CONTROL_VOLTAGE_3V15,                /**< 3.15 Volts */
+    POW_CONTROL_VOLTAGE_3V30,                 /**< 3.30 Volts */
+    POW_CONTROL_VOLTAGE_5V00,                 /**< 3.30 Volts */
+    POW_CONTROL_VOLTAGE_DEPRECATED_1,        /**<  */
+    POW_CONTROL_NUM_VOLTAGE,                 /**< number of available voltage levels, hard coded value */
+    POW_CONTROL_MAX_VOLTAGE = 0x7FFFFFFF     /**< hard coded value */
+} POW_CONTROL_VOLTAGE_T;
+// CODEGEN_END(POW_CONTROL_VOLTAGE_T) end of automated generated source by tool, don't remove this line
+
+/* doxygen part for POW ISpec */
+// CODEGEN_BEGIN(POW_CONTROL_VOLTAGE_RELATED) begin of automated generated source by tool, don't remove this line
+/**
+  * @fn POW_RETURN_RESULT_T POW_SetVoltageDemands(POW_CONTROL_VOLTAGE_ID_T voltage_id,POW_CONTROL_VOLTAGE_T voltage, POW_CONTROL_VOLTAGE_STATE_T state)
+  *
+  * @par POW_CONTROL_VDDP_MMC - PMU regulator LMMC1
+  *   - VOLTAGE
+  *    - POW_CONTROL_VOLTAGE_1V20
+  *    - POW_CONTROL_VOLTAGE_1V8
+  *    - POW_CONTROL_VOLTAGE_2V85
+  *    - POW_CONTROL_VOLTAGE_2V9
+  *   - STATE
+  *    - POW_CONTROL_VOLTAGE_DISABLE
+  *    - POW_CONTROL_VOLTAGE_ENABLE
+  *    - POW_CONTROL_VOLTAGE_HW_CONTROLLED
+  *
+  * @par POW_CONTROL_VDDP_MMC_TD - PMU regulator LMMC1
+  *   - VOLTAGE
+  *    - POW_CONTROL_VOLTAGE_1V20
+  *    - POW_CONTROL_VOLTAGE_1V8
+  *    - POW_CONTROL_VOLTAGE_2V85
+  *    - POW_CONTROL_VOLTAGE_2V9
+  *   - STATE
+  *    - POW_CONTROL_VOLTAGE_DISABLE
+  *    - POW_CONTROL_VOLTAGE_ENABLE
+  *    - POW_CONTROL_VOLTAGE_HW_CONTROLLED
+  *
+  * @par POW_CONTROL_VDD_VEMMC - PMU regulator SD2
+  *   - VOLTAGE
+  *    - POW_CONTROL_VOLTAGE_ON
+  *   - STATE
+  *    - POW_CONTROL_VOLTAGE_DISABLE
+  *    - POW_CONTROL_VOLTAGE_ENABLE
+  *    - POW_CONTROL_VOLTAGE_HW_CONTROLLED
+  *
+  * @par POW_CONTROL_VDDP_VEMMC_P - PMU regulator NOTCFG
+  *   - VOLTAGE
+  *    - POW_CONTROL_VOLTAGE_ON
+  *   - STATE
+  *    - POW_CONTROL_VOLTAGE_DISABLE
+  *    - POW_CONTROL_VOLTAGE_ENABLE
+  *    - POW_CONTROL_VOLTAGE_HW_CONTROLLED
+  *
+  * @par POW_CONTROL_VDD_SDIO - PMU regulator SD2
+  *   - VOLTAGE
+  *    - POW_CONTROL_VOLTAGE_ON
+  *   - STATE
+  *    - POW_CONTROL_VOLTAGE_DISABLE
+  *    - POW_CONTROL_VOLTAGE_ENABLE
+  *    - POW_CONTROL_VOLTAGE_HW_CONTROLLED
+  *
+  * @par POW_CONTROL_VDD_MIPI_CSI - PMU regulator LMIPI
+  *   - VOLTAGE
+  *    - POW_CONTROL_VOLTAGE_1V00
+  *    - POW_CONTROL_VOLTAGE_1V10
+  *    - POW_CONTROL_VOLTAGE_1V17
+  *    - POW_CONTROL_VOLTAGE_1V20
+  *   - STATE
+  *    - POW_CONTROL_VOLTAGE_DISABLE
+  *    - POW_CONTROL_VOLTAGE_ENABLE
+  *    - POW_CONTROL_VOLTAGE_HW_CONTROLLED
+  *
+  * @par POW_CONTROL_VDD_MIPI_DSI - PMU regulator LMIPI
+  *   - VOLTAGE
+  *    - POW_CONTROL_VOLTAGE_1V00
+  *    - POW_CONTROL_VOLTAGE_1V10
+  *    - POW_CONTROL_VOLTAGE_1V17
+  *    - POW_CONTROL_VOLTAGE_1V20
+  *   - STATE
+  *    - POW_CONTROL_VOLTAGE_DISABLE
+  *    - POW_CONTROL_VOLTAGE_ENABLE
+  *    - POW_CONTROL_VOLTAGE_HW_CONTROLLED
+  *
+  * @par POW_CONTROL_VDD_USB_1V1 - PMU regulator LAIF
+  *   - VOLTAGE
+  *    - POW_CONTROL_VOLTAGE_1V00
+  *    - POW_CONTROL_VOLTAGE_1V10
+  *    - POW_CONTROL_VOLTAGE_1V8
+  *    - POW_CONTROL_VOLTAGE_2V5
+  *   - STATE
+  *    - POW_CONTROL_VOLTAGE_DISABLE
+  *    - POW_CONTROL_VOLTAGE_ENABLE
+  *    - POW_CONTROL_VOLTAGE_HW_CONTROLLED
+  *
+  * @par POW_CONTROL_VDD_USB_3V3 - PMU regulator LUSB
+  *   - VOLTAGE
+  *    - POW_CONTROL_VOLTAGE_2V5
+  *    - POW_CONTROL_VOLTAGE_2V85
+  *    - POW_CONTROL_VOLTAGE_3V15
+  *   - STATE
+  *    - POW_CONTROL_VOLTAGE_DISABLE
+  *    - POW_CONTROL_VOLTAGE_ENABLE
+  *    - POW_CONTROL_VOLTAGE_HW_CONTROLLED
+  *
+  * @par POW_CONTROL_VDDP_SIM - PMU regulator LSIM1
+  *   - VOLTAGE
+  *    - POW_CONTROL_VOLTAGE_1V20
+  *    - POW_CONTROL_VOLTAGE_1V8
+  *    - POW_CONTROL_VOLTAGE_2V91
+  *   - STATE
+  *    - POW_CONTROL_VOLTAGE_DISABLE
+  *    - POW_CONTROL_VOLTAGE_ENABLE
+  *    - POW_CONTROL_VOLTAGE_HW_CONTROLLED
+  *
+  * @par POW_CONTROL_VDDP_SIM2 - PMU regulator LSIM2
+  *   - VOLTAGE
+  *    - POW_CONTROL_VOLTAGE_1V20
+  *    - POW_CONTROL_VOLTAGE_1V8
+  *    - POW_CONTROL_VOLTAGE_2V91
+  *   - STATE
+  *    - POW_CONTROL_VOLTAGE_DISABLE
+  *    - POW_CONTROL_VOLTAGE_ENABLE
+  *    - POW_CONTROL_VOLTAGE_HW_CONTROLLED
+  *
+  * @par POW_CONTROL_VDD_PLL - PMU regulator LPLL
+  *   - VOLTAGE
+  *    - POW_CONTROL_VOLTAGE_1V00
+  *    - POW_CONTROL_VOLTAGE_1V10
+  *    - POW_CONTROL_VOLTAGE_1V20
+  *    - POW_CONTROL_VOLTAGE_1V25
+  *   - STATE
+  *    - POW_CONTROL_VOLTAGE_DISABLE
+  *    - POW_CONTROL_VOLTAGE_ENABLE
+  *    - POW_CONTROL_VOLTAGE_HW_CONTROLLED
+  *
+  * @par POW_CONTROL_VDD_CAM_PRIM_DIGITAL - PMU regulator NOTCFG
+  *   - VOLTAGE
+  *    - POW_CONTROL_VOLTAGE_ON
+  *   - STATE
+  *    - POW_CONTROL_VOLTAGE_DISABLE
+  *    - POW_CONTROL_VOLTAGE_ENABLE
+  *    - POW_CONTROL_VOLTAGE_HW_CONTROLLED
+  *
+  * @par POW_CONTROL_VDD_CAM_PRIM_ANALOG - PMU regulator LAUX1
+  *   - VOLTAGE
+  *    - POW_CONTROL_VOLTAGE_1V8
+  *    - POW_CONTROL_VOLTAGE_2V5
+  *    - POW_CONTROL_VOLTAGE_2V8
+  *    - POW_CONTROL_VOLTAGE_2V85
+  *   - STATE
+  *    - POW_CONTROL_VOLTAGE_DISABLE
+  *    - POW_CONTROL_VOLTAGE_ENABLE
+  *    - POW_CONTROL_VOLTAGE_HW_CONTROLLED
+  *
+  * @par POW_CONTROL_VDD_CAM_PRIM_IO - PMU regulator NOTCFG
+  *   - VOLTAGE
+  *    - POW_CONTROL_VOLTAGE_ON
+  *   - STATE
+  *    - POW_CONTROL_VOLTAGE_DISABLE
+  *    - POW_CONTROL_VOLTAGE_ENABLE
+  *    - POW_CONTROL_VOLTAGE_HW_CONTROLLED
+  *
+  * @par POW_CONTROL_VDD_CAM_PRIM_AF - PMU regulator NOTCFG
+  *   - VOLTAGE
+  *    - POW_CONTROL_VOLTAGE_ON
+  *   - STATE
+  *    - POW_CONTROL_VOLTAGE_DISABLE
+  *    - POW_CONTROL_VOLTAGE_ENABLE
+  *    - POW_CONTROL_VOLTAGE_HW_CONTROLLED
+  *
+  * @par POW_CONTROL_VDD_CAM_SEC_DIGITAL - PMU regulator NOTCFG
+  *   - VOLTAGE
+  *    - POW_CONTROL_VOLTAGE_ON
+  *   - STATE
+  *    - POW_CONTROL_VOLTAGE_DISABLE
+  *    - POW_CONTROL_VOLTAGE_ENABLE
+  *    - POW_CONTROL_VOLTAGE_HW_CONTROLLED
+  *
+  * @par POW_CONTROL_VDD_CAM_SEC_ANALOG - PMU regulator LAUX1
+  *   - VOLTAGE
+  *    - POW_CONTROL_VOLTAGE_1V8
+  *    - POW_CONTROL_VOLTAGE_2V5
+  *    - POW_CONTROL_VOLTAGE_2V8
+  *    - POW_CONTROL_VOLTAGE_2V85
+  *   - STATE
+  *    - POW_CONTROL_VOLTAGE_DISABLE
+  *    - POW_CONTROL_VOLTAGE_ENABLE
+  *    - POW_CONTROL_VOLTAGE_HW_CONTROLLED
+  *
+  * @par POW_CONTROL_VDD_CAM_SEC_IO - PMU regulator NOTCFG
+  *   - VOLTAGE
+  *    - POW_CONTROL_VOLTAGE_ON
+  *   - STATE
+  *    - POW_CONTROL_VOLTAGE_DISABLE
+  *    - POW_CONTROL_VOLTAGE_ENABLE
+  *    - POW_CONTROL_VOLTAGE_HW_CONTROLLED
+  *
+  * @par POW_CONTROL_VDD_CAM_SEC_AF - PMU regulator NOTCFG
+  *   - VOLTAGE
+  *    - POW_CONTROL_VOLTAGE_ON
+  *   - STATE
+  *    - POW_CONTROL_VOLTAGE_DISABLE
+  *    - POW_CONTROL_VOLTAGE_ENABLE
+  *    - POW_CONTROL_VOLTAGE_HW_CONTROLLED
+  *
+  * @par POW_CONTROL_VDD_PRIM_DISPLAY - PMU regulator LAUX2
+  *   - VOLTAGE
+  *    - POW_CONTROL_VOLTAGE_1V8
+  *    - POW_CONTROL_VOLTAGE_2V5
+  *    - POW_CONTROL_VOLTAGE_2V8
+  *    - POW_CONTROL_VOLTAGE_2V85
+  *   - STATE
+  *    - POW_CONTROL_VOLTAGE_DISABLE
+  *    - POW_CONTROL_VOLTAGE_ENABLE
+  *    - POW_CONTROL_VOLTAGE_HW_CONTROLLED
+  *
+  * @par POW_CONTROL_VDD_PRIM_DISP_BACKLIGHT - PMU regulator NOTCFG
+  *   - VOLTAGE
+  *    - POW_CONTROL_VOLTAGE_ON
+  *   - STATE
+  *    - POW_CONTROL_VOLTAGE_DISABLE
+  *    - POW_CONTROL_VOLTAGE_ENABLE
+  *    - POW_CONTROL_VOLTAGE_HW_CONTROLLED
+  *
+  * @par POW_CONTROL_VDD_TOUCHSCREEN - PMU regulator SD2
+  *   - VOLTAGE
+  *    - POW_CONTROL_VOLTAGE_ON
+  *   - STATE
+  *    - POW_CONTROL_VOLTAGE_DISABLE
+  *    - POW_CONTROL_VOLTAGE_ENABLE
+  *    - POW_CONTROL_VOLTAGE_HW_CONTROLLED
+  *
+  * @par POW_CONTROL_VDD_TOUCH_SENSOR - PMU regulator LAUX2
+  *   - VOLTAGE
+  *    - POW_CONTROL_VOLTAGE_1V8
+  *    - POW_CONTROL_VOLTAGE_2V5
+  *    - POW_CONTROL_VOLTAGE_2V8
+  *    - POW_CONTROL_VOLTAGE_2V85
+  *   - STATE
+  *    - POW_CONTROL_VOLTAGE_DISABLE
+  *    - POW_CONTROL_VOLTAGE_ENABLE
+  *    - POW_CONTROL_VOLTAGE_HW_CONTROLLED
+  *
+  * @par POW_CONTROL_VDD_PROXIMITY_SENSOR - PMU regulator LAUX2
+  *   - VOLTAGE
+  *    - POW_CONTROL_VOLTAGE_1V8
+  *    - POW_CONTROL_VOLTAGE_2V5
+  *    - POW_CONTROL_VOLTAGE_2V8
+  *    - POW_CONTROL_VOLTAGE_2V85
+  *   - STATE
+  *    - POW_CONTROL_VOLTAGE_DISABLE
+  *    - POW_CONTROL_VOLTAGE_ENABLE
+  *    - POW_CONTROL_VOLTAGE_HW_CONTROLLED
+  *
+  * @par POW_CONTROL_VDD_ACCELEROMETER - PMU regulator LAUX2
+  *   - VOLTAGE
+  *    - POW_CONTROL_VOLTAGE_1V8
+  *    - POW_CONTROL_VOLTAGE_2V5
+  *    - POW_CONTROL_VOLTAGE_2V8
+  *    - POW_CONTROL_VOLTAGE_2V85
+  *   - STATE
+  *    - POW_CONTROL_VOLTAGE_DISABLE
+  *    - POW_CONTROL_VOLTAGE_ENABLE
+  *    - POW_CONTROL_VOLTAGE_HW_CONTROLLED
+  *
+  * @par POW_CONTROL_VDD_MAGNETOMETER - PMU regulator LAUX2
+  *   - VOLTAGE
+  *    - POW_CONTROL_VOLTAGE_1V8
+  *    - POW_CONTROL_VOLTAGE_2V5
+  *    - POW_CONTROL_VOLTAGE_2V8
+  *    - POW_CONTROL_VOLTAGE_2V85
+  *   - STATE
+  *    - POW_CONTROL_VOLTAGE_DISABLE
+  *    - POW_CONTROL_VOLTAGE_ENABLE
+  *    - POW_CONTROL_VOLTAGE_HW_CONTROLLED
+  *
+  * @par POW_CONTROL_VDD_GYROSCOPE - PMU regulator LAUX2
+  *   - VOLTAGE
+  *    - POW_CONTROL_VOLTAGE_1V8
+  *    - POW_CONTROL_VOLTAGE_2V5
+  *    - POW_CONTROL_VOLTAGE_2V8
+  *    - POW_CONTROL_VOLTAGE_2V85
+  *   - STATE
+  *    - POW_CONTROL_VOLTAGE_DISABLE
+  *    - POW_CONTROL_VOLTAGE_ENABLE
+  *    - POW_CONTROL_VOLTAGE_HW_CONTROLLED
+  *
+  * @par POW_CONTROL_VDD_DIGRF1 - PMU regulator LMIPI
+  *   - VOLTAGE
+  *    - POW_CONTROL_VOLTAGE_1V00
+  *    - POW_CONTROL_VOLTAGE_1V10
+  *    - POW_CONTROL_VOLTAGE_1V17
+  *    - POW_CONTROL_VOLTAGE_1V20
+  *   - STATE
+  *    - POW_CONTROL_VOLTAGE_DISABLE
+  *    - POW_CONTROL_VOLTAGE_ENABLE
+  *    - POW_CONTROL_VOLTAGE_HW_CONTROLLED
+  *
+  * @par POW_CONTROL_VDD_EMIC_IO - PMU regulator LMEM
+  *   - VOLTAGE
+  *    - POW_CONTROL_VOLTAGE_1V02
+  *    - POW_CONTROL_VOLTAGE_1V12
+  *    - POW_CONTROL_VOLTAGE_1V226
+  *    - POW_CONTROL_VOLTAGE_1V25
+  *   - STATE
+  *    - POW_CONTROL_VOLTAGE_DISABLE
+  *    - POW_CONTROL_VOLTAGE_ENABLE
+  *    - POW_CONTROL_VOLTAGE_HW_CONTROLLED
+  *
+  * @par POW_CONTROL_VDD_EMIC_1V8_IO - PMU regulator SD2
+  *   - VOLTAGE
+  *    - POW_CONTROL_VOLTAGE_ON
+  *   - STATE
+  *    - POW_CONTROL_VOLTAGE_DISABLE
+  *    - POW_CONTROL_VOLTAGE_ENABLE
+  *    - POW_CONTROL_VOLTAGE_HW_CONTROLLED
+  *
+  * @par POW_CONTROL_VDD_EMIC_CORE - PMU regulator LAIF
+  *   - VOLTAGE
+  *    - POW_CONTROL_VOLTAGE_1V00
+  *    - POW_CONTROL_VOLTAGE_1V10
+  *    - POW_CONTROL_VOLTAGE_1V8
+  *    - POW_CONTROL_VOLTAGE_2V5
+  *   - STATE
+  *    - POW_CONTROL_VOLTAGE_DISABLE
+  *    - POW_CONTROL_VOLTAGE_ENABLE
+  *    - POW_CONTROL_VOLTAGE_HW_CONTROLLED
+  *
+  * @par POW_CONTROL_VDD_EMIC_DLL - PMU regulator LAIF
+  *   - VOLTAGE
+  *    - POW_CONTROL_VOLTAGE_1V00
+  *    - POW_CONTROL_VOLTAGE_1V10
+  *    - POW_CONTROL_VOLTAGE_1V8
+  *    - POW_CONTROL_VOLTAGE_2V5
+  *   - STATE
+  *    - POW_CONTROL_VOLTAGE_DISABLE
+  *    - POW_CONTROL_VOLTAGE_ENABLE
+  *    - POW_CONTROL_VOLTAGE_HW_CONTROLLED
+  *
+  * @par POW_CONTROL_VDD_IDI_RX - PMU regulator LAIF
+  *   - VOLTAGE
+  *    - POW_CONTROL_VOLTAGE_1V00
+  *    - POW_CONTROL_VOLTAGE_1V10
+  *    - POW_CONTROL_VOLTAGE_1V8
+  *    - POW_CONTROL_VOLTAGE_2V5
+  *   - STATE
+  *    - POW_CONTROL_VOLTAGE_DISABLE
+  *    - POW_CONTROL_VOLTAGE_ENABLE
+  *    - POW_CONTROL_VOLTAGE_HW_CONTROLLED
+  *
+  * @par POW_CONTROL_VDD_ABB_GNSS_TCXO_LDO - PMU regulator GNSS_TCXO_LDO
+  *   - VOLTAGE
+  *    - POW_CONTROL_VOLTAGE_ON
+  *   - STATE
+  *    - POW_CONTROL_VOLTAGE_DISABLE
+  *    - POW_CONTROL_VOLTAGE_ENABLE
+  *    - POW_CONTROL_VOLTAGE_HW_CONTROLLED
+  *
+*/
+// CODEGEN_END(POW_CONTROL_VOLTAGE_RELATED) end of automated generated source by tool, don't remove this line
+
+#if defined(__cplusplus)
+}   /* extern "C" */
+#endif
+
+#endif /* _POW_DRIVERIF_BOARD_H_ */
diff --git a/devices/pm/power_control/make/power_control.mk b/devices/pm/power_control/make/power_control.mk
index a84c153..65229ea 100644
--- a/devices/pm/power_control/make/power_control.mk
+++ b/devices/pm/power_control/make/power_control.mk
@@ -229,6 +229,9 @@ ifeq '$(findstring SF3GR_GARNET_EXTPMIC,${C_DEFINES})' 'SF3GR_GARNET_EXTPMIC'
     include $(POWDIR)/power_control/pmu/make/$(DEFAULTBOARDID)_ext_pmic/ext_pmic.mk
   endif
 endif
+ifeq '$(findstring SF3GX_EXTPMIC,${C_DEFINES})' 'SF3GX_EXTPMIC'
+include $(POWDIR)/power_control/pmu/make/$(BOARDID)_ext_pmic/ext_pmic.mk
+endif
 ###POW-------------------------------------------------------------------
 include $(POWDIR)/power_control/pow/make/pow.mk
 ifneq '$(wildcard $(POWDIR)/power_control/pow/make/$(BOARDID)/pow_board.mk)' ''
@@ -306,6 +309,10 @@ INCLUDEDIR += $(POWDIR)/power_control/pmu/src/$(DEFAULTBOARDID)_ext_pmic
 INCLUDEDIR += $(POWDIR)/power_control/pow/src/$(BOARDID)_ext_pmic
 INCLUDEDIR += $(POWDIR)/power_control/pow/src/$(DEFAULTBOARDID)_ext_pmic
 endif
+ifeq '$(findstring SF3GX_EXTPMIC,${C_DEFINES})' 'SF3GX_EXTPMIC'
+INCLUDEDIR += $(POWDIR)/power_control/pmu/src/$(BOARDID)_ext_pmic
+INCLUDEDIR += $(POWDIR)/power_control/pow/src/$(BOARDID)_ext_pmic
+endif
 INCLUDEDIR += $(RELEASEDIR)/inc/pal
 INCLUDEDIR += $(RELEASEDIR)/inc/guest
 INCLUDEDIR += $(RELEASEDIR)/inc
@@ -442,6 +449,10 @@ SOURCEDIR += $(POWDIR)/power_control/pmu/src/$(DEFAULTBOARDID)_ext_pmic
 SOURCEDIR += $(POWDIR)/power_control/pow/src/$(BOARDID)_ext_pmic
 SOURCEDIR += $(POWDIR)/power_control/pow/src/$(DEFAULTBOARDID)_ext_pmic
 endif
+ifeq '$(findstring SF3GX_EXTPMIC,${C_DEFINES})' 'SF3GX_EXTPMIC'
+SOURCEDIR += $(POWDIR)/power_control/pmu/src/$(BOARDID)_ext_pmic
+SOURCEDIR += $(POWDIR)/power_control/pow/src/$(BOARDID)_ext_pmic
+endif
 SOURCEDIR += $(POWDIR)
 SOURCEDIR += $(POWDIR)/power_control
 SOURCEDIR += $(POWDIR)/power_control/cgu/
diff --git a/devices/pm/power_control/pmu/make/board_sf_3gx b/devices/pm/power_control/pmu/make/board_sf_3gx
new file mode 120000
index 0000000..70c4b86
--- /dev/null
+++ b/devices/pm/power_control/pmu/make/board_sf_3gx
@@ -0,0 +1 @@
+board_sf_3gr
\ No newline at end of file
diff --git a/devices/pm/power_control/pmu/make/board_sf_3gx_ext_pmic/ext_pmic.mk b/devices/pm/power_control/pmu/make/board_sf_3gx_ext_pmic/ext_pmic.mk
new file mode 100644
index 0000000..e59194b
--- /dev/null
+++ b/devices/pm/power_control/pmu/make/board_sf_3gx_ext_pmic/ext_pmic.mk
@@ -0,0 +1,57 @@
+# ============================================================================
+# Copyright (C) 2013 Intel Mobile Communications GmbH
+#
+#      Sec Class: Intel Confidential (IC)
+#
+# =============================================================================
+#
+# This document contains proprietary information belonging to IMC.
+# Passing on and copying of this document, use and communication of
+# its contents is not permitted without prior written authorisation.
+#
+# =============================================================================
+#  Revision Information:
+#    $$File name:  /mhw_drv_src/power_control/pmu/make/pmu_int_agold620/pmu_pmucfg.mk $
+#
+# =============================================================================
+#  History :
+#
+#  Date        Author        Comment
+# -----------------------------------------------------------------------------
+#  2013-03-12  J.Dirksen     initial creation
+# =============================================================================
+
+
+# ------------- "C"-Defines ---------------------------------------------------
+#
+##   add manually
+## CC_DEFS  += ...
+#
+# ------------- "C" Sources ---------------------------------------------------
+#
+ifeq '$(findstring SF3GX_VCPU_I2C_CTRL,${C_DEFINES})' 'SF3GX_VCPU_I2C_CTRL'
+${BUILD_LIB}_FILES  += sy8827e.c
+endif
+#
+# ------------- Assembler Sources -----------------------------------------------
+#
+### actually no assembler source files for ${BUILD_LIB}_FILES +=
+#
+# ------------- Include Path -----------------------------------------------------
+#
+${BUILD_LIB}_INC    +=  ${MHW_DRV_SRC}/power_control/pmu/src/${PMU_CFG_FOLDER}
+
+#
+# PMU target test only
+#${BUILD_LIB}_INC    += $(MHW_DRV_SRC)/power_control/pmu/ttest/${PMU_CFG_FOLDER}
+#
+# ------------- Source Path ------------------------------------------------------
+#
+SRC_PATH            +=  ${MHW_DRV_SRC}/power_control/pmu/src/${PMU_CFG_FOLDER}
+
+#
+# PMU target test only
+#SRC_PATH            += $(MHW_DRV_SRC)/power_control/pmu/ttest/${PMU_CFG_FOLDER}
+#
+# ================================================================================
+#
diff --git a/devices/pm/power_control/pmu/src/board_sf_3gx b/devices/pm/power_control/pmu/src/board_sf_3gx
new file mode 120000
index 0000000..70c4b86
--- /dev/null
+++ b/devices/pm/power_control/pmu/src/board_sf_3gx
@@ -0,0 +1 @@
+board_sf_3gr
\ No newline at end of file
diff --git a/devices/pm/power_control/pow/make/board_sf_3gx b/devices/pm/power_control/pow/make/board_sf_3gx
new file mode 120000
index 0000000..70c4b86
--- /dev/null
+++ b/devices/pm/power_control/pow/make/board_sf_3gx
@@ -0,0 +1 @@
+board_sf_3gr
\ No newline at end of file
diff --git a/devices/pm/power_control/pow/src/board_sf_3gx b/devices/pm/power_control/pow/src/board_sf_3gx
new file mode 120000
index 0000000..70c4b86
--- /dev/null
+++ b/devices/pm/power_control/pow/src/board_sf_3gx
@@ -0,0 +1 @@
+board_sf_3gr
\ No newline at end of file
diff --git a/devices/pm/power_management/omp/make/board_sf_3gx b/devices/pm/power_management/omp/make/board_sf_3gx
new file mode 120000
index 0000000..70c4b86
--- /dev/null
+++ b/devices/pm/power_management/omp/make/board_sf_3gx
@@ -0,0 +1 @@
+board_sf_3gr
\ No newline at end of file
diff --git a/devices/pm/power_management/omp/src/board_sf_3gx b/devices/pm/power_management/omp/src/board_sf_3gx
new file mode 120000
index 0000000..70c4b86
--- /dev/null
+++ b/devices/pm/power_management/omp/src/board_sf_3gx
@@ -0,0 +1 @@
+board_sf_3gr
\ No newline at end of file
diff --git a/devices/pm/power_management/prh/make/board_sf_3gx b/devices/pm/power_management/prh/make/board_sf_3gx
new file mode 120000
index 0000000..70c4b86
--- /dev/null
+++ b/devices/pm/power_management/prh/make/board_sf_3gx
@@ -0,0 +1 @@
+board_sf_3gr
\ No newline at end of file
diff --git a/devices/pm/power_management/prh/src/board_sf_3gx/prh_cfg.c b/devices/pm/power_management/prh/src/board_sf_3gx/prh_cfg.c
new file mode 120000
index 0000000..56f9867
--- /dev/null
+++ b/devices/pm/power_management/prh/src/board_sf_3gx/prh_cfg.c
@@ -0,0 +1 @@
+../board_sf_3gr/prh_cfg.c
\ No newline at end of file
diff --git a/devices/pm/power_management/prh/src/board_sf_3gx/prh_cfg_at.c b/devices/pm/power_management/prh/src/board_sf_3gx/prh_cfg_at.c
new file mode 120000
index 0000000..4e0f9c8
--- /dev/null
+++ b/devices/pm/power_management/prh/src/board_sf_3gx/prh_cfg_at.c
@@ -0,0 +1 @@
+../board_sf_3gr/prh_cfg_at.c
\ No newline at end of file
diff --git a/devices/pm/power_management/prh/src/board_sf_3gx/prh_cfg_internal.h b/devices/pm/power_management/prh/src/board_sf_3gx/prh_cfg_internal.h
new file mode 120000
index 0000000..0c38c79
--- /dev/null
+++ b/devices/pm/power_management/prh/src/board_sf_3gx/prh_cfg_internal.h
@@ -0,0 +1 @@
+../board_sf_3gr/prh_cfg_internal.h
\ No newline at end of file
diff --git a/devices/pm/power_management/prh/src/board_sf_3gx/prh_cpu_drv_cfg.c b/devices/pm/power_management/prh/src/board_sf_3gx/prh_cpu_drv_cfg.c
new file mode 100644
index 0000000..032d93a
--- /dev/null
+++ b/devices/pm/power_management/prh/src/board_sf_3gx/prh_cpu_drv_cfg.c
@@ -0,0 +1,824 @@
+/*
+ *       Copyright (C) 2013 Intel Mobile Communications GmbH
+ *
+ *            Sec Class: Intel Confidential (IC)
+ *
+ *
+ * This document contains proprietary information belonging to IMC.
+ * Passing on and copying of this document, use and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * Description:
+ *   This file contains the CPU driver voltage handling part.
+ *
+ * Revision Information:
+ *  $File name:  /mhw_drv_src/power_management/prh/src/xgold632_agold620/prh_cpu_drv_cfg.c $
+ *   Comment:
+  *     Power Concept 4 implementation
+ * =============================================================================
+ * History:
+ *
+ * Date         Author       Comment
+ * -----------------------------------------------------------------------------
+ * 2012-06-06   A. Caruso    initial xmm632
+ * 2013-04-09   SaiManohar   Added Support for 754MHZ with FEAT_POW_CPU_FREQUENCY_754MHZ
+ * ===========================================================================*/
+
+/*---------------------------------------------------------------------------------------------------
+PRH_PER_ARM11_CLK peripheral     ENABLE_LOW   ENABLE_MED   ENABLE_HIGH   ENABLE_ULTRA HIGH   DISABLE
+power resources/modes
+-----------------------------------------------------------------------------------------------------
+
+Init mode:                       --           --           HIGH          --                  --
+ * ALIGN WITH CPU drv, prh_volf_cfg
+
+Clocks:
+#ifdef POWER_MANAGEMENT_PRH_754MHZ_SUPPORT
+POW_CONTROL_PS_CPU_KERNEL_CLK    208MHz        312MHz       754MHz        1024MHz       OFF
+#elif
+POW_CONTROL_PS_CPU_KERNEL_CLK    208MHz        312MHz       900MHz        1024MHz       OFF
+
+
+Core voltage:                    LOW           MED          HIGH          ULTRA_HIGH    LOW
+
+-----------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/* INCLUDES                                                                                                      */
+/*---------------------------------------------------------------------------------------------------------------*/
+#include <prh.h>
+#include <prh_internal.h>
+#include <prh_cfg_internal.h>
+#include <pow_driverif_chip.h>
+#include <prh_volt_cfg_internal.h>
+#include <scu.h>
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/* DEFINES                                                                                                       */
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/* Number of power logical modes */
+#define PRH_PER_CPU_CLK_NOF_MODES (U32)PRH_PER_ARM11_CLK_MODE_END - (U32)PRH_PER_ARM11_CLK_MODE_START
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/* TYPE DEFINITIONS                                                                                              */
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/* PRH_PER_ARM11_CLK peripheral                                                                                           */
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/* PRH_PER_ARM11_CLK peripheral power resources */
+
+typedef struct
+{
+  sPRH_PER_CLOCK_CFG_INFO_T  cpu_clk_312mhz;
+  sPRH_PER_CLOCK_CFG_INFO_T  cpu_clk_416mhz;
+  sPRH_PER_CLOCK_CFG_INFO_T  cpu_clk_728mhz;
+  sPRH_PER_CLOCK_CFG_INFO_T  cpu_clk_900mhz; 
+  sPRH_PER_CLOCK_CFG_INFO_T  cpu_clk_max_freq; 
+  ePRH_PER_VOLT_USER_ID_T    per_volt_id;
+}sPRH_PER_CPU_CLK_POW_RES_INFO_T;
+
+typedef struct
+{
+  sPRH_PER_VOLT_SET_INFO_T      vlow;  /**< voltage level */
+  sPRH_PER_VOLT_SET_INFO_T      vmhigh;
+  sPRH_PER_VOLT_SET_INFO_T      vhigh;
+  sPRH_PER_VOLT_SET_INFO_T      vuhigh;
+
+}sPRH_PER_CPU_VOLT_POW_RES_INFO_T;
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/* INTERNAL FUNCTION DECLARATIONS                                                                                */
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/* INTERNAL VARIABLE DEFINITIONS                                                                                 */
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/* PRH_PER_ARM11_CLK peripheral                                                                                           */
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/* PRH_PER_ARM11_CLK peripheral info mode */
+static sPRH_PER_ARM11_CLK_INFO_T prh_per_cpu_clk_mode =
+{
+  PRH_PER_ARM11_CLK_MODE_START,
+};
+
+/* PRH_PER_ARM11_CLK peripheral info configuration */
+static sPRH_PER_CFG_T prh_per_cpu_clk_cfg_info =
+{
+  (uPRH_PER_INFO_T *) &prh_per_cpu_clk_mode,
+  PRH_PER_UNLOCKED
+};
+
+/* PRH_PER_ARM11_CLK peripheral power resources configuration */
+static sPRH_PER_CPU_CLK_POW_RES_INFO_T  prh_per_cpu_clk_pow_res = 
+{
+  /* cpu_clk_312mhz  */ {POW_CONTROL_PS_CPU_KERNEL_CLK,  POW_CONTROL_FREQ_312M,  POW_CONTROL_FREQ_312M},
+  /* cpu_clk_416mhz  */ {POW_CONTROL_PS_CPU_KERNEL_CLK,  POW_CONTROL_FREQ_416M,  POW_CONTROL_FREQ_416M},
+  /* cpu_clk_728mhz  */ {POW_CONTROL_PS_CPU_KERNEL_CLK,  POW_CONTROL_FREQ_728M,  POW_CONTROL_FREQ_728M},
+  /* cpu_clk_900mhz  */ {POW_CONTROL_PS_CPU_KERNEL_CLK,  POW_CONTROL_FREQ_900M,  POW_CONTROL_FREQ_900M},
+  /* cpu_clk_1200mhz */ {POW_CONTROL_PS_CPU_KERNEL_CLK,  POW_CONTROL_FREQ_1200M, POW_CONTROL_FREQ_1200M},
+  /* per_volt_id     */ PRH_PER_VOLT_PS_CPU_CLK,
+};
+
+static sPRH_PER_CPU_VOLT_POW_RES_INFO_T prh_per_cpu_volt_pow_res =
+{
+  /* vlow, 416MHz */   {POW_CONTROL_VDD_VCPU,  POW_CONTROL_VOLTAGE_0V87},
+  /* vmhigh 750MHz */ {POW_CONTROL_VDD_VCPU,  POW_CONTROL_VOLTAGE_1V02},
+  /* vhigh 900MHz */  {POW_CONTROL_VDD_VCPU,  POW_CONTROL_VOLTAGE_1V14},
+  /* vuhigh 1060MHz */ {POW_CONTROL_VDD_VCPU,  POW_CONTROL_VOLTAGE_1V32},
+};
+
+
+#ifdef SF3GR_4_LEVEL_CPUFREQ
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/* Init power resources sequence */
+/* Internal state transition:
+ * - [S0] PRH_PER_ARM11_CLK_MODE_START --> [S4] PRH_PER_ARM11_CLK_ENABLE_HIGH_PERF
+ */
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_cpu_clk_init_seq[] =
+{
+  {PRH_PER_VOLT_HIGH_REQ_CMD,       (void *)&prh_per_cpu_clk_pow_res.per_volt_id},
+  {PRH_PER_VOLT_STAB_REQ_CMD,       NULL},
+  {PRH_PER_VOLT_ON_CMD,             (void *)&prh_per_cpu_volt_pow_res.vhigh},
+  {PRH_PER_CLK_CFG_CMD,             (void *)&prh_per_cpu_clk_pow_res.cpu_clk_900mhz},
+  {PRH_PER_CLK_ON_CMD,              (void *)&prh_per_cpu_clk_pow_res.cpu_clk_900mhz},
+  {PRH_PER_EMIF_LOW_POWER_OFF_CMD,    NULL},
+  {PRH_PER_END_CMD,                 NULL},
+};
+
+#if defined SF_R_ES_1_0
+
+/* Init power resources sequence */
+/* Internal state transition:
+ * - [S0] PRH_PER_ARM11_CLK_MODE_START --> [S2] PRH_PER_ARM11_CLK_ENABLE_MED_PERF
+ */
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_cpu_clk_s02_seq[] =
+{
+  {PRH_PER_VOLT_HIGH_REQ_CMD,       (void *)&prh_per_cpu_clk_pow_res.per_volt_id},
+  {PRH_PER_VOLT_STAB_REQ_CMD,       NULL},
+  {PRH_PER_CLK_CFG_CMD,			  (void *)&prh_per_cpu_clk_pow_res.cpu_clk_416mhz},
+  {PRH_PER_CLK_ON_CMD,			  (void *)&prh_per_cpu_clk_pow_res.cpu_clk_416mhz},
+  {PRH_PER_EMIF_LOW_POWER_ON_CMD,    NULL},
+  {PRH_PER_END_CMD,                 NULL},
+};
+
+#endif
+
+/* Init power resources sequence */
+/* Internal state transition:
+ * - [S0] PRH_PER_ARM11_CLK_MODE_START --> [S3] PRH_PER_ARM11_CLK_ENABLE_MED_HIGH_PERF
+ */
+
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_cpu_clk_s03_seq[] =
+{
+  {PRH_PER_VOLT_HIGH_REQ_CMD,       (void *)&prh_per_cpu_clk_pow_res.per_volt_id},
+  {PRH_PER_VOLT_STAB_REQ_CMD,       NULL},
+  {PRH_PER_VOLT_ON_CMD,             (void *)&prh_per_cpu_volt_pow_res.vmhigh},
+  {PRH_PER_CLK_CFG_CMD,             (void *)&prh_per_cpu_clk_pow_res.cpu_clk_728mhz},
+  {PRH_PER_CLK_ON_CMD,              (void *)&prh_per_cpu_clk_pow_res.cpu_clk_728mhz},
+  {PRH_PER_END_CMD,                 NULL},
+};
+
+/* Init power resources sequence */
+/* Internal state transition:
+ * - [S0] PRH_PER_ARM11_CLK_MODE_START --> [S5] PRH_PER_ARM11_CLK_ENABLE_ULTRA_HIGH_PERF
+ */
+
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_cpu_clk_s05_seq[] =
+{
+#if defined	(CPU_1040MHZ_VCORE_ULTRA_HIGH)
+  {PRH_PER_VOLT_ULTRA_HIGH_REQ_CMD,   (void *)&prh_per_cpu_clk_pow_res.per_volt_id},
+#else
+  {PRH_PER_VOLT_HIGH_REQ_CMD,   (void *)&prh_per_cpu_clk_pow_res.per_volt_id},
+#endif
+  {PRH_PER_VOLT_STAB_REQ_CMD,         NULL},
+  {PRH_PER_VOLT_ON_CMD,             (void *)&prh_per_cpu_volt_pow_res.vuhigh},
+  {PRH_PER_CLK_CFG_CMD,               (void *)&prh_per_cpu_clk_pow_res.cpu_clk_max_freq},
+  {PRH_PER_CLK_ON_CMD,               (void *)&prh_per_cpu_clk_pow_res.cpu_clk_max_freq},
+  {PRH_PER_END_CMD,                   NULL},
+};
+
+
+/* PRH_PER_ARM11_CLK peripheral power resources enable sequences */
+/* Internal state transition:
+ * - [S2] PRH_PER_ARM11_CLK_ENABLE_MED_PERF         --> [S1] PRH_PER_ARM11_CLK_ENABLE_LOW_PERF,
+ * - [S3] PRH_PER_ARM11_CLK_ENABLE_MED_HIGH_PERF    --> [S1] PRH_PER_ARM11_CLK_ENABLE_LOW_PERF,
+ * - [S4] PRH_PER_ARM11_CLK_ENABLE_HIGH_PERF        --> [S1] PRH_PER_ARM11_CLK_ENABLE_LOW_PERF,
+ * - [S5] PRH_PER_ARM11_CLK_ENABLE_ULTRA_HIGH_PERF  --> [S1] PRH_PER_ARM11_CLK_ENABLE_LOW_PERF,
+  */
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_cpu_clk_s21_seq[] =
+{
+
+  {PRH_PER_CLK_CFG_CMD,         (void *)&prh_per_cpu_clk_pow_res.cpu_clk_312mhz},
+  {PRH_PER_VOLT_LOW_REQ_CMD,    (void *)&prh_per_cpu_clk_pow_res.per_volt_id},
+  {PRH_PER_VOLT_ON_CMD,         (void *)&prh_per_cpu_volt_pow_res.vlow},
+  {PRH_PER_EMIF_LOW_POWER_ON_CMD,    NULL},
+  {PRH_PER_END_CMD,             NULL},
+};
+
+/* PRH_PER_ARM11_CLK peripheral power resources enable sequences */
+/* Internal state transition:
+ * - [S1] PRH_PER_ARM11_CLK_ENABLE_LOW_PERF   --> [S2] PRH_PER_ARM11_CLK_ENABLE_MED_PERF,
+  */
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_cpu_clk_s12_seq[] =
+{
+  {PRH_PER_VOLT_MED_REQ_CMD,    (void *)&prh_per_cpu_clk_pow_res.per_volt_id},
+  {PRH_PER_VOLT_STAB_REQ_CMD,   NULL},
+  {PRH_PER_CLK_CFG_CMD,         (void *)&prh_per_cpu_clk_pow_res.cpu_clk_416mhz},
+  {PRH_PER_END_CMD,             NULL},
+};
+
+/* PRH_PER_ARM11_CLK peripheral power resources enable sequences */
+/* Internal state transition:
+ * - [S1] PRH_PER_ARM11_CLK_ENABLE_LOW_PERF --> [S3] PRH_PER_ARM11_CLK_ENABLE_MED_HIGH_PERF
+ * - [S2] PRH_PER_ARM11_CLK_ENABLE_MED_PERF --> [S3] PRH_PER_ARM11_CLK_ENABLE_MED_HIGH_PERF
+ */
+
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_cpu_clk_s13_seq[] =
+{
+  {PRH_PER_VOLT_HIGH_REQ_CMD,       (void *)&prh_per_cpu_clk_pow_res.per_volt_id},
+  {PRH_PER_VOLT_STAB_REQ_CMD,       NULL},
+  {PRH_PER_VOLT_ON_CMD,             (void *)&prh_per_cpu_volt_pow_res.vmhigh},
+  {PRH_PER_CLK_CFG_CMD,             (void *)&prh_per_cpu_clk_pow_res.cpu_clk_728mhz},
+  {PRH_PER_EMIF_LOW_POWER_OFF_CMD,  NULL},
+  {PRH_PER_END_CMD,                 NULL},
+};
+
+/* PRH_PER_ARM11_CLK peripheral power resources enable sequences */
+/* Internal state transition:
+ * - [S3] PRH_PER_ARM11_CLK_ENABLE_MED_HIGH_PERF    --> [S2] PRH_PER_ARM11_CLK_ENABLE_MED_PERF,
+ * - [S4] PRH_PER_ARM11_CLK_ENABLE_HIGH_PERF        --> [S2] PRH_PER_ARM11_CLK_ENABLE_MED_PERF,
+ * - [S5] PRH_PER_ARM11_CLK_ENABLE_ULTRA_HIGH_PERF  --> [S2] PRH_PER_ARM11_CLK_ENABLE_MED_PERF,
+  */
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_cpu_clk_s32_seq[] =
+{
+
+
+  {PRH_PER_CLK_CFG_CMD,         (void *)&prh_per_cpu_clk_pow_res.cpu_clk_416mhz},
+  {PRH_PER_VOLT_ON_CMD,         (void *)&prh_per_cpu_volt_pow_res.vlow},
+  {PRH_PER_VOLT_MED_REQ_CMD,    (void *)&prh_per_cpu_clk_pow_res.per_volt_id},
+  {PRH_PER_EMIF_LOW_POWER_ON_CMD,    NULL},
+  {PRH_PER_END_CMD,             NULL},
+};
+
+/* PRH_PER_ARM11_CLK peripheral power resources enable sequences */
+/* Internal state transition:
+ * - [S3] PRH_PER_ARM11_CLK_ENABLE_MED_HIGH_PERF  --> [S4] PRH_PER_ARM11_CLK_ENABLE_HIGH_PERF,
+  */
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_cpu_clk_s34_seq[] =
+{
+  {PRH_PER_VOLT_ON_CMD,         (void *)&prh_per_cpu_volt_pow_res.vhigh},
+  {PRH_PER_CLK_CFG_CMD,         (void *)&prh_per_cpu_clk_pow_res.cpu_clk_900mhz},
+  {PRH_PER_END_CMD,             NULL},
+};
+
+/* PRH_PER_ARM11_CLK peripheral power resources enable sequences */
+/* Internal state transition:
+ * - [S4] PRH_PER_ARM11_CLK_ENABLE_HIGH_PERF  --> [S3] PRH_PER_ARM11_CLK_ENABLE_MED_HIGH_PERF,
+  */
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_cpu_clk_s43_seq[] =
+{
+  {PRH_PER_VOLT_ON_CMD,         (void *)&prh_per_cpu_volt_pow_res.vmhigh},
+  {PRH_PER_CLK_CFG_CMD,         (void *)&prh_per_cpu_clk_pow_res.cpu_clk_728mhz},
+  {PRH_PER_END_CMD,             NULL},
+};
+
+/* PRH_PER_ARM11_CLK peripheral power resources enable sequences */
+/* Internal state transition:
+ * - [S5] PRH_PER_ARM11_CLK_ENABLE_ULTRA_HIGH_PERF  --> [S3] PRH_PER_ARM11_CLK_ENABLE_MED_HIGH_PERF,
+  */
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_cpu_clk_s53_seq[] =
+{
+  {PRH_PER_CLK_CFG_CMD,         (void *)&prh_per_cpu_clk_pow_res.cpu_clk_728mhz},
+  {PRH_PER_VOLT_HIGH_REQ_CMD,    (void *)&prh_per_cpu_clk_pow_res.per_volt_id},
+  {PRH_PER_VOLT_ON_CMD,         (void *)&prh_per_cpu_volt_pow_res.vmhigh},
+  {PRH_PER_END_CMD,             NULL},
+};
+
+/* PRH_PER_ARM11_CLK peripheral power resources enable sequences */
+/* Internal state transition:
+ * - [S5] PRH_PER_ARM11_CLK_ENABLE_ULTRA_HIGH_PERF  --> [S4] PRH_PER_ARM11_CLK_ENABLE_HIGH_PERF,
+  */
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_cpu_clk_s54_seq[] =
+{
+  {PRH_PER_CLK_CFG_CMD,         (void *)&prh_per_cpu_clk_pow_res.cpu_clk_900mhz},
+  {PRH_PER_VOLT_HIGH_REQ_CMD,    (void *)&prh_per_cpu_clk_pow_res.per_volt_id},
+  {PRH_PER_VOLT_ON_CMD,         (void *)&prh_per_cpu_volt_pow_res.vhigh},
+  {PRH_PER_END_CMD,             NULL},
+};
+
+/* PRH_PER_ARM11_CLK peripheral power resources enable sequences */
+/* Internal state transition:
+ * - [S1] PRH_PER_ARM11_CLK_ENABLE_LOW_PERF  --> [S4] PRH_PER_ARM11_CLK_ENABLE_HIGH_PERF,
+ * - [S2] PRH_PER_ARM11_CLK_ENABLE_MED_PERF  --> [S4] PRH_PER_ARM11_CLK_ENABLE_HIGH_PERF,
+  */
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_cpu_clk_s14_seq[] =
+{
+  {PRH_PER_VOLT_HIGH_REQ_CMD,   (void *)&prh_per_cpu_clk_pow_res.per_volt_id},
+  {PRH_PER_VOLT_STAB_REQ_CMD,   NULL},
+  {PRH_PER_VOLT_ON_CMD,         (void *)&prh_per_cpu_volt_pow_res.vhigh},
+  {PRH_PER_CLK_CFG_CMD,         (void *)&prh_per_cpu_clk_pow_res.cpu_clk_900mhz},
+  {PRH_PER_EMIF_LOW_POWER_OFF_CMD,    NULL},
+  {PRH_PER_END_CMD,             NULL},
+};
+
+/* ARM11_CLK peripheral power resources enable sequences */
+/* Internal state transition:
+ * - [S1] PRH_PER_ARM11_CLK_ENABLE_LOW_PERF      --> [S5] PRH_PER_ARM11_CLK_ENABLE_ULTRA_HIGH_PERF,
+ * - [S2] PRH_PER_ARM11_CLK_ENABLE_MED_PERF      --> [S5] PRH_PER_ARM11_CLK_ENABLE_ULTRA_HIGH_PERF,
+ * - [S3] PRH_PER_ARM11_CLK_ENABLE_MED_HIGH_PERF --> [S5] PRH_PER_ARM11_CLK_ENABLE_ULTRA_HIGH_PERF,
+ * - [S4] PRH_PER_ARM11_CLK_ENABLE_HIGH_PERF     --> [S5] PRH_PER_ARM11_CLK_ENABLE_ULTRA_HIGH_PERF,
+ */
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_cpu_clk_s15_seq[] =
+{
+#if defined	(CPU_1040MHZ_VCORE_ULTRA_HIGH)
+  {PRH_PER_VOLT_ULTRA_HIGH_REQ_CMD, (void *)&prh_per_cpu_clk_pow_res.per_volt_id},
+#else
+  {PRH_PER_VOLT_HIGH_REQ_CMD,       (void *)&prh_per_cpu_clk_pow_res.per_volt_id},
+#endif
+  {PRH_PER_VOLT_STAB_REQ_CMD,         NULL},
+  {PRH_PER_VOLT_ON_CMD,             (void *)&prh_per_cpu_volt_pow_res.vuhigh},
+  {PRH_PER_CLK_CFG_CMD,               (void *)&prh_per_cpu_clk_pow_res.cpu_clk_max_freq},
+
+  {PRH_PER_END_CMD,                   NULL},
+};
+
+/* Dummy power resources sequences */
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_dummy_seq[] =
+{
+  {PRH_PER_END_CMD,     NULL},
+};
+
+/* The table maps the peripheral power resources sequences according to the current
+   power mode of the peripheral and the requested power mode of the user
+   [S0] PRH_PER_ARM11_CLK_MODE_START
+   [S1] PRH_PER_ARM11_CLK_ENABLE_LOW_PERF
+   [S2] PRH_PER_ARM11_CLK_ENABLE_MED_PERF
+   [S3] PRH_PER_ARM11_CLK_ENABLE_MED_HIGH_PERF
+   [S4] PRH_PER_ARM11_CLK_ENABLE_HIGH_PERF
+   [S5] PRH_PER_ARM11_CLK_ENABLE_ULTRA_HIGH_PERF
+*/
+static const sPRH_PER_GEN_SEQ_INFO_T * p_prh_per_cpu_clk_seq_table[PRH_PER_CPU_CLK_NOF_MODES][PRH_PER_CPU_CLK_NOF_MODES] =
+{
+                  /* next mode */
+/*current mode */ /* S0     S1                           S2                           S3                           S4                            S5                            */
+/* S0 */            {NULL,  NULL,                        &prh_per_cpu_clk_s02_seq[0], &prh_per_cpu_clk_s03_seq[0], &prh_per_cpu_clk_init_seq[0], &prh_per_cpu_clk_s05_seq[0],  },
+/* S1 */            {NULL,  &prh_per_dummy_seq[0],       &prh_per_cpu_clk_s12_seq[0], &prh_per_cpu_clk_s13_seq[0], &prh_per_cpu_clk_s14_seq[0],  &prh_per_cpu_clk_s15_seq[0],  },
+/* S2 */            {NULL,  &prh_per_cpu_clk_s21_seq[0], &prh_per_dummy_seq[0],       &prh_per_cpu_clk_s13_seq[0], &prh_per_cpu_clk_s14_seq[0],  &prh_per_cpu_clk_s15_seq[0],  },
+/* S3 */            {NULL,  &prh_per_cpu_clk_s21_seq[0], &prh_per_cpu_clk_s32_seq[0], &prh_per_dummy_seq[0],       &prh_per_cpu_clk_s34_seq[0],  &prh_per_cpu_clk_s15_seq[0],  },
+/* S4 */            {NULL,  &prh_per_cpu_clk_s21_seq[0], &prh_per_cpu_clk_s32_seq[0], &prh_per_cpu_clk_s43_seq[0], &prh_per_dummy_seq[0],        &prh_per_cpu_clk_s15_seq[0],  },
+/* S5 */            {NULL,  &prh_per_cpu_clk_s21_seq[0], &prh_per_cpu_clk_s32_seq[0], &prh_per_cpu_clk_s53_seq[0], &prh_per_cpu_clk_s54_seq[0],        &prh_per_dummy_seq[0],  },
+};
+#else
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/* Init power resources sequence */
+/* Internal state transition:
+ * - [S0] PRH_PER_ARM11_CLK_MODE_START --> [S3] PRH_PER_ARM11_CLK_ENABLE_HIGH_PERF
+ */
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_cpu_clk_init_seq[] =
+{
+  {PRH_PER_VOLT_HIGH_REQ_CMD,       (void *)&prh_per_cpu_clk_pow_res.per_volt_id},
+  {PRH_PER_VOLT_STAB_REQ_CMD,       NULL},
+  {PRH_PER_VOLT_ON_CMD,             (void *)&prh_per_cpu_volt_pow_res.vhigh},
+  {PRH_PER_CLK_CFG_CMD,             (void *)&prh_per_cpu_clk_pow_res.cpu_clk_900mhz},
+  {PRH_PER_CLK_ON_CMD,              (void *)&prh_per_cpu_clk_pow_res.cpu_clk_900mhz},
+  {PRH_PER_END_CMD,                 NULL},
+};
+
+#if defined SF_R_ES_1_0
+
+/* Init power resources sequence */
+/* Internal state transition:
+ * - [S0] PRH_PER_ARM11_CLK_MODE_START --> [S0] PRH_PER_ARM11_CLK_ENABLE_MED_PERF
+ */
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_cpu_clk_s02_seq[] =
+{
+  {PRH_PER_VOLT_HIGH_REQ_CMD,       (void *)&prh_per_cpu_clk_pow_res.per_volt_id},
+  {PRH_PER_VOLT_STAB_REQ_CMD,       NULL},
+  {PRH_PER_CLK_CFG_CMD,			  (void *)&prh_per_cpu_clk_pow_res.cpu_clk_416mhz},
+  {PRH_PER_CLK_ON_CMD,			  (void *)&prh_per_cpu_clk_pow_res.cpu_clk_416mhz},
+  {PRH_PER_END_CMD,                 NULL},
+};
+
+#endif
+
+/* Init power resources sequence */
+/* Internal state transition:
+ * - [S0] PRH_PER_ARM11_CLK_MODE_START --> [S4] PRH_PER_ARM11_CLK_ENABLE_ULTRA_HIGH_PERF
+ */
+
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_cpu_clk_s04_seq[] =
+{
+#if defined	(CPU_1040MHZ_VCORE_ULTRA_HIGH)
+  {PRH_PER_VOLT_ULTRA_HIGH_REQ_CMD,   (void *)&prh_per_cpu_clk_pow_res.per_volt_id},
+#else
+  {PRH_PER_VOLT_HIGH_REQ_CMD,   (void *)&prh_per_cpu_clk_pow_res.per_volt_id},
+#endif
+  {PRH_PER_VOLT_STAB_REQ_CMD,         NULL},
+  {PRH_PER_VOLT_ON_CMD,             (void *)&prh_per_cpu_volt_pow_res.vuhigh},
+  {PRH_PER_CLK_CFG_CMD,               (void *)&prh_per_cpu_clk_pow_res.cpu_clk_max_freq},
+  {PRH_PER_CLK_ON_CMD,               (void *)&prh_per_cpu_clk_pow_res.cpu_clk_max_freq},
+  {PRH_PER_END_CMD,                   NULL},
+};
+
+
+/* PRH_PER_ARM11_CLK peripheral power resources enable sequences */
+/* Internal state transition:
+ * - [S2] PRH_PER_ARM11_CLK_ENABLE_MED_PERF         --> [S1] PRH_PER_ARM11_CLK_ENABLE_LOW_PERF,
+ * - [S3] PRH_PER_ARM11_CLK_ENABLE_HIGH_PERF        --> [S1] PRH_PER_ARM11_CLK_ENABLE_LOW_PERF,
+ * - [S4] PRH_PER_ARM11_CLK_ENABLE_ULTRA_HIGH_PERF  --> [S1] PRH_PER_ARM11_CLK_ENABLE_LOW_PERF,
+  */
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_cpu_clk_s21_seq[] =
+{
+
+  {PRH_PER_CLK_CFG_CMD,         (void *)&prh_per_cpu_clk_pow_res.cpu_clk_312mhz},
+  {PRH_PER_VOLT_LOW_REQ_CMD,    (void *)&prh_per_cpu_clk_pow_res.per_volt_id},
+  {PRH_PER_VOLT_ON_CMD,         (void *)&prh_per_cpu_volt_pow_res.vlow},
+  {PRH_PER_END_CMD,             NULL},
+};
+
+/* PRH_PER_ARM11_CLK peripheral power resources enable sequences */
+/* Internal state transition:
+ * - [S1] PRH_PER_ARM11_CLK_ENABLE_LOW_PERF   --> [S2] PRH_PER_ARM11_CLK_ENABLE_MED_PERF,
+  */
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_cpu_clk_s12_seq[] =
+{
+  {PRH_PER_VOLT_MED_REQ_CMD,    (void *)&prh_per_cpu_clk_pow_res.per_volt_id},
+  {PRH_PER_VOLT_STAB_REQ_CMD,   NULL},
+
+  {PRH_PER_CLK_CFG_CMD,         (void *)&prh_per_cpu_clk_pow_res.cpu_clk_416mhz},
+
+  {PRH_PER_END_CMD,             NULL},
+};
+
+/* PRH_PER_ARM11_CLK peripheral power resources enable sequences */
+/* Internal state transition:
+ * - [S3] PRH_PER_ARM11_CLK_ENABLE_HIGH_PERF        --> [S2] PRH_PER_ARM11_CLK_ENABLE_MED_PERF,
+ * - [S4] PRH_PER_ARM11_CLK_ENABLE_ULTRA_HIGH_PERF  --> [S2] PRH_PER_ARM11_CLK_ENABLE_MED_PERF,
+  */
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_cpu_clk_s32_seq[] =
+{
+
+
+  {PRH_PER_CLK_CFG_CMD,         (void *)&prh_per_cpu_clk_pow_res.cpu_clk_416mhz},
+  {PRH_PER_VOLT_ON_CMD,         (void *)&prh_per_cpu_volt_pow_res.vlow},
+
+  {PRH_PER_VOLT_MED_REQ_CMD,    (void *)&prh_per_cpu_clk_pow_res.per_volt_id},
+  {PRH_PER_END_CMD,             NULL},
+};
+
+/* PRH_PER_ARM11_CLK peripheral power resources enable sequences */
+/* Internal state transition:
+ * - [S4] PRH_PER_ARM11_CLK_ENABLE_ULTRA_HIGH_PERF  --> [S3] PRH_PER_ARM11_CLK_ENABLE_HIGH_PERF,
+  */
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_cpu_clk_s43_seq[] =
+{
+  {PRH_PER_CLK_CFG_CMD,         (void *)&prh_per_cpu_clk_pow_res.cpu_clk_900mhz},
+
+
+  {PRH_PER_VOLT_HIGH_REQ_CMD,    (void *)&prh_per_cpu_clk_pow_res.per_volt_id},
+  {PRH_PER_VOLT_ON_CMD,         (void *)&prh_per_cpu_volt_pow_res.vhigh},
+
+  {PRH_PER_END_CMD,             NULL},
+};
+
+/* PRH_PER_ARM11_CLK peripheral power resources enable sequences */
+/* Internal state transition:
+ * - [S1] PRH_PER_ARM11_CLK_ENABLE_LOW_PERF  --> [S3] PRH_PER_ARM11_CLK_ENABLE_HIGH_PERF,
+ * - [S2] PRH_PER_ARM11_CLK_ENABLE_MED_PERF  --> [S3] PRH_PER_ARM11_CLK_ENABLE_HIGH_PERF,
+  */
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_cpu_clk_s13_seq[] =
+{
+  {PRH_PER_VOLT_HIGH_REQ_CMD,   (void *)&prh_per_cpu_clk_pow_res.per_volt_id},
+  {PRH_PER_VOLT_STAB_REQ_CMD,   NULL},
+  {PRH_PER_VOLT_ON_CMD,         (void *)&prh_per_cpu_volt_pow_res.vhigh},
+
+
+  {PRH_PER_CLK_CFG_CMD,         (void *)&prh_per_cpu_clk_pow_res.cpu_clk_900mhz},
+
+  {PRH_PER_END_CMD,             NULL},
+};
+
+/* ARM11_CLK peripheral power resources enable sequences */
+/* Internal state transition:
+ * - [S1] PRH_PER_ARM11_CLK_ENABLE_LOW_PERF  --> [S4] PRH_PER_ARM11_CLK_ENABLE_ULTRA_HIGH_PERF,
+ * - [S2] PRH_PER_ARM11_CLK_ENABLE_MED_PERF  --> [S4] PRH_PER_ARM11_CLK_ENABLE_ULTRA_HIGH_PERF,
+ * - [S3] PRH_PER_ARM11_CLK_ENABLE_HIGH_PERF --> [S4] PRH_PER_ARM11_CLK_ENABLE_ULTRA_HIGH_PERF,
+ */
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_cpu_clk_s14_seq[] =
+{
+#if defined	(CPU_1040MHZ_VCORE_ULTRA_HIGH)
+  {PRH_PER_VOLT_ULTRA_HIGH_REQ_CMD, (void *)&prh_per_cpu_clk_pow_res.per_volt_id},
+#else
+  {PRH_PER_VOLT_HIGH_REQ_CMD,       (void *)&prh_per_cpu_clk_pow_res.per_volt_id},
+#endif
+  {PRH_PER_VOLT_STAB_REQ_CMD,         NULL},
+  {PRH_PER_VOLT_ON_CMD,             (void *)&prh_per_cpu_volt_pow_res.vuhigh},
+  {PRH_PER_CLK_CFG_CMD,               (void *)&prh_per_cpu_clk_pow_res.cpu_clk_max_freq},
+
+  {PRH_PER_END_CMD,                   NULL},
+};
+/* ARM11_CLK peripheral power resources enable sequences */
+/* Internal state transition:
+ * - [S3] PRH_PER_ARM11_CLK_ENABLE_HIGH_PERF --> [S4] PRH_PER_ARM11_CLK_ENABLE_ULTRA_HIGH_PERF
+ */
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_cpu_clk_s34_seq[] =
+{
+#if defined	(CPU_1040MHZ_VCORE_ULTRA_HIGH)
+  {PRH_PER_VOLT_ULTRA_HIGH_REQ_CMD, (void *)&prh_per_cpu_clk_pow_res.per_volt_id},
+#else
+  {PRH_PER_VOLT_HIGH_REQ_CMD,       (void *)&prh_per_cpu_clk_pow_res.per_volt_id},
+#endif
+  {PRH_PER_VOLT_STAB_REQ_CMD,         NULL},
+  {PRH_PER_VOLT_ON_CMD,             (void *)&prh_per_cpu_volt_pow_res.vuhigh},
+  {PRH_PER_CLK_CFG_CMD,               (void *)&prh_per_cpu_clk_pow_res.cpu_clk_max_freq},
+  {PRH_PER_END_CMD,                   NULL},
+};
+
+/* Dummy power resources sequences */
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_dummy_seq[] =
+{
+  {PRH_PER_END_CMD,     NULL},
+};
+
+/* The table maps the peripheral power resources sequences according to the current
+   power mode of the peripheral and the requested power mode of the user
+   [S0] PRH_PER_ARM11_CLK_MODE_START
+   [S1] PRH_PER_ARM11_CLK_ENABLE_LOW_PERF
+   [S2] PRH_PER_ARM11_CLK_ENABLE_MED_PERF
+   [S3] PRH_PER_ARM11_CLK_ENABLE_HIGH_PERF
+   [S4] PRH_PER_ARM11_CLK_ENABLE_ULTRA_HIGH_PERF
+*/
+static const sPRH_PER_GEN_SEQ_INFO_T * p_prh_per_cpu_clk_seq_table[PRH_PER_CPU_CLK_NOF_MODES][PRH_PER_CPU_CLK_NOF_MODES] =
+{
+                  /* next mode */
+/*current mode */ /* S0     S1                           S2                           S3                            S4                            */
+/* S0 */            {NULL,  NULL,                        &prh_per_cpu_clk_s02_seq[0],   &prh_per_cpu_clk_init_seq[0], &prh_per_cpu_clk_s04_seq[0],                         },
+/* S1 */            {NULL,  &prh_per_dummy_seq[0],       &prh_per_cpu_clk_s12_seq[0], &prh_per_cpu_clk_s13_seq[0],  &prh_per_cpu_clk_s14_seq[0],  },
+/* S2 */            {NULL,  &prh_per_cpu_clk_s21_seq[0], &prh_per_dummy_seq[0],       &prh_per_cpu_clk_s13_seq[0],  &prh_per_cpu_clk_s14_seq[0],  },
+/* S3 */            {NULL,  &prh_per_cpu_clk_s21_seq[0], &prh_per_cpu_clk_s32_seq[0], &prh_per_dummy_seq[0],        &prh_per_cpu_clk_s34_seq[0],  },
+/* S4 */            {NULL,  &prh_per_cpu_clk_s21_seq[0], &prh_per_cpu_clk_s32_seq[0], &prh_per_cpu_clk_s43_seq[0],        &prh_per_dummy_seq[0],  },
+};
+#endif // #ifdef SF3GR_4_LEVEL_CPUFREQ
+/*---------------------------------------------------------------------------------------------------------------*/
+/* INTERNAL FUNCTION DECLARATIONS                                                                                */
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/* EXPORTED FUNCTIONS                                                                                            */
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/****************************************************************************************
+* Function:    prh_cpu_drv_get_init_per_mode_info
+* Parameters:  per_id - HW peripheral identifier
+*              p_per_mode_info - pointer to peripheral power mode info
+* Returns:     ePRH_RETURN_T - error or PRH_OK
+* Description: Used to get the PRH_PER_ARM11_CLK peripheral initial power mode settings
+*
+****************************************************************************************/
+ePRH_RETURN_T prh_cpu_drv_get_init_cpu_frequency_voltage_configuration(void)
+{
+  T_SCU_FEAT_CHIPREV chip_rev;
+
+  chip_rev = scu_feat_chipid_rev_get(SCU_FEAT_CHIPID_SF_3GR_SOC);
+
+  if (chip_rev == SCU_FEAT_CHIPREV_ES1)
+  {
+    prh_per_cpu_clk_pow_res.cpu_clk_max_freq.max_clk = POW_CONTROL_FREQ_1040M;
+    prh_per_cpu_clk_pow_res.cpu_clk_max_freq.min_clk = POW_CONTROL_FREQ_1040M;
+  }
+  else
+  { 
+  #if defined (CPU_MAX_FREQ_1160MHZ)
+    prh_per_cpu_clk_pow_res.cpu_clk_max_freq.max_clk = POW_CONTROL_FREQ_1160M;
+    prh_per_cpu_clk_pow_res.cpu_clk_max_freq.min_clk = POW_CONTROL_FREQ_1160M;
+  #else
+    prh_per_cpu_clk_pow_res.cpu_clk_max_freq.max_clk = POW_CONTROL_FREQ_1040M;
+    prh_per_cpu_clk_pow_res.cpu_clk_max_freq.min_clk = POW_CONTROL_FREQ_1040M;
+  #endif
+
+   prh_per_cpu_volt_pow_res.vlow.volt_level = POW_CONTROL_VOLTAGE_0V87;
+   prh_per_cpu_volt_pow_res.vmhigh.volt_level =  POW_CONTROL_VOLTAGE_1V02;
+   prh_per_cpu_volt_pow_res.vhigh.volt_level =  POW_CONTROL_VOLTAGE_1V14;  
+   prh_per_cpu_volt_pow_res.vuhigh.volt_level =  POW_CONTROL_VOLTAGE_1V32;
+  }
+
+  return PRH_OK; 
+}
+
+ePRH_RETURN_T prh_cpu_drv_get_init_per_mode_info (const ePRH_PER_ID_T per_id, sPRH_PER_MODE_INFO_T * p_per_mode_info)
+{
+  ePRH_RETURN_T ret_val = PRH_OK;
+
+  /* Check the peripheral identifier range */
+  if (PRH_PER_NOF_ID <= per_id)
+  {
+    ret_val = PRH_ERR_INV_PER_ID;
+  }
+  else if (NULL == p_per_mode_info)
+  {
+    ret_val = PRH_ERR_INV_POINTER;
+  }
+  else
+  {
+    switch (per_id)
+    {
+      case PRH_PER_ARM11_CLK:
+        p_per_mode_info->prh_per_type = PRH_PER_TYPE_ARM11_CLK;
+
+        p_per_mode_info->prh_per_info.prh_per_arm11_clk_info.arm11_clk_mode = PRH_PER_ARM11_CLK_ENABLE_HIGH_PERF;
+
+		break;
+
+      default:
+        ret_val = PRH_ERR_INV_PER_ID;
+        break;
+    }
+  }
+
+  if (ret_val == PRH_OK)
+  {
+    ret_val = prh_cpu_drv_get_init_cpu_frequency_voltage_configuration();
+  }
+
+  return ret_val;
+}
+
+/****************************************************************************************
+* Function:    prh_cpu_drv_check_per_mode_info
+* Parameters:  per_id - HW peripheral identifier
+*              p_per_mode_info - pointer to peripheral power mode info
+* Returns:     ePRH_RETURN_T - error or PRH_OK
+* Description: Used to check the PRH_PER_ARM11_CLK peripheral power mode settings range
+*
+****************************************************************************************/
+ePRH_RETURN_T prh_cpu_drv_check_per_mode_info(const ePRH_PER_ID_T per_id, const sPRH_PER_MODE_INFO_T * const p_per_mode_info)
+{
+  ePRH_RETURN_T ret_val = PRH_OK;
+
+  /* Check the peripheral identifier range */
+  if (PRH_PER_NOF_ID <= per_id)
+  {
+    ret_val = PRH_ERR_INV_PER_ID;
+  }
+  /* Check the pointer */
+  else if (NULL == p_per_mode_info)
+  {
+    ret_val = PRH_ERR_INV_POINTER;
+  }
+  else
+  {
+    switch (per_id)
+    {
+      case PRH_PER_ARM11_CLK:
+        if ((PRH_PER_ARM11_CLK_MODE_START >= p_per_mode_info->prh_per_info.prh_per_arm11_clk_info.arm11_clk_mode) &&
+            (PRH_PER_ARM11_CLK_MODE_END   <= p_per_mode_info->prh_per_info.prh_per_arm11_clk_info.arm11_clk_mode))
+        {
+          ret_val = PRH_ERR_INV_MODE_INFO;
+        }
+        break;
+
+      default:
+        ret_val = PRH_ERR_INV_PER_ID;
+        break;
+    }
+  }
+  return ret_val;
+}
+
+/****************************************************************************************
+* Function:    prh_cpu_drv_get_per_cfg_info
+* Parameters:  per_id - HW peripheral identifier
+*              p_cfg_info - pointer to power mode info
+* Returns:     ePRH_RETURN_T - error or PRH_OK
+* Description: Used to get the PRH_PER_ARM11_CLK power mode information
+*
+****************************************************************************************/
+ePRH_RETURN_T prh_cpu_drv_get_per_cfg_info(const ePRH_PER_ID_T per_id, sPRH_PER_CFG_T ** p_cfg_info)
+{
+  ePRH_RETURN_T ret_val = PRH_OK;
+
+  /* Check the peripheral identifier range */
+  if (PRH_PER_NOF_ID <= per_id)
+  {
+    ret_val = PRH_ERR_INV_PER_ID;
+  }
+  /* Check the pointer */
+  else if (NULL == p_cfg_info)
+  {
+    ret_val = PRH_ERR_INV_POINTER;
+  }
+  else
+  {
+    *p_cfg_info = NULL;
+    switch (per_id)
+    {
+      case PRH_PER_ARM11_CLK:
+        *p_cfg_info = &prh_per_cpu_clk_cfg_info;
+        break;
+
+      default:
+        ret_val = PRH_ERR_INV_PER_ID;
+        break;
+    }
+  }
+  return ret_val;
+}
+
+/****************************************************************************************
+* Function:    prh_cpu_drv_set_per_mode_info
+* Parameters:  per_id - HW peripheral identifier
+*              p_per_mode_info - power mode info requested from the user
+* Returns:     ePRH_RETURN_T - error or PRH_OK
+* Description: Used to update the PRH_PER_ARM11_CLK power mode information
+*
+****************************************************************************************/
+ePRH_RETURN_T prh_cpu_drv_set_per_mode_info(const ePRH_PER_ID_T per_id, const sPRH_PER_MODE_INFO_T * const p_per_mode_info)
+{
+  ePRH_RETURN_T ret_val = PRH_OK;
+
+  /* Check the peripheral identifier range */
+  if (PRH_PER_NOF_ID <= per_id)
+  {
+    ret_val = PRH_ERR_INV_PER_ID;
+  }
+  /* Check the pointer */
+  else if (NULL == p_per_mode_info)
+  {
+    ret_val = PRH_ERR_INV_POINTER;
+  }
+  else
+  {
+    switch (per_id)
+    {
+      case PRH_PER_ARM11_CLK:
+        prh_per_cpu_clk_mode.arm11_clk_mode = p_per_mode_info->prh_per_info.prh_per_arm11_clk_info.arm11_clk_mode;
+        break;
+
+      default:
+        ret_val = PRH_ERR_INV_PER_ID;
+        break;
+    }
+  }
+  return ret_val;
+}
+
+/****************************************************************************************
+* Function:    prh_cpu_drv_get_per_seq_info
+* Parameters:  per_id - HW peripheral identifier
+*              p_per_mode_info - power mode info requested from the user
+*              p_seq_info - pointer to the power resource setting/configuration sequence to be loaded
+* Returns:     ePRH_RETURN_T - error or PRH_OK
+* Description: Used to retrieve the power resource setting/configuration sequence depending on the
+*              power mode info requested from the user
+*
+****************************************************************************************/
+ePRH_RETURN_T prh_cpu_drv_get_per_seq_info(const ePRH_PER_ID_T per_id, const sPRH_PER_MODE_INFO_T *const p_per_mode_info, const sPRH_PER_GEN_SEQ_INFO_T ** p_seq_info)
+{
+  ePRH_RETURN_T ret_val = PRH_OK;
+
+  /* Check the peripheral identifier range */
+  if (PRH_PER_NOF_ID <= per_id)
+  {
+    ret_val = PRH_ERR_INV_PER_ID;
+  }
+  /* Check the pointer */
+  else if (NULL == p_per_mode_info)
+  {
+    ret_val = PRH_ERR_INV_POINTER;
+  }
+  /* Check the pointer */
+  else if (NULL == p_seq_info)
+  {
+    ret_val = PRH_ERR_INV_POINTER;
+  }
+  else
+  {
+    *p_seq_info = NULL;
+    switch (per_id)
+    {
+      case PRH_PER_ARM11_CLK:
+        {
+          /* retrieve the user requested power mode for PRH_PER_ARM11_CLK peripheral */
+          ePRH_PER_ARM11_CLK_MODE_T curr_mode = prh_per_cpu_clk_mode.arm11_clk_mode;
+          ePRH_PER_ARM11_CLK_MODE_T next_mode = p_per_mode_info->prh_per_info.prh_per_arm11_clk_info.arm11_clk_mode;
+          /* retrieve the pointer to power resources steps */
+          *p_seq_info = p_prh_per_cpu_clk_seq_table[(U32)curr_mode - (U32)PRH_PER_ARM11_CLK_MODE_START][(U32)next_mode - (U32)PRH_PER_ARM11_CLK_MODE_START];
+        }
+        break;
+
+      default:
+        ret_val = PRH_ERR_INV_PER_ID;
+        break;
+    }
+  }
+  return ret_val;
+}
+
diff --git a/devices/pm/power_management/prh/src/board_sf_3gx/prh_ext_accelerometer_drv_cfg.c b/devices/pm/power_management/prh/src/board_sf_3gx/prh_ext_accelerometer_drv_cfg.c
new file mode 120000
index 0000000..3afdb10
--- /dev/null
+++ b/devices/pm/power_management/prh/src/board_sf_3gx/prh_ext_accelerometer_drv_cfg.c
@@ -0,0 +1 @@
+../board_sf_3gr/prh_ext_accelerometer_drv_cfg.c
\ No newline at end of file
diff --git a/devices/pm/power_management/prh/src/board_sf_3gx/prh_ext_accelerometer_drv_cfg.h b/devices/pm/power_management/prh/src/board_sf_3gx/prh_ext_accelerometer_drv_cfg.h
new file mode 120000
index 0000000..26357ca
--- /dev/null
+++ b/devices/pm/power_management/prh/src/board_sf_3gx/prh_ext_accelerometer_drv_cfg.h
@@ -0,0 +1 @@
+../board_sf_3gr/prh_ext_accelerometer_drv_cfg.h
\ No newline at end of file
diff --git a/devices/pm/power_management/prh/src/board_sf_3gx/prh_ext_cam_drv_cfg.c b/devices/pm/power_management/prh/src/board_sf_3gx/prh_ext_cam_drv_cfg.c
new file mode 100644
index 0000000..56f0deb
--- /dev/null
+++ b/devices/pm/power_management/prh/src/board_sf_3gx/prh_ext_cam_drv_cfg.c
@@ -0,0 +1,503 @@
+/*
+ *       Copyright (C) 2013-2014 Intel Mobile Communications GmbH
+ *       
+ *            Sec Class: Intel Confidential (IC)
+ *       
+ *
+ * This document contains proprietary information belonging to IMC.
+ * Passing on and copying of this document, use and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * Description:
+ *   This file contains the handling of CIF peripheral
+ *
+ * Revision Information:
+ *  $File name:  /mhw_drv_src/power_management/prh/src/board_sf_3g/prh_ext_cam_drv_cfg.c $
+ *   Comment:
+ *     Power Concept 4 implementation 
+ * =============================================================================
+ * History:
+ *
+ * Date         Author       Comment
+ * -----------------------------------------------------------------------------
+ * 2012-06-06   A. Caruso    initial xmm6310
+ * 2013-01-21   Hua Lei      SMS03191527 - [CSI2UTA] PRH adaptations to support new UTA APIs
+ * 2013-03-07   Shivaprashanth SMS03913802 | xmm6321 - Configuration of VAUX1 voltage
+ * ========================================================================================*/
+
+/*-----------------------------------------------------------------------------
+EXT PRIMARY CAMERA peripheral     ENABLE                   DISABLE   
+power resources/modes                                                          
+-------------------------------------------------------------------------------
+
+Init mode:                         --                      DISABLE
+
+Clocks:
+POW_CONTROL_CAM_PRIM_CLK           26MHz                   OFF           
+
+Voltages:
+POW_CONTROL_VDD_CAM_PRIM_ANALOG,   1.8V                    OFF                       
+POW_CONTROL_VDD_CAM_PRIM_DIGITAL   --                      --
+POW_CONTROL_VDD_CAM_PRIM_IO,       --                      --
+POW_CONTROL_VDD_CAM_PRIM_AF,       --                      --
+
+-------------------------------------------------------------------------------*/
+
+/*-----------------------------------------------------------------------------
+EXT SECONDARY CAMERA peripheral    ENABLE                   DISABLE   
+power resources/modes                                                          
+-------------------------------------------------------------------------------
+
+Init mode:                         --                       DISABLE
+
+Clocks:
+POW_CONTROL_SEC_PRIM_CLK          26MHz                     OFF           
+
+Voltages:
+POW_CONTROL_VDD_CAM_SEC_ANALOG,   1.8V                      --
+POW_CONTROL_VDD_CAM_SEC_DIGITAL,  --                        --
+POW_CONTROL_VDD_CAM_SEC_IO,       --                        --                      
+POW_CONTROL_VDD_CAM_SEC_AF,       --                        --                      
+
+-------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/* INCLUDES                                                                                                      */
+/*---------------------------------------------------------------------------------------------------------------*/
+#include "prh.h"
+#include "prh_internal.h"
+#include "prh_cfg_internal.h"
+#include "pow_driverif_chip.h"
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/* DEFINES                                                                                                       */
+/*---------------------------------------------------------------------------------------------------------------*/
+#define PRH_PER_SUB_CAMERA_DELAY_1 (1)
+#define PRH_PER_SUB_CAMERA_DELAY_2 (1)
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/* TYPE DEFINITIONS                                                                                              */
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/* External Camera peripheral power resources */
+typedef struct 
+{
+  sPRH_PER_CLOCK_CFG_INFO_T clk;
+  sPRH_PER_VOLT_SET_INFO_T  io_volt;
+  sPRH_PER_VOLT_SET_INFO_T  ana;
+  POW_CONTROL_ID_T          psv;
+  U32                       delay_1;
+  U32                       delay_2;
+}sPRH_PER_EXT_CAMERA_POW_RES_INFO_T;
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/* INTERNAL FUNCTION DECLARATIONS                                                                                */
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/* INTERNAL VARIABLE DEFINITIONS                                                                                 */
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/* EXT_PRIMARY_CAMERA peripheral info mode */
+static sPRH_PER_GENERIC_INFO_T prh_per_ext_prim_camera_mode =
+{
+  PRH_PER_GENERIC_MODE_START
+};
+
+/* EXT_PRIMARY_CAMERA peripheral info configuration */
+static sPRH_PER_CFG_T prh_per_ext_prim_camera_cfg_info =
+{
+  (uPRH_PER_INFO_T *) &prh_per_ext_prim_camera_mode,
+  PRH_PER_UNLOCKED
+};
+
+/* EXT_PRIMARY_CAMERA peripheral power resources configuration */
+static const sPRH_PER_EXT_CAMERA_POW_RES_INFO_T  prh_per_ext_prim_camera_pow_res = 
+{
+  /* clk   */ {POW_CONTROL_CAM_PRIM_CLK,         POW_CONTROL_FREQ_26M,   POW_CONTROL_FREQ_DONT_CARE},
+  /* io_volt */ {POW_CONTROL_VDD_CAM_PRIM_IO,  POW_CONTROL_VOLTAGE_2V85},
+  /* ana   */ {POW_CONTROL_VDD_CAM_PRIM_ANALOG,  POW_CONTROL_VOLTAGE_1V8},
+  /* psv   */ POW_CONTROL_CAM_PRIM_ID,
+  /* delay_1*/ NULL,
+  /* delay_2*/ NULL,
+};
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/* Init power resources sequence */
+/* Internal state transition:
+ * - [S0] PRH_PER_GENERIC_MODE_START --> [S1] PRH_PER_GENERIC_DISABLE
+ */
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_ext_prim_camera_init_seq[] =
+{
+  {PRH_PER_CLK_CFG_CMD,    (void *)&prh_per_ext_prim_camera_pow_res.clk},
+  {PRH_PER_VOLT_OFF_CMD,   (void *)&prh_per_ext_prim_camera_pow_res.ana},
+  {PRH_PER_VOLT_OFF_CMD,   (void *)&prh_per_ext_prim_camera_pow_res.io_volt},
+  {PRH_PER_END_CMD,        NULL},
+};
+
+/* Enable power resources sequence */
+/* Internal state transition:
+ * - [S1] PRH_PER_GENERIC_DISABLE --> [S2] PRH_PER_GENERIC_ENABLE
+ */
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_ext_prim_camera_en_seq[] =
+{
+  {PRH_PER_PSV_OFF_CMD,   (void *)&prh_per_ext_prim_camera_pow_res.psv},
+  {PRH_PER_VOLT_ON_CMD,   (void *)&prh_per_ext_prim_camera_pow_res.io_volt},  	
+  {PRH_PER_VOLT_ON_CMD,   (void *)&prh_per_ext_prim_camera_pow_res.ana},
+  {PRH_PER_CLK_ON_CMD,    (void *)&prh_per_ext_prim_camera_pow_res.clk},
+  {PRH_PER_END_CMD,        NULL},
+};
+
+/* Disable power resources sequence */
+/* Internal state transition:
+ * - [S2] PRH_PER_GENERIC_ENABLE --> [S1] PRH_PER_GENERIC_DISABLE
+ */
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_ext_prim_camera_dis_seq[] =
+{
+  {PRH_PER_CLK_OFF_CMD,    (void *)&prh_per_ext_prim_camera_pow_res.clk},
+  {PRH_PER_VOLT_OFF_CMD,   (void *)&prh_per_ext_prim_camera_pow_res.ana},
+  {PRH_PER_VOLT_OFF_CMD,   (void *)&prh_per_ext_prim_camera_pow_res.io_volt},
+  {PRH_PER_PSV_ON_CMD,     (void *)&prh_per_ext_prim_camera_pow_res.psv},
+  {PRH_PER_END_CMD,        NULL},
+};
+
+/* Dummy power resources sequences */
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_dummy_seq[] =
+{
+  {PRH_PER_END_CMD,        NULL},
+};
+
+/* The table maps the peripheral power resources sequences according to the current 
+   power mode of the peripheral and the requested power mode of the user
+   [S0] PRH_PER_GENERIC_MODE_START
+   [S1] PRH_PER_GENERIC_DISABLE
+   [S2] PRH_PER_GENERIC_ENABLE*/
+
+static const sPRH_PER_GEN_SEQ_INFO_T * p_prh_per_ext_prim_camera_seq_table[PRH_PER_GENERIC_MODE_END][PRH_PER_GENERIC_MODE_END] =
+{ 
+                  /* next mode */
+/*current mode */ /* S0     S1                                    S2                             */
+/* S0 */            {NULL,  &prh_per_ext_prim_camera_init_seq[0], NULL                           },
+/* S1 */            {NULL,  &prh_per_dummy_seq[0],                &prh_per_ext_prim_camera_en_seq[0] },
+/* S2 */            {NULL,  &prh_per_ext_prim_camera_dis_seq[0],  &prh_per_dummy_seq[0]          },
+};
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/* EXT_SECONDARY_CAMERA peripheral info mode */
+static sPRH_PER_GENERIC_INFO_T prh_per_ext_sec_camera_mode =
+{
+  PRH_PER_GENERIC_MODE_START
+};
+
+/* EXT_SECONDARY_CAMERA peripheral info configuration */
+static sPRH_PER_CFG_T prh_per_ext_sec_camera_cfg_info =
+{
+  (uPRH_PER_INFO_T *) &prh_per_ext_sec_camera_mode,
+  PRH_PER_UNLOCKED
+};
+
+/* EXT_SECONDARY_CAMERA peripheral power resources configuration */
+static const sPRH_PER_EXT_CAMERA_POW_RES_INFO_T  prh_per_ext_sec_camera_pow_res = 
+{
+  /* clk  */ {POW_CONTROL_CAM_SEC_CLK,     POW_CONTROL_FREQ_26M,   POW_CONTROL_FREQ_DONT_CARE},
+  /* io_volt */ {POW_CONTROL_VDD_CAM_SEC_IO,  POW_CONTROL_VOLTAGE_2V85},
+  /* ana  */ {POW_CONTROL_VDD_CAM_SEC_ANALOG,  POW_CONTROL_VOLTAGE_1V8},
+  /* psv  */ POW_CONTROL_CAM_SEC_ID,
+};
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/* Init power resources sequence */
+/* Internal state transition:
+ * - [S0] PRH_PER_GENERIC_MODE_START --> [S1] PRH_PER_GENERIC_DISABLE
+ */
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_ext_sec_camera_init_seq[] =
+{
+  {PRH_PER_CLK_CFG_CMD,    (void *)&prh_per_ext_sec_camera_pow_res.clk},
+  {PRH_PER_VOLT_OFF_CMD,   (void *)&prh_per_ext_sec_camera_pow_res.ana},
+  {PRH_PER_VOLT_OFF_CMD,   (void *)&prh_per_ext_sec_camera_pow_res.io_volt},  
+  {PRH_PER_END_CMD,        NULL},
+};
+
+/* Enable power resources sequence */
+/* Internal state transition:
+ * - [S1] PRH_PER_GENERIC_DISABLE --> [S2] PRH_PER_GENERIC_ENABLE
+ */
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_ext_sec_camera_en_seq[] =
+{
+  {PRH_PER_PSV_OFF_CMD,   (void *)&prh_per_ext_sec_camera_pow_res.psv},
+  {PRH_PER_VOLT_ON_CMD,   (void *)&prh_per_ext_sec_camera_pow_res.ana},
+  {PRH_PER_WAIT_CMD,      (void *)&prh_per_ext_sec_camera_pow_res.delay_2},
+  {PRH_PER_VOLT_ON_CMD,   (void *)&prh_per_ext_sec_camera_pow_res.io_volt},
+  {PRH_PER_WAIT_CMD,      (void *)&prh_per_ext_sec_camera_pow_res.delay_2},
+  {PRH_PER_CLK_ON_CMD,    (void *)&prh_per_ext_sec_camera_pow_res.clk},
+  {PRH_PER_END_CMD,       NULL},
+};
+
+/* Disable power resources sequence */
+/* Internal state transition:
+ * - [S2] PRH_PER_GENERIC_ENABLE --> [S1] PRH_PER_GENERIC_DISABLE
+ */
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_ext_sec_camera_dis_seq[] =
+{
+  {PRH_PER_CLK_OFF_CMD,    (void *)&prh_per_ext_sec_camera_pow_res.clk},
+  {PRH_PER_WAIT_CMD,       (void *)&prh_per_ext_sec_camera_pow_res.delay_2},
+  {PRH_PER_VOLT_OFF_CMD,   (void *)&prh_per_ext_sec_camera_pow_res.io_volt},
+  {PRH_PER_WAIT_CMD,       (void *)&prh_per_ext_sec_camera_pow_res.delay_2},
+  {PRH_PER_VOLT_OFF_CMD,   (void *)&prh_per_ext_sec_camera_pow_res.ana},
+  {PRH_PER_PSV_ON_CMD,     (void *)&prh_per_ext_sec_camera_pow_res.psv},
+  {PRH_PER_END_CMD,        NULL},
+};
+
+/* The table maps the peripheral power resources sequences according to the current 
+   power mode of the peripheral and the requested power mode of the user
+   [S0] PRH_PER_GENERIC_MODE_START
+   [S1] PRH_PER_GENERIC_DISABLE
+   [S2] PRH_PER_GENERIC_ENABLE
+*/
+static const sPRH_PER_GEN_SEQ_INFO_T * p_prh_per_ext_sec_camera_seq_table[PRH_PER_GENERIC_MODE_END][PRH_PER_GENERIC_MODE_END] =
+{ 
+                  /* next mode */
+/*current mode */ /* S0     S1                                   S2                                */
+/* S0 */            {NULL,  &prh_per_ext_sec_camera_init_seq[0], NULL                              },
+/* S1 */            {NULL,  &prh_per_dummy_seq[0],               &prh_per_ext_sec_camera_en_seq[0] },
+/* S2 */            {NULL,  &prh_per_ext_sec_camera_dis_seq[0],  &prh_per_dummy_seq[0]             },
+};
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/* INTERNAL FUNCTION DECLARATIONS                                                                                */
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/* EXPORTED FUNCTIONS                                                                                            */
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/****************************************************************************************
+* Function:    prh_ext_cam_drv_get_init_per_mode_info
+* Parameters:  per_id - HW peripheral identifier
+*              p_per_mode_info - pointer to peripheral power mode info
+* Returns:     ePRH_RETURN_T - error or PRH_OK
+* Description: Used to get the CIF peripheral initial power mode settings
+*
+****************************************************************************************/
+ePRH_RETURN_T prh_ext_cam_drv_get_init_per_mode_info (const ePRH_PER_ID_T per_id, sPRH_PER_MODE_INFO_T * p_per_mode_info)
+{
+  ePRH_RETURN_T ret_val = PRH_OK;
+
+  /* Check the peripheral identifier range */
+  if (PRH_PER_NOF_ID <= per_id)
+  {
+    ret_val = PRH_ERR_INV_PER_ID;
+  }
+  else if (NULL == p_per_mode_info)
+  {
+    ret_val = PRH_ERR_INV_POINTER;
+  }
+  else
+  {
+    switch (per_id)
+    {
+      case PRH_PER_EXT_PRIM_CAM:
+      case PRH_PER_EXT_SEC_CAM:
+          p_per_mode_info->prh_per_type = PRH_PER_TYPE_GENERIC;
+          p_per_mode_info->prh_per_info.prh_per_generic_info.generic_mode = PRH_PER_GENERIC_DISABLE;
+          break;
+
+      default:
+        ret_val = PRH_ERR_INV_PER_ID;
+        break;
+    }
+  }
+  return ret_val;
+}
+
+/****************************************************************************************
+* Function:    prh_ext_cam_drv_check_per_mode_info
+* Parameters:  per_id - HW peripheral identifier
+*              p_per_mode_info - pointer to peripheral power mode info
+* Returns:     ePRH_RETURN_T - error or PRH_OK
+* Description: Used to check the CIF peripheral power mode settings range
+*
+****************************************************************************************/
+ePRH_RETURN_T prh_ext_cam_drv_check_per_mode_info(const ePRH_PER_ID_T per_id, const sPRH_PER_MODE_INFO_T * const p_per_mode_info)
+{
+  ePRH_RETURN_T ret_val = PRH_OK;
+
+  /* Check the peripheral identifier range */
+  if (PRH_PER_NOF_ID <= per_id)
+  {
+    ret_val = PRH_ERR_INV_PER_ID;
+  }
+  /* Check the pointer */
+  else if (NULL == p_per_mode_info)
+  {
+    ret_val = PRH_ERR_INV_POINTER;
+  }
+  else
+  {
+    switch (per_id)
+    {
+       case PRH_PER_EXT_PRIM_CAM:
+       case PRH_PER_EXT_SEC_CAM:
+         if ((PRH_PER_GENERIC_MODE_START >= p_per_mode_info->prh_per_info.prh_per_generic_info.generic_mode) ||
+             (PRH_PER_GENERIC_MODE_END   <= p_per_mode_info->prh_per_info.prh_per_generic_info.generic_mode))
+         {
+            ret_val = PRH_ERR_INV_MODE_INFO;
+         }
+          break;
+
+          default:
+              ret_val = PRH_ERR_INV_PER_ID;
+          break;
+    }
+  }
+  return ret_val;
+}
+
+/****************************************************************************************
+* Function:    prh_ext_cam_drv_get_per_cfg_info
+* Parameters:  per_id - HW peripheral identifier
+*              p_cfg_info - pointer to power mode info 
+* Returns:     ePRH_RETURN_T - error or PRH_OK     
+* Description: Used to get the CIF power mode information
+*
+****************************************************************************************/
+ePRH_RETURN_T prh_ext_cam_drv_get_per_cfg_info(const ePRH_PER_ID_T per_id, sPRH_PER_CFG_T ** p_cfg_info)
+{
+  ePRH_RETURN_T ret_val = PRH_OK; 
+  
+  /* Check the peripheral identifier range */
+  if (PRH_PER_NOF_ID <= per_id)
+  {
+    ret_val = PRH_ERR_INV_PER_ID;
+  }
+  /* Check the pointer */
+  else if (NULL == p_cfg_info)
+  {
+    ret_val = PRH_ERR_INV_POINTER;
+  }
+  else
+  {
+    *p_cfg_info = NULL;
+    switch (per_id)
+    {
+      case PRH_PER_EXT_PRIM_CAM:
+        *p_cfg_info = &prh_per_ext_prim_camera_cfg_info;
+        break;
+
+      case PRH_PER_EXT_SEC_CAM:
+        *p_cfg_info = &prh_per_ext_sec_camera_cfg_info;
+        break;
+        
+      default:
+        ret_val = PRH_ERR_INV_PER_ID;
+        break;
+    }
+  }
+  return ret_val;
+}
+
+/****************************************************************************************
+* Function:    prh_ext_cam_drv_set_per_mode_info
+* Parameters:  per_id - HW peripheral identifier
+*              p_per_mode_info - power mode info requested from the user 
+* Returns:     ePRH_RETURN_T - error or PRH_OK     
+* Description: Used to update the CIF power mode information
+*
+****************************************************************************************/
+ePRH_RETURN_T prh_ext_cam_drv_set_per_mode_info(const ePRH_PER_ID_T per_id, const sPRH_PER_MODE_INFO_T * const p_per_mode_info)
+{
+  ePRH_RETURN_T ret_val = PRH_OK; 
+  
+  /* Check the peripheral identifier range */
+  if (PRH_PER_NOF_ID <= per_id)
+  {
+    ret_val = PRH_ERR_INV_PER_ID;
+  }
+  /* Check the pointer */
+  else if (NULL == p_per_mode_info)
+  {
+    ret_val = PRH_ERR_INV_POINTER;
+  }
+  else
+  {
+    switch (per_id)
+    {
+      case PRH_PER_EXT_PRIM_CAM:
+          prh_per_ext_prim_camera_mode.generic_mode = p_per_mode_info->prh_per_info.prh_per_generic_info.generic_mode;
+          break;
+        
+      case PRH_PER_EXT_SEC_CAM:
+          prh_per_ext_sec_camera_mode.generic_mode = p_per_mode_info->prh_per_info.prh_per_generic_info.generic_mode;
+          break;
+        
+      default:
+        ret_val = PRH_ERR_INV_PER_ID;
+        break;
+    }
+  }
+  return ret_val;
+}
+
+/****************************************************************************************
+* Function:    prh_ext_cam_drv_get_per_seq_info
+* Parameters:  per_id - HW peripheral identifier
+*              p_per_mode_info - power mode info requested from the user
+*              p_seq_info - pointer to the power resource setting/configuration sequence to be loaded
+* Returns:     ePRH_RETURN_T - error or PRH_OK   
+* Description: Used to retrieve the power resource setting/configuration sequence depending on the 
+*              power mode info requested from the user
+*
+****************************************************************************************/
+ePRH_RETURN_T prh_ext_cam_drv_get_per_seq_info(const ePRH_PER_ID_T per_id, const sPRH_PER_MODE_INFO_T *const p_per_mode_info, const sPRH_PER_GEN_SEQ_INFO_T ** p_seq_info)
+{
+  ePRH_RETURN_T ret_val = PRH_OK; 
+
+  /* Check the peripheral identifier range */
+  if (PRH_PER_NOF_ID <= per_id)
+  {
+    ret_val = PRH_ERR_INV_PER_ID;
+  }
+  /* Check the pointer */
+  else if (NULL == p_per_mode_info)
+  {
+    ret_val = PRH_ERR_INV_POINTER;
+  }
+  /* Check the pointer */
+  else if (NULL == p_seq_info)
+  {
+    ret_val = PRH_ERR_INV_POINTER;
+  }
+  else
+  {
+    *p_seq_info = NULL;  
+    switch (per_id)
+    {
+      case PRH_PER_EXT_PRIM_CAM:
+        {
+          /* retrieve the user requested power mode for CIF peripheral */
+          ePRH_PER_GENERIC_MODE_T next_mode = p_per_mode_info->prh_per_info.prh_per_generic_info.generic_mode;
+          /* retrieve the power resources setting table */
+          *p_seq_info = p_prh_per_ext_prim_camera_seq_table[prh_per_ext_prim_camera_mode.generic_mode][next_mode];
+        }   
+          break;
+        
+      case PRH_PER_EXT_SEC_CAM:
+        {
+          /* retrieve the user requested power mode for CIF peripheral */
+          ePRH_PER_GENERIC_MODE_T next_mode = p_per_mode_info->prh_per_info.prh_per_generic_info.generic_mode;
+          /* retrieve the power resources setting table */
+          *p_seq_info = p_prh_per_ext_sec_camera_seq_table[prh_per_ext_sec_camera_mode.generic_mode][next_mode];
+        }   
+          break;
+        
+        default:
+          ret_val = PRH_ERR_INV_PER_ID;
+          break;
+    }
+  }
+  return ret_val;
+}
+
+
diff --git a/devices/pm/power_management/prh/src/board_sf_3gx/prh_ext_cam_drv_cfg.h b/devices/pm/power_management/prh/src/board_sf_3gx/prh_ext_cam_drv_cfg.h
new file mode 120000
index 0000000..3d634c0
--- /dev/null
+++ b/devices/pm/power_management/prh/src/board_sf_3gx/prh_ext_cam_drv_cfg.h
@@ -0,0 +1 @@
+../board_sf_3gr/prh_ext_cam_drv_cfg.h
\ No newline at end of file
diff --git a/devices/pm/power_management/prh/src/board_sf_3gx/prh_ext_disp_drv_cfg.c b/devices/pm/power_management/prh/src/board_sf_3gx/prh_ext_disp_drv_cfg.c
new file mode 100644
index 0000000..c86407f
--- /dev/null
+++ b/devices/pm/power_management/prh/src/board_sf_3gx/prh_ext_disp_drv_cfg.c
@@ -0,0 +1,387 @@
+/*
+ *       Copyright (C) 2013-2014 Intel Mobile Communications GmbH
+ *
+ *            Sec Class: Intel Confidential (IC)
+ *
+ *
+ * This document contains proprietary information belonging to IMC.
+ * Passing on and copying of this document, use and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * Description:
+ *   This file contains the handling of DCC peripheral
+ *
+ * Revision Information:
+ *  $File name:  /mhw_drv_src/power_management/prh/src/board_xmm6321/prh_ext_disp_drv_cfg.c $
+ *   Comment:
+ *     Power Concept 4 implementation
+ * =============================================================================
+ * History:
+ *
+ * Date         Author       Comment
+ * -----------------------------------------------------------------------------
+ * 2012-06-06   A. Caruso    initial xmm6310
+ * 2012-11-28   Lesly A M    SMS03103133 - [Lepton] Keep Display and touch sensor ON for the BU
+ *
+ * ===========================================================================*/
+
+/*-----------------------------------------------------------------------------
+EXT DISPLAY peripheral              ENABLE                   DISABLE
+power resources/modes
+-------------------------------------------------------------------------------
+
+Init mode:                           --                       DISABLE
+
+Voltages:
+POW_CONTROL_VDD_PRIM_DISPLAY,        2.8V                     OFF
+
+-------------------------------------------------------------------------------*/
+
+
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/* INCLUDES                                                                                                      */
+/*---------------------------------------------------------------------------------------------------------------*/
+#include <prh.h>
+#include <prh_internal.h>
+#include <prh_cfg_internal.h>
+#include <pow_driverif_chip.h>
+#include <prh_ll_internal.h>
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/* DEFINES                                                                                                       */
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/* Timeout for waiting for the DISS bit in the CLC register to be cleared */
+#define  DCC_CLC_POLL_TIMEOUT      5
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/* TYPE DEFINITIONS                                                                                              */
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/* External Display peripheral power resources */
+typedef struct
+{
+  sPRH_PER_VOLT_SET_INFO_T  volt;
+  sPRH_PER_VOLT_SET_INFO_T  mipi_dsi;
+}sPRH_PER_EXT_DISPLAY_POW_RES_INFO_T;
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/* INTERNAL FUNCTION DECLARATIONS                                                                                */
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/* INTERNAL VARIABLE DEFINITIONS                                                                                 */
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/* EXT_DISPLAY peripheral info mode */
+static sPRH_PER_GENERIC_INFO_T prh_per_ext_display_mode =
+{
+  PRH_PER_GENERIC_MODE_START
+};
+
+/* EXT_DISPLAY peripheral info configuration */
+static sPRH_PER_CFG_T prh_per_ext_display_cfg_info =
+{
+  (uPRH_PER_INFO_T *) &prh_per_ext_display_mode,
+  PRH_PER_UNLOCKED
+};
+
+/* EXT_DISPLAY peripheral power resources configuration */
+static const sPRH_PER_EXT_DISPLAY_POW_RES_INFO_T  prh_per_ext_display_pow_res =
+{
+  /* mipi_ana   */ {POW_CONTROL_VDD_PRIM_DISPLAY,    POW_CONTROL_VOLTAGE_3V30},
+  /* mipi_dsi */ {POW_CONTROL_VDD_MIPI_DSI,        POW_CONTROL_VOLTAGE_1V17},
+
+ };
+
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/* Init power resources sequence */
+/* Internal state transition:
+ * - [S0] PRH_PER_GENERIC_MODE_START --> [S1] PRH_PER_GENERIC_DISABLE
+ */
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_ext_display_init_s01_seq[] =
+{
+  {PRH_PER_END_CMD,        NULL},
+};
+
+/* Enable power resources sequence */
+/* Internal state transition:
+ * - [S0] PRH_PER_GENERIC_MODE_START --> [S2] PRH_PER_GENERIC_ENABLE
+ */
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_ext_display_init_s02_seq[] =
+{
+
+  {PRH_PER_VOLT_ON_CMD,    (void *)&prh_per_ext_display_pow_res.mipi_dsi},
+  {PRH_PER_VOLT_ON_CMD,    (void *)&prh_per_ext_display_pow_res.volt},
+  {PRH_PER_END_CMD,        NULL},
+};
+
+/* Enable power resources sequence */
+/* Internal state transition:
+ * - [S1] PRH_PER_GENERIC_DISABLE --> [S2] PRH_PER_GENERIC_ENABLE
+ */
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_ext_display_en_seq[] =
+{
+
+  {PRH_PER_VOLT_ON_CMD,    (void *)&prh_per_ext_display_pow_res.mipi_dsi},
+  {PRH_PER_VOLT_ON_CMD,    (void *)&prh_per_ext_display_pow_res.volt},
+  {PRH_PER_END_CMD,        NULL},
+};
+
+/* Disable power resources sequence */
+/* Internal state transition:
+ * - [S2] PRH_PER_GENERIC_ENABLE --> [S1] PRH_PER_GENERIC_DISABLE
+ */
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_ext_display_dis_seq[] =
+{
+  {PRH_PER_VOLT_OFF_CMD,   (void *)&prh_per_ext_display_pow_res.volt},
+  {PRH_PER_VOLT_OFF_CMD,   (void *)&prh_per_ext_display_pow_res.mipi_dsi},
+  {PRH_PER_END_CMD,        NULL},
+};
+
+/* Dummy power resources sequences */
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_dummy_seq[] =
+{
+  {PRH_PER_END_CMD,        NULL},
+};
+
+/* The table maps the peripheral power resources sequences according to the current
+   power mode of the peripheral and the requested power mode of the user
+   [S0] PRH_PER_GENERIC_MODE_START
+   [S1] PRH_PER_GENERIC_DISABLE
+   [S2] PRH_PER_GENERIC_ENABLE
+*/
+static const sPRH_PER_GEN_SEQ_INFO_T * p_prh_per_ext_display_seq_table[PRH_PER_GENERIC_MODE_END][PRH_PER_GENERIC_MODE_END] =
+{
+                  /* next mode */
+/*current mode */ /* S0     S1                                S2                             */
+/* S0 */            {NULL,  &prh_per_ext_display_init_s01_seq[0], &prh_per_ext_display_init_s02_seq[0]                           },
+/* S1 */            {NULL,  &prh_per_dummy_seq[0],            &prh_per_ext_display_en_seq[0] },
+/* S2 */            {NULL,  &prh_per_ext_display_dis_seq[0],  &prh_per_dummy_seq[0]          },
+};
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/* INTERNAL FUNCTION                                                                               */
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/* EXPORTED FUNCTIONS                                                                                            */
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/****************************************************************************************
+* Function:    prh_ext_disp_drv_get_init_per_mode_info
+* Parameters:  per_id - HW peripheral identifier
+*              p_per_mode_info - pointer to peripheral power mode info
+* Returns:     ePRH_RETURN_T - error or PRH_OK
+* Description: Used to get the DCC peripheral initial power mode settings
+*
+****************************************************************************************/
+ePRH_RETURN_T prh_ext_disp_drv_get_init_per_mode_info (const ePRH_PER_ID_T per_id, sPRH_PER_MODE_INFO_T * p_per_mode_info)
+{
+  ePRH_RETURN_T ret_val = PRH_OK;
+
+  /* Check the peripheral identifier range */
+  if (PRH_PER_NOF_ID <= per_id)
+  {
+    ret_val = PRH_ERR_INV_PER_ID;
+  }
+  else if (NULL == p_per_mode_info)
+  {
+    ret_val = PRH_ERR_INV_POINTER;
+  }
+  else
+  {
+    switch (per_id)
+    {
+      case PRH_PER_EXT_DISPLAY:
+        p_per_mode_info->prh_per_type = PRH_PER_TYPE_GENERIC;
+#if defined(POWER_MANAGEMENT_PRH_TS_DISP_RESET_ON)
+        p_per_mode_info->prh_per_info.prh_per_generic_info.generic_mode = PRH_PER_GENERIC_ENABLE;
+#else
+        p_per_mode_info->prh_per_info.prh_per_generic_info.generic_mode = PRH_PER_GENERIC_DISABLE;
+#endif
+        break;
+
+      default:
+        ret_val = PRH_ERR_INV_PER_ID;
+        break;
+    }
+  }
+  return ret_val;
+}
+
+/****************************************************************************************
+* Function:    prh_ext_disp_drv_check_per_mode_info
+* Parameters:  per_id - HW peripheral identifier
+*              p_per_mode_info - pointer to peripheral power mode info
+* Returns:     ePRH_RETURN_T - error or PRH_OK
+* Description: Used to check the DCC peripheral power mode settings range
+*
+****************************************************************************************/
+ePRH_RETURN_T prh_ext_disp_drv_check_per_mode_info(const ePRH_PER_ID_T per_id, const sPRH_PER_MODE_INFO_T * const p_per_mode_info)
+{
+  ePRH_RETURN_T ret_val = PRH_OK;
+
+  /* Check the peripheral identifier range */
+  if (PRH_PER_NOF_ID <= per_id)
+  {
+    ret_val = PRH_ERR_INV_PER_ID;
+  }
+  /* Check the pointer */
+  else if (NULL == p_per_mode_info)
+  {
+    ret_val = PRH_ERR_INV_POINTER;
+  }
+  else
+  {
+    switch (per_id)
+    {
+      case PRH_PER_EXT_DISPLAY:
+        if ((PRH_PER_GENERIC_MODE_START >= p_per_mode_info->prh_per_info.prh_per_generic_info.generic_mode) ||
+            (PRH_PER_GENERIC_MODE_END   <= p_per_mode_info->prh_per_info.prh_per_generic_info.generic_mode))
+        {
+          ret_val = PRH_ERR_INV_MODE_INFO;
+        }
+        break;
+
+      default:
+        ret_val = PRH_ERR_INV_PER_ID;
+        break;
+    }
+  }
+  return ret_val;
+}
+
+/****************************************************************************************
+* Function:    prh_ext_disp_drv_get_per_cfg_info
+* Parameters:  per_id - HW peripheral identifier
+*              p_cfg_info - pointer to power mode info
+* Returns:     ePRH_RETURN_T - error or PRH_OK
+* Description: Used to get the DCC power mode information
+*
+****************************************************************************************/
+ePRH_RETURN_T prh_ext_disp_drv_get_per_cfg_info(const ePRH_PER_ID_T per_id, sPRH_PER_CFG_T ** p_cfg_info)
+{
+  ePRH_RETURN_T ret_val = PRH_OK;
+
+  /* Check the peripheral identifier range */
+  if (PRH_PER_NOF_ID <= per_id)
+  {
+    ret_val = PRH_ERR_INV_PER_ID;
+  }
+  /* Check the pointer */
+  else if (NULL == p_cfg_info)
+  {
+    ret_val = PRH_ERR_INV_POINTER;
+  }
+  else
+  {
+    *p_cfg_info = NULL;
+    switch (per_id)
+    {
+      case PRH_PER_EXT_DISPLAY:
+        *p_cfg_info = &prh_per_ext_display_cfg_info;
+        break;
+
+      default:
+        ret_val = PRH_ERR_INV_PER_ID;
+        break;
+    }
+  }
+  return ret_val;
+}
+
+/****************************************************************************************
+* Function:    prh_ext_disp_drv_set_per_mode_info
+* Parameters:  per_id - HW peripheral identifier
+*              p_per_mode_info - power mode info requested from the user
+* Returns:     ePRH_RETURN_T - error or PRH_OK
+* Description: Used to update the DCC power mode information
+*
+****************************************************************************************/
+ePRH_RETURN_T prh_ext_disp_drv_set_per_mode_info(const ePRH_PER_ID_T per_id, const sPRH_PER_MODE_INFO_T * const p_per_mode_info)
+{
+  ePRH_RETURN_T ret_val = PRH_OK;
+
+  /* Check the peripheral identifier range */
+  if (PRH_PER_NOF_ID <= per_id)
+  {
+    ret_val = PRH_ERR_INV_PER_ID;
+  }
+  /* Check the pointer */
+  else if (NULL == p_per_mode_info)
+  {
+    ret_val = PRH_ERR_INV_POINTER;
+  }
+  else
+  {
+    switch (per_id)
+    {
+      case PRH_PER_EXT_DISPLAY:
+        prh_per_ext_display_mode.generic_mode = p_per_mode_info->prh_per_info.prh_per_generic_info.generic_mode;
+        break;
+
+      default:
+        ret_val = PRH_ERR_INV_PER_ID;
+        break;
+    }
+  }
+  return ret_val;
+}
+
+/****************************************************************************************
+* Function:    prh_ext_disp_drv_get_per_seq_info
+* Parameters:  per_id - HW peripheral identifier
+*              p_per_mode_info - power mode info requested from the user
+*              p_seq_info - pointer to the power resource setting/configuration sequence to be loaded
+* Returns:     ePRH_RETURN_T - error or PRH_OK
+* Description: Used to retrieve the power resource setting/configuration sequence depending on the
+*              power mode info requested from the user
+*
+****************************************************************************************/
+ePRH_RETURN_T prh_ext_disp_drv_get_per_seq_info(const ePRH_PER_ID_T per_id, const sPRH_PER_MODE_INFO_T *const p_per_mode_info, const sPRH_PER_GEN_SEQ_INFO_T ** p_seq_info)
+{
+  ePRH_RETURN_T ret_val = PRH_OK;
+
+  /* Check the peripheral identifier range */
+  if (PRH_PER_NOF_ID <= per_id)
+  {
+    ret_val = PRH_ERR_INV_PER_ID;
+  }
+  /* Check the pointer */
+  else if (NULL == p_per_mode_info)
+  {
+    ret_val = PRH_ERR_INV_POINTER;
+  }
+  /* Check the pointer */
+  else if (NULL == p_seq_info)
+  {
+    ret_val = PRH_ERR_INV_POINTER;
+  }
+  else
+  {
+    *p_seq_info = NULL;
+    switch (per_id)
+    {
+      case PRH_PER_EXT_DISPLAY:
+        {
+          /* retrieve the user requested power mode for DCC peripheral */
+          ePRH_PER_GENERIC_MODE_T next_mode = p_per_mode_info->prh_per_info.prh_per_generic_info.generic_mode;
+          /* retrieve the power resources setting table */
+          *p_seq_info = p_prh_per_ext_display_seq_table[prh_per_ext_display_mode.generic_mode][next_mode];
+        }
+        break;
+
+      default:
+        ret_val = PRH_ERR_INV_PER_ID;
+        break;
+    }
+  }
+  return ret_val;
+}
+
+
diff --git a/devices/pm/power_management/prh/src/board_sf_3gx/prh_ext_disp_drv_cfg.h b/devices/pm/power_management/prh/src/board_sf_3gx/prh_ext_disp_drv_cfg.h
new file mode 120000
index 0000000..c348e35
--- /dev/null
+++ b/devices/pm/power_management/prh/src/board_sf_3gx/prh_ext_disp_drv_cfg.h
@@ -0,0 +1 @@
+../board_sf_3gr/prh_ext_disp_drv_cfg.h
\ No newline at end of file
diff --git a/devices/pm/power_management/prh/src/board_sf_3gx/prh_ext_gyroscope_drv_cfg.c b/devices/pm/power_management/prh/src/board_sf_3gx/prh_ext_gyroscope_drv_cfg.c
new file mode 120000
index 0000000..1b99afa
--- /dev/null
+++ b/devices/pm/power_management/prh/src/board_sf_3gx/prh_ext_gyroscope_drv_cfg.c
@@ -0,0 +1 @@
+../board_sf_3gr/prh_ext_gyroscope_drv_cfg.c
\ No newline at end of file
diff --git a/devices/pm/power_management/prh/src/board_sf_3gx/prh_ext_gyroscope_drv_cfg.h b/devices/pm/power_management/prh/src/board_sf_3gx/prh_ext_gyroscope_drv_cfg.h
new file mode 120000
index 0000000..ea6fd86
--- /dev/null
+++ b/devices/pm/power_management/prh/src/board_sf_3gx/prh_ext_gyroscope_drv_cfg.h
@@ -0,0 +1 @@
+../board_sf_3gr/prh_ext_gyroscope_drv_cfg.h
\ No newline at end of file
diff --git a/devices/pm/power_management/prh/src/board_sf_3gx/prh_ext_magnetometer_drv_cfg.c b/devices/pm/power_management/prh/src/board_sf_3gx/prh_ext_magnetometer_drv_cfg.c
new file mode 120000
index 0000000..dc4a7a9
--- /dev/null
+++ b/devices/pm/power_management/prh/src/board_sf_3gx/prh_ext_magnetometer_drv_cfg.c
@@ -0,0 +1 @@
+../board_sf_3gr/prh_ext_magnetometer_drv_cfg.c
\ No newline at end of file
diff --git a/devices/pm/power_management/prh/src/board_sf_3gx/prh_ext_magnetometer_drv_cfg.h b/devices/pm/power_management/prh/src/board_sf_3gx/prh_ext_magnetometer_drv_cfg.h
new file mode 120000
index 0000000..88c103c
--- /dev/null
+++ b/devices/pm/power_management/prh/src/board_sf_3gx/prh_ext_magnetometer_drv_cfg.h
@@ -0,0 +1 @@
+../board_sf_3gr/prh_ext_magnetometer_drv_cfg.h
\ No newline at end of file
diff --git a/devices/pm/power_management/prh/src/board_sf_3gx/prh_ext_proximity_sensor_drv_cfg.c b/devices/pm/power_management/prh/src/board_sf_3gx/prh_ext_proximity_sensor_drv_cfg.c
new file mode 120000
index 0000000..93862da
--- /dev/null
+++ b/devices/pm/power_management/prh/src/board_sf_3gx/prh_ext_proximity_sensor_drv_cfg.c
@@ -0,0 +1 @@
+../board_sf_3gr/prh_ext_proximity_sensor_drv_cfg.c
\ No newline at end of file
diff --git a/devices/pm/power_management/prh/src/board_sf_3gx/prh_ext_proximity_sensor_drv_cfg.h b/devices/pm/power_management/prh/src/board_sf_3gx/prh_ext_proximity_sensor_drv_cfg.h
new file mode 120000
index 0000000..9115c92
--- /dev/null
+++ b/devices/pm/power_management/prh/src/board_sf_3gx/prh_ext_proximity_sensor_drv_cfg.h
@@ -0,0 +1 @@
+../board_sf_3gr/prh_ext_proximity_sensor_drv_cfg.h
\ No newline at end of file
diff --git a/devices/pm/power_management/prh/src/board_sf_3gx/prh_ext_tp_drv_cfg.c b/devices/pm/power_management/prh/src/board_sf_3gx/prh_ext_tp_drv_cfg.c
new file mode 120000
index 0000000..47a98d6
--- /dev/null
+++ b/devices/pm/power_management/prh/src/board_sf_3gx/prh_ext_tp_drv_cfg.c
@@ -0,0 +1 @@
+../board_sf_3gr/prh_ext_tp_drv_cfg.c
\ No newline at end of file
diff --git a/devices/pm/power_management/prh/src/board_sf_3gx/prh_ext_tp_drv_cfg.h b/devices/pm/power_management/prh/src/board_sf_3gx/prh_ext_tp_drv_cfg.h
new file mode 120000
index 0000000..6080cff
--- /dev/null
+++ b/devices/pm/power_management/prh/src/board_sf_3gx/prh_ext_tp_drv_cfg.h
@@ -0,0 +1 @@
+../board_sf_3gr/prh_ext_tp_drv_cfg.h
\ No newline at end of file
diff --git a/devices/pm/power_management/prh/src/board_sf_3gx/prh_gpu_drv_cfg.c b/devices/pm/power_management/prh/src/board_sf_3gx/prh_gpu_drv_cfg.c
new file mode 100644
index 0000000..10c9292
--- /dev/null
+++ b/devices/pm/power_management/prh/src/board_sf_3gx/prh_gpu_drv_cfg.c
@@ -0,0 +1,597 @@
+/*
+ *       Copyright (C) 2013-2014 Intel Mobile Communications GmbH
+ *       
+ *            Sec Class: Intel Confidential (IC)
+ *       
+ *
+ * This document contains proprietary information belonging to IMC.
+ * Passing on and copying of this document, use and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * Description:
+ *   This file contains the handling of GPU peripheral
+ *
+ * Revision Information:
+ *  $File name:  /mhw_drv_src/power_management/prh/src/xgold632_agold610/prh_gpu_drv_cfg.c $
+ *   Comment:
+ *     Power Concept 4 implementation 
+ * =============================================================================
+ * History:
+ *
+ * Date         Author       Comment
+ * -----------------------------------------------------------------------------
+ * 2012-06-06   A. Caruso    initial xmm632
+ *
+ * ===========================================================================*/
+
+/*-------------------------------------------------------------------------------------------
+GPU peripheral                    ENABLE_LOW    ENABLE_MED  ENABLE_HIGH  ENABLE_UHIGH  DISABLE 
+power resources/modes                                                          
+---------------------------------------------------------------------------------------------
+
+Init mode:                         --            --          --          --            DISABLE
+
+Power Subdomains:
+POW_CONTROL_SUB_D_GPU             ON            ON          ON           ON            OFF
+
+Clocks:
+POW_CONTROL_GPU_KERNEL_CLK        104M          156M        312M         420M          OFF
+POW_CONTROL_GPU_BUS_CLK           >=26MHz       >=26MHz     >=26MHz      >=26MHz       OFF
+
+Core voltage:                     LOW           MED         MED          HIGH          LOW
+
+---------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/* INCLUDES                                                                                                      */
+/*---------------------------------------------------------------------------------------------------------------*/
+#include <prh.h>
+#include <prh_internal.h>
+#include <prh_cfg_internal.h>
+#include <pow_driverif_chip.h>
+#include <prh_ll_internal.h>
+#include <prh_volt_cfg_internal.h>
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/* DEFINES                                                                                                       */
+/*---------------------------------------------------------------------------------------------------------------*/
+
+#define PRH_PER_GPU_NOF_MODE     (U32)PRH_PER_GPU_MODE_END - (U32)PRH_PER_GPU_MODE_START
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/* TYPE DEFINITIONS                                                                                              */
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/* GPU peripheral power resources */
+typedef struct 
+{
+  sPRH_PER_CLOCK_CFG_INFO_T bus_clk;
+  sPRH_PER_CLOCK_CFG_INFO_T kernel_clk_low;
+  sPRH_PER_CLOCK_CFG_INFO_T kernel_clk_mid;
+  sPRH_PER_CLOCK_CFG_INFO_T kernel_clk_high;
+  sPRH_PER_CLOCK_CFG_INFO_T kernel_clk_uhigh;
+  sPRH_PER_CLOCK_CFG_INFO_T master_clk_low;
+  sPRH_PER_CLOCK_CFG_INFO_T master_clk_mid;
+  sPRH_PER_CLOCK_CFG_INFO_T master_clk_high;
+  POW_CONTROL_POWER_SUB_D_T subdom;
+  ePRH_PER_VOLT_USER_ID_T   per_volt_id;
+  POW_CONTROL_ID_T          psv;
+}sPRH_PER_GPU_POW_RES_INFO_T;
+
+typedef struct
+{
+  sPRH_PER_VOLT_SET_INFO_T      vlow;  /**< voltage level */
+  sPRH_PER_VOLT_SET_INFO_T      vmed;  /**< voltage level */
+  sPRH_PER_VOLT_SET_INFO_T      vhigh;
+  sPRH_PER_VOLT_SET_INFO_T      vuhigh;
+
+}sPRH_PER_GPU_VOLT_POW_RES_INFO_T;
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/* INTERNAL FUNCTION DECLARATIONS                                                                                */
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/* INTERNAL VARIABLE DEFINITIONS                                                                                 */
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/* GPU peripheral info mode */
+static sPRH_PER_GPU_INFO_T prh_per_gpu_mode =
+{
+  PRH_PER_GPU_MODE_START
+};
+
+/* GPU peripheral info configuration */
+static sPRH_PER_CFG_T prh_per_gpu_cfg_info =
+{
+  (uPRH_PER_INFO_T *) &prh_per_gpu_mode,
+  PRH_PER_UNLOCKED
+};
+
+/* GPU peripheral power resources configuration */
+static const sPRH_PER_GPU_POW_RES_INFO_T  prh_per_gpu_pow_res = 
+{
+  /* bus_clk          */ {POW_CONTROL_GPU_BUS_CLK,     POW_CONTROL_FREQ_26M,   POW_CONTROL_FREQ_DONT_CARE},
+  /* kernel_clk_low   */ {POW_CONTROL_GPU_KERNEL_CLK,  POW_CONTROL_FREQ_208M,  POW_CONTROL_FREQ_208M},
+  /* kernel_clk_mid   */ {POW_CONTROL_GPU_KERNEL_CLK,  POW_CONTROL_FREQ_312M,  POW_CONTROL_FREQ_312M},
+  /* kernel_clk_high  */ {POW_CONTROL_GPU_KERNEL_CLK,  POW_CONTROL_FREQ_416M,  POW_CONTROL_FREQ_416M},
+  /* kernel_clk_uhigh */ {POW_CONTROL_GPU_KERNEL_CLK,  POW_CONTROL_FREQ_600M,  POW_CONTROL_FREQ_600M},
+  /* master_clk_low   */ {POW_CONTROL_GPU_MASTER_CLK,  POW_CONTROL_FREQ_104M,  POW_CONTROL_FREQ_DONT_CARE},
+  /* master_clk_mid   */ {POW_CONTROL_GPU_MASTER_CLK,  POW_CONTROL_FREQ_156M,  POW_CONTROL_FREQ_DONT_CARE},
+  /* master_clk_high  */ {POW_CONTROL_GPU_MASTER_CLK,  POW_CONTROL_FREQ_400M,  POW_CONTROL_FREQ_DONT_CARE},
+  /* subdom           */ POW_CONTROL_SUB_D_GPU,
+  /* per_volt_id      */ PRH_PER_VOLT_GPU,
+  /* psv              */ POW_CONTROL_GPU_ID,
+};
+
+static const sPRH_PER_GPU_VOLT_POW_RES_INFO_T prh_per_gpu_volt_pow_res =
+{
+  /* vlow */   {POW_CONTROL_VDD_GPU,  POW_CONTROL_VOLTAGE_1V10},
+  /* vmed */   {POW_CONTROL_VDD_GPU,  POW_CONTROL_VOLTAGE_1V10},
+  /* vhigh */  {POW_CONTROL_VDD_GPU,  POW_CONTROL_VOLTAGE_1V10},
+  /* vuhigh */ {POW_CONTROL_VDD_GPU,  POW_CONTROL_VOLTAGE_1V30},
+};
+
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/* Init power resources sequence */
+/* Internal state transition:
+ * - [S0] PRH_PER_GPU_MODE_START --> [S1] PRH_PER_GPU_DISABLE
+ */
+static sPRH_PER_GEN_SEQ_INFO_T prh_per_gpu_init_seq[] =
+{
+  {PRH_PER_CLK_CFG_CMD,    (void *)&prh_per_gpu_pow_res.bus_clk},
+  {PRH_PER_END_CMD,        NULL},
+};
+
+/*------------------------------------------------------------------------------*/
+
+/* Internal state transition: 
+ * - [S1] PRH_PER_GPU_DISABLE --> [S2] PRH_PER_GPU_ENABLE_LOW_PERF
+ */
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_gpu_en_low_s12_seq[] =
+{
+  {PRH_PER_CLK_CFG_CMD,       (void *)&prh_per_gpu_pow_res.kernel_clk_low},
+  {PRH_PER_CLK_CFG_CMD,       (void *)&prh_per_gpu_pow_res.master_clk_low},
+  {PRH_PER_PSV_OFF_CMD,       (void *)&prh_per_gpu_pow_res.psv},
+  {PRH_PER_SUBDOM_ON_CMD,     (void *)&prh_per_gpu_pow_res.subdom},
+  {PRH_PER_VOLT_ON_CMD,       (void *)&prh_per_gpu_volt_pow_res.vlow},
+  {PRH_PER_CLK_ON_CMD,        (void *)&prh_per_gpu_pow_res.bus_clk},
+  {PRH_PER_CLK_ON_CMD,        (void *)&prh_per_gpu_pow_res.kernel_clk_low},
+  {PRH_PER_CLK_ON_CMD,       (void *)&prh_per_gpu_pow_res.master_clk_low},
+  {PRH_PER_END_CMD,           NULL},
+};
+
+/* Internal state transition: 
+ * - [S3] PRH_PER_GPU_ENABLE_MID_PERF        --> [S2] PRH_PER_GPU_ENABLE_LOW_PERF
+ * - [S4] PRH_PER_GPU_ENABLE_HIGH_PERF       --> [S2] PRH_PER_GPU_ENABLE_LOW_PERF 
+ * - [S5] PRH_PER_GPU_ENABLE_ULTRA_HIGH_PERF --> [S2] PRH_PER_GPU_ENABLE_LOW_PERF 
+ */
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_gpu_en_low_s32_seq[] =
+{
+  {PRH_PER_CLK_CFG_CMD,       (void *)&prh_per_gpu_pow_res.kernel_clk_low},
+  {PRH_PER_CLK_CFG_CMD,       (void *)&prh_per_gpu_pow_res.master_clk_low},
+  {PRH_PER_VOLT_LOW_REQ_CMD,  (void *)&prh_per_gpu_pow_res.per_volt_id},
+  {PRH_PER_VOLT_ON_CMD,       (void *)&prh_per_gpu_volt_pow_res.vlow},
+  {PRH_PER_END_CMD,           NULL},
+};
+
+/*------------------------------------------------------------------------------*/
+
+/* Internal state transition: 
+ * - [S1] PRH_PER_GPU_DISABLE          --> [S3] PRH_PER_GPU_ENABLE_MID_PERF
+ */
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_gpu_en_mid_s13_seq[] =
+{
+  {PRH_PER_CLK_CFG_CMD,       (void *)&prh_per_gpu_pow_res.kernel_clk_mid},
+  {PRH_PER_CLK_CFG_CMD,       (void *)&prh_per_gpu_pow_res.master_clk_mid},
+  {PRH_PER_PSV_OFF_CMD,       (void *)&prh_per_gpu_pow_res.psv},
+  {PRH_PER_SUBDOM_ON_CMD,     (void *)&prh_per_gpu_pow_res.subdom},
+  {PRH_PER_VOLT_MED_REQ_CMD,  (void *)&prh_per_gpu_pow_res.per_volt_id},
+  {PRH_PER_VOLT_STAB_REQ_CMD, NULL},
+  {PRH_PER_VOLT_ON_CMD,       (void *)&prh_per_gpu_volt_pow_res.vmed},
+  {PRH_PER_CLK_ON_CMD,        (void *)&prh_per_gpu_pow_res.bus_clk},
+  {PRH_PER_CLK_ON_CMD,        (void *)&prh_per_gpu_pow_res.kernel_clk_mid},
+  {PRH_PER_CLK_ON_CMD,       (void *)&prh_per_gpu_pow_res.master_clk_mid},  
+  {PRH_PER_END_CMD,           NULL},
+};
+
+/* Internal state transition: 
+ * - [S2] PRH_PER_GPU_ENABLE_LOW_PERF  --> [S3] PRH_PER_GPU_ENABLE_MID_PERF
+ */
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_gpu_en_mid_s23_seq[] =
+{
+  {PRH_PER_VOLT_MED_REQ_CMD,  (void *)&prh_per_gpu_pow_res.per_volt_id},
+  {PRH_PER_VOLT_STAB_REQ_CMD, NULL},
+  {PRH_PER_VOLT_ON_CMD,       (void *)&prh_per_gpu_volt_pow_res.vmed},
+  {PRH_PER_CLK_CFG_CMD,       (void *)&prh_per_gpu_pow_res.kernel_clk_mid},
+  {PRH_PER_CLK_CFG_CMD,       (void *)&prh_per_gpu_pow_res.master_clk_mid},
+  {PRH_PER_END_CMD,           NULL},
+};
+
+/* Internal state transition: 
+ * - [S4] PRH_PER_GPU_ENABLE_HIGH_PERF --> [S3] PRH_PER_GPU_ENABLE_MID_PERF
+ */
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_gpu_en_mid_s43_seq[] =
+{
+  {PRH_PER_CLK_CFG_CMD,        (void *)&prh_per_gpu_pow_res.kernel_clk_mid},
+  {PRH_PER_CLK_CFG_CMD,       (void *)&prh_per_gpu_pow_res.master_clk_mid},
+  {PRH_PER_END_CMD,            NULL},
+};
+
+/* Internal state transition: 
+ * - [S5] PRH_PER_GPU_ENABLE_ULTRA_HIGH_PERF  --> [S3] PRH_PER_GPU_ENABLE_MID_PERF
+ */
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_gpu_en_mid_s53_seq[] =
+{
+  {PRH_PER_CLK_CFG_CMD,        (void *)&prh_per_gpu_pow_res.kernel_clk_mid},
+  {PRH_PER_CLK_CFG_CMD,       (void *)&prh_per_gpu_pow_res.master_clk_mid},
+  {PRH_PER_VOLT_MED_REQ_CMD,   (void *)&prh_per_gpu_pow_res.per_volt_id},
+  {PRH_PER_VOLT_ON_CMD,       (void *)&prh_per_gpu_volt_pow_res.vmed},
+  {PRH_PER_END_CMD,            NULL},
+};
+
+/*------------------------------------------------------------------------------*/
+
+/* Internal state transition: 
+ * - [S1] PRH_PER_GPU_DISABLE --> [S4] PRH_PER_GPU_ENABLE_HIGH_PERF
+ */
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_gpu_en_high_s14_seq[] =
+{
+  {PRH_PER_CLK_CFG_CMD,        (void *)&prh_per_gpu_pow_res.kernel_clk_high},
+  {PRH_PER_CLK_CFG_CMD,        (void *)&prh_per_gpu_pow_res.master_clk_high},
+  {PRH_PER_PSV_OFF_CMD,        (void *)&prh_per_gpu_pow_res.psv},
+  {PRH_PER_SUBDOM_ON_CMD,      (void *)&prh_per_gpu_pow_res.subdom},
+  {PRH_PER_VOLT_MED_REQ_CMD,   (void *)&prh_per_gpu_pow_res.per_volt_id},
+  {PRH_PER_VOLT_ON_CMD,       (void *)&prh_per_gpu_volt_pow_res.vhigh},
+  {PRH_PER_VOLT_STAB_REQ_CMD,  NULL},
+  {PRH_PER_CLK_ON_CMD,         (void *)&prh_per_gpu_pow_res.bus_clk},
+  {PRH_PER_CLK_ON_CMD,         (void *)&prh_per_gpu_pow_res.kernel_clk_high},
+  {PRH_PER_CLK_ON_CMD,        (void *)&prh_per_gpu_pow_res.master_clk_high},
+  {PRH_PER_END_CMD,            NULL},
+};
+
+/* Internal state transition: 
+ * - [S2] PRH_PER_GPU_ENABLE_LOW_PERF --> [S4] PRH_PER_GPU_ENABLE_HIGH_PERF
+ */
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_gpu_en_high_s24_seq[] =
+{
+  {PRH_PER_VOLT_MED_REQ_CMD,  (void *)&prh_per_gpu_pow_res.per_volt_id},
+  {PRH_PER_VOLT_STAB_REQ_CMD, NULL},
+  {PRH_PER_VOLT_ON_CMD,       (void *)&prh_per_gpu_volt_pow_res.vhigh},
+  {PRH_PER_CLK_CFG_CMD,       (void *)&prh_per_gpu_pow_res.kernel_clk_high},
+  {PRH_PER_CLK_CFG_CMD,        (void *)&prh_per_gpu_pow_res.master_clk_high},
+  {PRH_PER_END_CMD,           NULL},
+};
+
+/* Internal state transition: 
+ * - [S3] PRH_PER_GPU_ENABLE_MID_PERF --> [S4] PRH_PER_GPU_ENABLE_HIGH_PERF 
+ */
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_gpu_en_high_s34_seq[] =
+{
+  {PRH_PER_CLK_CFG_CMD,        (void *)&prh_per_gpu_pow_res.kernel_clk_high},
+  {PRH_PER_CLK_CFG_CMD,        (void *)&prh_per_gpu_pow_res.master_clk_high},
+  {PRH_PER_END_CMD,            NULL},
+};
+
+/* Internal state transition: 
+ * - [S5] PRH_PER_GPU_ENABLE_ULTRA_HIGH_PERF --> [S4] PRH_PER_GPU_ENABLE_HIGH_PERF 
+ */
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_gpu_en_high_s54_seq[] =
+{
+  {PRH_PER_CLK_CFG_CMD,        (void *)&prh_per_gpu_pow_res.kernel_clk_high},
+  {PRH_PER_VOLT_MED_REQ_CMD,   (void *)&prh_per_gpu_pow_res.per_volt_id},
+  {PRH_PER_VOLT_ON_CMD,       (void *)&prh_per_gpu_volt_pow_res.vhigh},
+  {PRH_PER_END_CMD,            NULL},
+};
+
+/*------------------------------------------------------------------------------*/
+
+/* Internal state transition: 
+ * - [S1] PRH_PER_GPU_DISABLE --> [S5] PRH_PER_GPU_ENABLE_ULTRA_HIGH_PERF
+ */
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_gpu_en_uhigh_s15_seq[] =
+{
+  {PRH_PER_CLK_CFG_CMD,        (void *)&prh_per_gpu_pow_res.kernel_clk_uhigh},
+  {PRH_PER_CLK_CFG_CMD,        (void *)&prh_per_gpu_pow_res.master_clk_high},
+  {PRH_PER_PSV_OFF_CMD,        (void *)&prh_per_gpu_pow_res.psv},
+  {PRH_PER_SUBDOM_ON_CMD,      (void *)&prh_per_gpu_pow_res.subdom},
+  {PRH_PER_VOLT_HIGH_REQ_CMD,  (void *)&prh_per_gpu_pow_res.per_volt_id},
+  {PRH_PER_VOLT_STAB_REQ_CMD,  NULL},
+  {PRH_PER_VOLT_ON_CMD,       (void *)&prh_per_gpu_volt_pow_res.vuhigh},
+  {PRH_PER_CLK_ON_CMD,         (void *)&prh_per_gpu_pow_res.bus_clk},
+  {PRH_PER_CLK_ON_CMD,         (void *)&prh_per_gpu_pow_res.kernel_clk_uhigh},
+  {PRH_PER_CLK_ON_CMD,        (void *)&prh_per_gpu_pow_res.master_clk_high},
+  {PRH_PER_END_CMD,            NULL},
+};
+
+/* Internal state transition: 
+ * - [S2] PRH_PER_GPU_ENABLE_LOW_PERF  --> [S5] PRH_PER_GPU_ENABLE_ULTRA_HIGH_PERF
+ * - [S3] PRH_PER_GPU_ENABLE_MID_PERF  --> [S5] PRH_PER_GPU_ENABLE_ULTRA_HIGH_PERF 
+ * - [S4] PRH_PER_GPU_ENABLE_HIGH_PERF --> [S5] PRH_PER_GPU_ENABLE_ULTRA_HIGH_PERF 
+ */
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_gpu_en_uhigh_s25_seq[] =
+{
+  {PRH_PER_VOLT_HIGH_REQ_CMD, (void *)&prh_per_gpu_pow_res.per_volt_id},
+  {PRH_PER_VOLT_STAB_REQ_CMD, NULL},
+  {PRH_PER_VOLT_ON_CMD,       (void *)&prh_per_gpu_volt_pow_res.vuhigh},
+  {PRH_PER_CLK_CFG_CMD,       (void *)&prh_per_gpu_pow_res.kernel_clk_uhigh},
+  {PRH_PER_CLK_CFG_CMD,        (void *)&prh_per_gpu_pow_res.master_clk_high},
+  {PRH_PER_END_CMD,           NULL},
+};
+
+/*------------------------------------------------------------------------------*/
+
+/* Internal state transition: 
+ * - [S2] PRH_PER_GPU_ENABLE_LOW_PERF  --> [S1] PRH_PER_GPU_DISABLE
+ */
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_gpu_dis_s21_seq[] =
+{
+  {PRH_PER_CLK_OFF_CMD,      (void *)&prh_per_gpu_pow_res.master_clk_low},
+  {PRH_PER_CLK_OFF_CMD,      (void *)&prh_per_gpu_pow_res.kernel_clk_low},
+  {PRH_PER_CLK_OFF_CMD,      (void *)&prh_per_gpu_pow_res.bus_clk},
+  {PRH_PER_SUBDOM_OFF_CMD,   (void *)&prh_per_gpu_pow_res.subdom},
+  {PRH_PER_PSV_ON_CMD,       (void *)&prh_per_gpu_pow_res.psv},
+  {PRH_PER_END_CMD,          NULL},
+};
+
+/* Internal state transition: 
+ * - [S3] PRH_PER_GPU_ENABLE_MID_PERF        --> [S1] PRH_PER_GPU_DISABLE
+ * - [S4] PRH_PER_GPU_ENABLE_HIGH_PERF       --> [S1] PRH_PER_GPU_DISABLE
+ * - [S5] PRH_PER_GPU_ENABLE_ULTRA_HIGH_PERF --> [S1] PRH_PER_GPU_DISABLE
+ */
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_gpu_dis_s31_seq[] =
+{
+  {PRH_PER_CLK_OFF_CMD,      (void *)&prh_per_gpu_pow_res.master_clk_low},
+  {PRH_PER_CLK_OFF_CMD,      (void *)&prh_per_gpu_pow_res.kernel_clk_low},
+  {PRH_PER_CLK_OFF_CMD,      (void *)&prh_per_gpu_pow_res.bus_clk},
+  {PRH_PER_SUBDOM_OFF_CMD,   (void *)&prh_per_gpu_pow_res.subdom},
+  {PRH_PER_VOLT_LOW_REQ_CMD, (void *)&prh_per_gpu_pow_res.per_volt_id},
+  {PRH_PER_VOLT_ON_CMD,       (void *)&prh_per_gpu_volt_pow_res.vlow},
+  {PRH_PER_PSV_ON_CMD,       (void *)&prh_per_gpu_pow_res.psv},
+  {PRH_PER_END_CMD,          NULL},
+};
+
+/*------------------------------------------------------------------------------*/
+
+/* Internal state transition: 
+ * - [Sm] --> [Sn] 
+ */
+static sPRH_PER_GEN_SEQ_INFO_T prh_per_dummy_seq[] =
+{
+  {PRH_PER_END_CMD,      NULL},
+};
+
+/*------------------------------------------------------------------------------*/
+
+static const sPRH_PER_GEN_SEQ_INFO_T * p_prh_per_gpu_seq_table[PRH_PER_GPU_NOF_MODE][PRH_PER_GPU_NOF_MODE] =
+{ 
+                  /* next mode */
+/* current mode */  /*S0    S1                            S2                               S3                               S4                               S5                                    */                             
+/* S0 */            {NULL,  &prh_per_gpu_init_seq[0],     NULL,                            NULL,                            NULL,                            NULL                                 },
+/* S1 */            {NULL,  &prh_per_dummy_seq[0],        &prh_per_gpu_en_low_s12_seq[0],  &prh_per_gpu_en_mid_s13_seq[0],  &prh_per_gpu_en_high_s14_seq[0], &prh_per_gpu_en_uhigh_s15_seq[0]}, 
+/* S2 */            {NULL,  &prh_per_gpu_dis_s21_seq[0],  &prh_per_dummy_seq[0],           &prh_per_gpu_en_mid_s23_seq[0],  &prh_per_gpu_en_high_s24_seq[0], &prh_per_gpu_en_uhigh_s25_seq[0]},
+/* S3 */            {NULL,  &prh_per_gpu_dis_s31_seq[0],  &prh_per_gpu_en_low_s32_seq[0],  &prh_per_dummy_seq[0],           &prh_per_gpu_en_high_s34_seq[0], &prh_per_gpu_en_uhigh_s25_seq[0]},
+/* S4 */            {NULL,  &prh_per_gpu_dis_s31_seq[0],  &prh_per_gpu_en_low_s32_seq[0],  &prh_per_gpu_en_mid_s43_seq[0],  &prh_per_dummy_seq[0],           &prh_per_gpu_en_uhigh_s25_seq[0]},
+/* S5 */            {NULL,  &prh_per_gpu_dis_s31_seq[0],  &prh_per_gpu_en_low_s32_seq[0],  &prh_per_gpu_en_mid_s53_seq[0],  &prh_per_gpu_en_high_s54_seq[0], &prh_per_dummy_seq[0]},
+};                                                                                                                                                                           
+
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/* INTERNAL FUNCTION                                                                               */
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/* EXPORTED FUNCTIONS                                                                                            */
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/****************************************************************************************
+* Function:    prh_gpu_drv_get_init_per_mode_info
+* Parameters:  per_id - HW peripheral identifier
+*              p_per_mode_info - pointer to peripheral power mode info
+* Returns:     ePRH_RETURN_T - error or PRH_OK
+* Description: Used to get the GPU peripheral initial power mode settings
+*
+****************************************************************************************/
+ePRH_RETURN_T prh_gpu_drv_get_init_per_mode_info (const ePRH_PER_ID_T per_id, sPRH_PER_MODE_INFO_T * p_per_mode_info)
+{
+  ePRH_RETURN_T ret_val = PRH_OK;
+
+  /* Check the peripheral identifier range */
+  if (PRH_PER_NOF_ID <= per_id)
+  {
+    ret_val = PRH_ERR_INV_PER_ID;
+  }
+  else if (NULL == p_per_mode_info)
+  {
+    ret_val = PRH_ERR_INV_POINTER;
+  }
+  else
+  {
+    switch (per_id)
+    {
+      case PRH_PER_GPU:
+        p_per_mode_info->prh_per_type = PRH_PER_TYPE_GPU;
+        p_per_mode_info->prh_per_info.prh_per_gpu_info.gpu_mode = PRH_PER_GPU_DISABLE;
+        break;
+
+      default:
+        ret_val = PRH_ERR_INV_PER_ID;
+        break;
+    }
+  }
+  return ret_val;
+}
+
+/****************************************************************************************
+* Function:    prh_gpu_drv_check_per_mode_info
+* Parameters:  per_id - HW peripheral identifier
+*              p_per_mode_info - pointer to peripheral power mode info
+* Returns:     ePRH_RETURN_T - error or PRH_OK
+* Description: Used to check the GPU peripheral power mode settings range
+*
+****************************************************************************************/
+ePRH_RETURN_T prh_gpu_drv_check_per_mode_info(const ePRH_PER_ID_T per_id, const sPRH_PER_MODE_INFO_T * const p_per_mode_info)
+{
+  ePRH_RETURN_T ret_val = PRH_OK;
+
+  /* Check the peripheral identifier range */
+  if (PRH_PER_NOF_ID <= per_id)
+  {
+    ret_val = PRH_ERR_INV_PER_ID;
+  }
+  /* Check the pointer */
+  else if (NULL == p_per_mode_info)
+  {
+    ret_val = PRH_ERR_INV_POINTER;
+  }
+  else
+  {
+    switch (per_id)
+    {
+      case PRH_PER_GPU:
+        if ((PRH_PER_GPU_MODE_START >= p_per_mode_info->prh_per_info.prh_per_gpu_info.gpu_mode) ||
+            (PRH_PER_GPU_MODE_END   <= p_per_mode_info->prh_per_info.prh_per_gpu_info.gpu_mode))
+        {
+          ret_val = PRH_ERR_INV_MODE_INFO;
+        }
+        break;
+
+      default:
+        ret_val = PRH_ERR_INV_PER_ID;
+        break;
+    }
+  }
+  return ret_val;
+}
+
+/****************************************************************************************
+* Function:    prh_gpu_drv_get_per_cfg_info
+* Parameters:  per_id - HW peripheral identifier
+*              p_cfg_info - pointer to power mode info 
+* Returns:     ePRH_RETURN_T - error or PRH_OK     
+* Description: Used to get the GPU power mode information
+*
+****************************************************************************************/
+ePRH_RETURN_T prh_gpu_drv_get_per_cfg_info(const ePRH_PER_ID_T per_id, sPRH_PER_CFG_T ** p_cfg_info)
+{
+  ePRH_RETURN_T ret_val = PRH_OK; 
+  
+  /* Check the peripheral identifier range */
+  if (PRH_PER_NOF_ID <= per_id)
+  {
+    ret_val = PRH_ERR_INV_PER_ID;
+  }
+  /* Check the pointer */
+  else if (NULL == p_cfg_info)
+  {
+    ret_val = PRH_ERR_INV_POINTER;
+  }
+  else
+  {
+    *p_cfg_info = NULL;
+    switch (per_id)
+    {
+      case PRH_PER_GPU:
+        *p_cfg_info = &prh_per_gpu_cfg_info;
+        break;
+
+      default:
+        ret_val = PRH_ERR_INV_PER_ID;
+        break;
+    }
+  }
+  return ret_val;
+}
+
+/****************************************************************************************
+* Function:    prh_gpu_drv_set_per_mode_info
+* Parameters:  per_id - HW peripheral identifier
+*              p_per_mode_info - power mode info requested from the user 
+* Returns:     ePRH_RETURN_T - error or PRH_OK     
+* Description: Used to update the GPU power mode information
+*
+****************************************************************************************/
+ePRH_RETURN_T prh_gpu_drv_set_per_mode_info(const ePRH_PER_ID_T per_id, const sPRH_PER_MODE_INFO_T * const p_per_mode_info)
+{
+  ePRH_RETURN_T ret_val = PRH_OK; 
+  
+  /* Check the peripheral identifier range */
+  if (PRH_PER_NOF_ID <= per_id)
+  {
+    ret_val = PRH_ERR_INV_PER_ID;
+  }
+  /* Check the pointer */
+  else if (NULL == p_per_mode_info)
+  {
+    ret_val = PRH_ERR_INV_POINTER;
+  }
+  else
+  {
+    switch (per_id)
+    {
+      case PRH_PER_GPU:
+        prh_per_gpu_mode.gpu_mode = p_per_mode_info->prh_per_info.prh_per_gpu_info.gpu_mode;
+        break;
+
+      default:
+        ret_val = PRH_ERR_INV_PER_ID;
+        break;
+    }
+  }
+  return ret_val;
+}
+
+/****************************************************************************************
+* Function:    prh_gpu_drv_get_per_seq_info
+* Parameters:  per_id - HW peripheral identifier
+*              p_per_mode_info - power mode info requested from the user
+*              p_seq_info - pointer to the power resource setting/configuration sequence to be loaded
+* Returns:     ePRH_RETURN_T - error or PRH_OK   
+* Description: Used to retrieve the power resource setting/configuration sequence depending on the 
+*              power mode info requested from the user
+*
+****************************************************************************************/
+ePRH_RETURN_T prh_gpu_drv_get_per_seq_info(const ePRH_PER_ID_T per_id, const sPRH_PER_MODE_INFO_T *const p_per_mode_info, const sPRH_PER_GEN_SEQ_INFO_T ** p_seq_info)
+{
+  ePRH_RETURN_T ret_val = PRH_OK; 
+
+  /* Check the peripheral identifier range */
+  if (PRH_PER_NOF_ID <= per_id)
+  {
+    ret_val = PRH_ERR_INV_PER_ID;
+  }
+  /* Check the pointer */
+  else if (NULL == p_per_mode_info)
+  {
+    ret_val = PRH_ERR_INV_POINTER;
+  }
+  /* Check the pointer */
+  else if (NULL == p_seq_info)
+  {
+    ret_val = PRH_ERR_INV_POINTER;
+  }
+  else
+  {
+    *p_seq_info = NULL;  
+    switch (per_id)
+    {
+      case PRH_PER_GPU:
+        {
+          /* retrieve the user requested power mode for gpu peripheral */
+          ePRH_PER_GPU_MODE_T curr_mode = prh_per_gpu_mode.gpu_mode;
+          ePRH_PER_GPU_MODE_T next_mode = p_per_mode_info->prh_per_info.prh_per_gpu_info.gpu_mode;
+          /* retrieve the power resources setting table */
+          *p_seq_info = p_prh_per_gpu_seq_table[(U32)curr_mode - (U32)PRH_PER_GPU_MODE_START][(U32)next_mode - (U32)PRH_PER_GPU_MODE_START];
+        }   
+        break;
+      
+      default:
+        ret_val = PRH_ERR_INV_PER_ID;
+        break;
+    }
+  }
+  return ret_val;
+}
+
+
diff --git a/devices/pm/power_management/prh/src/board_sf_3gx/prh_mmcsd_drv_cfg.c b/devices/pm/power_management/prh/src/board_sf_3gx/prh_mmcsd_drv_cfg.c
new file mode 120000
index 0000000..2eec338
--- /dev/null
+++ b/devices/pm/power_management/prh/src/board_sf_3gx/prh_mmcsd_drv_cfg.c
@@ -0,0 +1 @@
+../board_sf_3gr/prh_mmcsd_drv_cfg.c
\ No newline at end of file
diff --git a/devices/pm/power_management/prh/src/board_sf_3gx/prh_pwm_drv_cfg.c b/devices/pm/power_management/prh/src/board_sf_3gx/prh_pwm_drv_cfg.c
new file mode 120000
index 0000000..256947a
--- /dev/null
+++ b/devices/pm/power_management/prh/src/board_sf_3gx/prh_pwm_drv_cfg.c
@@ -0,0 +1 @@
+../board_sf_3gr/prh_pwm_drv_cfg.c
\ No newline at end of file
diff --git a/devices/pm/power_management/prh/src/board_sf_3gx/prh_pwm_drv_cfg.h b/devices/pm/power_management/prh/src/board_sf_3gx/prh_pwm_drv_cfg.h
new file mode 120000
index 0000000..e52e2b1
--- /dev/null
+++ b/devices/pm/power_management/prh/src/board_sf_3gx/prh_pwm_drv_cfg.h
@@ -0,0 +1 @@
+../board_sf_3gr/prh_pwm_drv_cfg.h
\ No newline at end of file
diff --git a/devices/pm/power_management/prh/src/board_sf_3gx/prh_rga_drv_cfg.c b/devices/pm/power_management/prh/src/board_sf_3gx/prh_rga_drv_cfg.c
new file mode 120000
index 0000000..380af03
--- /dev/null
+++ b/devices/pm/power_management/prh/src/board_sf_3gx/prh_rga_drv_cfg.c
@@ -0,0 +1 @@
+../board_sf_3gr/prh_rga_drv_cfg.c
\ No newline at end of file
diff --git a/devices/pm/power_management/prh/src/board_sf_3gx/prh_rga_drv_cfg.h b/devices/pm/power_management/prh/src/board_sf_3gx/prh_rga_drv_cfg.h
new file mode 120000
index 0000000..efe33fe
--- /dev/null
+++ b/devices/pm/power_management/prh/src/board_sf_3gx/prh_rga_drv_cfg.h
@@ -0,0 +1 @@
+../board_sf_3gr/prh_rga_drv_cfg.h
\ No newline at end of file
diff --git a/devices/pm/power_management/prh/src/board_sf_3gx/prh_usb_drv_cfg.c b/devices/pm/power_management/prh/src/board_sf_3gx/prh_usb_drv_cfg.c
new file mode 100644
index 0000000..1b8a368
--- /dev/null
+++ b/devices/pm/power_management/prh/src/board_sf_3gx/prh_usb_drv_cfg.c
@@ -0,0 +1,563 @@
+/*
+ *       Copyright (C) 2013 Intel Mobile Communications GmbH
+ *
+ *            Sec Class: Intel Confidential (IC)
+ *
+ *
+ * This document contains proprietary information belonging to IMC.
+ * Passing on and copying of this document, use and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * Description:
+ *   This file contains the POW driver voltage handling part.
+ *
+ * Revision Information:
+ *  $File name:  /mhw_drv_src/power_management/prh/src/sf_3g_soc_agold620/prh_usb_drv_cfg.c $
+ *   Comment:
+ *
+ * =============================================================================
+ * History:
+ *
+ * Date         Author       Comment
+ * -----------------------------------------------------------------------------
+ * 2013-04-22   A. Caruso    initial xmm6321
+ * 2013-05-08   SaiManohar   Removal of USB call-back for xgold6321
+ * 2013-06-19   Shivaprashanth SMS03856491 - updated USB 1V1 to 1.1V
+ * =========================================================================*/
+
+/*--------------------------------------------------------------------------------------
+USB HS peripheral                   ENABLE_ISO      ENABLE      SUSPEND     DISABLE
+power resources
+----------------------------------------------------------------------------------------
+
+Init mode:                          --              ENABLE      --          --
+
+Power Subdomains:
+POW_CONTROL_SUB_D_USB_HS            ON(boot)        ON (boot)   OFF         OFF
+(USB_HS_CT)
+
+Clocks:
+POW_CONTROL_USB_HS_BUS_CLK          52 MHz          52 MHz      OFF         OFF
+(clk_ahb_per2)
+POW_CONTROL_USB_HS_KERNEL_CLK       52 MHz          52 MHz      OFF         OFF
+(clk_usb_hs)
+POW_CONTROL_USB_PLL_E_480M_CLK      480 MHz         480 MHz     OFF         OFF
+
+Voltages:
+POW_CONTROL_VDD_USB_1V1             1.1V            1.1V        1.1V        OFF
+(VDD_USB_HS_PH_DIG)
+
+
+Isolation:                          ON              OFF         OFF         ON
+(usb_hs_dig_iso)
+
+--------------------------------------------------------------------------------------*/
+
+/*
+Power Up Sequence (updated according to data sheet):
+----------------------------------------------------
+[USB Drv] scu_reset_module_state ON
+[USB Drv] usbpow_otg_set_scu_usb_cnf_hsrfs ON
+[PRH Drv] prh_set_per_mode(PRH_PER_USB_HS_ENABLE)
+-   Enable clk_ahb_per2
+-   Enable clk_usb_hs (No effect: always running)
+-   Enable PLLE (480MHz)
+-   Enable VDDP_USB (3.1V)
+-   Enable VDD_USB_HS_PH_DIG (1.1V)
+-   Enable Subdomain USB_HS_CT
+        SPCUPsc.USB_HS_PDN = 0
+[USB Drv] Declamp USB
+-   PCGCCTL.StopClk = 0
+-   PCGCCTL.PwrClmp =0
+-   PCGCCTL.RstPdwnModule = 0
+[PRH Drv] prh_set_per_mode(PRH_PER_USB_HS_ENABLE_ISO)
+-   Wait for all LDOs completely powered up (50s)
+-   Remove Isolation (usb_hs_dig_iso)
+        SPCUPsc.USB_HS_DIG_ISO = 1
+-   Wait 10mics.
+[USB Drv] scu_reset_module_state OFF
+[USB Drv] usbpow_otg_set_scu_usb_cnf_hsrfs OFF
+*/
+
+/*
+Power down sequence
+-------------------
+[USB Drv]Clamp USB HS
+-   PCGCCTL.PwrClmp =1
+-   PCGCCTL.RstPdwnModule = 1
+-   PCGCCTL.StopClk = 1
+[PRH Drv] prh_set_per_mode
+-   Disable PLLE (480MHz)
+-   Disable clk_usb_hs (No effect: always running)
+-   Disable clk_ahb_per2
+-   Disable subdomain USB_HS_CT
+        SPCUPsc.USB_HS_PDN = 1
+-   Add isolation
+        SPCUPsc.USB_HS_DIG_ISO = 0
+-   Disable VDDP_USB (3.1V)
+-   Disable VDD_USB_HS_PH_DIG (1.1V)
+*/
+
+/*     State transitions supported
+
+-   DISABLE -> ENABLE (power-up)
+-   ENABLE -> ENABLE_ISO (power-up)
+-   ENABLE_ISO -> SUSPEND (suspend)
+-   ENABLE_ISO -> SUSPEND_NO_PSV  (suspend)
+-   SUSPEND -> ENABLE_ISO (wake-up)
+-   SUSPEND_NO_PSV -> ENABLE_ISO (wake-up)
+-   SUSPEND -> DISABLE (disable)
+-   SUSPEND_NO_PSV -> DISABLE (disable)
+-   ENABLE_ISO -> DISABLE (disable)
+*/
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/* INCLUDES                                                                                                      */
+/*---------------------------------------------------------------------------------------------------------------*/
+#include "prh.h"
+#include "prh_internal.h"
+#include "prh_cfg_internal.h"
+#include "pow_driverif_chip.h"
+#include "spcu_internal.h"
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/* DEFINES                                                                                                       */
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/* Number of power logical modes */
+#define PRH_PER_USB_HS_NOF_MODES (U32)PRH_PER_USB_HS_MODE_END - (U32)PRH_PER_USB_HS_MODE_START
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/* TYPE DEFINITIONS                                                                                              */
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/* USB HS peripheral power resources */
+typedef struct
+{
+  sPRH_PER_CLOCK_CFG_INFO_T bus_clk;
+  sPRH_PER_CLOCK_CFG_INFO_T kernel_clk;
+  sPRH_PER_CLOCK_CFG_INFO_T pll_e_clk;
+  POW_CONTROL_POWER_SUB_D_T subdom;
+  sPRH_PER_VOLT_SET_INFO_T  vdd_phy;
+  sPRH_PER_VOLT_SET_INFO_T  vddp_phy;
+  T_SPCU_POWCTRL            spcu_user;
+  POW_CONTROL_ID_T          psv;
+}sPRH_PER_USB_HS_POW_RES_INFO_T;
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/* INTERNAL FUNCTION DECLARATIONS                                                                                */
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/* INTERNAL VARIABLE DEFINITIONS                                                                                 */
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/* USB HS peripheral                                                                                             */
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/* USB HS peripheral mode info */
+static sPRH_PER_USB_HS_INFO_T prh_per_usb_hs_mode =
+{
+  PRH_PER_USB_HS_MODE_START,
+};
+
+/* USB HS peripheral configuration info */
+static sPRH_PER_CFG_T prh_per_usb_hs_cfg_info =
+{
+  (uPRH_PER_INFO_T *)&prh_per_usb_hs_mode,
+  PRH_PER_UNLOCKED
+};
+
+/* USB HS peripheral power resources configuration */
+static const sPRH_PER_USB_HS_POW_RES_INFO_T  prh_per_usb_hs_pow_res =
+{
+  /* bus_clk         */ {POW_CONTROL_USB_HS_BUS_CLK,     POW_CONTROL_FREQ_52M,   POW_CONTROL_FREQ_DONT_CARE},
+  /* kernel_clk      */ {POW_CONTROL_USB_HS_KERNEL_CLK,  POW_CONTROL_FREQ_52M,    POW_CONTROL_FREQ_52M},
+  /* pll_e_clk       */ {POW_CONTROL_USB_PLL_E_480M_CLK, POW_CONTROL_FREQ_480M,  POW_CONTROL_FREQ_480M},
+  /* subdom          */ POW_CONTROL_SUB_D_USB_HS,
+  /* vdd_phy         */ {POW_CONTROL_VDD_USB_1V1,        POW_CONTROL_VOLTAGE_1V10},
+  /* vddp_phy        */ {POW_CONTROL_VDD_USB_3V3,        POW_CONTROL_VOLTAGE_3V15},
+  /* spcu_user       */ SPCU_USB_HS_PHY,
+  /* psv             */ POW_CONTROL_USB_HS_ID
+};
+
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/* Init power resources sequence */
+/* Internal state transition:
+ * - [S0] PRH_PER_USB_HS_MODE_START --> [S1] PRH_PER_USB_HS_DISABLE
+ */
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_usb_hs_s0_to_s1_seq[] =
+{
+  {PRH_PER_CLK_CFG_CMD,    (void *)&prh_per_usb_hs_pow_res.bus_clk},
+  {PRH_PER_CLK_CFG_CMD,    (void *)&prh_per_usb_hs_pow_res.kernel_clk},
+  {PRH_PER_CLK_CFG_CMD,    (void *)&prh_per_usb_hs_pow_res.pll_e_clk},
+  {PRH_PER_END_CMD,        NULL},
+};
+
+/* Enable power resources sequence */
+/* Internal state transition:
+ * - [S1] PRH_PER_USB_HS_DISABLE --> [S4] PRH_PER_USB_HS_ENABLE
+ */
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_usb_hs_s1_to_s4_seq[] =
+{
+  {PRH_PER_CLK_ON_CMD,     (void *)&prh_per_usb_hs_pow_res.bus_clk},
+  {PRH_PER_CLK_ON_CMD,     (void *)&prh_per_usb_hs_pow_res.kernel_clk},
+  {PRH_PER_CLK_ON_CMD,     (void *)&prh_per_usb_hs_pow_res.pll_e_clk},
+  {PRH_PER_VOLT_ON_CMD,    (void *)&prh_per_usb_hs_pow_res.vddp_phy},
+  {PRH_PER_VOLT_ON_CMD,    (void *)&prh_per_usb_hs_pow_res.vdd_phy},
+  {PRH_PER_SUBDOM_ON_CMD,  (void *)&prh_per_usb_hs_pow_res.subdom},
+  {PRH_PER_END_CMD,        NULL},
+};
+
+/* Disable the isolation, called after usb de-clamp */
+/* Internal state transition:
+ * - [S4] PRH_PER_USB_HS_ENABLE --> [S5] PRH_PER_USB_HS_ENABLE_ISO
+ */
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_usb_hs_s4_to_s5_seq[] =
+{
+  {PRH_PER_WAIT_CMD,       NULL},
+  {PRH_PER_SPCU_ON_CMD,    (void *)&prh_per_usb_hs_pow_res.spcu_user},
+  {PRH_PER_WAIT_CMD,       NULL},
+  {PRH_PER_PSV_OFF_CMD,    (void *)&prh_per_usb_hs_pow_res.psv},
+  {PRH_PER_END_CMD,        NULL},
+};
+
+/* Suspend power resources sequence */
+/* Internal state transition:
+ * - [S5] PRH_PER_USB_HS_ENABLE_ISO --> [S2] PRH_PER_USB_HS_SUSPEND
+ */
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_usb_hs_s5_to_s2_seq[] =
+{
+  {PRH_PER_CLK_OFF_CMD,    (void *)&prh_per_usb_hs_pow_res.pll_e_clk},
+  {PRH_PER_CLK_OFF_CMD,    (void *)&prh_per_usb_hs_pow_res.kernel_clk},
+  {PRH_PER_CLK_OFF_CMD,    (void *)&prh_per_usb_hs_pow_res.bus_clk},
+  {PRH_PER_SUBDOM_OFF_CMD, (void *)&prh_per_usb_hs_pow_res.subdom},
+  {PRH_PER_PSV_ON_CMD,     (void *)&prh_per_usb_hs_pow_res.psv},
+  {PRH_PER_END_CMD,        NULL},
+};
+
+/* Suspend power resources sequence with no power saving */
+/* Internal state transition:
+ * - [S5] PRH_PER_USB_HS_ENABLE_ISO --> [S3] PRH_PER_USB_HS_SUSPEND_NO_PSV
+ */
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_usb_hs_s5_to_s3_seq[] =
+{
+  {PRH_PER_CLK_OFF_CMD,    (void *)&prh_per_usb_hs_pow_res.pll_e_clk},
+  {PRH_PER_CLK_OFF_CMD,    (void *)&prh_per_usb_hs_pow_res.kernel_clk},
+  {PRH_PER_CLK_OFF_CMD,    (void *)&prh_per_usb_hs_pow_res.bus_clk},
+  {PRH_PER_SUBDOM_OFF_CMD, (void *)&prh_per_usb_hs_pow_res.subdom},
+  {PRH_PER_END_CMD,        NULL},
+};
+
+/* Resume power resources sequence */
+/* Internal state transition:
+ * - [S2] PRH_PER_USB_HS_SUSPEND --> [S5] PRH_PER_USB_HS_ENABLE_ISO
+ */
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_usb_hs_s2_to_s5_seq[] =
+{
+  {PRH_PER_PSV_OFF_CMD,    (void *)&prh_per_usb_hs_pow_res.psv},
+  {PRH_PER_SUBDOM_ON_CMD,  (void *)&prh_per_usb_hs_pow_res.subdom},
+  {PRH_PER_CLK_ON_CMD,     (void *)&prh_per_usb_hs_pow_res.bus_clk},
+  {PRH_PER_CLK_ON_CMD,     (void *)&prh_per_usb_hs_pow_res.kernel_clk},
+  {PRH_PER_CLK_ON_CMD,     (void *)&prh_per_usb_hs_pow_res.pll_e_clk},
+  {PRH_PER_END_CMD,        NULL},
+};
+
+/* Resume power resources sequence with power saving enabled */
+/* Internal state transition:
+ * - [S3] PRH_PER_USB_HS_SUSPEND_NO_PSV --> [S5] PRH_PER_USB_HS_ENABLE_ISO
+ */
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_usb_hs_s3_to_s5_seq[] =
+{
+  {PRH_PER_SUBDOM_ON_CMD,  (void *)&prh_per_usb_hs_pow_res.subdom},
+  {PRH_PER_CLK_ON_CMD,     (void *)&prh_per_usb_hs_pow_res.bus_clk},
+  {PRH_PER_CLK_ON_CMD,     (void *)&prh_per_usb_hs_pow_res.kernel_clk},
+  {PRH_PER_CLK_ON_CMD,     (void *)&prh_per_usb_hs_pow_res.pll_e_clk},
+  {PRH_PER_END_CMD,        NULL},
+};
+
+/* Disable  power resources sequence */
+/* Internal state transition:
+ * - [S5] PRH_PER_USB_HS_ENABLE_ISO --> [S1] PRH_PER_USB_HS_DISABLE
+ */
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_usb_hs_s5_to_s1_seq[] =
+{
+  {PRH_PER_CLK_OFF_CMD,    (void *)&prh_per_usb_hs_pow_res.pll_e_clk},
+  {PRH_PER_CLK_OFF_CMD,    (void *)&prh_per_usb_hs_pow_res.kernel_clk},
+  {PRH_PER_CLK_OFF_CMD,    (void *)&prh_per_usb_hs_pow_res.bus_clk},
+  {PRH_PER_SUBDOM_OFF_CMD, (void *)&prh_per_usb_hs_pow_res.subdom},
+  {PRH_PER_VOLT_OFF_CMD,   (void *)&prh_per_usb_hs_pow_res.vddp_phy},  
+  {PRH_PER_VOLT_OFF_CMD,   (void *)&prh_per_usb_hs_pow_res.vdd_phy},
+  {PRH_PER_PSV_ON_CMD,     (void *)&prh_per_usb_hs_pow_res.psv},
+  {PRH_PER_END_CMD,        NULL},
+};
+
+/* Disable  power resources sequence */
+/* Internal state transition:
+ * - [S2] PRH_PER_USB_HS_SUSPEND --> [S1] PRH_PER_USB_HS_DISABLE
+ */
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_usb_hs_s2_to_s1_seq[] =
+{
+  {PRH_PER_VOLT_OFF_CMD,	 (void *)&prh_per_usb_hs_pow_res.vddp_phy},
+  {PRH_PER_VOLT_OFF_CMD,   (void *)&prh_per_usb_hs_pow_res.vdd_phy},
+  {PRH_PER_END_CMD,        NULL},
+};
+
+/* Disable  power resources sequence along with power saving */
+/* Internal state transition:
+ * - [S3] PRH_PER_USB_HS_SUSPEND_NO_PSV --> [S1] PRH_PER_USB_HS_DISABLE
+ */
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_usb_hs_s3_to_s1_seq[] =
+{
+  {PRH_PER_VOLT_OFF_CMD,	 (void *)&prh_per_usb_hs_pow_res.vddp_phy},
+  {PRH_PER_VOLT_OFF_CMD,   (void *)&prh_per_usb_hs_pow_res.vdd_phy},
+  {PRH_PER_PSV_ON_CMD,     (void *)&prh_per_usb_hs_pow_res.psv},
+  {PRH_PER_END_CMD,        NULL},
+};
+
+/* Dummy power resources sequences */
+static const sPRH_PER_GEN_SEQ_INFO_T prh_per_dummy_seq[] =
+{
+  {PRH_PER_END_CMD,      NULL},
+};
+
+/* The table maps the peripheral power resources sequences according to the current
+   power mode of the peripheral and the requested power mode of the user
+   [S0] PRH_PER_USB_HS_MODE_START
+   [S1] PRH_PER_USB_HS_DISABLE
+   [S2] PRH_PER_USB_HS_SUSPEND
+   [S3] PRH_PER_USB_HS_SUSPEND_NO_PSV
+   [S4] PRH_PER_USB_HS_ENABLE
+   [S5] PRH_PER_USB_HS_ENABLE_ISO
+*/
+static const sPRH_PER_GEN_SEQ_INFO_T * p_prh_per_usb_hs_seq_table[PRH_PER_USB_HS_NOF_MODES][PRH_PER_USB_HS_NOF_MODES] =
+{
+                  /* next mode */
+/*current mode */ /* S0    S1                               S2                               S3                               S4                               S5*/
+/* S0 */            {NULL, &prh_per_usb_hs_s0_to_s1_seq[0], NULL,                            NULL,                            NULL,                            NULL},
+/* S1 */            {NULL, &prh_per_dummy_seq[0],           NULL,                            NULL,                            &prh_per_usb_hs_s1_to_s4_seq[0], NULL},
+/* S2 */            {NULL, &prh_per_usb_hs_s2_to_s1_seq[0], &prh_per_dummy_seq[0],           NULL,                            NULL,                            &prh_per_usb_hs_s2_to_s5_seq[0]},
+/* S3 */            {NULL, &prh_per_usb_hs_s3_to_s1_seq[0], NULL,                            &prh_per_dummy_seq[0],           NULL,                            &prh_per_usb_hs_s3_to_s5_seq[0]},
+/* S4 */            {NULL, NULL,                            NULL,                            NULL,                            &prh_per_dummy_seq[0],           &prh_per_usb_hs_s4_to_s5_seq[0]},
+/* S5 */            {NULL, &prh_per_usb_hs_s5_to_s1_seq[0], &prh_per_usb_hs_s5_to_s2_seq[0], &prh_per_usb_hs_s5_to_s3_seq[0], NULL,                            &prh_per_dummy_seq[0]},
+};
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/* INTERNAL FUNCTION DECLARATIONS                                                                                */
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/* EXPORTED FUNCTIONS                                                                                            */
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/****************************************************************************************
+* Function:    prh_usb_drv_get_init_per_mode_info
+* Parameters:  per_id - HW peripheral identifier
+*              p_per_mode_info - pointer to peripheral power mode info
+* Returns:     ePRH_RETURN_T - error or PRH_OK
+* Description: Used to get the USB peripherals initial power mode settings
+*
+****************************************************************************************/
+ePRH_RETURN_T prh_usb_drv_get_init_per_mode_info (const ePRH_PER_ID_T per_id, sPRH_PER_MODE_INFO_T * p_per_mode_info)
+{
+  ePRH_RETURN_T ret_val = PRH_OK;
+
+  /* Check the peripheral identifier range */
+  if (PRH_PER_NOF_ID <= per_id)
+  {
+    ret_val = PRH_ERR_INV_PER_ID;
+  }
+  /* Check the pointer */
+  else if (NULL == p_per_mode_info)
+  {
+    ret_val = PRH_ERR_INV_POINTER;
+  }
+  else
+  {
+    switch (per_id)
+    {
+      /* USB HS */
+      case PRH_PER_USB_HS:
+        p_per_mode_info->prh_per_type = PRH_PER_TYPE_USB_HS;
+        p_per_mode_info->prh_per_info.prh_per_usb_hs_info.usb_hs_mode = PRH_PER_USB_HS_DISABLE;
+        break;
+
+      default:
+        ret_val = PRH_ERR_INV_PER_ID;
+        break;
+    }
+  }
+  return ret_val;
+}
+
+/****************************************************************************************
+* Function:    prh_usb_drv_check_per_mode_info
+* Parameters:  per_id - HW peripheral identifier
+*              p_per_mode_info - pointer to peripheral power mode info
+* Returns:     ePRH_RETURN_T - error or PRH_OK
+* Description: Used to check the USB peripherals power mode settings range
+*
+****************************************************************************************/
+ePRH_RETURN_T prh_usb_drv_check_per_mode_info(const ePRH_PER_ID_T per_id, const sPRH_PER_MODE_INFO_T * const p_per_mode_info)
+{
+  ePRH_RETURN_T ret_val = PRH_OK;
+
+  /* Check the peripheral identifier range */
+  if (PRH_PER_NOF_ID <= per_id)
+  {
+    ret_val = PRH_ERR_INV_PER_ID;
+  }
+  /* Check the pointer */
+  else if (NULL == p_per_mode_info)
+  {
+    ret_val = PRH_ERR_INV_POINTER;
+  }
+  else
+  {
+    switch (per_id)
+    {
+      /* USB HS */
+      case PRH_PER_USB_HS:
+        if ((PRH_PER_USB_HS_MODE_START >= p_per_mode_info->prh_per_info.prh_per_usb_hs_info.usb_hs_mode) ||
+            (PRH_PER_USB_HS_MODE_END   <= p_per_mode_info->prh_per_info.prh_per_usb_hs_info.usb_hs_mode))
+        {
+          ret_val = PRH_ERR_INV_MODE_INFO;
+        }
+        break;
+
+      default:
+        ret_val = PRH_ERR_INV_PER_ID;
+        break;
+    }
+  }
+  return ret_val;
+}
+
+/****************************************************************************************
+* Function:    prh_usb_drv_get_per_cfg_info
+* Parameters:  per_id - HW peripheral identifier
+*              p_cfg_info - pointer to power mode info
+* Description: Used to get the USB power mode information
+*
+****************************************************************************************/
+ePRH_RETURN_T prh_usb_drv_get_per_cfg_info(const ePRH_PER_ID_T per_id, sPRH_PER_CFG_T ** p_cfg_info)
+{
+  ePRH_RETURN_T ret_val = PRH_OK;
+
+  /* Check the peripheral identifier range */
+  if (PRH_PER_NOF_ID <= per_id)
+  {
+    ret_val = PRH_ERR_INV_PER_ID;
+  }
+  /* Check the pointer */
+  else if (NULL == p_cfg_info)
+  {
+    ret_val = PRH_ERR_INV_POINTER;
+  }
+  else
+  {
+    *p_cfg_info = NULL;
+    switch (per_id)
+    {
+      case PRH_PER_USB_HS:
+        *p_cfg_info = &prh_per_usb_hs_cfg_info;
+        break;
+
+      default:
+        ret_val = PRH_ERR_INV_PER_ID;
+        break;
+    }
+  }
+  return ret_val;
+}
+
+/****************************************************************************************
+* Function:    prh_usb_drv_set_per_mode_info
+* Parameters:  per_id - HW peripheral identifier
+*              p_per_mode_info - power mode info requested from the user
+* Description: Used to update the USB power mode information
+*
+****************************************************************************************/
+ePRH_RETURN_T prh_usb_drv_set_per_mode_info(const ePRH_PER_ID_T per_id, const sPRH_PER_MODE_INFO_T * const p_per_mode_info)
+{
+  ePRH_RETURN_T ret_val = PRH_OK;
+
+  /* Check the peripheral identifier range */
+  if (PRH_PER_NOF_ID <= per_id)
+  {
+    ret_val = PRH_ERR_INV_PER_ID;
+  }
+  /* Check the pointer */
+  else if (NULL == p_per_mode_info)
+  {
+    ret_val = PRH_ERR_INV_POINTER;
+  }
+  else
+  {
+    switch (per_id)
+    {
+      case PRH_PER_USB_HS:
+        prh_per_usb_hs_mode.usb_hs_mode = p_per_mode_info->prh_per_info.prh_per_usb_hs_info.usb_hs_mode;
+        break;
+
+      default:
+        ret_val = PRH_ERR_INV_PER_ID;
+      break;
+    }
+  }
+  return ret_val;
+}
+
+/****************************************************************************************
+* Function:    prh_usb_drv_get_per_seq_info
+* Parameters:  per_id - HW peripheral identifier
+*              p_per_mode_info - power mode info requested from the user
+*              p_seq_info - pointer to the power resource setting/configuration sequence to be loaded
+* Returns:     ePRH_RETURN_T - error or PRH_OK
+* Description: Used to retrieve the USIF power resource setting/configuration sequence depending on the
+*              power mode info requested from the user
+*
+****************************************************************************************/
+ePRH_RETURN_T prh_usb_drv_get_per_seq_info(const ePRH_PER_ID_T per_id, const sPRH_PER_MODE_INFO_T * const p_per_mode_info, const sPRH_PER_GEN_SEQ_INFO_T ** p_seq_info)
+{
+  ePRH_RETURN_T ret_val = PRH_OK;
+
+  /* Check the peripheral identifier range */
+  if (PRH_PER_NOF_ID <= per_id)
+  {
+    ret_val = PRH_ERR_INV_PER_ID;
+  }
+  /* Check the pointer */
+  else if (NULL == p_per_mode_info)
+  {
+    ret_val = PRH_ERR_INV_POINTER;
+  }
+  /* Check the pointer */
+  else if (NULL == p_seq_info)
+  {
+    ret_val = PRH_ERR_INV_POINTER;
+  }
+  else
+  {
+    *p_seq_info = NULL;
+    switch (per_id)
+    {
+      case PRH_PER_USB_HS:
+        {
+          /* retrieve the user requested power mode for USB HS peripheral */
+          ePRH_PER_USB_HS_MODE_T curr_mode = (prh_per_usb_hs_mode.usb_hs_mode);
+          ePRH_PER_USB_HS_MODE_T next_mode = (p_per_mode_info->prh_per_info.prh_per_usb_hs_info.usb_hs_mode);
+          /* retrieve the power resources setting table */
+          *p_seq_info = p_prh_per_usb_hs_seq_table[(U32)curr_mode - (U32)PRH_PER_USB_HS_MODE_START][(U32)next_mode - (U32)PRH_PER_USB_HS_MODE_START];
+        }
+        break;
+
+      default:
+        ret_val = PRH_ERR_INV_PER_ID;
+        break;
+    }
+  }
+  return ret_val;
+}
diff --git a/devices/pm/power_management/prh/src/board_sf_3gx/prh_usb_drv_cfg.h b/devices/pm/power_management/prh/src/board_sf_3gx/prh_usb_drv_cfg.h
new file mode 100644
index 0000000..74ebae6
--- /dev/null
+++ b/devices/pm/power_management/prh/src/board_sf_3gx/prh_usb_drv_cfg.h
@@ -0,0 +1,103 @@
+/*
+ *       Copyright (C) 2013 Intel Mobile Communications GmbH
+ *       
+ *            Sec Class: Intel Confidential (IC)
+ *       
+ *
+ * This document contains proprietary information belonging to IMC.
+ * Passing on and copying of this document, use and communication
+ * of its contents is not permitted without prior written authorisation.
+ *
+ * Description:
+ *     This headerfile contains the interface for the configuration depending handling of USB peripheral.
+ *
+ * Revision Information:
+ *  $File name:  /mhw_drv_src/power_management/prh/src/sf_3g_soc_agold620/prh_usb_drv_cfg.h $
+ *   Comment:
+ *     Power Concept 4 implementation
+ *
+ * =============================================================================
+ * History:
+ *
+ * Date         Author             Comment
+ * -----------------------------------------------------------------------------
+ * 2010-10-15   A. Caruso          initial
+ * ===========================================================================*/
+
+#ifndef __PRH_USB_DRV_CFG_INTERNAL_H__
+#define __PRH_USB_DRV_CFG_INTERNAL_H__
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/* TYPE DEFINITIONS                                                                                              */
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/* EXTERNAL DATA STRUCTURES                                                                                      */
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/* EXTERNAL FUNCTION DECLARATIONS                                                                                */
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/** @brief Used to get the USB peripherals initial power mode settings
+  * @ingroup prh_internalif_grp
+  *
+  * @param per_id contains the HW peripheral identifier  
+  * @param p_per_mode_info contains the pointer to init power mode setting information of the HW peripheral
+  * @return ePRH_RETURN_T: error code or PRH_OK 
+  */
+ePRH_RETURN_T prh_usb_drv_get_init_per_mode_info (const ePRH_PER_ID_T per_id, sPRH_PER_MODE_INFO_T * p_per_mode_info);
+
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/** @brief Used to check the USB peripherals power mode settings range 
+  * @ingroup prh_internalif_grp
+  *
+  * @param per_id contains the HW peripheral identifier  
+  * @param p_per_mode_info contains the pointer to power mode setting information of the HW peripheral
+  * @return ePRH_RETURN_T: error code or PRH_OK 
+  */
+ePRH_RETURN_T prh_usb_drv_check_per_mode_info(const ePRH_PER_ID_T per_id, const sPRH_PER_MODE_INFO_T * const p_per_mode_info);
+
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/** @brief Used to retrieve the pointer to the USB peripherals power mode info.
+  * @ingroup prh_internalif_grp
+  *
+  * @param per_id contains the HW peripheral identifier  
+  * @param p_cfg_info contains the pointer to power mode info
+  * @return ePRH_RETURN_T: error code or PRH_OK 
+  */
+ePRH_RETURN_T prh_usb_drv_get_per_cfg_info(const ePRH_PER_ID_T per_id, sPRH_PER_CFG_T ** p_cfg_info);
+
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/** @brief Used to set the power mode of the USB peripherals.
+  * @ingroup prh_internalif_grp
+  *
+  * @param per_id contains the HW peripheral identifier
+  * @param p_per_mode_info contains the pointer to power mode setting information of the HW peripheral
+  * @return ePRH_RETURN_T: error code or PRH_OK 
+  */
+ePRH_RETURN_T prh_usb_drv_set_per_mode_info(const ePRH_PER_ID_T per_id, const sPRH_PER_MODE_INFO_T * const p_per_mode_info);
+
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/** @brief Used to retrieve the pointer to the power resources configuration steps according to the power mode requested from the user.
+  * @ingroup prh_internalif_grp
+  *
+  * @param per_id contains the HW peripheral identifier
+  * @param p_per_mode_info contains the pointer to power mode setting information of the HW peripheral
+  * @param p_seq_info contains the pointer to the power resource configuration steps
+  * @return ePRH_RETURN_T: error code or PRH_OK 
+  */
+ePRH_RETURN_T prh_usb_drv_get_per_seq_info(const ePRH_PER_ID_T per_id, const sPRH_PER_MODE_INFO_T * const p_per_mode_info, const sPRH_PER_GEN_SEQ_INFO_T ** const p_seq_info);
+
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/* END                                                                                                           */
+/*---------------------------------------------------------------------------------------------------------------*/
+
+#endif //__PRH_USB_DRV_CFG_INTERNAL_H__
diff --git a/devices/scu/src/sofia3gx b/devices/scu/src/sofia3gx
new file mode 120000
index 0000000..00d525b
--- /dev/null
+++ b/devices/scu/src/sofia3gx
@@ -0,0 +1 @@
+sofia3gr
\ No newline at end of file
diff --git a/devices/stm/src/sofia3gx b/devices/stm/src/sofia3gx
new file mode 120000
index 0000000..00d525b
--- /dev/null
+++ b/devices/stm/src/sofia3gx
@@ -0,0 +1 @@
+sofia3gr
\ No newline at end of file
diff --git a/devices/tado/src/sofia3gx b/devices/tado/src/sofia3gx
new file mode 120000
index 0000000..00d525b
--- /dev/null
+++ b/devices/tado/src/sofia3gx
@@ -0,0 +1 @@
+sofia3gr
\ No newline at end of file
diff --git a/make/configs/sofia3gx/platform_common.cfg b/make/configs/sofia3gx/platform_common.cfg
new file mode 100644
index 0000000..edddfb9
--- /dev/null
+++ b/make/configs/sofia3gx/platform_common.cfg
@@ -0,0 +1,75 @@
+CPU             =
+PLATFORMFOLDER  = sofia3gx
+CHIPID          = sf_3gr_soc
+ACHIPID         = agold620
+BOARDID         = board_sf_3gx
+BOARD_REV       = es_1_0
+CHIP_REV        = es_1_0
+PRG_FILE        =
+DELIVERYEXCLUDELIST = $(DELIVERYFILESDIR)/$(PROJECTFOLDER)/exclude.list
+
+C_DEFINES += SF3GX_EXTPMIC
+C_DEFINES += VMM_PRH_QUEUE_ENABLE
+C_DEFINES += SF_R_ES_1_0
+# Open vop boot display at SLB
+C_DEFINES += CONFIG_BOOT_DISPLAY
+C_DEFINES += EMIC_PRIO_DISABLE
+#C_DEFINES += VMM_SCU_WDT_PRESENT
+
+C_DEFINES += SF3GX_VCPU_I2C_CTRL
+C_DEFINES += SF3GR_GARNET_4_LEVEL_CPUFREQ
+
+# Define to support CPU Max Clk Freq @ 1.16GHz (Only for SF3GR ES2.0)
+C_DEFINES += CPU_MAX_FREQ_1160MHZ
+
+#This retains the RTC in Sync mode always and switches to Async mode only when we enter the sleep mode.
+C_DEFINES += RTC_IN_SYNC_MODE_WORKAROUND
+
+##SF_3G_ES1.0 will follow SF_3G_ES2.1 
+###C_DEFINES += FEAT_RESET_IDI
+C_DEFINES += SF_ES_2_0
+C_DEFINES += SF3G_AGOLD_VER_2_0_1
+C_DEFINES += SF_ES_2_1
+
+## NOTE: Uncomment below to run CPU @ 1GHz; else default CPU @ 728MHz
+#C_DEFINES += POWER_CPU_FREQUENCY_AT_1040GHZ
+
+# NOTE:Define below to run CPU @ 208Mhz after bootup, should be used only for Vmodem
+#C_DEFINES += POWER_CPU_FREQUENCY_AT_208GHZ_VMODEM
+
+ifeq '$(findstring _DVFS_,${PLATFORM})' '_DVFS_'
+#DVFS support. To be turned on
+FEATURE += FEAT_CPU_CLOCK_HW_SCALING
+C_DEFINES += SF_DVFS_NOTIFY
+endif
+
+ifeq '$(findstring _NOMODEM,${PLATFORM})' '_NOMODEM'
+C_DEFINES += NOMODEM_SUPPORT
+endif
+
+##**
+ #*
+ #* NOTE: SD Card Corruption SW Workaround for SF3GR
+ #*
+ ##**/
+FEATURE += FEAT_SD_DATA_CORRUPTION_SW_WA
+
+#DEVICE_LIST += dcc
+DEVICE_LIST += vop
+DEVICE_LIST += usif
+DEVICE_LIST += idi
+DEVICE_LIST += stm
+DEVICE_LIST += pcl
+DEVICE_LIST += pm
+DEVICE_LIST += tado
+DEVICE_LIST += usb
+DEVICE_LIST += scu
+DEVICE_LIST += noc_firewall
+DEVICE_LIST += mem_log
+DEVICE_LIST += i2c_bus
+DEVICE_LIST += gptu
+DEVICE_LIST += mmc_sd
+DEVICE_LIST += noc_qos # For testing only
+DEVICE_LIST += rtc
+DEVICE_LIST += chr
+DEVICE_LIST += meas
-- 
1.9.1

