From 289dd9822a8e55001b3b2eaa70c0bdfe44f2658c Mon Sep 17 00:00:00 2001
From: Bin Yang <bin.yang@intel.com>
Date: Sat, 6 Feb 2016 14:44:29 +0800
Subject: [PATCH 2/5] 3gx: add board_sf_3gx_ext_pmic support

Change-Id: Ibbc1e30aa49584bd96ce807da67b91e66e83dbb1
Signed-off-by: Bin Yang <bin.yang@intel.com>
---
 .../pmu/src/board_sf_3gx_ext_pmic/pmu_domain_cfg.c |  514 +++++
 .../src/board_sf_3gx_ext_pmic/pmu_domain_hal_cfg.c | 2109 ++++++++++++++++++++
 .../board_sf_3gx_ext_pmic/pmu_domain_init_cfg.c    |  163 ++
 .../pmu_int_hal_cfg_internal.h                     |  584 ++++++
 .../board_sf_3gx_ext_pmic/pmu_int_vm_access_cfg.h  |    1 +
 .../src/board_sf_3gx_ext_pmic/pmu_internal_cfg.h   |  412 ++++
 .../pow/src/board_sf_3gx_ext_pmic/pow_bootcore.c   |  261 +++
 .../src/board_sf_3gx_ext_pmic/pow_volt_board_cfg.c |  495 +++++
 .../src/board_sf_3gx_ext_pmic/pow_volt_pmu_cfg.c   |  339 ++++
 .../src/board_sf_3gx_ext_pmic/pow_volt_spcu_cfg.h  |    1 +
 10 files changed, 4879 insertions(+)
 create mode 100644 devices/pm/power_control/pmu/src/board_sf_3gx_ext_pmic/pmu_domain_cfg.c
 create mode 100644 devices/pm/power_control/pmu/src/board_sf_3gx_ext_pmic/pmu_domain_hal_cfg.c
 create mode 100644 devices/pm/power_control/pmu/src/board_sf_3gx_ext_pmic/pmu_domain_init_cfg.c
 create mode 100644 devices/pm/power_control/pmu/src/board_sf_3gx_ext_pmic/pmu_int_hal_cfg_internal.h
 create mode 120000 devices/pm/power_control/pmu/src/board_sf_3gx_ext_pmic/pmu_int_vm_access_cfg.h
 create mode 100644 devices/pm/power_control/pmu/src/board_sf_3gx_ext_pmic/pmu_internal_cfg.h
 create mode 100644 devices/pm/power_control/pow/src/board_sf_3gx_ext_pmic/pow_bootcore.c
 create mode 100644 devices/pm/power_control/pow/src/board_sf_3gx_ext_pmic/pow_volt_board_cfg.c
 create mode 100644 devices/pm/power_control/pow/src/board_sf_3gx_ext_pmic/pow_volt_pmu_cfg.c
 create mode 120000 devices/pm/power_control/pow/src/board_sf_3gx_ext_pmic/pow_volt_spcu_cfg.h

diff --git a/devices/pm/power_control/pmu/src/board_sf_3gx_ext_pmic/pmu_domain_cfg.c b/devices/pm/power_control/pmu/src/board_sf_3gx_ext_pmic/pmu_domain_cfg.c
new file mode 100644
index 0000000..2988d93
--- /dev/null
+++ b/devices/pm/power_control/pmu/src/board_sf_3gx_ext_pmic/pmu_domain_cfg.c
@@ -0,0 +1,514 @@
+/* =============================================================================
+ * Copyright (C) 2013-2014 Intel Mobile Communications GmbH
+ *
+ *      Sec Class: Intel Confidential (IC)
+ *
+ * =============================================================================
+ *
+ * This document contains proprietary information belonging to IMC.
+ * Passing on and copying of this document, use and communication of its
+ * contents is not permitted without prior written authorisation.
+ *
+ * =============================================================================
+ * Revision Information :
+ *   $File name:  /mhw_drv_src/power_control/pmu/src/pmu_int_agold620/pmu_domain_cfg.c $
+ *   Responsible: Vijayanand Jagadeesan
+ *   Comment:
+ *     Created
+ *
+ * =============================================================================
+ *
+ * This file contains the HW dependent implementation part of the PMU domain
+ * driver interface part
+ * HW set-up: AGOLD620 PMU (Connected to XGOLD632 via IDI)
+ * ===========================================================================*/
+
+/*----------------------------------------------*/
+/* INCLUDES                                     */
+/*----------------------------------------------*/
+
+#include "bastypes.h"
+
+#include "pmu_driverif_cfg.h"
+#include "pmu_driverif.h"
+
+#include "pmu_internal_cfg.h"
+#include "trap.h"
+#include "pmu_internal.h"
+
+#include "pmu_domain_internal.h"
+#include "pmu_domain_cfg_internal.h"
+#include "pmu_int_hal_cfg_internal.h"
+
+#include "iui_os.h"
+#include "pow_volt_spcu_cfg.h"
+
+#include "scu.h"
+
+/*----------------------------------------------*/
+/* DEFINES                                      */
+/*----------------------------------------------*/
+//for external pmic sync operator
+sPMU_SYNC_T sync_cmd = {0};
+
+static S8* FILE_NAME = (S8*) __FILE__;
+
+/*----------------------------------------------*/
+/* TYPE DEFINITIONS                             */
+/*----------------------------------------------*/
+
+/* @brief Type definition for functions used to set the domain voltage */
+typedef ePMU_RETURN_T (*PMU_SET_DOMAIN_VOLTAGE_T)(const ePMU_VOLTAGE_LIST_T voltage);
+
+/* @brief Type definition for functions used to set the domain mode */
+typedef ePMU_RETURN_T (*PMU_SET_DOMAIN_MODE_T)(const ePMU_MODE_LIST_T mode);
+
+/* @brief Type definition for functions used to set the domain pull down */
+typedef ePMU_RETURN_T (*PMU_SET_DOMAIN_PULLDOWN_T)(const BOOL pull_down);
+
+/** @brief This type of struct is needed to hold the domain setting access functions of the PMU */
+typedef struct
+{
+  ePMU_DOMAIN_T             domain;                   /**< Contains the PMU domain names */
+  PMU_SET_DOMAIN_VOLTAGE_T  set_domain_voltage_func;  /**< Contains the function for setting the domain voltage */
+  PMU_SET_DOMAIN_MODE_T     set_domain_mode_func;     /**< Contains the function for setting the domain mode */
+  PMU_SET_DOMAIN_PULLDOWN_T set_domain_pulldown_func; /**< Contains the function for setting the domain pull down */
+void (*set_domain_all_func)(const ePMU_MODE_LIST_T mode,const ePMU_VOLTAGE_LIST_T voltage, const BOOL pull_down, void (*callback)(void) );
+} sPMU_DOMAIN_SET_FUNCS_T;
+
+/* @brief Type definition for functions used to get the domain info (applied voltage (SW view), applied nominal voltage (HW view), applied mode) */
+typedef ePMU_RETURN_T (*PMU_GET_DOMAIN_INFO_T)(ePMU_VOLTAGE_LIST_T * const pmu_volt_p, ePMU_VOLTAGE_LIST_T * const pmu_volt_nom_p, ePMU_MODE_LIST_T * const pmu_mode_p);
+
+/** @brief This type of struct is needed to hold the domain info get functions of the PMU */
+typedef struct
+{
+  ePMU_DOMAIN_T          domain;               /**< Contains the PMU domain names */
+  PMU_GET_DOMAIN_INFO_T  get_domain_info_func; /**< Contains the function for setting the domain voltage */
+} sPMU_DOMAIN_GET_FUNCS_T;
+
+/*----------------------------------------------*/
+/* VARIABLE DECLARATION                         */
+/*----------------------------------------------*/
+extern void pal_prh_i2c_setup_async(unsigned char* data_p,unsigned size, unsigned int write, void (*cb));
+
+#if defined(SILENT_RESET)
+/* Include this for now to emulate the old behavior. When all users are updated
+   used the rst driver this can be removed again. The variable is declared in nu_boot.c */
+extern U32 NU_silent_reset_flag;
+#endif
+
+/*----------------------------------------------*/
+/* VARIABLE DEFINITIONS                         */
+/*----------------------------------------------*/
+// CODEGEN_BEGIN(PMU_DOMAIN_SET_FUNCS_T) begin of automated generated source by tool, don't remove this line
+static const sPMU_DOMAIN_SET_FUNCS_T pmu_domain_set_func[PMU_NOF_DOMAINS] =
+{
+  /* domain                             set_domain_voltage_func                 set_domain_mode_func                    set_domain_pulldown_func                remark */
+    { PMU_DOMAIN_LSIM1,                   PMU_int_hal_set_lsim1_voltage,          PMU_int_hal_set_lsim1_mode,             PMU_int_hal_set_lsim1_pull_down          ,NULL                                                  },
+  { PMU_DOMAIN_LSIM2,                   PMU_int_hal_set_lsim2_voltage,          PMU_int_hal_set_lsim2_mode,             PMU_int_hal_set_lsim2_pull_down          ,NULL                                                  },
+  { PMU_DOMAIN_LAUX1,                   PMU_int_hal_set_laux1_voltage,          PMU_int_hal_set_laux1_mode,             PMU_int_hal_set_laux1_pull_down           ,NULL                                                 },
+  { PMU_DOMAIN_LAUX2,                   PMU_int_hal_set_laux2_voltage,          PMU_int_hal_set_laux2_mode,             PMU_int_hal_set_laux2_pull_down            ,NULL                                                },
+  { PMU_DOMAIN_LMMC1,                   PMU_int_hal_set_lmmc1_voltage,          PMU_int_hal_set_lmmc1_mode,             PMU_int_hal_set_lmmc1_pull_down            ,NULL                                                },
+  { PMU_DOMAIN_LUSB,                    PMU_int_hal_set_lusb_voltage,           PMU_int_hal_set_lusb_mode,              PMU_int_hal_set_lusb_pull_down             ,NULL                                                },
+  { PMU_DOMAIN_LPMU,                    NULL,                                   NULL,                                   NULL                                        ,NULL                                               },
+  { PMU_DOMAIN_LAIF,                    PMU_int_hal_set_laif_voltage,           PMU_int_hal_set_laif_mode,              PMU_int_hal_set_laif_pull_down              ,NULL                                               },
+  { PMU_DOMAIN_LCABB,                   PMU_int_hal_set_lcabb_voltage,          PMU_int_hal_set_lcabb_mode,             PMU_int_hal_set_lcabb_pull_down             ,NULL                                               },
+  { PMU_DOMAIN_LMEM,                    PMU_int_hal_set_lmem_voltage,           PMU_int_hal_set_lmem_mode,              PMU_int_hal_set_lmem_pull_down              ,NULL                                               },
+  { PMU_DOMAIN_LMIPI,                   PMU_int_hal_set_lmipi_voltage,          PMU_int_hal_set_lmipi_mode,             PMU_int_hal_set_lmipi_pull_down             ,NULL                                               },
+  { PMU_DOMAIN_LPLL,                    PMU_int_hal_set_lpll_voltage,           PMU_int_hal_set_lpll_mode,              PMU_int_hal_set_lpll_pull_down               ,NULL                                              },
+  { PMU_DOMAIN_SD1,                     NULL,                                   NULL,                                   NULL                                         ,NULL                                              },
+  { PMU_DOMAIN_SD2,                     NULL,                                   NULL,                                   NULL                                         ,NULL                                              },
+  { PMU_DOMAIN_ELDO_VMMC,               PMU_int_hal_set_eldo_vmmc_voltage,      PMU_int_hal_set_eldo_vmmc_mode,         NULL                                          ,NULL                                             },
+  { PMU_DOMAIN_GNSS_TCXO_LDO,           PMU_int_hal_set_gnss_tcxo_ldo_voltage,  PMU_int_hal_set_gnss_tcxo_ldo_mode,     NULL                                           ,NULL                                            },
+  { PMU_DOMAIN_EXT_BUCK1,               NULL/*PMU_int_hal_set_ext_buck1_voltage*/,      NULL,                                   NULL                                           ,NULL                                            },
+  { PMU_DOMAIN_EXT_BUCK2,               NULL,                                   NULL,                                   NULL                                           ,NULL                                            },
+  { PMU_DOMAIN_EXT_LDO5,                NULL,                                   NULL,          NULL                                           ,NULL                                            },
+  { PMU_DOMAIN_DUMMY,                   NULL,                                   NULL,                                   NULL                                              ,NULL                                         },
+};
+// CODEGEN_END(PMU_DOMAIN_SET_FUNCS_T) end of automated generated source by tool, don't remove this line
+
+// CODEGEN_BEGIN(PMU_DOMAIN_GET_FUNCS_T) begin of automated generated source by tool, don't remove this line
+static const sPMU_DOMAIN_GET_FUNCS_T pmu_domain_get_func[PMU_NOF_DOMAINS] =
+{
+  /* domain                             get_domain_info_func                    remark */
+  { PMU_DOMAIN_LSIM1,                   PMU_int_hal_get_lsim1_info                                                                },
+  { PMU_DOMAIN_LSIM2,                   PMU_int_hal_get_lsim2_info                                                                },
+  { PMU_DOMAIN_LAUX1,                   PMU_int_hal_get_laux1_info                                                                },
+  { PMU_DOMAIN_LAUX2,                   PMU_int_hal_get_laux2_info                                                                },
+  { PMU_DOMAIN_LMMC1,                   PMU_int_hal_get_lmmc1_info                                                                },
+  { PMU_DOMAIN_LUSB,                    PMU_int_hal_get_lusb_info                                                                 },
+  { PMU_DOMAIN_LPMU,                    PMU_int_hal_get_lpmu_info                                                                 },
+  { PMU_DOMAIN_LAIF,                    PMU_int_hal_get_laif_info                                                                 },
+  { PMU_DOMAIN_LCABB,                   PMU_int_hal_get_lcabb_info                                                                },
+  { PMU_DOMAIN_LMEM,                    PMU_int_hal_get_lmem_info                                                                 },
+  { PMU_DOMAIN_LMIPI,                   PMU_int_hal_get_lmipi_info                                                                },
+  { PMU_DOMAIN_LPLL,                    PMU_int_hal_get_lpll_info                                                                 },
+  { PMU_DOMAIN_SD1,                     PMU_int_hal_get_sd1_info                                                                  },
+  { PMU_DOMAIN_SD2,                     PMU_int_hal_get_sd2_info                                                                  },
+  { PMU_DOMAIN_ELDO_VMMC,               PMU_int_hal_get_eldo_vmmc_info                                                            },
+  { PMU_DOMAIN_GNSS_TCXO_LDO,           PMU_int_hal_get_gnss_tcxo_ldo_info                                                        },
+  { PMU_DOMAIN_EXT_BUCK1,               PMU_int_hal_get_ext_buck1_info                                                            },
+  { PMU_DOMAIN_EXT_BUCK2,               PMU_int_hal_get_ext_buck2_info                                                            },
+  { PMU_DOMAIN_EXT_LDO5,                PMU_int_hal_get_ext_ldo5_info                                                             },
+  { PMU_DOMAIN_DUMMY,                   NULL                                                                                      },
+};
+// CODEGEN_END(PMU_DOMAIN_GET_FUNCS_T) end of automated generated source by tool, don't remove this line
+
+/*----------------------------------------------*/
+/* INTERNAL FUNCTION DELCARATIONS               */
+/*----------------------------------------------*/
+
+/*----------------------------------------------*/
+/* INTERNAL FUNCTIONS                           */
+/*----------------------------------------------*/
+
+/*----------------------------------------------*/
+/* EXPORTED FUNCTIONS                           */
+/*----------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_domain_internal.h
+  *
+  */
+ePMU_RETURN_T PMU_dom_init_HW ( void )
+{
+  ePMU_RETURN_T ret_val = PMU_OK;
+#if !defined (SOC_VMM_POWER)
+  T_SCU_FEAT_VOLTAGE_CLASS scu_voltage_class = SCU_FEAT_VOLTAGE_CLASS_INVALID;
+#endif
+  ePMU_VOLTAGECLASSES_T pmu_voltage_class = PMU_VOLTAGECLASS_0;
+
+  /* Voltage scaling set-up */
+  /* Get the voltage class of processor from SCU driver */
+#if !defined (SOC_VMM_POWER)
+  scu_voltage_class = scu_feat_voltage_class_get();
+  switch(scu_voltage_class)
+  {
+    case  SCU_FEAT_VOLTAGE_CLASS_INVALID:
+      /* Fall through to next case, because we only have non-fused chips, so always
+       * SCU_FEAT_VOLTAGE_CLASS_INVALID is provided
+       */
+    case SCU_FEAT_VOLTAGE_CLASS_0:
+      pmu_voltage_class = PMU_VOLTAGECLASS_0;
+      break;
+    case SCU_FEAT_VOLTAGE_CLASS_1:
+      pmu_voltage_class = PMU_VOLTAGECLASS_1;
+      break;
+    case SCU_FEAT_VOLTAGE_CLASS_2:
+      pmu_voltage_class = PMU_VOLTAGECLASS_2;
+      break;
+    case SCU_FEAT_VOLTAGE_CLASS_3:
+      pmu_voltage_class = PMU_VOLTAGECLASS_3;
+      break;
+    case SCU_FEAT_VOLTAGE_CLASS_4:
+      pmu_voltage_class = PMU_VOLTAGECLASS_4;
+      break;
+    case SCU_FEAT_VOLTAGE_CLASS_5:
+      pmu_voltage_class = PMU_VOLTAGECLASS_5;
+      break;
+    case SCU_FEAT_VOLTAGE_CLASS_6:
+      pmu_voltage_class = PMU_VOLTAGECLASS_6;
+      break;
+    case SCU_FEAT_VOLTAGE_CLASS_7:
+      pmu_voltage_class = PMU_VOLTAGECLASS_7;
+      break;
+    default:
+      PMU_trap(TRAP_PMU_PARAM_OUT_OF_RANGE, sizeof(T_SCU_FEAT_VOLTAGE_CLASS), &scu_voltage_class, __LINE__, FILE_NAME);
+      break;
+  }
+ #else
+   pmu_voltage_class = PMU_VOLTAGECLASS_0;
+ #endif
+  /* Set value depending on voltage class provided by SCU*/
+  ret_val = PMU_int_hal_set_sd1_valueset(pmu_voltage_class);
+  if (PMU_OK != ret_val )
+  {
+    PMU_trap(TRAP_PMU_PARAM_OUT_OF_RANGE, sizeof(ePMU_VOLTAGECLASSES_T), &pmu_voltage_class, __LINE__, FILE_NAME);
+  }
+
+  /* Board dependent external LDO initialization */
+  ret_val = PMU_dom_init_ext_ldo_HW();
+  if (PMU_OK != ret_val )
+  {
+    PMU_trap(TRAP_PMU_INTERNAL_ERROR, 0, NULL, __LINE__, FILE_NAME);
+  }
+  ret_val = PMU_int_hal_set_lsim1_auto_power_down(TRUE);
+  if (PMU_OK != ret_val )
+  {
+    PMU_trap(TRAP_PMU_INTERNAL_ERROR, 0, NULL, __LINE__, FILE_NAME);
+  }
+  ret_val = PMU_int_hal_set_lsim2_auto_power_down(TRUE);
+  if (PMU_OK != ret_val )
+  {
+    PMU_trap(TRAP_PMU_INTERNAL_ERROR, 0, NULL, __LINE__, FILE_NAME);
+  }
+  /*initialize LDOs */
+  ret_val = PMU_dom_init_config();
+  return ret_val;
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_domain_internal.h
+  *
+*/
+ePMU_RETURN_T PMU_dom_init_config ( void )
+{
+  int cur_domain;
+  ePMU_RETURN_T ret_val = PMU_OK;
+  sPMU_INITIAL_CONFIG_T * pmu_initial_config_p = NULL;
+
+  pmu_initial_config_p = PMU_dom_get_initial_config_array_pointer();
+
+  /*initialize LDOs */
+  for (cur_domain=0; cur_domain < (int)PMU_NOF_DOMAINS; cur_domain++)
+  {
+#if defined(CDS) || defined(MSY)
+    /* do not disable SIM1 and SIM2 domain for CDS and MSY images because they do not support
+       the usage of variable NU_silent_reset_flag */
+    if ((cur_domain != PMU_dom_get_sim1_domain()) &&
+        (cur_domain != PMU_dom_get_sim2_domain()))
+#else /* defined(CDS) || defined(MSY) */
+#if defined(SILENT_RESET)
+    /* Include this for now to emulate the old behavior. When all users are updated
+       used the rst driver this can be removed again. The variable is declared in nu_boot.c
+    */
+    if (((cur_domain != PMU_dom_get_sim1_domain()) &&
+         (cur_domain != PMU_dom_get_sim2_domain())) ||
+        (!NU_silent_reset_flag))
+#endif
+#endif /* defined(CDS) || defined(MSY) */
+    {
+#if defined(SF3GX_VCPU_I2C_CTRL)
+      if (PMU_DOMAIN_EXT_BUCK1 == cur_domain)
+      {
+        // skip ext buck1 init. adding init power if needed
+        continue;
+      }
+#endif
+      /* Set pull down */
+      if (NULL != pmu_domain_set_func[cur_domain].set_domain_pulldown_func)
+      {
+        ret_val = pmu_domain_set_func[cur_domain].set_domain_pulldown_func((pmu_initial_config_p + cur_domain)->pulldown);
+      }
+      if (PMU_OK != ret_val)
+      {
+        PMU_trap(TRAP_PMU_INTERNAL_ERROR, 0, NULL, __LINE__, FILE_NAME);
+      }
+      if (NULL != pmu_domain_set_func[cur_domain].set_domain_mode_func)
+      {
+        ret_val = pmu_domain_set_func[cur_domain].set_domain_mode_func((pmu_initial_config_p + cur_domain)->mode);
+      }
+      if (PMU_OK != ret_val)
+      {
+        PMU_trap(TRAP_PMU_INTERNAL_ERROR, 0, NULL, __LINE__, FILE_NAME);
+      }
+      /* Set voltage */
+      if (NULL != pmu_domain_set_func[cur_domain].set_domain_voltage_func)
+      {
+        ret_val = pmu_domain_set_func[cur_domain].set_domain_voltage_func((pmu_initial_config_p + cur_domain)->voltage);
+      }
+      if (PMU_OK != ret_val)
+      {
+        PMU_trap(TRAP_PMU_INTERNAL_ERROR, 0, NULL, __LINE__, FILE_NAME);
+      }
+    }
+  }
+  PMU_int_hal_flush_domain_settings();
+
+  return PMU_OK;
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_domain_internal.h
+  *
+*/
+ePMU_RETURN_T PMU_dom_get_init_config(const ePMU_DOMAIN_T domain, ePMU_VOLTAGE_LIST_T * const voltage_p, ePMU_MODE_LIST_T * const mode_p)
+{
+  sPMU_INITIAL_CONFIG_T * pmu_initial_config_p = NULL;
+
+  if (PMU_NOF_DOMAINS <= domain)
+  {
+    ePMU_DOMAIN_T trap_domain = domain;
+
+    PMU_trap(TRAP_PMU_INVALID_DOMAIN, sizeof(ePMU_DOMAIN_T), &trap_domain, __LINE__, FILE_NAME);
+  }
+  else
+  {
+    pmu_initial_config_p = PMU_dom_get_initial_config_array_pointer();
+
+    *voltage_p = (pmu_initial_config_p + domain)->voltage;
+    *mode_p = (pmu_initial_config_p + domain)->mode;
+  }
+
+  return PMU_OK;
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_domain_internal.h
+  *
+  */
+ePMU_RETURN_T PMU_dom_req_domain_voltage (const ePMU_DOMAIN_T domain, const ePMU_VOLTAGE_LIST_T voltage, const ePMU_MODE_LIST_T enable)
+{
+  /* Inside this function the voltages are configured and the regulators are switched on/off/HW
+   * controlled. What is not done here is to switch the pull down resistors this shall be done
+   * only in the initialization phase.
+   */
+
+  /* The SD domains can't be modified here because this regulators are always on, the trimming of
+   * this regulators is done inside the initialization phase.
+   */
+  ePMU_VOLTAGE_LIST_T pmu_volt;
+  ePMU_VOLTAGE_LIST_T pmu_volt_nom;
+  ePMU_MODE_LIST_T pmu_mode;
+  ePMU_RETURN_T ret_val = PMU_OK;
+  pow_volt_phys_domain_info_s *pow_volt_phys_domain_info_ptr = NULL;
+  pow_volt_phys_domain_info_ptr = pow_volt_get_phys_domain_info_ptr();
+  ePMU_DOMAIN_T trap_domain = domain;
+
+  /* The handling of concurrent accesses is done in the caller function set_power_domain()
+   * in pow_volt.c. Via disabled IRQ's.
+   */
+
+  if (PMU_NOF_DOMAINS <= domain)
+  {
+    ePMU_DOMAIN_T trap_domain = domain;
+    PMU_trap(TRAP_PMU_INVALID_DOMAIN, sizeof(ePMU_DOMAIN_T), &trap_domain, __LINE__, FILE_NAME);
+  }
+  else
+  {
+#if defined(SF3GX_VCPU_I2C_CTRL)
+  /////////////////change for interface
+    if (PMU_DOMAIN_EXT_BUCK1 == domain)
+    {
+        if (pow_volt_phys_domain_info_ptr[domain].prh_sync_fct && pal_pm_guestvm_start_status() == true)
+        {
+          sync_cmd.sync = 0;
+        }
+        else
+        {
+          sync_cmd.sync = 1;
+        }
+        sync_cmd.domain= domain;
+
+        /* Set voltage */
+        if (NULL != pmu_domain_set_func[domain].set_domain_voltage_func)
+        {
+          ret_val = pmu_domain_set_func[domain].set_domain_voltage_func(voltage);
+        }
+
+        if (NULL != pmu_domain_set_func[domain].set_domain_mode_func)
+        {
+          ret_val = pmu_domain_set_func[domain].set_domain_mode_func(enable);
+        }
+        return ret_val;
+    }
+#endif
+    /* Set voltage */
+    if (NULL != pmu_domain_set_func[domain].set_domain_voltage_func)
+    {
+      ret_val = pmu_domain_set_func[domain].set_domain_voltage_func(voltage);
+    }
+    if (PMU_OK != ret_val)
+    {
+      ePMU_VOLTAGE_LIST_T trap_voltage = voltage;
+      PMU_trap(TRAP_PMU_PARAM_OUT_OF_RANGE, sizeof(ePMU_VOLTAGE_LIST_T), &trap_voltage, __LINE__, FILE_NAME);
+    }
+    else
+    {
+      /* Set mode */
+      if (NULL != pmu_domain_set_func[domain].set_domain_mode_func)
+      {
+        ret_val = pmu_domain_set_func[domain].set_domain_mode_func(enable);
+      }
+      if (PMU_OK != ret_val)
+      {
+        ePMU_MODE_LIST_T trap_enable = enable;
+        PMU_trap(TRAP_PMU_PARAM_OUT_OF_RANGE, sizeof(ePMU_MODE_LIST_T), &trap_enable, __LINE__, FILE_NAME);
+      }
+      else
+      {
+        /* Make sure mode is updated before returning.*/
+        if (NULL != pmu_domain_get_func[domain].get_domain_info_func)
+        {
+          ret_val = pmu_domain_get_func[domain].get_domain_info_func(&pmu_volt, &pmu_volt_nom, &pmu_mode);
+        }
+        if (PMU_OK != ret_val)
+        {
+          ePMU_MODE_LIST_T trap_enable = enable;
+          PMU_trap(TRAP_PMU_PARAM_OUT_OF_RANGE, sizeof(ePMU_MODE_LIST_T), &trap_enable, __LINE__, FILE_NAME);
+        }
+      }
+    }
+  }
+  return ret_val;
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_domain_internal.h
+  *
+  */
+ePMU_RETURN_T PMU_dom_get_domain_info
+(
+  const ePMU_DOMAIN_T pmu_domain,
+  ePMU_VOLTAGE_LIST_T * const pmu_volt_p,
+  ePMU_VOLTAGE_LIST_T * const pmu_volt_nom_p,
+  ePMU_MODE_LIST_T * const pmu_mode_p
+)
+{
+  /* inside this function the information regarding LDO's, external LDO's and SD's is fetched */
+
+  ePMU_RETURN_T ret_val = PMU_OK;
+
+  /* The handling of concurrent accesses is done in the caller function set_power_domain()
+   * in pow_volt.c. Via disabled IRQ's.
+   */
+
+  /* Check input parameters */
+  if ((NULL != pmu_volt_p) &&
+      (NULL != pmu_volt_nom_p) &&
+      (NULL != pmu_mode_p))
+  {
+    if (PMU_NOF_DOMAINS <= pmu_domain)
+    {
+      ePMU_DOMAIN_T trap_domain = pmu_domain;
+
+      PMU_trap(TRAP_PMU_INVALID_DOMAIN, sizeof(ePMU_DOMAIN_T), &trap_domain, __LINE__, FILE_NAME);
+      ret_val = PMU_ERR_OUT_OF_RANGE;
+    }
+    else
+    {
+      /* Set default values, e.g. for PMU_DOMAIN_DUMMY */
+      *pmu_volt_p = PMU_VOLTAGE_FIXED;
+      *pmu_volt_nom_p = PMU_VOLTAGE_FIXED;
+      *pmu_mode_p = PMU_MODE_FIXED;
+      /* Get the domain info */
+      if (NULL != pmu_domain_get_func[pmu_domain].get_domain_info_func)
+      {
+        ret_val = pmu_domain_get_func[pmu_domain].get_domain_info_func(pmu_volt_p, pmu_volt_nom_p, pmu_mode_p);
+      }
+    }
+  }
+  else
+  {
+    ret_val = PMU_ERR_INV_ARG;
+  }
+
+  return ret_val;
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_domain_internal.h
+  *
+  */
+
+ePMU_RETURN_T PMU_dom_set_sd_duty_cycle
+(
+  const ePMU_SD_DUTY_CYCLE_T sd_duty_cycle
+)
+{
+  ePMU_RETURN_T ret_val = PMU_OK;
+  //PRH Frequency manager API should be used to set SD duty cycle.
+  return ret_val;
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+
diff --git a/devices/pm/power_control/pmu/src/board_sf_3gx_ext_pmic/pmu_domain_hal_cfg.c b/devices/pm/power_control/pmu/src/board_sf_3gx_ext_pmic/pmu_domain_hal_cfg.c
new file mode 100644
index 0000000..8f3dda6
--- /dev/null
+++ b/devices/pm/power_control/pmu/src/board_sf_3gx_ext_pmic/pmu_domain_hal_cfg.c
@@ -0,0 +1,2109 @@
+/* =============================================================================
+ * Copyright (C) 2013-2014 Intel Mobile Communications GmbH
+ *
+ *      Sec Class: Intel Confidential (IC)
+ *
+ * =============================================================================
+ *
+ * This document contains proprietary information belonging to IMC.
+ * Passing on and copying of this document, use and communication of its
+ * contents is not permitted without prior written authorisation.
+ *
+ * =============================================================================
+ * Revision Information :
+ *   $File name:  /mhw_drv_src/power_control/pmu/src/pmu_int_agold620/pmu_domain_hal_cfg.c $
+ *   Responsible: Vijayanand Jagadeesan
+ *   Comment:
+ *     Created
+ * =============================================================================
+ *
+ * This file contains the HW dependent implementation part of the PMU HAL for domain handling.
+ * HW set-up: AGOLD620 PMU (Connected to XGOLD632 via IDI)
+ * ===========================================================================*/
+
+/*----------------------------------------------*/
+/* INCLUDES                                     */
+/*----------------------------------------------*/
+
+#include "bastypes.h"
+
+#include "uta_dbg.h"         /* for compile time assert */
+
+#include "iui_os.h"
+#include "emif_driverif.h"
+
+
+//#include "pcl_driverif.h"    /* PAD control */
+
+#include "trap.h"
+#include "scu.h"
+
+
+#include "pmu_driverif_cfg.h"
+#include "pmu_driverif.h"
+
+#include "pmu_internal_cfg.h"
+#include "pmu_internal.h"
+#include "pmu_int_hal_cfg_internal.h"
+
+#include "pmu_reg.h"
+
+#ifdef SF3GX_VCPU_I2C_CTRL
+#include "sy8827e.h"
+#endif
+
+/*----------------------------------------------*/
+/* DEFINES                                      */
+/*----------------------------------------------*/
+
+
+/*----------------------------------------------*/
+/* TYPE DEFINITIONS                             */
+/*----------------------------------------------*/
+
+/*----------------------------------------------*/
+/* VARIABLE DEFINITIONS                         */
+/*----------------------------------------------*/
+
+/*----------------------------------------------*/
+/* INTERNAL FUNCTION DELCARATIONS               */
+/*----------------------------------------------*/
+
+/*----------------------------------------------*/
+/* INTERNAL FUNCTIONS                           */
+/*----------------------------------------------*/
+
+/*----------------------------------------------*/
+/* EXPORTED FUNCTIONS                           */
+/*----------------------------------------------*/
+
+/*##############################################*/
+/*# DOMAIN part ################################*/
+/*##############################################*/
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_int_hal_cfg_internal.h */
+ePMU_RETURN_T PMU_int_hal_flush_domain_settings
+(
+   void
+)
+{
+ /* Read a register to push all writes through IDI interface - TO DO */
+  getPmu_LPLL_Config(&pmu);
+
+  return PMU_OK;
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/****************************************************************************************
+* LSIM1 regulator
+****************************************************************************************/
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_int_hal_cfg_internal.h */
+ePMU_RETURN_T PMU_int_hal_get_lsim1_info
+(
+  ePMU_VOLTAGE_LIST_T * const pmu_volt_p,
+  ePMU_VOLTAGE_LIST_T * const pmu_volt_nom_p,
+  ePMU_MODE_LIST_T    * const pmu_mode_p
+)
+{
+  ePMU_RETURN_T PMU_ret_val = PMU_OK;
+  uLSIM1_Config myLDO_SIM1 = {0};
+
+  /* Check input parameters */
+  if ((NULL == pmu_volt_p) ||
+     (NULL == pmu_volt_nom_p) ||
+      (NULL == pmu_mode_p))
+  {
+      PMU_ret_val = PMU_ERR_INV_ARG;
+  }
+  else
+  {
+     /* LSIM1 power domain */
+     myLDO_SIM1.LSIM1_Config_Content = getPmu_LSIM1_Config(&pmu);
+     switch (myLDO_SIM1.LSIM1_Config_Structure.LDOVoltage)
+     {
+      case LSIM1_CONFIG_LDOVOLTAGE_V120:
+         *pmu_volt_p = PMU_VOLTAGE_1V20;
+         break;
+      case LSIM1_CONFIG_LDOVOLTAGE_V180:
+         *pmu_volt_p = PMU_VOLTAGE_1V80;
+         break;
+       case LSIM1_CONFIG_LDOVOLTAGE_VNU2:
+      case LSIM1_CONFIG_LDOVOLTAGE_V291:
+         *pmu_volt_p = PMU_VOLTAGE_2V91;
+         break;
+     }
+     *pmu_volt_nom_p = *pmu_volt_p;
+     switch (myLDO_SIM1.LSIM1_Config_Structure.LDOMode)
+     {
+      case LSIM1_CONFIG_LDOMODE_OFF:
+         *pmu_mode_p = PMU_MODE_OFF;
+         break;
+      case LSIM1_CONFIG_LDOMODE_STDBYOFF:
+         *pmu_mode_p = PMU_MODE_OFF_STDBY;
+         break;
+      case LSIM1_CONFIG_LDOMODE_STDBYMODE:
+          *pmu_mode_p = PMU_MODE_IDLE_STDBY;
+         break;
+      case LSIM1_CONFIG_LDOMODE_ON:
+        *pmu_mode_p = PMU_MODE_ON;
+         break;
+     }
+  }
+  return PMU_ret_val;
+}
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_int_hal_cfg_internal.h */
+ePMU_RETURN_T PMU_int_hal_set_lsim1_voltage
+(
+  const ePMU_VOLTAGE_LIST_T voltage
+)
+{
+  /* configure LSIM1 voltage map offical enum to HW related enums */
+  switch(voltage)
+  {
+    case PMU_VOLTAGE_1V20:
+       setPmu_LSIM1_Config_LDOVoltage(&pmu,LSIM1_CONFIG_LDOVOLTAGE_V120);
+       return PMU_OK;
+      case PMU_VOLTAGE_1V80:
+          setPmu_LSIM1_Config_LDOVoltage(&pmu,LSIM1_CONFIG_LDOVOLTAGE_V180);
+      return PMU_OK;
+    case PMU_VOLTAGE_2V91:
+      setPmu_LSIM1_Config_LDOVoltage(&pmu,LSIM1_CONFIG_LDOVOLTAGE_V291);
+      return PMU_OK;
+    case PMU_VOLTAGE_FIXED:
+      return PMU_OK;
+    default:
+      return PMU_ERR_INV_VOLT; /*voltage not supported */
+  }
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_int_hal_cfg_internal.h */
+ePMU_RETURN_T PMU_int_hal_set_lsim1_pull_down
+(
+  const BOOL pull_down
+)
+{
+  /* configure LSIM1 pull down map offical enum to HW related enum */
+  if (pull_down)
+  {
+    setPmu_LSIM1_Config_LDOPullDown(&pmu,LSIM1_CONFIG_LDOPULLDOWN_ON);
+  }
+  else
+  {
+    setPmu_LSIM1_Config_LDOPullDown(&pmu,LSIM1_CONFIG_LDOPULLDOWN_OFF);
+  }
+
+  return PMU_OK;
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_int_hal_cfg_internal.h */
+ePMU_RETURN_T PMU_int_hal_set_lsim1_mode
+(
+  const ePMU_MODE_LIST_T mode
+)
+{
+  /* configure LSIM1 mode map offical enum to HW related enums */
+  switch(mode)
+  {
+    case PMU_MODE_FIXED:
+      return PMU_OK; /* nothing has to be done here */
+    case PMU_MODE_ON:
+      PMU_int_hal_set_lsim1_pull_down(FALSE);
+      setPmu_LSIM1_Config_LDOMode(&pmu,LSIM1_CONFIG_LDOMODE_ON);
+      return PMU_OK;
+    case PMU_MODE_IDLE_STDBY:
+      PMU_int_hal_set_lsim1_pull_down(FALSE);
+      setPmu_LSIM1_Config_LDOMode(&pmu,LSIM1_CONFIG_LDOMODE_STDBYMODE);
+      return PMU_OK;
+    case PMU_MODE_OFF_STDBY:
+      PMU_int_hal_set_lsim1_pull_down(FALSE);
+      setPmu_LSIM1_Config_LDOMode(&pmu,LSIM1_CONFIG_LDOMODE_STDBYOFF);
+      return PMU_OK;
+    case PMU_MODE_OFF:
+      PMU_int_hal_set_lsim1_pull_down(TRUE);
+      setPmu_LSIM1_Config_LDOMode(&pmu,LSIM1_CONFIG_LDOMODE_OFF);
+      return PMU_OK;
+    default:
+      return PMU_ERR_INV_MODE;
+  }
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+/****************************************************************************************
+* LSIM2 regulator
+****************************************************************************************/
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_int_hal_cfg_internal.h */
+ePMU_RETURN_T PMU_int_hal_get_lsim2_info
+(
+  ePMU_VOLTAGE_LIST_T * const pmu_volt_p,
+  ePMU_VOLTAGE_LIST_T * const pmu_volt_nom_p,
+  ePMU_MODE_LIST_T    * const pmu_mode_p
+)
+{
+  ePMU_RETURN_T PMU_ret_val = PMU_OK;
+  uLSIM2_Config myLDO_SIM2 = {0};
+
+    /* Check input parameters */
+  if ((NULL == pmu_volt_p) ||
+      (NULL == pmu_volt_nom_p) ||
+      (NULL == pmu_mode_p))
+  {
+    PMU_ret_val = PMU_ERR_INV_ARG;
+  }
+  else
+  {
+    /* LSIM2 power domain */
+    myLDO_SIM2.LSIM2_Config_Content = getPmu_LSIM2_Config(&pmu);
+    switch (myLDO_SIM2.LSIM2_Config_Structure.LDOVoltage)
+    {
+      case LSIM2_CONFIG_LDOVOLTAGE_V120:
+        *pmu_volt_p = PMU_VOLTAGE_1V20;
+        break;
+      case LSIM2_CONFIG_LDOVOLTAGE_V180:
+        *pmu_volt_p = PMU_VOLTAGE_1V80;
+        break;
+      case LSIM2_CONFIG_LDOVOLTAGE_VNU:
+      case LSIM2_CONFIG_LDOVOLTAGE_V291:
+        *pmu_volt_p = PMU_VOLTAGE_2V91;
+        break;
+     }
+    *pmu_volt_nom_p = *pmu_volt_p;
+    switch (myLDO_SIM2.LSIM2_Config_Structure.LDOMode)
+    {
+      case LSIM2_CONFIG_LDOMODE_OFF:
+        *pmu_mode_p = PMU_MODE_OFF;
+        break;
+      case LSIM2_CONFIG_LDOMODE_STDBYOFF:
+        *pmu_mode_p = PMU_MODE_OFF_STDBY;
+        break;
+      case LSIM2_CONFIG_LDOMODE_STDBYMODE:
+          *pmu_mode_p = PMU_MODE_IDLE_STDBY;
+        break;
+      case LSIM2_CONFIG_LDOMODE_ON:
+        *pmu_mode_p = PMU_MODE_ON;
+        break;
+     }
+  }
+
+  return PMU_ret_val;
+}
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_int_hal_cfg_internal.h */
+ePMU_RETURN_T PMU_int_hal_set_lsim2_voltage
+(
+  const ePMU_VOLTAGE_LIST_T voltage
+)
+{
+  /* configure LSIM2 voltage map offical enum to HW related enums */
+  switch(voltage)
+  {
+    case PMU_VOLTAGE_1V20:
+       setPmu_LSIM2_Config_LDOVoltage(&pmu,LSIM2_CONFIG_LDOVOLTAGE_V120);
+       return PMU_OK;
+    case PMU_VOLTAGE_1V80:
+       setPmu_LSIM2_Config_LDOVoltage(&pmu,LSIM2_CONFIG_LDOVOLTAGE_V180);
+       return PMU_OK;
+    case PMU_VOLTAGE_2V91:
+       setPmu_LSIM2_Config_LDOVoltage(&pmu,LSIM2_CONFIG_LDOVOLTAGE_V291);
+       return PMU_OK;
+    case PMU_VOLTAGE_FIXED:
+       return PMU_OK;
+    default:
+      return PMU_ERR_INV_VOLT; /*voltage not supported */
+  }
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_int_hal_cfg_internal.h */
+ePMU_RETURN_T PMU_int_hal_set_lsim2_pull_down
+(
+  const BOOL pull_down
+)
+{
+  /* configure LSIM2 pull down map offical enum to HW related enum */
+  if (pull_down)
+  {
+    setPmu_LSIM2_Config_LDOPullDown(&pmu,LSIM2_CONFIG_LDOPULLDOWN_ON);
+  }
+  else
+  {
+    setPmu_LSIM2_Config_LDOPullDown(&pmu,LSIM2_CONFIG_LDOPULLDOWN_OFF);
+  }
+
+  return PMU_OK;
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_int_hal_cfg_internal.h */
+ePMU_RETURN_T PMU_int_hal_set_lsim2_mode
+(
+  const ePMU_MODE_LIST_T mode
+)
+{
+  /* configure LSIM2 mode map offical enum to HW related enums */
+  switch(mode)
+  {
+   case PMU_MODE_FIXED:
+      return PMU_OK; /* nothing has to be done here */
+   case PMU_MODE_ON:
+      PMU_int_hal_set_lsim2_pull_down(FALSE);
+      setPmu_LSIM2_Config_LDOMode(&pmu,LSIM2_CONFIG_LDOMODE_ON);
+      return PMU_OK;
+   case PMU_MODE_IDLE_STDBY:
+      PMU_int_hal_set_lsim2_pull_down(FALSE);
+      setPmu_LSIM2_Config_LDOMode(&pmu,LSIM2_CONFIG_LDOMODE_STDBYMODE);
+      return PMU_OK;
+   case PMU_MODE_OFF_STDBY:
+      PMU_int_hal_set_lsim2_pull_down(FALSE);
+      setPmu_LSIM2_Config_LDOMode(&pmu,LSIM2_CONFIG_LDOMODE_STDBYOFF);
+      return PMU_OK;
+   case PMU_MODE_OFF:
+      PMU_int_hal_set_lsim2_pull_down(TRUE);
+      setPmu_LSIM2_Config_LDOMode(&pmu,LSIM2_CONFIG_LDOMODE_OFF);
+      return PMU_OK;
+   default:
+    return PMU_ERR_INV_MODE;
+  }
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/****************************************************************************************
+* LPLL regulator
+****************************************************************************************/
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_int_hal_cfg_internal.h */
+ePMU_RETURN_T PMU_int_hal_get_lpll_info
+(
+  ePMU_VOLTAGE_LIST_T * const pmu_volt_p,
+  ePMU_VOLTAGE_LIST_T * const pmu_volt_nom_p,
+  ePMU_MODE_LIST_T    * const pmu_mode_p
+)
+{
+  ePMU_RETURN_T PMU_ret_val = PMU_OK;
+  uLPLL_Config myLDO_PLL = {0};
+
+    /* Check input parameters */
+  if ((NULL == pmu_volt_p) ||
+      (NULL == pmu_volt_nom_p) ||
+      (NULL == pmu_mode_p))
+  {
+    PMU_ret_val = PMU_ERR_INV_ARG;
+  }
+  else
+  {
+    /* LPLL power domain */
+    myLDO_PLL.LPLL_Config_Content = getPmu_LPLL_Config(&pmu);
+    switch (myLDO_PLL.LPLL_Config_Structure.LDOVoltage)
+    {
+      case LPLL_CONFIG_LDOVOLTAGE_V120:
+         *pmu_volt_p = PMU_VOLTAGE_1V20;
+         break;
+      case LPLL_CONFIG_LDOVOLTAGE_V125:
+         *pmu_volt_p = PMU_VOLTAGE_1V25;
+        break;
+      case LPLL_CONFIG_LDOVOLTAGE_V110:
+       *pmu_volt_p = PMU_VOLTAGE_1V10;
+         break;
+      case LPLL_CONFIG_LDOVOLTAGE_V100:
+         *pmu_volt_p = PMU_VOLTAGE_1V00;
+         break;
+    }
+    *pmu_volt_nom_p = *pmu_volt_p;
+    switch (myLDO_PLL.LPLL_Config_Structure.LDOMode)
+    {
+      case LPLL_CONFIG_LDOMODE_OFF:
+        *pmu_mode_p = PMU_MODE_OFF;
+        break;
+      case LPLL_CONFIG_LDOMODE_STDBYOFF:
+        *pmu_mode_p = PMU_MODE_OFF_STDBY;
+        break;
+      case LPLL_CONFIG_LDOMODE_STDBYMODE:
+          *pmu_mode_p = PMU_MODE_IDLE_STDBY;
+        break;
+      case LPLL_CONFIG_LDOMODE_ON:
+        *pmu_mode_p = PMU_MODE_ON;
+        break;
+     }
+  }
+
+  return PMU_ret_val;
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+ePMU_RETURN_T PMU_int_hal_set_lpll_voltage
+(
+  const ePMU_VOLTAGE_LIST_T voltage
+)
+{
+  /* configure LPLL voltage map offical enum to HW related enums */
+  switch(voltage)
+  {
+    case PMU_VOLTAGE_1V00:
+       setPmu_LPLL_Config_LDOVoltage(&pmu,LPLL_CONFIG_LDOVOLTAGE_V100);
+       return PMU_OK;
+    case PMU_VOLTAGE_1V10:
+       setPmu_LPLL_Config_LDOVoltage(&pmu,LPLL_CONFIG_LDOVOLTAGE_V110);
+       return PMU_OK;
+    case PMU_VOLTAGE_1V20:
+       setPmu_LPLL_Config_LDOVoltage(&pmu,LPLL_CONFIG_LDOVOLTAGE_V120);
+       return PMU_OK;
+      case PMU_VOLTAGE_1V25:
+       setPmu_LPLL_Config_LDOVoltage(&pmu,LPLL_CONFIG_LDOVOLTAGE_V125);
+       return PMU_OK;
+    case PMU_VOLTAGE_FIXED:
+       return PMU_OK;
+    default:
+      return PMU_ERR_INV_VOLT; /*voltage not supported */
+  }
+}
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_int_hal_cfg_internal.h */
+ePMU_RETURN_T PMU_int_hal_set_lpll_mode
+(
+  const ePMU_MODE_LIST_T mode
+)
+{
+  /* configure LPLL mode map offical enum to HW related enums */
+  switch(mode)
+  {
+    case PMU_MODE_FIXED:
+      return PMU_OK; /* nothing has to be done here */
+    case PMU_MODE_ON:
+      setPmu_LPLL_Config_LDOMode(&pmu,LPLL_CONFIG_LDOMODE_ON);
+      return PMU_OK;
+    case PMU_MODE_IDLE_STDBY:
+      setPmu_LPLL_Config_LDOMode(&pmu,LPLL_CONFIG_LDOMODE_STDBYMODE);
+      return PMU_OK;
+    case PMU_MODE_OFF_STDBY:
+      setPmu_LPLL_Config_LDOMode(&pmu,LPLL_CONFIG_LDOMODE_STDBYOFF);
+      return PMU_OK;
+    case PMU_MODE_OFF:
+      setPmu_LPLL_Config_LDOMode(&pmu,LPLL_CONFIG_LDOMODE_OFF);
+          return PMU_OK;
+    default:
+      return PMU_ERR_INV_MODE;
+  }
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_int_hal_cfg_internal.h */
+ePMU_RETURN_T PMU_int_hal_set_lpll_pull_down
+(
+  const BOOL pull_down
+)
+{
+  /* configure LPLL pull down map offical enum to HW related enum */
+  if (pull_down)
+  {
+    setPmu_LPLL_Config_LDOPullDown(&pmu,LPLL_CONFIG_LDOPULLDOWN_ON);
+  }
+  else
+  {
+    setPmu_LPLL_Config_LDOPullDown(&pmu,LPLL_CONFIG_LDOPULLDOWN_OFF);
+  }
+
+  return PMU_OK;
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+/****************************************************************************************
+* LAUX1 regulator
+****************************************************************************************/
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_int_hal_cfg_internal.h */
+ePMU_RETURN_T PMU_int_hal_get_laux1_info
+(
+  ePMU_VOLTAGE_LIST_T * const pmu_volt_p,
+  ePMU_VOLTAGE_LIST_T * const pmu_volt_nom_p,
+  ePMU_MODE_LIST_T    * const pmu_mode_p
+)
+{
+ ePMU_RETURN_T PMU_ret_val = PMU_OK;
+ uLAUX1_Config myLDO_AUX1 = {0};
+
+    /* Check input parameters */
+ if ((NULL == pmu_volt_p) ||
+      (NULL == pmu_volt_nom_p) ||
+      (NULL == pmu_mode_p))
+ {
+    PMU_ret_val = PMU_ERR_INV_ARG;
+ }
+ else
+ {
+    /* LAUX1 power domain */
+    myLDO_AUX1.LAUX1_Config_Content = getPmu_LAUX1_Config(&pmu);
+    switch (myLDO_AUX1.LAUX1_Config_Structure.LDOVoltage)
+    {
+      case LAUX1_CONFIG_LDOVOLTAGE_V180:
+        *pmu_volt_p = PMU_VOLTAGE_1V80;
+        break;
+      case LAUX1_CONFIG_LDOVOLTAGE_V250:
+        *pmu_volt_p = PMU_VOLTAGE_2V50;
+        break;
+      case LAUX1_CONFIG_LDOVOLTAGE_V280:
+        *pmu_volt_p = PMU_VOLTAGE_2V80;
+        break;
+      case LAUX1_CONFIG_LDOVOLTAGE_V285:
+        *pmu_volt_p = PMU_VOLTAGE_2V85;
+        break;
+    }
+    *pmu_volt_nom_p = *pmu_volt_p;
+    switch (myLDO_AUX1.LAUX1_Config_Structure.LDOMode)
+    {
+      case LAUX1_CONFIG_LDOMODE_OFF:
+        *pmu_mode_p = PMU_MODE_OFF;
+        break;
+      case LAUX1_CONFIG_LDOMODE_STDBYOFF:
+        *pmu_mode_p = PMU_MODE_OFF_STDBY;
+        break;
+      case LAUX1_CONFIG_LDOMODE_STDBYMODE:
+          *pmu_mode_p = PMU_MODE_IDLE_STDBY;
+        break;
+      case LAUX1_CONFIG_LDOMODE_ON:
+        *pmu_mode_p = PMU_MODE_ON;
+        break;
+    }
+ }
+  return PMU_ret_val;
+}
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_int_hal_cfg_internal.h */
+ePMU_RETURN_T PMU_int_hal_set_laux1_voltage
+(
+  const ePMU_VOLTAGE_LIST_T voltage
+)
+{
+  /* configure LAUX1 voltage map offical enum to HW related enums */
+  switch(voltage)
+  {
+    case PMU_VOLTAGE_1V80:
+     setPmu_LAUX1_Config_LDOVoltage(&pmu,LAUX1_CONFIG_LDOVOLTAGE_V180);
+     return PMU_OK;
+    case PMU_VOLTAGE_2V50:
+     setPmu_LAUX1_Config_LDOVoltage(&pmu,LAUX1_CONFIG_LDOVOLTAGE_V250);
+     return PMU_OK;
+    case PMU_VOLTAGE_2V80:
+     setPmu_LAUX1_Config_LDOVoltage(&pmu,LAUX1_CONFIG_LDOVOLTAGE_V280);
+     return PMU_OK;
+    case PMU_VOLTAGE_2V85:
+     setPmu_LAUX1_Config_LDOVoltage(&pmu,LAUX1_CONFIG_LDOVOLTAGE_V285);
+     return PMU_OK;
+    case PMU_VOLTAGE_FIXED:
+     return PMU_OK;
+    default:
+      return PMU_ERR_INV_VOLT; /*voltage not supported */
+  }
+
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_int_hal_cfg_internal.h */
+ePMU_RETURN_T PMU_int_hal_set_laux1_mode
+(
+  const ePMU_MODE_LIST_T mode
+)
+{
+  /* configure LAUX1 mode map offical enum to HW related enums */
+  switch(mode)
+  {
+    case PMU_MODE_FIXED:
+       return PMU_OK; /* nothing has to be done here */
+    case PMU_MODE_ON:
+       setPmu_LAUX1_Config_LDOMode(&pmu,LAUX1_CONFIG_LDOMODE_ON);
+       return PMU_OK;
+    case PMU_MODE_IDLE_STDBY:
+       setPmu_LAUX1_Config_LDOMode(&pmu,LAUX1_CONFIG_LDOMODE_STDBYMODE);
+       return PMU_OK;
+    case PMU_MODE_OFF_STDBY:
+       setPmu_LAUX1_Config_LDOMode(&pmu,LAUX1_CONFIG_LDOMODE_STDBYOFF);
+       return PMU_OK;
+    case PMU_MODE_OFF:
+       setPmu_LAUX1_Config_LDOMode(&pmu,LAUX1_CONFIG_LDOMODE_OFF);
+       return PMU_OK;
+    default:
+       return PMU_ERR_INV_MODE;
+  }
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_int_hal_cfg_internal.h */
+ePMU_RETURN_T PMU_int_hal_set_laux1_pull_down
+(
+  const BOOL pull_down
+)
+{
+  /* configure LAUX1 pull down map offical enum to HW related enum */
+  if (pull_down)
+  {
+    setPmu_LAUX1_Config_LDOPullDown(&pmu,LAUX1_CONFIG_LDOPULLDOWN_ON);
+  }
+  else
+  {
+    setPmu_LAUX1_Config_LDOPullDown(&pmu,LAUX1_CONFIG_LDOPULLDOWN_OFF);
+  }
+  return PMU_OK;
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/****************************************************************************************
+* LAUX2 regulator
+****************************************************************************************/
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_int_hal_cfg_internal.h */
+ePMU_RETURN_T PMU_int_hal_get_laux2_info
+(
+  ePMU_VOLTAGE_LIST_T * const pmu_volt_p,
+  ePMU_VOLTAGE_LIST_T * const pmu_volt_nom_p,
+  ePMU_MODE_LIST_T    * const pmu_mode_p
+)
+{
+ ePMU_RETURN_T PMU_ret_val = PMU_OK;
+ uLAUX2_Config myLDO_AUX2 = {0};
+
+    /* Check input parameters */
+ if ((NULL == pmu_volt_p) ||
+      (NULL == pmu_volt_nom_p) ||
+      (NULL == pmu_mode_p))
+ {
+    PMU_ret_val = PMU_ERR_INV_ARG;
+ }
+ else
+ {
+    /* LAUX2 power domain */
+    myLDO_AUX2.LAUX2_Config_Content = getPmu_LAUX2_Config(&pmu);
+    switch (myLDO_AUX2.LAUX2_Config_Structure.LDOVoltage)
+    {
+      case LAUX2_CONFIG_LDOVOLTAGE_V180:
+        *pmu_volt_p = PMU_VOLTAGE_1V80;
+        break;
+      case LAUX2_CONFIG_LDOVOLTAGE_V250:
+        *pmu_volt_p = PMU_VOLTAGE_2V50;
+        break;
+      case LAUX2_CONFIG_LDOVOLTAGE_V280:
+        *pmu_volt_p = PMU_VOLTAGE_2V80;
+        break;
+      case LAUX2_CONFIG_LDOVOLTAGE_V285:
+        *pmu_volt_p = PMU_VOLTAGE_2V85;
+        break;
+    }
+    *pmu_volt_nom_p = *pmu_volt_p;
+    switch (myLDO_AUX2.LAUX2_Config_Structure.LDOMode)
+    {
+      case LAUX2_CONFIG_LDOMODE_OFF:
+        *pmu_mode_p = PMU_MODE_OFF;
+        break;
+      case LAUX2_CONFIG_LDOMODE_STDBYOFF:
+        *pmu_mode_p = PMU_MODE_OFF_STDBY;
+        break;
+      case LAUX2_CONFIG_LDOMODE_STDBYMODE:
+          *pmu_mode_p = PMU_MODE_IDLE_STDBY;
+        break;
+      case LAUX2_CONFIG_LDOMODE_ON:
+        *pmu_mode_p = PMU_MODE_ON;
+        break;
+     }
+ }
+  return PMU_ret_val;
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_int_hal_cfg_internal.h */
+ePMU_RETURN_T PMU_int_hal_set_laux2_voltage
+(
+  const ePMU_VOLTAGE_LIST_T voltage
+)
+{
+  /* configure LAUX2 voltage map offical enum to HW related enums */
+  switch(voltage)
+  {
+    case PMU_VOLTAGE_1V80:
+     setPmu_LAUX2_Config_LDOVoltage(&pmu,LAUX2_CONFIG_LDOVOLTAGE_V180);
+     return PMU_OK;
+    case PMU_VOLTAGE_2V50:
+     setPmu_LAUX2_Config_LDOVoltage(&pmu,LAUX2_CONFIG_LDOVOLTAGE_V250);
+     return PMU_OK;
+    case PMU_VOLTAGE_2V80:
+     setPmu_LAUX2_Config_LDOVoltage(&pmu,LAUX2_CONFIG_LDOVOLTAGE_V280);
+     return PMU_OK;
+    case PMU_VOLTAGE_2V85:
+     setPmu_LAUX2_Config_LDOVoltage(&pmu,LAUX2_CONFIG_LDOVOLTAGE_V285);
+     return PMU_OK;
+    case PMU_VOLTAGE_FIXED:
+     return PMU_OK;
+    default:
+      return PMU_ERR_INV_VOLT; /*voltage not supported */
+  }
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_int_hal_cfg_internal.h */
+ePMU_RETURN_T PMU_int_hal_set_laux2_mode
+(
+  const ePMU_MODE_LIST_T mode
+)
+{
+  /* configure LAUX2 mode map offical enum to HW related enums */
+  switch(mode)
+  {
+    case PMU_MODE_FIXED:
+       return PMU_OK; /* nothing has to be done here */
+    case PMU_MODE_ON:
+       setPmu_LAUX2_Config_LDOMode(&pmu,LAUX2_CONFIG_LDOMODE_ON);
+       return PMU_OK;
+    case PMU_MODE_IDLE_STDBY:
+       setPmu_LAUX2_Config_LDOMode(&pmu,LAUX2_CONFIG_LDOMODE_STDBYMODE);
+       return PMU_OK;
+    case PMU_MODE_OFF_STDBY:
+       setPmu_LAUX2_Config_LDOMode(&pmu,LAUX2_CONFIG_LDOMODE_STDBYOFF);
+       return PMU_OK;
+    case PMU_MODE_OFF:
+       setPmu_LAUX2_Config_LDOMode(&pmu,LAUX2_CONFIG_LDOMODE_OFF);
+       return PMU_OK;
+    default:
+       return PMU_ERR_INV_MODE;
+  }
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_int_hal_cfg_internal.h */
+ePMU_RETURN_T PMU_int_hal_set_laux2_pull_down
+(
+  const BOOL pull_down
+)
+{
+  /* configure LAUX2 pull down map offical enum to HW related enum */
+  if (pull_down)
+  {
+    setPmu_LAUX2_Config_LDOPullDown(&pmu,LAUX2_CONFIG_LDOPULLDOWN_ON);
+  }
+  else
+  {
+    setPmu_LAUX2_Config_LDOPullDown(&pmu,LAUX2_CONFIG_LDOPULLDOWN_OFF);
+  }
+  return PMU_OK;
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------------*/
+/****************************************************************************************
+* LCABB regulator
+****************************************************************************************/
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_int_hal_cfg_internal.h */
+ePMU_RETURN_T PMU_int_hal_get_lcabb_info
+(
+  ePMU_VOLTAGE_LIST_T * const pmu_volt_p,
+  ePMU_VOLTAGE_LIST_T * const pmu_volt_nom_p,
+  ePMU_MODE_LIST_T    * const pmu_mode_p
+)
+{
+  ePMU_RETURN_T PMU_ret_val = PMU_OK;
+  uLCABB_Config myLDO_LCABB = {0};
+
+    /* Check input parameters */
+  if ((NULL == pmu_volt_p) ||
+      (NULL == pmu_volt_nom_p) ||
+      (NULL == pmu_mode_p))
+  {
+    PMU_ret_val = PMU_ERR_INV_ARG;
+  }
+  else
+  {
+    /* LCABB power domain */
+    myLDO_LCABB.LCABB_Config_Content = getPmu_LCABB_Config(&pmu);
+    switch (myLDO_LCABB.LCABB_Config_Structure.LDOVoltage)
+    {
+      case LCABB_CONFIG_LDOVOLTAGE_V100:
+        *pmu_volt_p = PMU_VOLTAGE_1V00;
+        break;
+      case LCABB_CONFIG_LDOVOLTAGE_V112:
+        *pmu_volt_p = PMU_VOLTAGE_1V12;
+        break;
+      case LCABB_CONFIG_LDOVOLTAGE_V116:
+        *pmu_volt_p = PMU_VOLTAGE_1V16;
+        break;
+      case LCABB_CONFIG_LDOVOLTAGE_V120:
+        *pmu_volt_p = PMU_VOLTAGE_1V20;
+        break;
+     }
+    *pmu_volt_nom_p = *pmu_volt_p;
+    switch (myLDO_LCABB.LCABB_Config_Structure.LDOMode)
+    {
+      case LCABB_CONFIG_LDOMODE_STDBYHIGHVOLTAGE:
+        *pmu_mode_p = PMU_MODE_STANDBYHIGHVOLTAGE;
+        break;
+      case LCABB_CONFIG_LDOMODE_STDBYLOWVOLTAGE:
+          *pmu_mode_p = PMU_MODE_STANDBYLOWVOLTAGE;
+        break;
+      case LCABB_CONFIG_LDOMODE_NU1:
+      case LCABB_CONFIG_LDOMODE_ON:
+        *pmu_mode_p = PMU_MODE_ON;
+        break;
+     }
+  }
+
+  return PMU_ret_val;
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------------*/
+
+ePMU_RETURN_T PMU_int_hal_set_lcabb_voltage
+(
+  const ePMU_VOLTAGE_LIST_T voltage
+)
+{
+  /* configure LCABB voltage map offical enum to HW related enums */
+  switch(voltage)
+  {
+    case PMU_VOLTAGE_1V00:
+     setPmu_LCABB_Config_LDOVoltage(&pmu,LCABB_CONFIG_LDOVOLTAGE_V100);
+     return PMU_OK;
+    case PMU_VOLTAGE_1V12:
+     setPmu_LCABB_Config_LDOVoltage(&pmu,LCABB_CONFIG_LDOVOLTAGE_V112);
+     return PMU_OK;
+    case PMU_VOLTAGE_1V16:
+     setPmu_LCABB_Config_LDOVoltage(&pmu,LCABB_CONFIG_LDOVOLTAGE_V116);
+     return PMU_OK;
+    case PMU_VOLTAGE_1V20:
+     setPmu_LCABB_Config_LDOVoltage(&pmu,LCABB_CONFIG_LDOVOLTAGE_V120);
+     return PMU_OK;
+    case PMU_VOLTAGE_FIXED:
+     return PMU_OK;
+    default:
+      return PMU_ERR_INV_VOLT; /*voltage not supported */
+  }
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_int_hal_cfg_internal.h */
+ePMU_RETURN_T PMU_int_hal_set_lcabb_mode
+(
+  const ePMU_MODE_LIST_T mode
+)
+{
+  /* configure LCABB mode map offical enum to HW related enums */
+  switch(mode)
+  {
+    case PMU_MODE_FIXED:
+       return PMU_OK; /* nothing has to be done here */
+    case PMU_MODE_ON:
+       setPmu_LCABB_Config_LDOMode(&pmu,LCABB_CONFIG_LDOMODE_ON);
+       return PMU_OK;
+    case PMU_MODE_IDLE_STDBY:
+    case PMU_MODE_STANDBYHIGHVOLTAGE:
+       setPmu_LCABB_Config_LDOMode(&pmu,LCABB_CONFIG_LDOMODE_STDBYHIGHVOLTAGE);
+       return PMU_OK;
+    case PMU_MODE_OFF_STDBY:
+    case PMU_MODE_STANDBYLOWVOLTAGE:
+       setPmu_LCABB_Config_LDOMode(&pmu,LCABB_CONFIG_LDOMODE_STDBYLOWVOLTAGE);
+       return PMU_OK;
+    case PMU_MODE_OFF:  /*cannot be off*/
+    default:
+       return PMU_ERR_INV_MODE;
+  }
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_int_hal_cfg_internal.h */
+ePMU_RETURN_T PMU_int_hal_set_lcabb_pull_down
+(
+  const BOOL pull_down
+)
+{
+  /* configure LCABB pull down map offical enum to HW related enum */
+  if (pull_down)
+  {
+   setPmu_LCABB_Config_LDOPullDown(&pmu,LCABB_CONFIG_LDOPULLDOWN_ON);
+  }
+  else
+  {
+   setPmu_LCABB_Config_LDOPullDown(&pmu,LCABB_CONFIG_LDOPULLDOWN_OFF);
+  }
+  return PMU_OK;
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------------*/
+/****************************************************************************************
+* LMMC1 regulator
+****************************************************************************************/
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_int_hal_cfg_internal.h */
+ePMU_RETURN_T PMU_int_hal_get_lmmc1_info
+(
+  ePMU_VOLTAGE_LIST_T * const pmu_volt_p,
+  ePMU_VOLTAGE_LIST_T * const pmu_volt_nom_p,
+  ePMU_MODE_LIST_T    * const pmu_mode_p
+)
+{
+  ePMU_RETURN_T PMU_ret_val = PMU_OK;
+  uLMMC1_Config myLDO_MMC = {0};
+
+    /* Check input parameters */
+  if ((NULL == pmu_volt_p) ||
+      (NULL == pmu_volt_nom_p) ||
+      (NULL == pmu_mode_p))
+  {
+    PMU_ret_val = PMU_ERR_INV_ARG;
+  }
+  else
+  {
+    /* LMMC1 power domain */
+    myLDO_MMC.LMMC1_Config_Content = getPmu_LMMC1_Config(&pmu);
+    switch (myLDO_MMC.LMMC1_Config_Structure.LDOVoltage)
+    {
+      case LMMC1_CONFIG_LDOVOLTAGE_V120:
+        *pmu_volt_p = PMU_VOLTAGE_1V20;
+        break;
+      case LMMC1_CONFIG_LDOVOLTAGE_V180:
+        *pmu_volt_p = PMU_VOLTAGE_1V80;
+        break;
+      case LMMC1_CONFIG_LDOVOLTAGE_V285:
+        *pmu_volt_p = PMU_VOLTAGE_2V85;
+        break;
+      case LMMC1_CONFIG_LDOVOLTAGE_V290:
+        *pmu_volt_p = PMU_VOLTAGE_2V90;
+        break;
+     }
+    *pmu_volt_nom_p = *pmu_volt_p;
+    switch (myLDO_MMC.LMMC1_Config_Structure.LDOMode)
+    {
+      case LMMC1_CONFIG_LDOMODE_OFF:
+        *pmu_mode_p = PMU_MODE_OFF;
+        break;
+      case LMMC1_CONFIG_LDOMODE_STDBYOFF:
+        *pmu_mode_p = PMU_MODE_OFF_STDBY;
+        break;
+      case LMMC1_CONFIG_LDOMODE_STDBYMODE:
+        *pmu_mode_p = PMU_MODE_IDLE_STDBY;
+        break;
+      case LMMC1_CONFIG_LDOMODE_ON:
+        *pmu_mode_p = PMU_MODE_ON;
+        break;
+     }
+  }
+
+  return PMU_ret_val;
+}
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_int_hal_cfg_internal.h */
+ePMU_RETURN_T PMU_int_hal_set_lmmc1_voltage
+(
+  const ePMU_VOLTAGE_LIST_T voltage
+)
+{
+ /* configure LMMC1 voltage map offical enum to HW related enums */
+ switch(voltage)
+ {
+   case PMU_VOLTAGE_1V20:
+    setPmu_LMMC1_Config_LDOVoltage(&pmu,LMMC1_CONFIG_LDOVOLTAGE_V120);
+    return PMU_OK;
+   case PMU_VOLTAGE_1V80:
+    setPmu_LMMC1_Config_LDOVoltage(&pmu,LMMC1_CONFIG_LDOVOLTAGE_V180);
+    return PMU_OK;
+   case PMU_VOLTAGE_2V85:
+    setPmu_LMMC1_Config_LDOVoltage(&pmu,LMMC1_CONFIG_LDOVOLTAGE_V285);
+    return PMU_OK;
+   case PMU_VOLTAGE_2V90:
+    setPmu_LMMC1_Config_LDOVoltage(&pmu,LMMC1_CONFIG_LDOVOLTAGE_V290);
+    return PMU_OK;
+   case PMU_VOLTAGE_FIXED:
+    return PMU_OK;
+   default:
+     return PMU_ERR_INV_VOLT; /*voltage not supported */
+ }
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_int_hal_cfg_internal.h */
+ePMU_RETURN_T PMU_int_hal_set_lmmc1_mode
+(
+  const ePMU_MODE_LIST_T mode
+)
+{
+  /* configure LMMC1 mode map offical enum to HW related enums */
+  switch(mode)
+  {
+    case PMU_MODE_FIXED:
+       return PMU_OK; /* nothing has to be done here */
+    case PMU_MODE_ON:
+       setPmu_LMMC1_Config_LDOMode(&pmu,LMMC1_CONFIG_LDOMODE_ON);
+       return PMU_OK;
+    case PMU_MODE_IDLE_STDBY:
+       setPmu_LMMC1_Config_LDOMode(&pmu,LMMC1_CONFIG_LDOMODE_STDBYMODE);
+       return PMU_OK;
+    case PMU_MODE_OFF_STDBY:
+       setPmu_LMMC1_Config_LDOMode(&pmu,LMMC1_CONFIG_LDOMODE_STDBYOFF);
+       return PMU_OK;
+    case PMU_MODE_OFF:
+       setPmu_LMMC1_Config_LDOMode(&pmu,LMMC1_CONFIG_LDOMODE_OFF);
+       return PMU_OK;
+    default:
+       return PMU_ERR_INV_MODE;
+   }
+
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_int_hal_cfg_internal.h */
+ePMU_RETURN_T PMU_int_hal_set_lmmc1_pull_down
+(
+  const BOOL pull_down
+)
+{
+  /* configure LMMC1 pull down map offical enum to HW related enum */
+  if (pull_down)
+  {
+    setPmu_LMMC1_Config_LDOPullDown(&pmu,LMMC1_CONFIG_LDOPULLDOWN_ON);
+  }
+  else
+  {
+    setPmu_LMMC1_Config_LDOPullDown(&pmu,LMMC1_CONFIG_LDOPULLDOWN_OFF);
+  }
+
+  return PMU_OK;
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------------*/
+/****************************************************************************************
+* LAIF regulator
+****************************************************************************************/
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_int_hal_cfg_internal.h */
+ePMU_RETURN_T PMU_int_hal_get_laif_info
+(
+  ePMU_VOLTAGE_LIST_T * const pmu_volt_p,
+  ePMU_VOLTAGE_LIST_T * const pmu_volt_nom_p,
+  ePMU_MODE_LIST_T    * const pmu_mode_p
+)
+{
+  ePMU_RETURN_T PMU_ret_val = PMU_OK;
+   uLAIF_Config myLDO_AIF = {0};
+
+     /* Check input parameters */
+   if ((NULL == pmu_volt_p) ||
+       (NULL == pmu_volt_nom_p) ||
+       (NULL == pmu_mode_p))
+   {
+     PMU_ret_val = PMU_ERR_INV_ARG;
+   }
+   else
+   {
+     /* LAIF power domain */
+     myLDO_AIF.LAIF_Config_Content = getPmu_LAIF_Config(&pmu);
+     switch (myLDO_AIF.LAIF_Config_Structure.LDOVoltage)
+     {
+#ifdef AG620_ES2_0_DEFINED
+       case LAIF_CONFIG_LDOVOLTAGE_V120:
+         *pmu_volt_p = PMU_VOLTAGE_1V20;
+         break;
+       case LAIF_CONFIG_LDOVOLTAGE_V180:
+         *pmu_volt_p = PMU_VOLTAGE_1V80;
+         break;
+#else
+       case LAIF_CONFIG_LDOVOLTAGE_V180:
+         *pmu_volt_p = PMU_VOLTAGE_1V80;
+         break;
+       case LAIF_CONFIG_LDOVOLTAGE_V250:
+         *pmu_volt_p = PMU_VOLTAGE_2V50;
+         break;
+#endif
+       case LAIF_CONFIG_LDOVOLTAGE_V110:
+         *pmu_volt_p = PMU_VOLTAGE_1V10;
+         break;
+       case LAIF_CONFIG_LDOVOLTAGE_V100:
+         *pmu_volt_p = PMU_VOLTAGE_1V00;
+         break;
+     }
+     *pmu_volt_nom_p = *pmu_volt_p;
+     switch (myLDO_AIF.LAIF_Config_Structure.LDOMode)
+     {
+      case LAIF_CONFIG_LDOMODE_OFF:
+        *pmu_mode_p = PMU_MODE_OFF;
+        break;
+      case LAIF_CONFIG_LDOMODE_STDBYOFF:
+        *pmu_mode_p = PMU_MODE_OFF_STDBY;
+        break;
+      case LAIF_CONFIG_LDOMODE_STDBYMODE:
+        *pmu_mode_p = PMU_MODE_IDLE_STDBY;
+        break;
+      case LAIF_CONFIG_LDOMODE_ON:
+        *pmu_mode_p = PMU_MODE_ON;
+        break;
+      }
+   }
+
+   return PMU_ret_val;
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_int_hal_cfg_internal.h */
+ePMU_RETURN_T PMU_int_hal_set_laif_voltage
+(
+  const ePMU_VOLTAGE_LIST_T voltage
+)
+{
+  /* configure LAIF voltage map offical enum to HW related enums */
+  switch(voltage)
+  {
+    case PMU_VOLTAGE_1V00:
+     setPmu_LAIF_Config_LDOVoltage(&pmu,LAIF_CONFIG_LDOVOLTAGE_V100);
+     return PMU_OK;
+    case PMU_VOLTAGE_1V10:
+     setPmu_LAIF_Config_LDOVoltage(&pmu,LAIF_CONFIG_LDOVOLTAGE_V110);
+     return PMU_OK;
+#ifdef AG620_ES2_0_DEFINED
+    case PMU_VOLTAGE_1V20:
+     setPmu_LAIF_Config_LDOVoltage(&pmu,LAIF_CONFIG_LDOVOLTAGE_V120);
+     return PMU_OK;
+    case PMU_VOLTAGE_1V80:
+     setPmu_LAIF_Config_LDOVoltage(&pmu,LAIF_CONFIG_LDOVOLTAGE_V180);
+     return PMU_OK;
+#else
+    case PMU_VOLTAGE_1V80:
+     setPmu_LAIF_Config_LDOVoltage(&pmu,LAIF_CONFIG_LDOVOLTAGE_V180);
+     return PMU_OK;
+    case PMU_VOLTAGE_2V50:
+     setPmu_LAIF_Config_LDOVoltage(&pmu,LAIF_CONFIG_LDOVOLTAGE_V250);
+     return PMU_OK;
+#endif
+    case PMU_VOLTAGE_FIXED:
+     return PMU_OK;
+    default:
+      return PMU_ERR_INV_VOLT; /*voltage not supported */
+  }
+
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_int_hal_cfg_internal.h */
+ePMU_RETURN_T PMU_int_hal_set_laif_mode
+(
+  const ePMU_MODE_LIST_T mode
+)
+{
+    /* configure LAIF mode map offical enum to HW related enums */
+  switch(mode)
+  {
+    case PMU_MODE_FIXED:
+       return PMU_OK; /* nothing has to be done here */
+    case PMU_MODE_ON:
+       setPmu_LAIF_Config_LDOMode(&pmu,LAIF_CONFIG_LDOMODE_ON);
+       return PMU_OK;
+    case PMU_MODE_IDLE_STDBY:
+       setPmu_LAIF_Config_LDOMode(&pmu,LAIF_CONFIG_LDOMODE_STDBYMODE);
+       return PMU_OK;
+    case PMU_MODE_OFF_STDBY:
+       setPmu_LAIF_Config_LDOMode(&pmu,LAIF_CONFIG_LDOMODE_STDBYOFF);
+       return PMU_OK;
+    case PMU_MODE_OFF:
+       setPmu_LAIF_Config_LDOMode(&pmu,LAIF_CONFIG_LDOMODE_OFF);
+       return PMU_OK;
+    default:
+       return PMU_ERR_INV_MODE;
+  }
+
+
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_int_hal_cfg_internal.h */
+ePMU_RETURN_T PMU_int_hal_set_laif_pull_down
+(
+  const BOOL pull_down
+)
+{
+
+ /* configure LAIF pull down map offical enum to HW related enum */
+ if (pull_down)
+ {
+   setPmu_LAIF_Config_LDOPullDown(&pmu,LAIF_CONFIG_LDOPULLDOWN_ON);
+ }
+ else
+ {
+   setPmu_LAIF_Config_LDOPullDown(&pmu,LAIF_CONFIG_LDOPULLDOWN_OFF);
+ }
+
+ return PMU_OK;
+
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------------*/
+/****************************************************************************************
+* LUSB regulator
+****************************************************************************************/
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_int_hal_cfg_internal.h */
+ePMU_RETURN_T PMU_int_hal_get_lusb_info
+(
+  ePMU_VOLTAGE_LIST_T * const pmu_volt_p,
+  ePMU_VOLTAGE_LIST_T * const pmu_volt_nom_p,
+  ePMU_MODE_LIST_T    * const pmu_mode_p
+)
+{
+  ePMU_RETURN_T PMU_ret_val = PMU_OK;
+  uLUSB_Config myLDO_USB = {0};
+
+    /* Check input parameters */
+  if ((NULL == pmu_volt_p) ||
+      (NULL == pmu_volt_nom_p) ||
+      (NULL == pmu_mode_p))
+  {
+    PMU_ret_val = PMU_ERR_INV_ARG;
+  }
+  else
+  {
+    /* LUSB power domain */
+    myLDO_USB.LUSB_Config_Content = getPmu_LUSB_Config(&pmu);
+    switch (myLDO_USB.LUSB_Config_Structure.LDOVoltage)
+    {
+      case LUSB_CONFIG_LDOVOLTAGE_VNU:
+      case LUSB_CONFIG_LDOVOLTAGE_V250:
+         *pmu_volt_p = PMU_VOLTAGE_2V50;
+         break;
+      case LUSB_CONFIG_LDOVOLTAGE_V285:
+         *pmu_volt_p = PMU_VOLTAGE_2V85;
+         break;
+      case LUSB_CONFIG_LDOVOLTAGE_V315:
+         *pmu_volt_p = PMU_VOLTAGE_3V15;
+         break;
+     }
+    *pmu_volt_nom_p = *pmu_volt_p;
+    switch (myLDO_USB.LUSB_Config_Structure.LDOMode)
+    {
+      case LUSB_CONFIG_LDOMODE_OFF:
+        *pmu_mode_p = PMU_MODE_OFF;
+        break;
+      case LUSB_CONFIG_LDOMODE_STDBYOFF:
+        *pmu_mode_p = PMU_MODE_OFF_STDBY;
+        break;
+      case LUSB_CONFIG_LDOMODE_STDBYMODE:
+        *pmu_mode_p = PMU_MODE_IDLE_STDBY;
+        break;
+      case LUSB_CONFIG_LDOMODE_ON:
+        *pmu_mode_p = PMU_MODE_ON;
+        break;
+     }
+  }
+  return PMU_ret_val;
+}
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_int_hal_cfg_internal.h */
+ePMU_RETURN_T PMU_int_hal_set_lusb_voltage
+(
+  const ePMU_VOLTAGE_LIST_T voltage
+)
+{
+    /* configure LUSB voltage map offical enum to HW related enums */
+    switch(voltage)
+    {
+      case PMU_VOLTAGE_2V50:
+       setPmu_LUSB_Config_LDOVoltage(&pmu,LUSB_CONFIG_LDOVOLTAGE_V250);
+       return PMU_OK;
+      case PMU_VOLTAGE_2V85:
+       setPmu_LUSB_Config_LDOVoltage(&pmu,LUSB_CONFIG_LDOVOLTAGE_V285);
+       return PMU_OK;
+      case PMU_VOLTAGE_3V15:
+       setPmu_LUSB_Config_LDOVoltage(&pmu,LUSB_CONFIG_LDOVOLTAGE_V315);
+       return PMU_OK;
+      case PMU_VOLTAGE_FIXED:
+       return PMU_OK;
+      default:
+        return PMU_ERR_INV_VOLT; /*voltage not supported */
+    }
+
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_int_hal_cfg_internal.h */
+ePMU_RETURN_T PMU_int_hal_set_lusb_mode
+(
+  const ePMU_MODE_LIST_T mode
+)
+{
+    /* configure LUSB mode map offical enum to HW related enums */
+  switch(mode)
+  {
+    case PMU_MODE_FIXED:
+       return PMU_OK; /* nothing has to be done here */
+    case PMU_MODE_ON:
+       setPmu_LUSB_Config_LDOMode(&pmu,LUSB_CONFIG_LDOMODE_ON);
+       return PMU_OK;
+    case PMU_MODE_IDLE_STDBY:
+       setPmu_LUSB_Config_LDOMode(&pmu,LUSB_CONFIG_LDOMODE_STDBYMODE);
+       return PMU_OK;
+    case PMU_MODE_OFF_STDBY:
+       setPmu_LUSB_Config_LDOMode(&pmu,LUSB_CONFIG_LDOMODE_STDBYOFF);
+       return PMU_OK;
+    case PMU_MODE_OFF:
+       setPmu_LUSB_Config_LDOMode(&pmu,LUSB_CONFIG_LDOMODE_OFF);
+       return PMU_OK;
+    default:
+       return PMU_ERR_INV_MODE;
+  }
+
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_int_hal_cfg_internal.h */
+ePMU_RETURN_T PMU_int_hal_set_lusb_pull_down
+(
+  const BOOL pull_down
+)
+{
+    /* configure LUSB pull down map offical enum to HW related enum */
+    if (pull_down)
+    {
+      setPmu_LUSB_Config_LDOPullDown(&pmu,LUSB_CONFIG_LDOPULLDOWN_ON);
+    }
+    else
+    {
+      setPmu_LUSB_Config_LDOPullDown(&pmu,LUSB_CONFIG_LDOPULLDOWN_OFF);
+    }
+
+    return PMU_OK;
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+/****************************************************************************************
+* LPMU regulator
+****************************************************************************************/
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_int_hal_cfg_internal.h */
+ePMU_RETURN_T PMU_int_hal_get_lpmu_info
+(
+  ePMU_VOLTAGE_LIST_T * const pmu_volt_p,
+  ePMU_VOLTAGE_LIST_T * const pmu_volt_nom_p,
+  ePMU_MODE_LIST_T    * const pmu_mode_p
+)
+{
+ return PMU_OK;
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+/****************************************************************************************
+* LMEM regulator
+****************************************************************************************/
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_int_hal_cfg_internal.h */
+ePMU_RETURN_T PMU_int_hal_get_lmem_info
+(
+  ePMU_VOLTAGE_LIST_T * const pmu_volt_p,
+  ePMU_VOLTAGE_LIST_T * const pmu_volt_nom_p,
+  ePMU_MODE_LIST_T    * const pmu_mode_p
+)
+{
+  ePMU_RETURN_T PMU_ret_val = PMU_OK;
+  uLMEM_Config myLDO_MEM = {0};
+
+    /* Check input parameters */
+  if ((NULL == pmu_volt_p) ||
+      (NULL == pmu_volt_nom_p) ||
+      (NULL == pmu_mode_p))
+  {
+    PMU_ret_val = PMU_ERR_INV_ARG;
+  }
+  else
+  {
+    /* LMEM power domain */
+    myLDO_MEM.LMEM_Config_Content = getPmu_LMEM_Config(&pmu);
+    switch (myLDO_MEM.LMEM_Config_Structure.LDOVoltage)
+    {
+      case LMEM_CONFIG_LDOVOLTAGE_V102:
+        *pmu_volt_p = PMU_VOLTAGE_1V02;
+        break;
+      case LMEM_CONFIG_LDOVOLTAGE_V112:
+        *pmu_volt_p = PMU_VOLTAGE_1V12;
+        break;
+      case LMEM_CONFIG_LDOVOLTAGE_V1226:
+        *pmu_volt_p = PMU_VOLTAGE_1V226;
+        break;
+      case LMEM_CONFIG_LDOVOLTAGE_V125:
+        *pmu_volt_p = PMU_VOLTAGE_1V25;
+        break;
+     }
+    *pmu_volt_nom_p = *pmu_volt_p;
+    switch (myLDO_MEM.LMEM_Config_Structure.LDOMode)
+    {
+      case LMEM_CONFIG_LDOMODE_OFF:
+        *pmu_mode_p = PMU_MODE_OFF;
+         break;
+      case LMEM_CONFIG_LDOMODE_STDBYOFF:
+        *pmu_mode_p = PMU_MODE_OFF_STDBY;
+         break;
+      case LMEM_CONFIG_LDOMODE_STDBYMODE:
+        *pmu_mode_p = PMU_MODE_IDLE_STDBY;
+        break;
+      case LMEM_CONFIG_LDOMODE_ON:
+        *pmu_mode_p = PMU_MODE_ON;
+        break;
+     }
+  }
+
+  return PMU_ret_val;
+}
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_int_hal_cfg_internal.h */
+ePMU_RETURN_T PMU_int_hal_set_lmem_voltage
+(
+  const ePMU_VOLTAGE_LIST_T voltage
+)
+{
+    /* configure LMEM voltage map offical enum to HW related enums */
+    switch(voltage)
+    {
+      case PMU_VOLTAGE_1V02:
+       setPmu_LMEM_Config_LDOVoltage(&pmu,LMEM_CONFIG_LDOVOLTAGE_V102);
+       return PMU_OK;
+      case PMU_VOLTAGE_1V12:
+       setPmu_LMEM_Config_LDOVoltage(&pmu,LMEM_CONFIG_LDOVOLTAGE_V112);
+       return PMU_OK;
+      case PMU_VOLTAGE_1V226:
+       setPmu_LMEM_Config_LDOVoltage(&pmu,LMEM_CONFIG_LDOVOLTAGE_V1226);
+       return PMU_OK;
+      case PMU_VOLTAGE_1V25:
+       setPmu_LMEM_Config_LDOVoltage(&pmu,LMEM_CONFIG_LDOVOLTAGE_V125);
+       return PMU_OK;
+      case PMU_VOLTAGE_FIXED:
+       return PMU_OK;
+      default:
+        return PMU_ERR_INV_VOLT; /*voltage not supported */
+    }
+
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_int_hal_cfg_internal.h */
+ePMU_RETURN_T PMU_int_hal_set_lmem_mode
+(
+  const ePMU_MODE_LIST_T mode
+)
+{
+    /* configure LMEM mode map offical enum to HW related enums */
+  switch(mode)
+  {
+    case PMU_MODE_FIXED:
+       return PMU_OK; /* nothing has to be done here */
+    case PMU_MODE_ON:
+       setPmu_LMEM_Config_LDOMode(&pmu,LMEM_CONFIG_LDOMODE_ON);
+       return PMU_OK;
+    case PMU_MODE_IDLE_STDBY:
+     setPmu_LMEM_Config_LDOMode(&pmu,LMEM_CONFIG_LDOMODE_STDBYMODE);
+       return PMU_OK;
+    case PMU_MODE_OFF_STDBY:
+      setPmu_LMEM_Config_LDOMode(&pmu,LMEM_CONFIG_LDOMODE_STDBYOFF);
+      return PMU_OK;
+    case PMU_MODE_OFF:
+      setPmu_LMEM_Config_LDOMode(&pmu,LMEM_CONFIG_LDOMODE_OFF);
+      return PMU_OK;
+    default:
+       return PMU_ERR_INV_MODE;
+
+  }
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_int_hal_cfg_internal.h */
+ePMU_RETURN_T PMU_int_hal_set_lmem_pull_down
+(
+  const BOOL pull_down
+)
+{
+    /* configure LMEM pull down map offical enum to HW related enum */
+    if (pull_down)
+    {
+      setPmu_LMEM_Config_LDOPullDown(&pmu,LMEM_CONFIG_LDOPULLDOWN_ON);
+    }
+    else
+    {
+      setPmu_LMEM_Config_LDOPullDown(&pmu,LMEM_CONFIG_LDOPULLDOWN_OFF);
+    }
+
+    return PMU_OK;
+}
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------------*/
+/****************************************************************************************
+* LMIPI regulator
+****************************************************************************************/
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_int_hal_cfg_internal.h */
+ePMU_RETURN_T PMU_int_hal_get_lmipi_info
+(
+  ePMU_VOLTAGE_LIST_T * const pmu_volt_p,
+  ePMU_VOLTAGE_LIST_T * const pmu_volt_nom_p,
+  ePMU_MODE_LIST_T    * const pmu_mode_p
+)
+{
+  ePMU_RETURN_T PMU_ret_val = PMU_OK;
+  uLMIPI_Config myLDO_MIPI = {0};
+
+    /* Check input parameters */
+  if ((NULL == pmu_volt_p) ||
+      (NULL == pmu_volt_nom_p) ||
+      (NULL == pmu_mode_p))
+  {
+    PMU_ret_val = PMU_ERR_INV_ARG;
+  }
+  else
+  {
+    /* LMIPI power domain */
+    myLDO_MIPI.LMIPI_Config_Content = getPmu_LMIPI_Config(&pmu);
+    switch (myLDO_MIPI.LMIPI_Config_Structure.LDOVoltage)
+    {
+      case LMIPI_CONFIG_LDOVOLTAGE_V100:
+         *pmu_volt_p = PMU_VOLTAGE_1V00;
+        break;
+        case LMIPI_CONFIG_LDOVOLTAGE_V120:
+        *pmu_volt_p = PMU_VOLTAGE_1V20;
+        break;
+      case LMIPI_CONFIG_LDOVOLTAGE_V110:
+        *pmu_volt_p = PMU_VOLTAGE_1V10;
+        break;
+      case LMIPI_CONFIG_LDOVOLTAGE_V117:
+        *pmu_volt_p = PMU_VOLTAGE_1V17;
+        break;
+     }
+    *pmu_volt_nom_p = *pmu_volt_p;
+    switch (myLDO_MIPI.LMIPI_Config_Structure.LDOMode)
+    {
+      case LMIPI_CONFIG_LDOMODE_OFF:
+        *pmu_mode_p = PMU_MODE_OFF;
+        break;
+      case LMIPI_CONFIG_LDOMODE_STDBYOFF:
+        *pmu_mode_p = PMU_MODE_OFF_STDBY;
+        break;
+      case LMIPI_CONFIG_LDOMODE_STDBYMODE:
+        *pmu_mode_p = PMU_MODE_IDLE_STDBY;
+        break;
+      case LMIPI_CONFIG_LDOMODE_ON:
+        *pmu_mode_p = PMU_MODE_ON;
+        break;
+     }
+  }
+
+  return PMU_ret_val;
+}
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_int_hal_cfg_internal.h */
+ePMU_RETURN_T PMU_int_hal_set_lmipi_voltage
+(
+  const ePMU_VOLTAGE_LIST_T voltage
+)
+{
+  /* configure Lmipi voltage map offical enum to HW related enums */
+  switch(voltage)
+  {
+   case PMU_VOLTAGE_1V00:
+    setPmu_LMIPI_Config_LDOVoltage(&pmu,LMIPI_CONFIG_LDOVOLTAGE_V100);
+    return PMU_OK;
+   case PMU_VOLTAGE_1V10:
+    setPmu_LMIPI_Config_LDOVoltage(&pmu,LMIPI_CONFIG_LDOVOLTAGE_V110);
+    return PMU_OK;
+    case PMU_VOLTAGE_1V20:
+     setPmu_LMIPI_Config_LDOVoltage(&pmu,LMIPI_CONFIG_LDOVOLTAGE_V120);
+     return PMU_OK;
+    case PMU_VOLTAGE_1V17:
+     setPmu_LMIPI_Config_LDOVoltage(&pmu,LMIPI_CONFIG_LDOVOLTAGE_V117);
+     return PMU_OK;
+    case PMU_VOLTAGE_FIXED:
+     return PMU_OK;
+    default:
+      return PMU_ERR_INV_VOLT; /*voltage not supported */
+  }
+
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_int_hal_cfg_internal.h */
+ePMU_RETURN_T PMU_int_hal_set_lmipi_mode
+(
+  const ePMU_MODE_LIST_T mode
+)
+{
+  /* configure LMIPI mode map offical enum to HW related enums */
+  switch(mode)
+  {
+    case PMU_MODE_FIXED:
+      return PMU_OK; /* nothing has to be done here */
+    case PMU_MODE_ON:
+      setPmu_LMIPI_Config_LDOMode(&pmu,LMIPI_CONFIG_LDOMODE_ON);
+      return PMU_OK;
+    case PMU_MODE_IDLE_STDBY:
+      setPmu_LMIPI_Config_LDOMode(&pmu,LMIPI_CONFIG_LDOMODE_STDBYMODE);
+      return PMU_OK;
+    case PMU_MODE_OFF_STDBY:
+      setPmu_LMIPI_Config_LDOMode(&pmu,LMIPI_CONFIG_LDOMODE_STDBYOFF);
+      return PMU_OK;
+    case PMU_MODE_OFF:
+      setPmu_LMIPI_Config_LDOMode(&pmu,LMIPI_CONFIG_LDOMODE_OFF);
+      return PMU_OK;
+    default:
+      return PMU_ERR_INV_MODE;
+   }
+
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_int_hal_cfg_internal.h */
+ePMU_RETURN_T PMU_int_hal_set_lmipi_pull_down
+(
+  const BOOL pull_down
+)
+{
+
+  /* configure LAIF pull down map offical enum to HW related enum */
+  if (pull_down)
+  {
+    setPmu_LMIPI_Config_LDOPullDown(&pmu,LMIPI_CONFIG_LDOPULLDOWN_ON);
+  }
+  else
+  {
+    setPmu_LMIPI_Config_LDOPullDown(&pmu,LMIPI_CONFIG_LDOPULLDOWN_OFF);
+  }
+
+  return PMU_OK;
+
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/****************************************************************************************
+ * External regulator for EMMC supply
+ ****************************************************************************************/
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_domain_cfg_internal.h */
+ePMU_RETURN_T PMU_int_hal_get_eldo_vmmc_info
+(
+  ePMU_VOLTAGE_LIST_T * const pmu_volt_p,
+  ePMU_VOLTAGE_LIST_T * const pmu_volt_nom_p,
+  ePMU_MODE_LIST_T    * const pmu_mode_p
+)
+{
+
+  ePMU_RETURN_T PMU_ret_val = PMU_OK;
+
+  /* Check input parameters */
+  if ((NULL == pmu_volt_p) ||
+      (NULL == pmu_volt_nom_p) ||
+      (NULL == pmu_mode_p))
+  {
+    PMU_ret_val = PMU_ERR_INV_ARG;
+  }
+  else
+  {
+    /* EMMC power domain provided by external LDO - controlled via GPIO */
+      *pmu_mode_p = PMU_MODE_ON;
+      *pmu_volt_p = PMU_VOLTAGE_1V80;
+
+    *pmu_volt_nom_p = *pmu_volt_p;
+  }
+
+  return PMU_ret_val;
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_domain_cfg_internal.h */
+ePMU_RETURN_T PMU_int_hal_set_eldo_vmmc_mode
+(
+  const ePMU_MODE_LIST_T mode
+)
+{
+  /* configure EMMC mode map offical enum to HW related enums */
+  switch(mode)
+  {
+    case PMU_MODE_FIXED:
+      return PMU_OK; /* nothing has to be done here */
+    case PMU_MODE_ON:
+      // Switch on ext. LDO by setting GPIO 'High'
+    return PMU_OK;
+    case PMU_MODE_OFF:
+      // Switch off ext. LDO by setting GPIO 'Low'
+    return PMU_OK;
+    case PMU_MODE_IDLE_STDBY:
+      // Fall through by purpose
+    case PMU_MODE_OFF_STDBY:
+      // Fall through by purpose
+    default:
+      return PMU_ERR_INV_MODE;
+  }
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_domain_cfg_internal.h */
+ePMU_RETURN_T PMU_int_hal_set_eldo_vmmc_voltage
+(
+  const ePMU_VOLTAGE_LIST_T voltage
+)
+{
+  /* configure ELAUD mode map offical enum to HW related enums */
+  switch(voltage)
+  {
+    case PMU_VOLTAGE_FIXED:
+      return PMU_OK; /* nothing has to be done here */
+    case PMU_VOLTAGE_1V80:
+    return PMU_OK;
+    default:
+    return PMU_ERR_INV_MODE;
+  }
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+/****************************************************************************************
+ * External regulator for GNSS TCXO control (AG620 ES2.0 only)
+ ****************************************************************************************/
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_domain_cfg_internal.h */
+ePMU_RETURN_T PMU_int_hal_get_gnss_tcxo_ldo_info
+(
+  ePMU_VOLTAGE_LIST_T * const pmu_volt_p,
+  ePMU_VOLTAGE_LIST_T * const pmu_volt_nom_p,
+  ePMU_MODE_LIST_T    * const pmu_mode_p
+)
+{
+
+  ePMU_RETURN_T PMU_ret_val = PMU_OK;
+
+  /* Check input parameters */
+  if ((NULL == pmu_volt_p) ||
+      (NULL == pmu_volt_nom_p) ||
+      (NULL == pmu_mode_p))
+  {
+    PMU_ret_val = PMU_ERR_INV_ARG;
+  }
+  else
+  {
+    /* gnss_tcxo power domain provided by external LDO - controlled via SCU */
+      *pmu_mode_p = PMU_MODE_ON;
+      *pmu_volt_p = PMU_VOLTAGE_FIXED;
+
+    *pmu_volt_nom_p = *pmu_volt_p;
+  }
+
+  return PMU_ret_val;
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_domain_cfg_internal.h */
+ePMU_RETURN_T PMU_int_hal_set_gnss_tcxo_ldo_mode
+(
+  const ePMU_MODE_LIST_T mode
+)
+{
+  ePMU_RETURN_T PMU_ret_val = PMU_OK;
+
+  /* configure gnss_tcxo mode map offical enum to HW related enums */
+  switch(mode)
+  {
+    case PMU_MODE_FIXED:
+      return PMU_OK; /* nothing has to be done here */
+    case PMU_MODE_ON:
+#if defined (AG620_ES2_0_DEFINED)
+      if (SCU_SUCCESS != scu_misc_sp_pur_ap_txco_req_set(TRUE))
+          PMU_ret_val = PMU_ERR_INV_MODE;
+      if (SCU_SUCCESS != scu_misc_sp_pur_ext_txco_set(TRUE))
+         PMU_ret_val = PMU_ERR_INV_MODE;
+#endif
+      return PMU_ret_val;
+    case PMU_MODE_OFF:
+#if defined (AG620_ES2_0_DEFINED)
+      if (SCU_SUCCESS != scu_misc_sp_pur_ap_txco_req_set(FALSE))
+        PMU_ret_val = PMU_ERR_INV_MODE;
+      if (SCU_SUCCESS != scu_misc_sp_pur_ext_txco_set(FALSE))
+        PMU_ret_val = PMU_ERR_INV_MODE;
+#endif
+      return PMU_ret_val;
+    case PMU_MODE_IDLE_STDBY:
+      // Fall through by purpose
+    case PMU_MODE_OFF_STDBY:
+      // Fall through by purpose
+    default:
+      return PMU_ERR_INV_MODE;
+  }
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_domain_cfg_internal.h */
+ePMU_RETURN_T PMU_int_hal_set_gnss_tcxo_ldo_voltage
+(
+  const ePMU_VOLTAGE_LIST_T voltage
+)
+{
+  ePMU_RETURN_T PMU_ret_val = PMU_OK;
+#if defined (AG620_ES2_0_DEFINED)
+  if (SCU_SUCCESS != scu_misc_sp_pur_ap_txco_req_set(TRUE))
+      PMU_ret_val = PMU_ERR_INV_VOLT;
+  if (SCU_SUCCESS != scu_misc_sp_pur_ext_txco_set(TRUE))
+     PMU_ret_val = PMU_ERR_INV_VOLT;
+#endif
+  return PMU_ret_val;
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/****************************************************************************************
+ * garnet External regulator BUCK1 for VCPU
+ ****************************************************************************************/
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_domain_cfg_internal.h */
+ePMU_VOLTAGE_LIST_T current_ext_buck1_voltage = PMU_VOLTAGE_1V00;
+ePMU_RETURN_T PMU_int_hal_set_ext_buck1_voltage
+(
+  const ePMU_VOLTAGE_LIST_T voltage
+)
+{
+  /* buck1 ic: sy8827e controlled by i2c */
+  sy8827e_set_voltage(voltage);
+
+  current_ext_buck1_voltage = voltage;
+  return PMU_OK;
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_domain_cfg_internal.h */
+ePMU_MODE_LIST_T current_vcpu_mode = PMU_MODE_OFF;
+ePMU_RETURN_T PMU_int_hal_get_ext_buck1_info
+(
+  ePMU_VOLTAGE_LIST_T * const pmu_volt_p,
+  ePMU_VOLTAGE_LIST_T * const pmu_volt_nom_p,
+  ePMU_MODE_LIST_T    * const pmu_mode_p
+)
+{
+  ePMU_RETURN_T PMU_ret_val = PMU_OK;
+
+  if (pmu_volt_p != NULL)
+    *pmu_volt_p = current_ext_buck1_voltage;
+
+  if (pmu_volt_p != NULL)
+    *pmu_volt_nom_p = current_ext_buck1_voltage;
+
+  if (pmu_volt_p != NULL)
+    *pmu_mode_p = current_vcpu_mode;
+
+  return PMU_ret_val;
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/****************************************************************************************
+ * garnet External regulator BUCK2 for VGPU
+ ****************************************************************************************/
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_domain_cfg_internal.h */
+ePMU_VOLTAGE_LIST_T current_ext_buck2_voltage = PMU_VOLTAGE_1V00;
+ePMU_RETURN_T PMU_int_hal_set_ext_buck2_voltage
+(
+  const ePMU_VOLTAGE_LIST_T voltage
+)
+{
+#if 0
+  /* sy8827f controlled by i2c, fixed value for VDD_GPU */
+  sy8827f_set_voltage(voltage);
+#endif
+
+  current_ext_buck2_voltage = voltage;
+  return PMU_OK;
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_domain_cfg_internal.h */
+ePMU_RETURN_T PMU_int_hal_get_ext_buck2_info
+(
+  ePMU_VOLTAGE_LIST_T * const pmu_volt_p,
+  ePMU_VOLTAGE_LIST_T * const pmu_volt_nom_p,
+  ePMU_MODE_LIST_T    * const pmu_mode_p
+)
+{
+  ePMU_RETURN_T PMU_ret_val = PMU_OK;
+  *pmu_volt_p = current_ext_buck2_voltage;
+  *pmu_volt_nom_p = current_ext_buck2_voltage;
+  *pmu_mode_p = PMU_MODE_FIXED;
+  return PMU_ret_val;
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/****************************************************************************************
+ * garnet External regulator LDO5 for SDcard
+ ****************************************************************************************/
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_domain_cfg_internal.h */
+ePMU_MODE_LIST_T current_ext_ldo5_mode = PMU_MODE_OFF;
+
+ePMU_RETURN_T PMU_int_hal_set_ext_ldo5_mode
+(
+  const ePMU_MODE_LIST_T mode
+)
+{
+  switch(mode)
+  {
+    case PMU_MODE_FIXED:
+      return PMU_OK; /* nothing has to be done here */
+    case PMU_MODE_ON:
+       *(volatile unsigned int*)(0xE4600280) = 0x1700; //PCL_32 O(H)
+       break;
+    case PMU_MODE_OFF:
+       *(volatile unsigned int*)(0xE4600280) = 0x1500; //PCL_32 O(L)
+       break;
+    case PMU_MODE_IDLE_STDBY:
+      // Fall through by purpose
+    case PMU_MODE_OFF_STDBY:
+      // Fall through by purpose
+    default:
+      return PMU_ERR_INV_MODE;
+  }
+  current_ext_ldo5_mode = mode;
+  return PMU_OK;
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_domain_cfg_internal.h */
+ePMU_RETURN_T PMU_int_hal_get_ext_ldo5_info
+(
+  ePMU_VOLTAGE_LIST_T * const pmu_volt_p,
+  ePMU_VOLTAGE_LIST_T * const pmu_volt_nom_p,
+  ePMU_MODE_LIST_T    * const pmu_mode_p
+)
+{
+  ePMU_RETURN_T PMU_ret_val = PMU_OK;
+  *pmu_volt_p = PMU_VOLTAGE_3V00;
+  *pmu_volt_nom_p = PMU_VOLTAGE_3V00;
+  *pmu_mode_p = current_ext_ldo5_mode;
+  return PMU_ret_val;
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+
+
+/****************************************************************************************
+* SD step down converter handling
+****************************************************************************************/
+
+/****************************************************************************************
+* SD1 step down converter1
+****************************************************************************************/
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_int_hal_cfg_internal.h */
+ePMU_RETURN_T PMU_int_hal_get_sd1_info
+(
+  ePMU_VOLTAGE_LIST_T * const pmu_volt_p,
+  ePMU_VOLTAGE_LIST_T * const pmu_volt_nom_p,
+  ePMU_MODE_LIST_T    * const pmu_mode_p
+)
+{
+  ePMU_RETURN_T PMU_ret_val = PMU_OK;
+
+    /* Check input parameters */
+  if ((NULL == pmu_volt_p) ||
+      (NULL == pmu_volt_nom_p) ||
+      (NULL == pmu_mode_p))
+  {
+    PMU_ret_val = PMU_ERR_INV_ARG;
+  }
+  else
+  {
+    /* SD1 power domain */
+    *pmu_volt_p = PMU_VOLTAGE_FIXED; /* From SW LDO domain interface point of view it isn't configurable */
+    *pmu_volt_nom_p = PMU_VOLTAGE_1V30; /* The voltage is 1V30 or smaller dependent on voltage scaling */
+    *pmu_mode_p = PMU_MODE_ON; /* Always on */
+  }
+
+  return PMU_ret_val;
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/****************************************************************************************
+* SD2 step down converter2
+****************************************************************************************/
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_int_hal_cfg_internal.h */
+ePMU_RETURN_T PMU_int_hal_get_sd2_info
+(
+  ePMU_VOLTAGE_LIST_T * const pmu_volt_p,
+  ePMU_VOLTAGE_LIST_T * const pmu_volt_nom_p,
+  ePMU_MODE_LIST_T    * const pmu_mode_p
+)
+{
+  ePMU_RETURN_T PMU_ret_val = PMU_OK;
+
+    /* Check input parameters */
+  if ((NULL == pmu_volt_p) ||
+      (NULL == pmu_volt_nom_p) ||
+      (NULL == pmu_mode_p))
+  {
+    PMU_ret_val = PMU_ERR_INV_ARG;
+  }
+  else
+  {
+    /* SD2 power domain */
+    *pmu_volt_p = PMU_VOLTAGE_FIXED; /* From SW LDO domain interface point of view it isn't configurable */
+    *pmu_volt_nom_p = PMU_VOLTAGE_1V80; /* Fixed value taken from XGOLD631 PMU product spec. */
+    *pmu_mode_p = PMU_MODE_ON; /* Always on */
+  }
+
+  return PMU_ret_val;
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_domain_cfg_internal.h */
+
+ePMU_RETURN_T PMU_int_hal_set_vcpu_mode
+(
+  const ePMU_MODE_LIST_T mode
+)
+{
+  current_vcpu_mode = PMU_MODE_ON;
+  return PMU_OK;
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_domain_cfg_internal.h */
+ePMU_RETURN_T PMU_int_hal_set_vcpu_voltage
+(
+  const ePMU_VOLTAGE_LIST_T voltage
+)
+{
+  /* configure ELAUD mode map offical enum to HW related enums */
+  return PMU_int_hal_set_ext_buck1_voltage(voltage);
+}
+
+ePMU_RETURN_T PMU_int_hal_get_vcpu_info
+(
+  ePMU_VOLTAGE_LIST_T * const pmu_volt_p,
+  ePMU_VOLTAGE_LIST_T * const pmu_volt_nom_p,
+  ePMU_MODE_LIST_T    * const pmu_mode_p
+)
+{
+  return PMU_int_hal_get_ext_buck1_info(pmu_volt_p, pmu_volt_nom_p, pmu_mode_p);
+}
diff --git a/devices/pm/power_control/pmu/src/board_sf_3gx_ext_pmic/pmu_domain_init_cfg.c b/devices/pm/power_control/pmu/src/board_sf_3gx_ext_pmic/pmu_domain_init_cfg.c
new file mode 100644
index 0000000..dd11020
--- /dev/null
+++ b/devices/pm/power_control/pmu/src/board_sf_3gx_ext_pmic/pmu_domain_init_cfg.c
@@ -0,0 +1,163 @@
+/* =============================================================================
+ * Copyright (C) 2013-2014 Intel Mobile Communications GmbH
+ *
+ *      Sec Class: Intel Confidential (IC)
+ *
+ * =============================================================================
+ *
+ * This document contains proprietary information belonging to IMC.
+ * Passing on and copying of this document, use and communication of
+ * its contents is not permitted without prior written authorisation.
+ *
+ * =============================================================================
+ * Revision Information :
+ *   $File name:  /mhw_drv_src/power_control/pmu/src/board_xmm6321/pmu_domain_init_cfg.c $
+ *   Comment:
+ *     Created
+ * =============================================================================
+ *
+ * This file contains the board dependent implementation part of the PMU Domain handling
+ * HW set-up: XGOLD631 internal PMU
+ * ===========================================================================*/
+
+/*----------------------------------------------*/
+/* INCLUDES                                     */
+/*----------------------------------------------*/
+
+#include "bastypes.h"
+
+#include "pmu_driverif_cfg.h"
+#include "pmu_driverif.h"
+
+#include "pmu_internal_cfg.h"
+#include "trap.h"
+#include "pmu_internal.h"
+
+#include "pmu_domain_internal.h"
+#include "pmu_domain_cfg_internal.h"
+#include "pmu_int_hal_cfg_internal.h"
+
+//#include "pcl_driverif.h"
+
+#include "iui_os.h"
+
+
+/*----------------------------------------------*/
+/* DEFINES                                      */
+/*----------------------------------------------*/
+
+
+/*----------------------------------------------*/
+/* TYPE DEFINITIONS                             */
+/*----------------------------------------------*/
+
+/*----------------------------------------------*/
+/* VARIABLE DECLARATIONS                        */
+/*----------------------------------------------*/
+
+/*----------------------------------------------*/
+/* VARIABLE DEFINITIONS                         */
+/*----------------------------------------------*/
+/**
+ * This struct holds the start-up configuration for the PMU.
+ * The struct holds all available power domains.
+ *
+ * Available elements:
+ * - domain: holds the Domain name. The domains are configured in pmu_internal_cfg.h
+ * - pull down: holds the Information if a pull down shall be set or not.
+ * - mode: defines if the regulator shall be enabled, disabled, switched into standby mode or configured as HW controlled
+ * - voltage: configures the domain voltage that should be set.
+ *
+ * The initialization function inside this file can get this struct via PMU_domain_get_config() function call.
+ */
+// CODEGEN_BEGIN(PMU_INITIAL_CONFIG_T) begin of automated generated source by tool, don't remove this line
+static sPMU_INITIAL_CONFIG_T pmu_initial_config[PMU_NOF_DOMAINS] =
+{
+/* domain                     pulldown                 mode                     voltage */
+ { PMU_DOMAIN_LSIM1,          PMU_PULLDOWN_EN,         PMU_MODE_OFF,            PMU_VOLTAGE_2V91    },
+ { PMU_DOMAIN_LSIM2,          PMU_PULLDOWN_EN,         PMU_MODE_OFF,            PMU_VOLTAGE_2V91    },
+ { PMU_DOMAIN_LAUX1,          PMU_PULLDOWN_EN,         PMU_MODE_OFF,            PMU_VOLTAGE_1V80    },
+ { PMU_DOMAIN_LAUX2,          PMU_PULLDOWN_EN,         PMU_MODE_OFF,            PMU_VOLTAGE_2V85    },
+ { PMU_DOMAIN_LMMC1,          PMU_PULLDOWN_EN,         PMU_MODE_OFF,            PMU_VOLTAGE_1V80    },
+ { PMU_DOMAIN_LUSB,           PMU_PULLDOWN_EN,         PMU_MODE_OFF,            PMU_VOLTAGE_3V15    },
+ { PMU_DOMAIN_LPMU,           PMU_PULLDOWN_FIXED,      PMU_MODE_FIXED,          PMU_VOLTAGE_FIXED   },
+ { PMU_DOMAIN_LAIF,           PMU_PULLDOWN_EN,         PMU_MODE_IDLE_STDBY,     PMU_VOLTAGE_1V10    },
+ { PMU_DOMAIN_LCABB,          PMU_PULLDOWN_EN,         PMU_MODE_STANDBYLOWVOLTAGE,PMU_VOLTAGE_1V20    },
+ { PMU_DOMAIN_LMEM,           PMU_PULLDOWN_EN,         PMU_MODE_OFF_STDBY,     PMU_VOLTAGE_1V226   },
+#if defined (CONFIG_BOOT_DISPLAY)
+ { PMU_DOMAIN_LMIPI,          PMU_PULLDOWN_EN,         PMU_MODE_ON,             PMU_VOLTAGE_1V17    },
+ { PMU_DOMAIN_LPLL,           PMU_PULLDOWN_EN,         PMU_MODE_ON,             PMU_VOLTAGE_1V20    },
+#else
+ { PMU_DOMAIN_LMIPI,          PMU_PULLDOWN_EN,         PMU_MODE_OFF,             PMU_VOLTAGE_1V17    },
+ { PMU_DOMAIN_LPLL,           PMU_PULLDOWN_EN,         PMU_MODE_OFF_STDBY,       PMU_VOLTAGE_1V20    },
+#endif
+ { PMU_DOMAIN_SD1,            PMU_PULLDOWN_FIXED,      PMU_MODE_FIXED,          PMU_VOLTAGE_FIXED   },
+ { PMU_DOMAIN_SD2,            PMU_PULLDOWN_FIXED,      PMU_MODE_FIXED,          PMU_VOLTAGE_FIXED   },
+ { PMU_DOMAIN_ELDO_VMMC,      PMU_PULLDOWN_FIXED,      PMU_MODE_OFF,            PMU_VOLTAGE_1V80    },
+ { PMU_DOMAIN_GNSS_TCXO_LDO,  PMU_PULLDOWN_FIXED,      PMU_MODE_OFF,            PMU_VOLTAGE_FIXED   },
+ { PMU_DOMAIN_EXT_BUCK1,      PMU_PULLDOWN_FIXED,      PMU_MODE_FIXED,          PMU_VOLTAGE_1V30    },
+ { PMU_DOMAIN_EXT_BUCK2,      PMU_PULLDOWN_FIXED,      PMU_MODE_FIXED,          PMU_VOLTAGE_1V30    },
+ { PMU_DOMAIN_EXT_LDO5,       PMU_PULLDOWN_FIXED,      PMU_MODE_OFF,            PMU_VOLTAGE_FIXED   },
+ { PMU_DOMAIN_DUMMY,         PMU_PULLDOWN_FIXED,       PMU_MODE_FIXED,          PMU_VOLTAGE_FIXED   },
+};
+// CODEGEN_END(PMU_INITIAL_CONFIG_T) end of automated generated source by tool, don't remove this line
+
+/*----------------------------------------------*/
+/* INTERNAL FUNCTION DELCARATIONS               */
+/*----------------------------------------------*/
+
+/*----------------------------------------------*/
+/* INTERNAL FUNCTIONS                           */
+/*----------------------------------------------*/
+
+/*----------------------------------------------*/
+/* EXPORTED FUNCTIONS                           */
+/*----------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_domain_cfg_internal.h
+ *
+ */
+ePMU_RETURN_T PMU_dom_init_ext_ldo_HW( void )
+{
+  return PMU_OK;
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_domain_cfg_internal.h
+ *
+ */
+ePMU_RETURN_T PMU_dom_late_init_ext_ldo_HW( void )
+{
+
+  return PMU_OK;
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_domain_internal.h
+ *
+ */
+sPMU_INITIAL_CONFIG_T * PMU_dom_get_initial_config_array_pointer ( void )
+{
+  return &pmu_initial_config[0];
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_domain_internal.h
+ *
+ */
+ePMU_DOMAIN_T PMU_dom_get_sim1_domain ( void )
+{
+  return PMU_DOMAIN_LSIM1;
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------------*/
+/** See pmu_domain_internal.h
+ *
+ */
+ePMU_DOMAIN_T PMU_dom_get_sim2_domain ( void )
+{
+  return PMU_DOMAIN_LSIM2;
+}
+/*---------------------------------------------------------------------------------------------------------------*/
+
diff --git a/devices/pm/power_control/pmu/src/board_sf_3gx_ext_pmic/pmu_int_hal_cfg_internal.h b/devices/pm/power_control/pmu/src/board_sf_3gx_ext_pmic/pmu_int_hal_cfg_internal.h
new file mode 100644
index 0000000..58bdd88
--- /dev/null
+++ b/devices/pm/power_control/pmu/src/board_sf_3gx_ext_pmic/pmu_int_hal_cfg_internal.h
@@ -0,0 +1,584 @@
+/* =============================================================================
+ * Copyright (C) 2013-2014 Intel Mobile Communications GmbH
+ *
+ *      Sec Class: Intel Confidential (IC)
+ *
+ * =============================================================================
+ *
+ * This document contains proprietary information belonging to IMC.
+ * Passing on and copying of this document, use and communication of its
+ * contents is not permitted without prior written authorisation.
+ *
+ * =============================================================================
+ * Revision Information :
+ *   $File name:  /mhw_drv_src/power_control/pmu/src/pmu_int_agold620/pmu_int_hal_cfg_internal.h $
+ *   Responsible: Vijayanand Jagadeesan
+ *   Comment:
+ *     Created
+ *   History:
+ *
+ * =============================================================================
+ *
+ * This file contains the interface towards the PMU driver
+ * HW dependent part
+ * HW set-up: AGOLD620 PMU (Connected to XGOLD632 via IDI)
+ *
+ * ===========================================================================*/
+
+#ifndef __PMU_INT_HAL_CFG_INTERNAL_H__
+#define __PMU_INT_HAL_CFG_INTERNAL_H__
+
+/*----------------------------------------------*/
+/* INCLUDES                                     */
+/*----------------------------------------------*/
+
+#include "pmu_driverif.h"
+#include "pmu_driverif_cfg.h"
+
+#if defined (DRV_LOWLEVEL_TESTINTERFACES) &&  defined (PMU_REGISTER_TESTINTERFACE)
+#include "pmu_ttest_cfg_internal.h"
+#endif //DRV_LOWLEVEL_TESTINTERFACES && PMU_REGISTER_TESTINTERFACE
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/* TYPE DEFINITIONS                                                                                              */
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/*##############################################*/
+/*# GENERIC part ###############################*/
+/*##############################################*/
+
+/*watchdog magic number*/
+#define WDT_MAGIC_NUMBER 0x169
+
+/*##############################################*/
+/*# IRQ part ###################################*/
+/*##############################################*/
+
+/** @brief TODO
+  *
+  */
+typedef enum
+{
+  PMU_ALL_DED_IRQS_CLEAR,   /**< TODO */
+  PMU_ALL_DED_IRQS_DISABLE, /**< TODO */
+  PMU_ALL_DED_IRQS_INIT     /**< TODO */
+} ePMU_ALL_DED_IRQS_ACTION;
+
+/** @brief TODO
+  *
+  */
+typedef struct
+{
+    BOOL irq_pending;       /**< Status of PMU interrupt setup */
+} sPMU_IRQ_STATUS_T;
+
+/*##############################################*/
+/*# SD part ####################################*/
+/*##############################################*/
+
+/** @brief TODO
+  *
+  */
+typedef enum
+{
+  PMU_VOLTAGECLASS_0,    /**< TODO */
+  PMU_VOLTAGECLASS_1,    /**< TODO */
+  PMU_VOLTAGECLASS_2,    /**< TODO */
+  PMU_VOLTAGECLASS_3,    /**< TODO */
+  PMU_VOLTAGECLASS_4,    /**< TODO */
+  PMU_VOLTAGECLASS_5,    /**< TODO */
+  PMU_VOLTAGECLASS_6,    /**< TODO */
+  PMU_VOLTAGECLASS_7,    /**< TODO */
+
+  PMU_NOF_VOLTAGECLASSES /**< End indicator */
+} ePMU_VOLTAGECLASSES_T;
+
+/** @brief TODO
+  *
+  */
+typedef struct
+{
+  unsigned char pmu_sd1_valueset1;  /* value used to program SD1V1 bits*/
+  unsigned char pmu_sd1_valueset2;  /* value used to program SD1V2 bits*/
+  unsigned char pmu_sd1_valueset3;  /* value used to program SD1V3 bits*/
+  unsigned char pmu_sd1_valueset4;  /* value used to program SD1V4 bits*/
+} sPMU_SD1_DVS1_VALUESET_T;
+
+typedef struct
+{
+  unsigned char pmu_sd1_vuhigh_valueset1;  /* value used to program SD1VUHigh bits*/
+} sPMU_SD1_DVS2_VALUESET_T;
+
+/** @brief Enumeration of possible SD1_SD2_PWM_MODE_DELAY
+  *
+  */
+typedef enum
+{
+  PMU_SD1_SD2_PWM_MODE_DELAY_ZERO = 0, /**< No control on SD1 SD2 aligment */
+  PMU_SD1_SD2_PWM_MODE_DELAY_90 = 1,   /**< 90 degrees phase shift SD1 to SD2 */
+  PMU_SD1_SD2_PWM_MODE_DELAY_180 = 2,  /**< 180 degrees phase shift SD1 to SD2 */
+  PMU_SD1_SD2_PWM_MODE_DELAY_270 = 3,  /**< 270 degrees phase shift SD1 to SD2 */
+  PMU_SD1_SD2_PWM_MODE_DELAY_END       /**< only used internal to mark and of list */
+} ePMU_SD1_SD2_PWM_MODE_DELAY_T;
+
+typedef enum
+{
+  PMU_SD_PWM_MODE_CCM = 0, /**< Continuous conduction mode PWM */
+  PMU_SD_PWM_MODE_DCM = 1  /**< Discontinuous conduction mode PWM */
+} ePMU_SD_PWM_MODE_T;
+
+typedef enum
+{
+  SDCONTROLMODE_LINEAR = 0,
+  SDCONTROLMODE_HYSTERETIC = 1,
+  SDCONTROLMODE_HYBRID = 2
+} ePMU_SDControlMode_T;
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/* EXTERNAL DATA DECLARATIONS                                                                                    */
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/* EXTERNAL FUNCTION DECLARATIONS                                                                                */
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/*##############################################*/
+/*# GENERIC part ###############################*/
+/*##############################################*/
+
+/** @brief TODO */
+ePMU_RETURN_T PMU_int_hal_force_sd1_pfm_mode(const BOOL enable);
+/** @brief TODO */
+ePMU_RETURN_T PMU_int_hal_force_sd2_pfm_mode(const BOOL enable);
+/** @brief TODO */
+ePMU_RETURN_T PMU_int_hal_sd1_set_ctrl_mode ( ePMU_SDControlMode_T mode);
+/** @brief TODO */
+ePMU_RETURN_T PMU_int_hal_sd2_set_ctrl_mode ( ePMU_SDControlMode_T mode);
+/** @brief TODO */
+BOOL PMU_int_hal_sd1_pwm_get(void);
+BOOL PMU_int_hal_sd2_pwm_get(void);
+/** @brief TODO */
+void PMU_int_hal_configure_sd1_coef(void);
+void PMU_int_hal_configure_sd2_coef(void);
+
+/** @brief TODO */
+void PMU_int_hal_reset_hw_watchdog(U32 time);
+/** @brief TODO */
+void PMU_int_hal_set_all_off(void);
+/** @brief TODO */
+void PMU_int_hal_set_sw_reset(void);
+/** @brief TODO */
+ePMU_RETURN_T PMU_int_hal_get_reset_source(ePMU_RESET_SOURCE_T * const reset_source_p);
+/** @brief TODO */
+ePMU_RETURN_T PMU_int_hal_clear_reset_source(const ePMU_RESET_SOURCE_T reset_source);
+/** @brief TODO */
+U32 PMU_int_hal_get_chip_version(void);
+/** @brief TODO */
+void PMU_int_hal_enable_clock(void);
+/** @brief TODO */
+ePMU_CHIP_REV_T PMU_int_hal_pre_init_get_pmu_revision(void);
+/** @brief TODO */
+ePMU_CHIP_REV_T PMU_int_hal_get_pmu_revision(void);
+/** @brief TODO */
+void PMU_int_hal_pre_init_configure_pll(void);
+/** @brief Disable PMU HWFI (USIF SPI) power saving) */
+void PMU_int_hal_hwif_stop_power_saving(void);
+
+void PMU_hal_thread(void *argv);
+/** @brief Enable PMU Charge pump */
+void PMU_int_hal_charge_pump_on(void);
+/** @brief Disable PMU charge pump */
+void PMU_int_hal_charge_pump_off(void);
+/*##############################################*/
+/*# APPLICATION part ###########################*/
+/*##############################################*/
+
+/** @brief  Can be used to get an application register field from the PMU.
+ *  @param  application_reg_field   Name of the register field
+ *  @param  value_p                 Pointer to a location where the content of the register field will be stored
+ *  @return                         PMU_OK or an error code
+ */
+ePMU_RETURN_T PMU_int_hal_get_register_field(const ePMU_APPLICATION_REG_FIELD_T application_reg_field, uPMUREG_REGISTERFIELD_T * const value_p);
+
+/** @brief Can be used to set an application register field in the PMU.
+ *  @param  application_reg_field   Name of the register field
+ *  @param  value_p                 Pointer to a location the new content of the register field is stored
+ *  @return                         PMU_OK or an error code
+ */
+ePMU_RETURN_T PMU_int_hal_set_register_field(const ePMU_APPLICATION_REG_FIELD_T application_reg_field, const uPMUREG_REGISTERFIELD_T * const value_p);
+
+/** @brief Can be used to get a complete application register from the PMU.
+ *  @param  application_reg   Name of the register
+ *  @param  value_p           Pointer to a location where the content of the register will be stored
+ *  @return                   PMU_OK or an error code
+ */
+ePMU_RETURN_T PMU_int_hal_get_register(const ePMU_APPLICATION_REG_T application_reg, tPMU_REGISTER_T * const value_p);
+
+/** @brief Can be used to set a complete application register in the PMU.
+ *  @param  application_reg   Name of the register
+ *  @param  value_p           Pointer to a location the new content of the register field is stored
+ *  @return                   PMU_OK or an error code
+ */
+ePMU_RETURN_T PMU_int_hal_set_register(const ePMU_APPLICATION_REG_T application_reg, const tPMU_REGISTER_T * const value_p);
+
+/*##############################################*/
+/*# IRQ part ###################################*/
+/*##############################################*/
+/** @brief TODO */
+ePMU_RETURN_T PMU_int_hal_setup_main_irq(const BOOL enable);
+/** @brief TODO */
+ePMU_RETURN_T PMU_int_hal_request_main_irq(void);
+/** @brief TODO */
+ePMU_RETURN_T PMU_int_hal_setup_dedicated_irq(const ePMU_IRQ_TYPE_T irq_type, const BOOL enable);
+/** @brief TODO */
+ePMU_RETURN_T PMU_int_hal_setup_all_dedicated_irqs(const ePMU_ALL_DED_IRQS_ACTION action);
+/** @brief TODO */
+ePMU_RETURN_T PMU_int_hal_enable_local_irqs (void);
+
+/** @brief TODO */
+ePMU_RETURN_T PMU_int_hal_check_and_clear_pending_irqs(sPMU_IRQ_STATUS_T * const pmu_irq_status_p,
+                                                                                 U32 * pending_ints);
+
+/** @brief Set a dedicated irq request in the PMU
+ *  @param  irq_type   The irq to be disabled
+ *  @return            PMU_OK or an error code
+ */
+ePMU_RETURN_T PMU_int_hal_request_irq(const ePMU_IRQ_TYPE_T irq_type);
+/** @brief TODO */
+ePMU_RETURN_T PMU_int_hal_get_irq_status(const ePMU_IRQ_TYPE_T irq_type, ePMU_IRQ_STATUS_T * const ret_stat_p);
+/*##############################################*/
+/*# DOMAIN part ################################*/
+/*##############################################*/
+
+/** @brief TODO */
+ePMU_RETURN_T PMU_int_hal_flush_domain_settings (void);
+
+/****************************************************************************************
+* LSIM1 regulator
+****************************************************************************************/
+
+/** @brief TODO */
+ePMU_RETURN_T PMU_int_hal_get_lsim1_info(ePMU_VOLTAGE_LIST_T * const pmu_volt_p, ePMU_VOLTAGE_LIST_T * const pmu_volt_nom_p, ePMU_MODE_LIST_T * const pmu_mode_p);
+/** @brief TODO */
+ePMU_RETURN_T PMU_int_hal_set_lsim1_voltage(const ePMU_VOLTAGE_LIST_T voltage);
+/** @brief TODO */
+ePMU_RETURN_T PMU_int_hal_set_lsim1_mode(const ePMU_MODE_LIST_T mode);
+/** @brief TODO */
+ePMU_RETURN_T PMU_int_hal_set_lsim1_pull_down(const BOOL pull_down);
+
+/****************************************************************************************
+* LSIM2 regulator
+****************************************************************************************/
+
+/** @brief TODO */
+ePMU_RETURN_T PMU_int_hal_get_lsim2_info(ePMU_VOLTAGE_LIST_T * const pmu_volt_p, ePMU_VOLTAGE_LIST_T * const pmu_volt_nom_p, ePMU_MODE_LIST_T * const pmu_mode_p);
+/** @brief TODO */
+ePMU_RETURN_T PMU_int_hal_set_lsim2_voltage(const ePMU_VOLTAGE_LIST_T voltage);
+/** @brief TODO */
+ePMU_RETURN_T PMU_int_hal_set_lsim2_mode(const ePMU_MODE_LIST_T mode);
+/** @brief TODO */
+ePMU_RETURN_T PMU_int_hal_set_lsim2_pull_down(const BOOL pull_down);
+
+/****************************************************************************************
+* LAUX1 regulator
+****************************************************************************************/
+
+ePMU_RETURN_T PMU_int_hal_set_laux1_voltage
+(
+  const ePMU_VOLTAGE_LIST_T voltage
+);
+ePMU_RETURN_T PMU_int_hal_set_laux1_mode
+(
+  const ePMU_MODE_LIST_T mode
+);
+
+ePMU_RETURN_T PMU_int_hal_set_laux1_pull_down
+(
+  const BOOL pull_down
+);
+
+ePMU_RETURN_T PMU_int_hal_get_laux1_info
+(
+  ePMU_VOLTAGE_LIST_T * const pmu_volt_p,
+  ePMU_VOLTAGE_LIST_T * const pmu_volt_nom_p,
+  ePMU_MODE_LIST_T    * const pmu_mode_p
+);
+
+/****************************************************************************************
+* LAUX2 regulator
+****************************************************************************************/
+
+ePMU_RETURN_T PMU_int_hal_set_laux2_voltage
+(
+  const ePMU_VOLTAGE_LIST_T voltage
+);
+ePMU_RETURN_T PMU_int_hal_set_laux2_mode
+(
+  const ePMU_MODE_LIST_T mode
+);
+
+ePMU_RETURN_T PMU_int_hal_set_laux2_pull_down
+(
+  const BOOL pull_down
+);
+ePMU_RETURN_T PMU_int_hal_get_laux2_info
+(
+  ePMU_VOLTAGE_LIST_T * const pmu_volt_p,
+  ePMU_VOLTAGE_LIST_T * const pmu_volt_nom_p,
+  ePMU_MODE_LIST_T    * const pmu_mode_p
+);
+
+/****************************************************************************************
+* LMMC1 regulator
+****************************************************************************************/
+ePMU_RETURN_T PMU_int_hal_set_lmmc1_voltage
+(
+  const ePMU_VOLTAGE_LIST_T voltage
+);
+ePMU_RETURN_T PMU_int_hal_set_lmmc1_mode
+(
+  const ePMU_MODE_LIST_T mode
+);
+ePMU_RETURN_T PMU_int_hal_set_lmmc1_pull_down
+(
+  const BOOL pull_down
+);
+ePMU_RETURN_T PMU_int_hal_get_lmmc1_info
+(
+  ePMU_VOLTAGE_LIST_T * const pmu_volt_p,
+  ePMU_VOLTAGE_LIST_T * const pmu_volt_nom_p,
+  ePMU_MODE_LIST_T    * const pmu_mode_p
+);
+/****************************************************************************************
+* LUSB regulator
+****************************************************************************************/
+ePMU_RETURN_T PMU_int_hal_set_lusb_voltage
+(
+  const ePMU_VOLTAGE_LIST_T voltage
+);
+ePMU_RETURN_T PMU_int_hal_set_lusb_mode
+(
+  const ePMU_MODE_LIST_T mode
+);
+ePMU_RETURN_T PMU_int_hal_set_lusb_pull_down
+(
+  const BOOL pull_down
+);
+ePMU_RETURN_T PMU_int_hal_get_lusb_info
+(
+  ePMU_VOLTAGE_LIST_T * const pmu_volt_p,
+  ePMU_VOLTAGE_LIST_T * const pmu_volt_nom_p,
+  ePMU_MODE_LIST_T    * const pmu_mode_p
+);
+/****************************************************************************************
+* LAIF regulator
+****************************************************************************************/
+ePMU_RETURN_T PMU_int_hal_set_laif_voltage
+(
+  const ePMU_VOLTAGE_LIST_T voltage
+);
+ePMU_RETURN_T PMU_int_hal_set_laif_mode
+(
+  const ePMU_MODE_LIST_T mode
+);
+ePMU_RETURN_T PMU_int_hal_set_laif_pull_down
+(
+  const BOOL pull_down
+);
+ePMU_RETURN_T PMU_int_hal_get_laif_info
+(
+  ePMU_VOLTAGE_LIST_T * const pmu_volt_p,
+  ePMU_VOLTAGE_LIST_T * const pmu_volt_nom_p,
+  ePMU_MODE_LIST_T    * const pmu_mode_p
+);
+/****************************************************************************************
+* LCABB regulator
+****************************************************************************************/
+
+ePMU_RETURN_T PMU_int_hal_set_lcabb_voltage
+(
+  const ePMU_VOLTAGE_LIST_T voltage
+);
+ePMU_RETURN_T PMU_int_hal_set_lcabb_mode
+(
+  const ePMU_MODE_LIST_T mode
+);
+ePMU_RETURN_T PMU_int_hal_set_lcabb_pull_down
+(
+  const BOOL pull_down
+);
+ePMU_RETURN_T PMU_int_hal_get_lcabb_info
+(
+  ePMU_VOLTAGE_LIST_T * const pmu_volt_p,
+  ePMU_VOLTAGE_LIST_T * const pmu_volt_nom_p,
+  ePMU_MODE_LIST_T    * const pmu_mode_p
+);
+
+/****************************************************************************************
+* LMEM regulator
+****************************************************************************************/
+
+ePMU_RETURN_T PMU_int_hal_set_lmem_voltage
+(
+  const ePMU_VOLTAGE_LIST_T voltage
+);
+ePMU_RETURN_T PMU_int_hal_set_lmem_mode
+(
+  const ePMU_MODE_LIST_T mode
+);
+ePMU_RETURN_T PMU_int_hal_set_lmem_pull_down
+(
+  const BOOL pull_down
+);
+ePMU_RETURN_T PMU_int_hal_get_lmem_info
+(
+  ePMU_VOLTAGE_LIST_T * const pmu_volt_p,
+  ePMU_VOLTAGE_LIST_T * const pmu_volt_nom_p,
+  ePMU_MODE_LIST_T    * const pmu_mode_p
+);
+
+/****************************************************************************************
+* LMIPI regulator
+****************************************************************************************/
+ePMU_RETURN_T PMU_int_hal_set_lmipi_voltage
+(
+  const ePMU_VOLTAGE_LIST_T voltage
+);
+ePMU_RETURN_T PMU_int_hal_set_lmipi_mode
+(
+  const ePMU_MODE_LIST_T mode
+);
+ePMU_RETURN_T PMU_int_hal_set_lmipi_pull_down
+(
+  const BOOL pull_down
+);
+ePMU_RETURN_T PMU_int_hal_get_lmipi_info
+(
+  ePMU_VOLTAGE_LIST_T * const pmu_volt_p,
+  ePMU_VOLTAGE_LIST_T * const pmu_volt_nom_p,
+  ePMU_MODE_LIST_T    * const pmu_mode_p
+);
+
+/****************************************************************************************
+* LPLL regulator
+****************************************************************************************/
+
+/** @brief TODO */
+ePMU_RETURN_T PMU_int_hal_get_lpll_info(ePMU_VOLTAGE_LIST_T * const pmu_volt_p, ePMU_VOLTAGE_LIST_T * const pmu_volt_nom_p, ePMU_MODE_LIST_T * const pmu_mode_p);
+/** @brief TODO */
+ePMU_RETURN_T PMU_int_hal_set_lpll_mode(const ePMU_MODE_LIST_T mode);
+/** @brief TODO */
+ePMU_RETURN_T PMU_int_hal_set_lpll_pull_down(const BOOL pull_down);
+/** @brief TODO */
+ePMU_RETURN_T PMU_int_hal_set_lpll_voltage(  const ePMU_VOLTAGE_LIST_T voltage);
+
+/****************************************************************************************
+* LPMU regulator
+****************************************************************************************/
+
+/** @brief TODO */
+ePMU_RETURN_T PMU_int_hal_get_lpmu_info(ePMU_VOLTAGE_LIST_T * const pmu_volt_p, ePMU_VOLTAGE_LIST_T * const pmu_volt_nom_p, ePMU_MODE_LIST_T * const pmu_mode_p);
+/** @brief TODO */
+ePMU_RETURN_T PMU_int_hal_set_lpmu_voltage(const ePMU_VOLTAGE_LIST_T voltage);
+
+/****************************************************************************************
+* EMMC external regulator
+****************************************************************************************/
+
+/** @brief TODO */
+ePMU_RETURN_T PMU_int_hal_get_eldo_vmmc_info(ePMU_VOLTAGE_LIST_T * const pmu_volt_p, ePMU_VOLTAGE_LIST_T * const pmu_volt_nom_p, ePMU_MODE_LIST_T * const pmu_mode_p);
+/** @brief TODO */
+ePMU_RETURN_T PMU_int_hal_set_eldo_vmmc_mode(const ePMU_MODE_LIST_T mode);
+/** @brief TODO */
+ePMU_RETURN_T PMU_int_hal_set_eldo_vmmc_voltage(  const ePMU_VOLTAGE_LIST_T voltage);
+
+/****************************************************************************************
+* ABB GNSS TCXO external regulator
+****************************************************************************************/
+
+/** @brief TODO */
+ePMU_RETURN_T PMU_int_hal_get_gnss_tcxo_ldo_info(ePMU_VOLTAGE_LIST_T * const pmu_volt_p, ePMU_VOLTAGE_LIST_T * const pmu_volt_nom_p, ePMU_MODE_LIST_T * const pmu_mode_p);
+/** @brief TODO */
+ePMU_RETURN_T PMU_int_hal_set_gnss_tcxo_ldo_mode(const ePMU_MODE_LIST_T mode);
+/** @brief TODO */
+ePMU_RETURN_T PMU_int_hal_set_gnss_tcxo_ldo_voltage(  const ePMU_VOLTAGE_LIST_T voltage);
+
+/****************************************************************************************
+* garnet external regulator: BUCK1 for VCPU
+****************************************************************************************/
+
+/** @brief TODO */
+ePMU_RETURN_T PMU_int_hal_get_ext_buck1_info(ePMU_VOLTAGE_LIST_T * const pmu_volt_p, ePMU_VOLTAGE_LIST_T * const pmu_volt_nom_p, ePMU_MODE_LIST_T * const pmu_mode_p);
+/** @brief TODO */
+ePMU_RETURN_T PMU_int_hal_set_ext_buck1_voltage(  const ePMU_VOLTAGE_LIST_T voltage);
+
+/****************************************************************************************
+* garnet external regulator: BUCK2 for VGPU
+****************************************************************************************/
+
+/** @brief TODO */
+ePMU_RETURN_T PMU_int_hal_get_ext_buck2_info(ePMU_VOLTAGE_LIST_T * const pmu_volt_p, ePMU_VOLTAGE_LIST_T * const pmu_volt_nom_p, ePMU_MODE_LIST_T * const pmu_mode_p);
+/** @brief TODO */
+ePMU_RETURN_T PMU_int_hal_set_ext_buck2_voltage(  const ePMU_VOLTAGE_LIST_T voltage);
+
+/****************************************************************************************
+* garnet external regulator: LDO5 for SDcard
+****************************************************************************************/
+
+/** @brief TODO */
+ePMU_RETURN_T PMU_int_hal_get_ext_ldo5_info(ePMU_VOLTAGE_LIST_T * const pmu_volt_p, ePMU_VOLTAGE_LIST_T * const pmu_volt_nom_p, ePMU_MODE_LIST_T * const pmu_mode_p);
+/** @brief TODO */
+ePMU_RETURN_T PMU_int_hal_set_ext_ldo5_mode(const ePMU_MODE_LIST_T mode);
+
+/****************************************************************************************
+* SD1 step down converter
+****************************************************************************************/
+
+/** @brief TODO */
+ePMU_RETURN_T PMU_int_hal_get_sd1_info(ePMU_VOLTAGE_LIST_T * const pmu_volt_p, ePMU_VOLTAGE_LIST_T * const pmu_volt_nom_p, ePMU_MODE_LIST_T * const pmu_mode_p);
+/** @brief TODO */
+ePMU_RETURN_T PMU_int_hal_pre_init_sd1_enable_pwm(const BOOL enable);
+/** @brief TODO */
+ePMU_RETURN_T PMU_int_hal_set_sd1_valueset(const ePMU_VOLTAGECLASSES_T voltage_class);
+
+/****************************************************************************************
+* SD2 step down converter
+****************************************************************************************/
+
+/** @brief TODO */
+ePMU_RETURN_T PMU_int_hal_get_sd2_info(ePMU_VOLTAGE_LIST_T * const pmu_volt_p, ePMU_VOLTAGE_LIST_T * const pmu_volt_nom_p, ePMU_MODE_LIST_T * const pmu_mode_p);
+/** @brief TODO */
+ePMU_RETURN_T PMU_int_hal_pre_init_sd2_enable_pwm(const BOOL enable);
+
+/****************************************************************************************
+* SD step down converter handling
+****************************************************************************************/
+
+/** @brief TODO */
+void PMU_int_hal_pre_init_sd_config_pfm_mode(void);
+/** @brief TODO */
+void PMU_int_hal_pre_init_sd_config_pwm_coeffs(void);
+/** @brief TODO */
+void PMU_int_hal_pre_init_sd_config_pwm_mode(const ePMU_SD_PWM_MODE_T mode);
+
+#if defined (DRV_LOWLEVEL_TESTINTERFACES) &&  defined (PMU_REGISTER_TESTINTERFACE)
+/*##############################################*/
+/*# TARGET TEST part ###########################*/
+/*##############################################*/
+
+/** @brief TODO */
+ePMU_RETURN_T PMU_int_hal_ttest_get_register(const ePMU_TTEST_REG_T ttest_reg, tPMU_REGISTER_T * const value_p);
+/** @brief TODO */
+ePMU_RETURN_T PMU_int_hal_ttest_set_register(const ePMU_TTEST_REG_T ttest_reg, const tPMU_REGISTER_T value);
+#endif //DRV_LOWLEVEL_TESTINTERFACES && PMU_REGISTER_TESTINTERFACE
+
+ePMU_RETURN_T PMU_int_hal_set_lsim1_auto_power_down( const BOOL mode );
+ePMU_RETURN_T PMU_int_hal_set_lsim2_auto_power_down( const BOOL mode );
+ePMU_RETURN_T PMU_int_hal_set_chp_clock(ePMU_AG620_CHP_FRQ_DIV_T divider);
+ePMU_RETURN_T PMU_int_hal_set_dcdc_clock(ePMU_AG620_SD_T sd_converter, ePMU_AG620_DCDC_SFT_T divider);
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/* END                                                                                                           */
+/*---------------------------------------------------------------------------------------------------------------*/
+
+#endif //__PMU_INT_HAL_CFG_INTERNAL_H__
diff --git a/devices/pm/power_control/pmu/src/board_sf_3gx_ext_pmic/pmu_int_vm_access_cfg.h b/devices/pm/power_control/pmu/src/board_sf_3gx_ext_pmic/pmu_int_vm_access_cfg.h
new file mode 120000
index 0000000..2b87bef
--- /dev/null
+++ b/devices/pm/power_control/pmu/src/board_sf_3gx_ext_pmic/pmu_int_vm_access_cfg.h
@@ -0,0 +1 @@
+../board_sf_3gr_ext_pmic/pmu_int_vm_access_cfg.h
\ No newline at end of file
diff --git a/devices/pm/power_control/pmu/src/board_sf_3gx_ext_pmic/pmu_internal_cfg.h b/devices/pm/power_control/pmu/src/board_sf_3gx_ext_pmic/pmu_internal_cfg.h
new file mode 100644
index 0000000..d6d97b4
--- /dev/null
+++ b/devices/pm/power_control/pmu/src/board_sf_3gx_ext_pmic/pmu_internal_cfg.h
@@ -0,0 +1,412 @@
+/* =============================================================================
+ * Copyright (C) 2013-2014 Intel Mobile Communications GmbH
+ *
+ *      Sec Class: Intel Confidential (IC)
+ *
+ * =============================================================================
+ *
+ * This document contains proprietary information belonging to IMC.
+ * Passing on and copying of this document, use and communication of its
+ * contents is not permitted without prior written authorisation.
+ *
+ * =============================================================================
+ * Revision Information :
+ *   $File name:  /mhw_drv_src/power_control/inc/pmu_int_agold620/pmu_internal_cfg.h $
+ *   Responsible: Vijayanand Jagadeesan
+ *   Comment:
+ *     Created
+ * =============================================================================
+ *
+ * This file contains the internal PMU driver interface
+ * HW dependent part
+ * HW set-up: HW set-up: AGOLD620 PMU (connected to XGOLD632 Baseband via IDI)
+ *
+ * ===========================================================================*/
+
+#ifndef __PMU_INTERNAL_CFG_H__
+#define __PMU_INTERNAL_CFG_H__
+
+
+#include "pmu_driverif_cfg.h"
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/* TYPE DEFINITIONS                                                                                              */
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/** @brief Contains all PMU Pre-Init commands
+  * @ingroup pmu_internalif_generic_grp
+  */
+typedef enum
+{
+  PMU_PREINITCMD_FIRST,                       /**< Start indicator */
+
+  PMU_PREINITCMD_INIT_HWIF = PMU_PREINITCMD_FIRST, /**< Command to execute the HW interface init*/
+  PMU_PREINITCMD_INIT,                             /**< Command to execute the pre-init */
+
+  PMU_NOF_PREINITCMDS,                        /**< End indicator */
+
+} ePMU_PREINITCMD_T;
+
+/** @brief Structure containing the data needed for executing the pre-init handling
+  * @ingroup pmu_internalif_generic_grp
+  */
+typedef struct
+{
+  BOOL pwm_mode_enabled;  /**< boolean keeping the information is PWM mode is enabled or not */
+} sPMU_PREINIT_DATA_T;
+
+/***************************************************************************************************
+* IMPORTANT: Any modification to this enumaration should be accompanied with correspending change
+* in GTI table gti_pow_PMU_domain_enum[]. If mismatched the system would trap.
+* Also modification to this enumeration has a dependancy on the Power trace tooling based
+* on Mobile Analyzer. If this enumeration is being modified, please raise a ticket against the Mobile
+* Analyzer to adapt your modification also to the MA tool.
+****************************************************************************************************/
+
+/** @brief Contains all modifiable PMU supply domains
+  * @ingroup pmu_internalif_domain_grp
+  */
+// CODEGEN_BEGIN(ePMU_DOMAIN_T) begin of automated generated source by tool, don't remove this line
+typedef enum
+{
+  PMU_DOMAIN_FIRST,                          /**< Start indicator, hard coded value  */
+  PMU_DOMAIN_LSIM1 = PMU_DOMAIN_FIRST,       /**< LSIM1 power domain */
+  PMU_DOMAIN_LSIM2,                          /**< LSIM2 power domain */
+  PMU_DOMAIN_LAUX1,                          /**< LAUX1 power domain */
+  PMU_DOMAIN_LAUX2,                          /**< LAUX2 power domain */
+  PMU_DOMAIN_LMMC1,                          /**< LMMC1 power domain */
+  PMU_DOMAIN_LUSB,                           /**< LUSB power domain */
+  PMU_DOMAIN_LPMU,                           /**< LPMU power domain */
+  PMU_DOMAIN_LAIF,                           /**< LAIF power domain */
+  PMU_DOMAIN_LCABB,                          /**< LCABB power domain */
+  PMU_DOMAIN_LMEM,                           /**< LMEM power domain */
+  PMU_DOMAIN_LMIPI,                          /**< LMIPI power domain */
+  PMU_DOMAIN_LPLL,                           /**< LPLL power domain */
+  PMU_DOMAIN_SD1,                            /**< SD1 power domain */
+  PMU_DOMAIN_SD2,                            /**< SD2 power domain */
+  PMU_DOMAIN_ELDO_VMMC,                      /**< EMMC power domain provided by external LDO - controlled via GPIO */
+  PMU_DOMAIN_GNSS_TCXO_LDO,                  /**< GNSS_TCXO_LDO power domain provided by external LDO */
+  PMU_DOMAIN_EXT_BUCK1,                      /**< garnet external buck1 for VCPU */
+  PMU_DOMAIN_EXT_BUCK2,                      /**< garnet external buck2 for VGPU */
+  PMU_DOMAIN_EXT_LDO5,                       /**< garnet external ldo5 for SD card */
+  PMU_DOMAIN_DUMMY,                          /**< Dummy power domain */
+  PMU_NOF_DOMAINS,                           /**< End indicator, hard coded value */
+  PMU_DOMAIN_NOTCFG = 0xFE,                  /**< Not configurable domain, hard coded value */
+  PMU_DOMAIN_UNDEF = 0xFF                    /**< Undefined domain, hard coded value */
+} ePMU_DOMAIN_T;
+// CODEGEN_END(ePMU_DOMAIN_T) end of automated generated source by tool, don't remove this line
+
+typedef struct
+{
+  BOOL sync;  /**< boolean keeping the information is sync mode is enabled or not */
+  ePMU_DOMAIN_T domain;
+} sPMU_SYNC_T;
+
+
+/***************************************************************************************************
+* IMPORTANT: Any modification to this enumaration should be accompanied with correspending change
+* in GTI table gti_pow_PMU_voltage_enum[]. If mismatched the system would trap.
+* Also modification to this enumeration has a dependancy on the Power trace tooling based
+* on Mobile Analyzer. If this enumeration is being modified, please raise a ticket against the Mobile
+* Analyzer to adapt your modification also to the MA tool.
+****************************************************************************************************/
+
+/** @brief Contains all possible voltages of the PMU
+  * @ingroup pmu_internalif_domain_grp
+  */
+// CODEGEN_BEGIN(ePMU_VOLTAGE_LIST_T) begin of automated generated source by tool, don't remove this line
+typedef enum
+{
+  PMU_VOLTAGE_UNKNOWN,             /**< Unknown voltage => do not use this, hard coded value */
+  PMU_VOLTAGE_FIXED,               /**< Voltage can't be configured or shall not be changed */
+  PMU_VOLTAGE_0V87,                /**< 0.87 Volts */
+  PMU_VOLTAGE_1V00,                /**< 1.00 Volts */
+  PMU_VOLTAGE_1V02,                /**< 1.02 Volts */
+  PMU_VOLTAGE_1V10,                /**< 1.10 Volts */
+  PMU_VOLTAGE_1V12,                /**< 1.12 Volts */
+  PMU_VOLTAGE_1V14,                /**< 1.14 Volts */  
+  PMU_VOLTAGE_1V16,                /**< 1.16 Volts */
+  PMU_VOLTAGE_1V17,                /**< 1.17 Volts */
+  PMU_VOLTAGE_1V20,                /**< 1.20 Volts */
+  PMU_VOLTAGE_1V22,                /**< 1.22 Volts */
+  PMU_VOLTAGE_1V226,               /**< 1.226 Volts */
+  PMU_VOLTAGE_1V25,                /**< 1.25 Volts */
+  PMU_VOLTAGE_1V30,                /**< 1.30 Volts */
+  PMU_VOLTAGE_1V32,                /**< 1.30 Volts */  
+  PMU_VOLTAGE_1V80,                /**< 1.80 Volts */
+  PMU_VOLTAGE_2V05,                /**< 2.05 Volts */
+  PMU_VOLTAGE_2V30,                /**< 2.30 Volts */
+  PMU_VOLTAGE_2V50,                /**< 2.50 Volts */
+  PMU_VOLTAGE_2V80,                /**< 2.80 Volts */
+  PMU_VOLTAGE_2V85,                /**< 2.85 Volts */
+  PMU_VOLTAGE_2V90,                /**< 2.90 Volts */
+  PMU_VOLTAGE_2V91,                /**< 2.91 Volts */
+  PMU_VOLTAGE_3V00,                /**< 3.00 Volts */
+  PMU_VOLTAGE_3V15,                /**< 3.15 Volts */
+  PMU_VOLTAGE_3V30,                /**< 3.30 Volts */
+  PMU_VOLTAGE_5V00,                /**< 5.00 Volts */
+  PMU_NOF_VOLTAGE                  /**< End indicator, hard coded value */
+} ePMU_VOLTAGE_LIST_T;
+// CODEGEN_END(ePMU_VOLTAGE_LIST_T) end of automated generated source by tool, don't remove this line
+
+/** @brief Contains all possible regulator modes
+  * @ingroup pmu_internalif_domain_grp
+  */
+// CODEGEN_BEGIN(ePMU_MODE_LIST_T) begin of automated generated source by tool, don't remove this line
+typedef enum
+{
+  /* mode                     remark */
+  PMU_MODE_NOT_KNOWN,         /**< Unknown mode => never use this, hard coded value */
+  PMU_MODE_FIXED,             /**< Mode can/shall not be modified */
+  PMU_MODE_IDLE_STDBY,        /**< LDO is automatically switched into idle mode (low power) in standby (sleep) mode by HW. It is automatically switched to active mode if system is active. */
+  PMU_MODE_OFF,               /**< LDO is off */
+  PMU_MODE_OFF_STDBY,         /**< LDO is automatically switched off in standby (sleep) mode by HW */
+  PMU_MODE_ON,                /**< LDO is always on */
+  PMU_MODE_STANDBYHIGHVOLTAGE,/**< ONLY for LCABB LDO !!! Use programmed voltage during sleep (standby) */
+  PMU_MODE_STANDBYLOWVOLTAGE, /**< ONLY for LCABB LDO !!! Use 1.00V during sleep (standby) */
+  PMU_NOF_MODE                /**< End indicator, hard coded value */
+} ePMU_MODE_LIST_T;
+// CODEGEN_END(ePMU_MODE_LIST_T) end of automated generated source by tool, don't remove this line
+
+/** @brief Enumeration of local interrupt types.
+  * NOTE: The interrupts SSC_PARERR_IRQ and SSC_CLK_IRQ need to be handled differently.
+  * They have an own HW line and can't be treated as interrupts because interrupts are
+  * globally disabled during SSC interface accesses. Instead the are treated level triggered by
+  * by polling the HW line.
+  * @ingroup pmu_internalif_irq_grp
+  */
+
+typedef enum
+{
+  PMU_LOCAL_FIRST_IRQ                = PMU_FIRST_IRQ,                   /**< Start indicator */
+  /* XGOLD631_INTERNAL_PMU */
+  /* C0 Interrupts*/
+  PMU_AG620_LOCAL_FOV_IRQ  = PMU_AG620_FOV_IRQ,            /*  fast overvoltage interrupt */
+  PMU_AG620_LOCAL_ONRE_IRQ = PMU_AG620_ONRE_IRQ,      /*  rising edge ON key interrupt */
+  PMU_AG620_LOCAL_ONFE_IRQ = PMU_AG620_ONFE_IRQ,      /*  falling edge ON key interrupt */
+  PMU_AG620_LOCAL_BUV_IRQ  = PMU_AG620_BUV_IRQ,       /*  Battery Undervoltage interrupt */
+  PMU_AG620_LOCAL_BRD_IRQ  = PMU_AG620_BRD_IRQ,   /*  battery removal interrupt */
+  PMU_AG620_LOCAL_ACD1_IRQ = PMU_AG620_ACD1_IRQ,  /*  accessory detection channel 1 interrupt */
+  PMU_AG620_LOCAL_ACD2_IRQ = PMU_AG620_ACD2_IRQ,  /*  accessory detection channel 2 interrupt*/
+  PMU_AG620_LOCAL_CHGI_IRQ = PMU_AG620_CHGI_IRQ,    /*  external battery charger interrupt */
+  PMU_AG620_LOCAL_CDET_IRQ = PMU_AG620_CDET_IRQ,  /*  external battery charger detection interrupt */
+  PMU_AG620_LOCAL_DBM_IRQ  = PMU_AG620_DBM_IRQ,  /*VBATMON digital comparator interrupt */
+  PMU_AG620_LOCAL_TWARN_IRQ = PMU_AG620_TWARN_IRQ,  /* interrupt for 105 degree - Configurable*/
+  PMU_AG620_LOCAL_TSTOP_IRQ = PMU_AG620_TSTOP_IRQ,  /*interrupt for 115 degree -Configurable*/
+  PMU_AG620_LOCAL_VIC_IRQ  = PMU_AG620_VIC_IRQ,   /*Vibra Overcurrent Interrupt */
+  PMU_AG620_LOCAL_CC_IRQ  = PMU_AG620_CC_IRQ,   /*Coulomb counter Interrupt */
+
+  PMU_AG620_LOCAL_INTERRUPTS  = PMU_NOF_IRQ_TYPES,        /**< Begin of local interrupts */
+  /* C0  Local Interrupts*/
+  PMU_AG620_LOCAL_LPCL_IRQ,        /*LPLL current limit interrupt*/
+  PMU_AG620_LOCAL_LAXCL_IRQ,    /*LAUX1 current limit interrupt */
+  PMU_AG620_LOCAL_LAX2CL_IRQ,    /*LAUX2 current limit interrupt*/
+  PMU_AG620_LOCAL_LAICL_IRQ,    /*LAIF current limit interrupt*/
+  PMU_AG620_LOCAL_LS1CL_IRQ,     /*LSIM1 current limit interrupt */
+  PMU_AG620_LOCAL_LS2CL_IRQ,     /*LSIM2 current limit interrupt */
+  PMU_AG620_LOCAL_LMMCL_IRQ,    /*LMMC1 current limit interrupt */
+  PMU_AG620_LOCAL_LUCL_IRQ,        /* LUSB current limit interrupt  */
+  PMU_AG620_LOCAL_LMICL_IRQ,    /*  LMIPI current limit interrupt */
+  PMU_AG620_LOCAL_LMECL_IRQ,    /*  LMEM current limit interrupt */
+  PMU_LOCAL_NOF_IRQ_TYPES                /**< Number of known interrupt types */
+} ePMU_LOCAL_IRQ_TYPE_T;
+
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/* EXTERNAL DATA DECLARATIONS                                                                                    */
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/* EXTERNAL FUNCTION DECLARATIONS                                                                                */
+/*---------------------------------------------------------------------------------------------------------------*/
+
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/* END                                                                                                           */
+/*---------------------------------------------------------------------------------------------------------------*/
+
+
+/** \fn ePMU_RETURN_T PMU_req_domain_voltage (const ePMU_DOMAIN_T domain, const ePMU_VOLTAGE_LIST_T voltage, const ePMU_MODE_LIST_T enable)
+  * @brief Function shall be used from the POW driver to request voltage and activation state for each PMU regulator.
+  * @ingroup pmu_internalif_domain_grp
+  *
+  * Following modes and voltages are available per domain:
+  *
+  */
+// CODEGEN_BEGIN(Doxygen_ModesAndVoltagesPerDomain) begin of automated generated source by tool, don't remove this line
+/**
+  *
+  * - PMU_DOMAIN_LSIM1
+  *   - Modes:
+  *     - PMU_MODE_IDLE_STDBY
+  *     - PMU_MODE_OFF
+  *     - PMU_MODE_OFF_STDBY
+  *     - PMU_MODE_ON
+  *   - Voltages:
+  *     - PMU_VOLTAGE_1V20
+  *     - PMU_VOLTAGE_1V80
+  *     - PMU_VOLTAGE_2V91
+  *
+  * - PMU_DOMAIN_LSIM2
+  *   - Modes:
+  *     - PMU_MODE_IDLE_STDBY
+  *     - PMU_MODE_OFF
+  *     - PMU_MODE_OFF_STDBY
+  *     - PMU_MODE_ON
+  *   - Voltages:
+  *     - PMU_VOLTAGE_1V20
+  *     - PMU_VOLTAGE_1V80
+  *     - PMU_VOLTAGE_2V91
+  *
+  * - PMU_DOMAIN_LAUX1
+  *   - Modes:
+  *     - PMU_MODE_IDLE_STDBY
+  *     - PMU_MODE_OFF
+  *     - PMU_MODE_OFF_STDBY
+  *     - PMU_MODE_ON
+  *   - Voltages:
+  *     - PMU_VOLTAGE_1V80
+  *     - PMU_VOLTAGE_2V50
+  *     - PMU_VOLTAGE_2V80
+  *     - PMU_VOLTAGE_2V85
+  *
+  * - PMU_DOMAIN_LAUX2
+  *   - Modes:
+  *     - PMU_MODE_IDLE_STDBY
+  *     - PMU_MODE_OFF
+  *     - PMU_MODE_OFF_STDBY
+  *     - PMU_MODE_ON
+  *   - Voltages:
+  *     - PMU_VOLTAGE_1V80
+  *     - PMU_VOLTAGE_2V50
+  *     - PMU_VOLTAGE_2V80
+  *     - PMU_VOLTAGE_2V85
+  *
+  * - PMU_DOMAIN_LMMC1
+  *   - Modes:
+  *     - PMU_MODE_IDLE_STDBY
+  *     - PMU_MODE_OFF
+  *     - PMU_MODE_OFF_STDBY
+  *     - PMU_MODE_ON
+  *   - Voltages:
+  *     - PMU_VOLTAGE_1V20
+  *     - PMU_VOLTAGE_1V80
+  *     - PMU_VOLTAGE_2V85
+  *     - PMU_VOLTAGE_2V90
+  *
+  * - PMU_DOMAIN_LUSB
+  *   - Modes:
+  *     - PMU_MODE_IDLE_STDBY
+  *     - PMU_MODE_OFF
+  *     - PMU_MODE_OFF_STDBY
+  *     - PMU_MODE_ON
+  *   - Voltages:
+  *     - PMU_VOLTAGE_2V50
+  *     - PMU_VOLTAGE_2V85
+  *     - PMU_VOLTAGE_3V15
+  *
+  * - PMU_DOMAIN_LPMU
+  *   - Modes:
+  *     - PMU_MODE_FIXED
+  *   - Voltages:
+  *     - PMU_VOLTAGE_FIXED
+  *
+  * - PMU_DOMAIN_LAIF
+  *   - Modes:
+  *     - PMU_MODE_IDLE_STDBY
+  *     - PMU_MODE_OFF
+  *     - PMU_MODE_OFF_STDBY
+  *     - PMU_MODE_ON
+  *   - Voltages:
+  *     - PMU_VOLTAGE_1V00
+  *     - PMU_VOLTAGE_1V10
+  *     - PMU_VOLTAGE_1V80
+  *     - PMU_VOLTAGE_2V50
+  *
+  * - PMU_DOMAIN_LCABB
+  *   - Modes:
+  *     - PMU_MODE_ON
+  *     - PMU_MODE_STANDBYHIGHVOLTAGE
+  *     - PMU_MODE_STANDBYLOWVOLTAGE
+  *   - Voltages:
+  *     - PMU_VOLTAGE_1V00
+  *     - PMU_VOLTAGE_1V12
+  *     - PMU_VOLTAGE_1V16
+  *     - PMU_VOLTAGE_1V20
+  *
+  * - PMU_DOMAIN_LMEM
+  *   - Modes:
+  *     - PMU_MODE_FIXED
+  *     - PMU_MODE_IDLE_STDBY
+  *     - PMU_MODE_ON
+  *   - Voltages:
+  *     - PMU_VOLTAGE_1V02
+  *     - PMU_VOLTAGE_1V12
+  *     - PMU_VOLTAGE_1V226
+  *     - PMU_VOLTAGE_1V25
+  *
+  * - PMU_DOMAIN_LMIPI
+  *   - Modes:
+  *     - PMU_MODE_IDLE_STDBY
+  *     - PMU_MODE_OFF
+  *     - PMU_MODE_OFF_STDBY
+  *     - PMU_MODE_ON
+  *   - Voltages:
+  *     - PMU_VOLTAGE_1V00
+  *     - PMU_VOLTAGE_1V10
+  *     - PMU_VOLTAGE_1V17
+  *     - PMU_VOLTAGE_1V20
+  *
+  * - PMU_DOMAIN_LPLL
+  *   - Modes:
+  *     - PMU_MODE_FIXED
+  *     - PMU_MODE_IDLE_STDBY
+  *     - PMU_MODE_OFF
+  *     - PMU_MODE_OFF_STDBY
+  *     - PMU_MODE_ON
+  *   - Voltages:
+  *     - PMU_VOLTAGE_1V00
+  *     - PMU_VOLTAGE_1V10
+  *     - PMU_VOLTAGE_1V20
+  *     - PMU_VOLTAGE_1V25
+  *
+  * - PMU_DOMAIN_SD1
+  *   - Modes:
+  *     - PMU_MODE_FIXED
+  *   - Voltages:
+  *     - PMU_VOLTAGE_FIXED
+  *
+  * - PMU_DOMAIN_SD2
+  *   - Modes:
+  *     - PMU_MODE_FIXED
+  *   - Voltages:
+  *     - PMU_VOLTAGE_FIXED
+  *
+  * - PMU_DOMAIN_ELDO_VMMC
+  *   - Modes:
+  *     - PMU_MODE_FIXED
+  *     - PMU_MODE_OFF
+  *     - PMU_MODE_ON
+  *   - Voltages:
+  *     - PMU_VOLTAGE_1V80
+  *
+  * - PMU_DOMAIN_GNSS_TCXO_LDO
+  *   - Modes:
+  *     - PMU_MODE_FIXED
+  *     - PMU_MODE_OFF
+  *     - PMU_MODE_ON
+  *   - Voltages:
+  *     - PMU_VOLTAGE_FIXED
+  *
+  * - PMU_DOMAIN_DUMMY
+  *   - Modes:
+  *     - PMU_MODE_FIXED
+  *   - Voltages:
+  *     - PMU_VOLTAGE_FIXED
+*/
+// CODEGEN_END(Doxygen_ModesAndVoltagesPerDomain) end of automated generated source by tool, don't remove this line
+
+#endif //__PMU_INTERNAL_CFG_H__
diff --git a/devices/pm/power_control/pow/src/board_sf_3gx_ext_pmic/pow_bootcore.c b/devices/pm/power_control/pow/src/board_sf_3gx_ext_pmic/pow_bootcore.c
new file mode 100644
index 0000000..12f8ae1
--- /dev/null
+++ b/devices/pm/power_control/pow/src/board_sf_3gx_ext_pmic/pow_bootcore.c
@@ -0,0 +1,261 @@
+/*  -------------------------------------------------------------------------
+    Copyright (C) 2013-2014 Intel Mobile Communications GmbH
+
+         Sec Class: Intel Confidential (IC)
+
+     ----------------------------------------------------------------------
+     Revision Information:
+       $$File name:
+       $$CC-Version:
+       $$Date:       2014-01-27    8:43:41 UTC $
+     ---------------------------------------------------------------------- */
+
+#include "spcu_reg.h"
+#include "cgu_internal.h"
+#include "cgu_internal_cfg.h"
+#ifdef SF_3G_TAB_EXTPMIC
+#include <pmic_bootcore.h>
+#endif
+
+enum POW_BOOTCORE_USER
+{
+  POW_BOOTCORE_USER_USIF1,
+  POW_BOOTCORE_USER_USIF2,
+};
+
+
+#if defined (POW_INTRAM_SUPPORT)
+__attribute__((section("BOOTCORE_POWER_RAM"))) void pow_pre_init_bootcore(void);
+#endif
+
+//for bring up
+void pow_iowrite(volatile unsigned int* address, unsigned int value)
+{
+  *address = value;
+}
+
+void pow_agold_setup(void)
+{
+  //setup power
+  //disable wdt
+  pow_iowrite(0xE6100184, 0x63000000);
+#if !defined (SF3GX_EXTPMIC)
+  pow_iowrite(0xE6500700, 0x2);
+#else
+  // power key on 1s timer
+  pow_iowrite(0xE650020C,0x120001);
+#endif
+
+  // write default value to charger control
+  pow_iowrite(0xE6500A08, 0x1);
+
+  // dcc pmu
+  //pow_iowrite(0xE6401120, 0x00000011);
+  //pow_iowrite(0xE6401124, 0x00000011);
+  //pow_iowrite(0xE6401138, 0x00000001);
+  //pow_iowrite(0xE6401158, 0x00000001);
+
+  // dcc pmu
+  pow_iowrite(0xE6500514, 0xE);
+	//pow_iowrite(0xE650092C, 0xA00);
+  pow_iowrite(0xE6401154, 0x3);
+
+  //pow_iowrite(0xE6401124, 0x00000011);
+  pow_iowrite(0xE6402038, 0x00000032); //what is this?
+
+  pow_iowrite(0xE6500404, 0x000E03D1);
+  pow_iowrite(0xE6500304, 0x000E03D1);
+
+
+  pow_iowrite(0xE640203C, 0x00001032);
+  pow_iowrite(0xE6402040, 0x00400032);
+
+  pow_iowrite(0xE6401138, 0x00000001);
+  pow_iowrite(0xE6401158, 0x00000001);
+
+
+  /* ModifiedVal = o        0,8V   1,0V  1,1V  1,20V  */
+  /* ResetValue  = x           o     o     o     o   */
+  /* PMU_VOLTAGECLASS_0   { 0x0f, 0x31, 0x40, 0x58}, */
+
+  pow_iowrite(0xE6500310, 0x58585858);
+  pow_iowrite(0xE6500314, 0x00000058);
+
+  /*
+   * RTC settings for keypad
+   */
+  pow_iowrite(0xE6A00104, 0x00AA);
+  pow_iowrite(0xE6200000, 0x100);
+  //pow_iowrite(0xE6200018, 0x0);
+  pow_iowrite(0xE6200010, 0xe040);
+  pow_iowrite(0xE6200078, 0);
+  pow_iowrite(0xE6A00104, 0x0055);
+}
+
+void pow_agold_platform_setup()
+{
+  pow_iowrite(0xE650050C, 0x0000000E); //LMIPI 1v17
+  pow_iowrite(0xE6500518, 0x0000000C); //LAUX1 1v80
+  pow_iowrite(0xE650051C, 0x0000000E); //LAUX2 2v8
+}
+
+
+void pow_pre_init_bootcore(void)
+{
+  pow_agold_setup();
+
+  SPCU_pre_init_bootcore(); //setup spcu vcore pwm mode and pmu_ctrl to be vhigh
+  CGU_pre_init_cpu();  //init pllb and set CPU to higher clock
+  CGU_pre_init_PMU();  //initialize abb_plla abb_psh1, plla, psh1, idi
+  CGU_pre_init_emmc(); //init EMMC clock
+
+  EMIC_bootInit();     //EMIC config
+}
+
+void pow_bootcore_set_cpu_clock_low(void)
+{
+  CGU_pre_init_cpu_low();  //init pllb and set CPU to higher clock
+}
+
+void pow_bootcore_set_cpu_clock_high(void)
+{
+  CGU_pre_init_cpu_high();  //init pllb and set CPU to higher clock
+}
+
+
+void SPCU_SetUSBPhyIsolation(void)
+{
+  setSpcu_SpcuPsc_USB_HS_DIG_ISO(&spcu, SPCUPSC_USB_HS_DIG_ISO_PON);
+}
+
+
+/*****************************************************************************
+  * Function:    SPCU_RemoveUSBPhyIsolation()
+  * Parameters:  none
+  * Returns:     none
+  * Description: none
+  *
+ *****************************************************************************/
+void SPCU_RemoveUSBPhyIsolation(void)
+{
+  setSpcu_SpcuPsc_USB_HS_DIG_ISO(&spcu, SPCUPSC_USB_HS_DIG_ISO_POFF);
+}
+
+
+/*****************************************************************************
+ * Function:	SPCU_PowerUSBcore()
+ * Parameters:	none
+ * Returns: 	none
+ * Description: none
+ *
+ *****************************************************************************/
+void SPCU_PowerUSBcore(void)
+{
+   setSpcu_SpcuPsc_USB_HS_PDN(&spcu, SPCUPSC_USB_HS_PDN_PON);
+}
+
+
+void pow_set_usb()
+{
+  pow_iowrite(0xE6500520, 0x0000000D); //LAIF ON
+  pow_iowrite(0xE6500500, 0x00000007); //LUSB V3.15 standby_off
+}
+
+//for display
+void spcu_phy_isolation_disable(void)
+{
+
+  setSpcu_SpcuIsoCtrl_digrf_lvds_iso(&spcu, SPCUISOCTRL_DIGRF_LVDS_ISO_DIS);
+#if !defined SF_ES_2_0 /*Removed in ES 2*/
+  setSpcu_SpcuIsoCtrl_digrf_pll_iso(&spcu, SPCUISOCTRL_DIGRF_PLL_ISO_DIS);
+#endif
+  //For PHY domain isolation disable
+  setSpcu_SpcuIsoCtrl_MasterD2AIntfLock(&spcu, SPCUISOCTRL_MASTERD2AINTFLOCK_DIS);
+  setSpcu_SpcuIsoCtrl_MasterA2DIntfLock(&spcu, SPCUISOCTRL_MASTERA2DINTFLOCK_DIS);
+}
+
+void pmu_bootcore_display_power_enable(void)
+{
+  // LCD module power
+#ifdef SF_3G_TAB_EXTPMIC
+  pmic_bootcore_set_req(PMIC_USER_ID_DIS,DIS_TO_ON);
+#endif
+
+  //Setting Voltage configurations of AUX
+  //setPmu_LAUX2_Config_LDOVoltage(&pmu,LAUX2_CONFIG_LDOVOLTAGE_V285);
+  //setPmu_LAUX2_Config_LDOMode(&pmu,LAUX2_CONFIG_LDOMODE_ON);
+  //todo: remove hardcode
+  pow_iowrite(0xE650051c, 0x7);
+
+  //For DSI PHY Voltage configuration
+  //setPmu_LMIPI_Config_LDOVoltage(&pmu,LMIPI_CONFIG_LDOVOLTAGE_V117);
+  //setPmu_LMIPI_Config_LDOMode(&pmu,LMIPI_CONFIG_LDOMODE_ON);
+  //todo: remove hardcode
+  pow_iowrite(0xE6500510, 0xE);
+
+  spcu_phy_isolation_disable();
+}
+
+void pmu_bootcore_enable_backlight(void)
+{
+#if !defined (AG620_ES2_0_DEFINED_FOR_BL)
+    pow_iowrite(0xE650092C, 0xA00);
+
+    cgu_backlight_clk_enable();
+
+    pow_iowrite(0xE650090C, 0xFF);
+    pow_iowrite(0xE6500908, 0xFB);
+    pow_iowrite(0xE6500918, 0xFFFF);
+    pow_iowrite(0xE650092C, 0x116);
+#else
+    pow_iowrite(0xE650182C, 0x200); //LED_CTRL
+    pow_iowrite(0xE6501954, 0x800); //safe_LED_CTRL
+
+    cgu_backlight_clk_enable();
+
+  #if defined(SF_ES_2_0)
+    pow_iowrite(0xE650180C, 0x00000127);
+    pow_iowrite(0xE6501808, 0x00000122);
+  #else
+    pow_iowrite(0xE650180C, 0xFF);
+    pow_iowrite(0xE6501808, 0xFB);
+  #endif
+    pow_iowrite(0xE650182C, 0x104);
+    pow_iowrite(0xE6501954, 0x0012); //GPOenable, CLSL default; ref_mux_sel - 10, mode -10, LED_STBY don't care
+#endif
+}
+
+U32 pow_bootcore_get_block_frequency(U32 user, U32 *freq)
+{
+  e_CGU_result result = CGU_RES_ERROR;
+  switch((enum POW_BOOTCORE_USER)(user))
+  {
+    case POW_BOOTCORE_USER_USIF1:
+      result = CGU_get_block_frequency(CGU_CLK_USIF1, freq);
+      break;
+    case POW_BOOTCORE_USER_USIF2:
+      result = CGU_get_block_frequency(CGU_CLK_USIF2, freq);
+      break;
+  }
+  return result;
+} 
+
+
+U32 pow_bootcore_set_block_frequency(U32 user, U32 freq)
+{
+  e_CGU_result result = CGU_RES_ERROR;
+  switch((enum POW_BOOTCORE_USER)(user))
+  {
+    case POW_BOOTCORE_USER_USIF1:
+      result = CGU_set_block_frequency(CGU_CLK_USIF1, freq);
+      break;
+    case POW_BOOTCORE_USER_USIF2:
+      result = CGU_set_block_frequency(CGU_CLK_USIF2, freq);
+      break;
+  }
+  return result;
+}
+
+
+
+
diff --git a/devices/pm/power_control/pow/src/board_sf_3gx_ext_pmic/pow_volt_board_cfg.c b/devices/pm/power_control/pow/src/board_sf_3gx_ext_pmic/pow_volt_board_cfg.c
new file mode 100644
index 0000000..cc1baab
--- /dev/null
+++ b/devices/pm/power_control/pow/src/board_sf_3gx_ext_pmic/pow_volt_board_cfg.c
@@ -0,0 +1,495 @@
+/* =============================================================================
+ * Copyright (C) 2013-2014 Intel Mobile Communications GmbH
+ *
+ *      Sec Class: Intel Confidential (IC)
+ *
+ * =============================================================================
+ *
+ * This document contains proprietary information belonging to IMC.
+ * Passing on and copying of this document, use and communication of
+ * its contents is not permitted without prior written authorisation.
+ *
+ * =============================================================================
+ * Revision Information :
+ *   $File name:  /mhw_drv_src/power_control/pow/src/board_xmm6321/pow_volt_board_cfg.c $
+ *   Responsible: esswein
+ *   Comment:
+ *     Created
+ * =============================================================================
+ *
+ * This file contains the board HW dependent implementation part of the POW voltage
+ * specific driver interface part
+ * HW set-up: AGOLD610 PMU (connected via IDI) for XMM6310 board.
+ * ===========================================================================*/
+
+/*----------------------------------------------*/
+/* INCLUDES                                     */
+/*----------------------------------------------*/
+#include "pow_volt_internal.h"
+#include "pmu_driverif_cfg.h"
+#include "pmu_driverif.h"
+#include "pmu_internal_cfg.h"
+#include "pmu_internal.h"
+#include "pow_volt_spcu_cfg.h"
+
+//#include "pcl_driverif.h"
+
+/*----------------------------------------------*/
+/* TYPE DEFINITIONS                             */
+/*----------------------------------------------*/
+
+/*----------------------------------------------*/
+/* INTERNAL FUNCTION DECLARATIONS               */
+/*----------------------------------------------*/
+/**
+ * The pre_fct_... functions are called before the virtual power domain is modified.
+ * The post_fct_... functions are called after this modification.
+ *
+ * If you want to handle power isolations this should normally be done in the pre
+ * and post functions of the physical power domains
+ */
+// CODEGEN_BEGIN(POW_VOLTAGE_PATCH_FUNTIONS) begin of automated generated source by tool, don't remove this line
+// CODEGEN_END(POW_VOLTAGE_PATCH_FUNTIONS) end of automated generated source by tool, don't remove this line
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/*----------------------------------------------*/
+/* VARIABLE DEFINITIONS                         */
+/*----------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------------*/
+// CODEGEN_BEGIN(VIRTUAL_POW_DOMAIN_VOLTAGES) begin of automated generated source by tool, don't remove this line
+
+/**
+ * Possible voltages of the virtual power domain VDDP_MMC.
+ * Has to be a subset of the possible voltages of the physical domain.
+*/
+static const POW_CONTROL_VOLTAGE_T  vddp_mmc_volt_lev[] = {
+   POW_CONTROL_VOLTAGE_1V20,
+   POW_CONTROL_VOLTAGE_1V8,
+   POW_CONTROL_VOLTAGE_2V85,
+   POW_CONTROL_VOLTAGE_2V9,
+   POW_CONTROL_NUM_VOLTAGE
+};
+
+/**
+ * Possible voltages of the virtual power domain VDDP_MMC_TD.
+ * Has to be a subset of the possible voltages of the physical domain.
+*/
+static const POW_CONTROL_VOLTAGE_T  vddp_mmc_td_volt_lev[] = {
+   POW_CONTROL_VOLTAGE_1V20,
+   POW_CONTROL_VOLTAGE_1V8,
+   POW_CONTROL_VOLTAGE_2V85,
+   POW_CONTROL_VOLTAGE_2V9,
+   POW_CONTROL_NUM_VOLTAGE
+};
+
+/**
+ * Possible voltages of the virtual power domain VDD_MIPI_CSI.
+ * Has to be a subset of the possible voltages of the physical domain.
+*/
+static const POW_CONTROL_VOLTAGE_T  vdd_mipi_csi_volt_lev[] = {
+   POW_CONTROL_VOLTAGE_1V00,
+   POW_CONTROL_VOLTAGE_1V10,
+   POW_CONTROL_VOLTAGE_1V17,
+   POW_CONTROL_VOLTAGE_1V20,
+   POW_CONTROL_NUM_VOLTAGE
+};
+
+/**
+ * Possible voltages of the virtual power domain VDD_MIPI_DSI.
+ * Has to be a subset of the possible voltages of the physical domain.
+*/
+static const POW_CONTROL_VOLTAGE_T  vdd_mipi_dsi_volt_lev[] = {
+   POW_CONTROL_VOLTAGE_1V00,
+   POW_CONTROL_VOLTAGE_1V10,
+   POW_CONTROL_VOLTAGE_1V17,
+   POW_CONTROL_VOLTAGE_1V20,
+   POW_CONTROL_VOLTAGE_1V8,
+   POW_CONTROL_NUM_VOLTAGE
+};
+
+/**
+ * Possible voltages of the virtual power domain VDD_DIGRF1.
+ * Has to be a subset of the possible voltages of the physical domain.
+*/
+static const POW_CONTROL_VOLTAGE_T  vdd_digrf1_volt_lev[] = {
+   POW_CONTROL_VOLTAGE_1V00,
+   POW_CONTROL_VOLTAGE_1V10,
+   POW_CONTROL_VOLTAGE_1V17,
+   POW_CONTROL_VOLTAGE_1V20,
+   POW_CONTROL_NUM_VOLTAGE
+};
+
+/**
+ * Possible voltages of the virtual power domain VDD_USB_1V1.
+ * Has to be a subset of the possible voltages of the physical domain.
+*/
+static const POW_CONTROL_VOLTAGE_T  vdd_usb_1v1_volt_lev[] = {
+   POW_CONTROL_VOLTAGE_1V00,
+   POW_CONTROL_VOLTAGE_1V10,
+   POW_CONTROL_VOLTAGE_1V8,
+   POW_CONTROL_VOLTAGE_2V5,
+   POW_CONTROL_NUM_VOLTAGE
+};
+
+/**
+ * Possible voltages of the virtual power domain VDD_EMIC_CORE.
+ * Has to be a subset of the possible voltages of the physical domain.
+*/
+static const POW_CONTROL_VOLTAGE_T  vdd_emic_core_volt_lev[] = {
+   POW_CONTROL_VOLTAGE_1V00,
+   POW_CONTROL_VOLTAGE_1V10,
+   POW_CONTROL_VOLTAGE_1V8,
+   POW_CONTROL_VOLTAGE_2V5,
+   POW_CONTROL_NUM_VOLTAGE
+};
+
+/**
+ * Possible voltages of the virtual power domain VDD_EMIC_DLL.
+ * Has to be a subset of the possible voltages of the physical domain.
+*/
+static const POW_CONTROL_VOLTAGE_T  vdd_emic_dll_volt_lev[] = {
+   POW_CONTROL_VOLTAGE_1V00,
+   POW_CONTROL_VOLTAGE_1V10,
+   POW_CONTROL_VOLTAGE_1V8,
+   POW_CONTROL_VOLTAGE_2V5,
+   POW_CONTROL_NUM_VOLTAGE
+};
+
+/**
+ * Possible voltages of the virtual power domain VDD_IDI_RX.
+ * Has to be a subset of the possible voltages of the physical domain.
+*/
+static const POW_CONTROL_VOLTAGE_T  vdd_idi_rx_volt_lev[] = {
+   POW_CONTROL_VOLTAGE_1V00,
+   POW_CONTROL_VOLTAGE_1V10,
+   POW_CONTROL_VOLTAGE_1V8,
+   POW_CONTROL_VOLTAGE_2V5,
+   POW_CONTROL_NUM_VOLTAGE
+};
+
+/**
+ * Possible voltages of the virtual power domain VDD_USB_3V3.
+ * Has to be a subset of the possible voltages of the physical domain.
+*/
+static const POW_CONTROL_VOLTAGE_T  vdd_usb_3v3_volt_lev[] = {
+   POW_CONTROL_VOLTAGE_2V5,
+   POW_CONTROL_VOLTAGE_2V85,
+   POW_CONTROL_VOLTAGE_3V15,
+   POW_CONTROL_NUM_VOLTAGE
+};
+
+/**
+ * Possible voltages of the virtual power domain VDDP_SIM.
+ * Has to be a subset of the possible voltages of the physical domain.
+*/
+static const POW_CONTROL_VOLTAGE_T  vddp_sim_volt_lev[] = {
+   POW_CONTROL_VOLTAGE_1V20,
+   POW_CONTROL_VOLTAGE_1V8,
+   POW_CONTROL_VOLTAGE_2V91,
+   POW_CONTROL_NUM_VOLTAGE
+};
+
+/**
+ * Possible voltages of the virtual power domain VDDP_SIM2.
+ * Has to be a subset of the possible voltages of the physical domain.
+*/
+static const POW_CONTROL_VOLTAGE_T  vddp_sim2_volt_lev[] = {
+   POW_CONTROL_VOLTAGE_1V20,
+   POW_CONTROL_VOLTAGE_1V8,
+   POW_CONTROL_VOLTAGE_2V91,
+   POW_CONTROL_NUM_VOLTAGE
+};
+
+/**
+ * Possible voltages of the virtual power domain VDD_PLL.
+ * Has to be a subset of the possible voltages of the physical domain.
+*/
+static const POW_CONTROL_VOLTAGE_T  vdd_pll_volt_lev[] = {
+   POW_CONTROL_VOLTAGE_1V00,
+   POW_CONTROL_VOLTAGE_1V10,
+   POW_CONTROL_VOLTAGE_1V20,
+   POW_CONTROL_VOLTAGE_1V25,
+   POW_CONTROL_NUM_VOLTAGE
+};
+
+/**
+ * Possible voltages of the virtual power domain VDD_CAM_PRIM_ANALOG.
+ * Has to be a subset of the possible voltages of the physical domain.
+*/
+static const POW_CONTROL_VOLTAGE_T  vdd_cam_prim_analog_volt_lev[] = {
+   POW_CONTROL_VOLTAGE_1V8,
+   POW_CONTROL_VOLTAGE_2V5,
+   POW_CONTROL_VOLTAGE_2V8,
+   POW_CONTROL_VOLTAGE_2V85,
+   POW_CONTROL_NUM_VOLTAGE
+};
+
+/**
+ * Possible voltages of the virtual power domain VDD_CAM_SEC_ANALOG.
+ * Has to be a subset of the possible voltages of the physical domain.
+*/
+static const POW_CONTROL_VOLTAGE_T  vdd_cam_sec_analog_volt_lev[] = {
+   POW_CONTROL_VOLTAGE_1V8,
+   POW_CONTROL_VOLTAGE_2V5,
+   POW_CONTROL_VOLTAGE_2V8,
+   POW_CONTROL_VOLTAGE_2V85,
+   POW_CONTROL_NUM_VOLTAGE
+};
+
+/**
+ * Possible voltages of the virtual power domain VDD_PRIM_DISPLAY.
+ * Has to be a subset of the possible voltages of the physical domain.
+*/
+static const POW_CONTROL_VOLTAGE_T  vdd_prim_display_volt_lev[] = {
+   POW_CONTROL_VOLTAGE_1V8,
+   POW_CONTROL_VOLTAGE_2V5,
+   POW_CONTROL_VOLTAGE_2V8,
+   POW_CONTROL_VOLTAGE_2V85,
+   POW_CONTROL_VOLTAGE_3V30,
+   POW_CONTROL_NUM_VOLTAGE
+};
+
+/**
+ * Possible voltages of the virtual power domain VDD_TOUCH_SENSOR.
+ * Has to be a subset of the possible voltages of the physical domain.
+*/
+static const POW_CONTROL_VOLTAGE_T  vdd_touch_sensor_volt_lev[] = {
+   POW_CONTROL_VOLTAGE_1V8,
+   POW_CONTROL_VOLTAGE_2V5,
+   POW_CONTROL_VOLTAGE_2V8,
+   POW_CONTROL_VOLTAGE_2V85,
+   POW_CONTROL_VOLTAGE_3V30,
+   POW_CONTROL_NUM_VOLTAGE
+};
+
+/**
+ * Possible voltages of the virtual power domain VDD_PROXIMITY_SENSOR.
+ * Has to be a subset of the possible voltages of the physical domain.
+*/
+static const POW_CONTROL_VOLTAGE_T  vdd_proximity_sensor_volt_lev[] = {
+   POW_CONTROL_VOLTAGE_1V8,
+   POW_CONTROL_VOLTAGE_2V5,
+   POW_CONTROL_VOLTAGE_2V8,
+   POW_CONTROL_VOLTAGE_2V85,
+   POW_CONTROL_NUM_VOLTAGE
+};
+
+/**
+ * Possible voltages of the virtual power domain VDD_ACCELEROMETER.
+ * Has to be a subset of the possible voltages of the physical domain.
+*/
+static const POW_CONTROL_VOLTAGE_T  vdd_accelerometer_volt_lev[] = {
+   POW_CONTROL_VOLTAGE_1V8,
+   POW_CONTROL_VOLTAGE_2V5,
+   POW_CONTROL_VOLTAGE_2V8,
+   POW_CONTROL_VOLTAGE_2V85,
+   POW_CONTROL_NUM_VOLTAGE
+};
+
+/**
+ * Possible voltages of the virtual power domain VDD_MAGNETOMETER.
+ * Has to be a subset of the possible voltages of the physical domain.
+*/
+static const POW_CONTROL_VOLTAGE_T  vdd_magnetometer_volt_lev[] = {
+   POW_CONTROL_VOLTAGE_1V8,
+   POW_CONTROL_VOLTAGE_2V5,
+   POW_CONTROL_VOLTAGE_2V8,
+   POW_CONTROL_VOLTAGE_2V85,
+   POW_CONTROL_NUM_VOLTAGE
+};
+
+/**
+ * Possible voltages of the virtual power domain VDD_GYROSCOPE.
+ * Has to be a subset of the possible voltages of the physical domain.
+*/
+static const POW_CONTROL_VOLTAGE_T  vdd_gyroscope_volt_lev[] = {
+   POW_CONTROL_VOLTAGE_1V8,
+   POW_CONTROL_VOLTAGE_2V5,
+   POW_CONTROL_VOLTAGE_2V8,
+   POW_CONTROL_VOLTAGE_2V85,
+   POW_CONTROL_NUM_VOLTAGE
+};
+
+/**
+ * Possible voltages of the virtual power domain VDD_PRIM_SEC_CAM_IO.
+ * Has to be a subset of the possible voltages of the physical domain.
+*/
+static const POW_CONTROL_VOLTAGE_T  vdd_prim_sec_cam_io_volt_lev[] = {
+   POW_CONTROL_VOLTAGE_1V8,
+   POW_CONTROL_VOLTAGE_2V5,
+   POW_CONTROL_VOLTAGE_2V8,
+   POW_CONTROL_VOLTAGE_2V85,
+   POW_CONTROL_NUM_VOLTAGE
+};
+
+/**
+ * Possible voltages of the virtual power domain VDD_EMIC_IO.
+ * Has to be a subset of the possible voltages of the physical domain.
+*/
+static const POW_CONTROL_VOLTAGE_T  vdd_emic_io_volt_lev[] = {
+   POW_CONTROL_VOLTAGE_1V02,
+   POW_CONTROL_VOLTAGE_1V12,
+   POW_CONTROL_VOLTAGE_1V226,
+   POW_CONTROL_VOLTAGE_1V25,
+   POW_CONTROL_NUM_VOLTAGE
+};
+
+/**
+ * Possible voltages of the virtual power domain VDD_ABB_GNSS_TCXO_LDO.
+ * Has to be a subset of the possible voltages of the physical domain.
+*/
+static const POW_CONTROL_VOLTAGE_T  vdd_abb_gnss_tcxo_ldo_volt_lev[] = {
+   POW_CONTROL_VOLTAGE_ON,
+   POW_CONTROL_NUM_VOLTAGE
+};
+
+static const POW_CONTROL_VOLTAGE_T  vdd_sd_card_volt_lev[] = {
+   POW_CONTROL_VOLTAGE_3V00,
+   POW_CONTROL_NUM_VOLTAGE
+};
+static const POW_CONTROL_VOLTAGE_T  vdd_emmc_volt_lev[] = {
+   POW_CONTROL_VOLTAGE_3V30,
+   POW_CONTROL_NUM_VOLTAGE
+};
+
+static const POW_CONTROL_VOLTAGE_T  vdd_bl_volt_lev[] = {
+   POW_CONTROL_VOLTAGE_5V00,
+   POW_CONTROL_NUM_VOLTAGE
+};
+
+/**
+ * Possible voltages of the virtual power domain VDD_CPU.
+ * Has to be a subset of the possible voltages of the physical domain.
+*/
+static const POW_CONTROL_VOLTAGE_T  vdd_ext_buck1_volt_lev[] = {
+   POW_CONTROL_VOLTAGE_0V87,
+   POW_CONTROL_VOLTAGE_1V00,
+   POW_CONTROL_VOLTAGE_1V02,
+   POW_CONTROL_VOLTAGE_1V10,
+   POW_CONTROL_VOLTAGE_1V14,
+   POW_CONTROL_VOLTAGE_1V25,
+   POW_CONTROL_VOLTAGE_1V30,
+   POW_CONTROL_VOLTAGE_1V32,
+   POW_CONTROL_NUM_VOLTAGE
+};
+
+/**
+ * Possible voltages of the virtual power domain VDD_GPU.
+ * Has to be a subset of the possible voltages of the physical domain.
+*/
+static const POW_CONTROL_VOLTAGE_T  vdd_ext_buck2_volt_lev[] = {
+   POW_CONTROL_VOLTAGE_1V00,
+   POW_CONTROL_VOLTAGE_1V10,
+   POW_CONTROL_VOLTAGE_1V30,
+   POW_CONTROL_NUM_VOLTAGE
+};
+
+// CODEGEN_END(VIRTUAL_POW_DOMAIN_VOLTAGES) end of automated generated source by tool, don't remove this line
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------------*/
+/**
+ * Information array about all virtual power domains.
+ * ALIGN WITH POW_CONTROL_VOLTAGE_T + additional_domains_e !!!
+ * The array pow_volt_virt_domain_info is initialized in POW_volt_init() by the function pow_volt_init_virt_domain()
+ * according to the init values of the PMU.
+ */
+
+/** Some remarks regarding I/O mode handling of XGOLD pads:
+ *
+ * Supported for the SDMMC1 Pads:
+ *   MMCI1_CMD
+ *   MMCI1_DAT_0
+ *   MMCI1_CLK
+ *   MMCI1_DAT_1
+ *   MMCI1_DAT_2
+ *   MMCI1_DAT_3
+ *
+ *   On the XMM6360 modem boards these pads are supplied by the SD2 (1.8V).
+ *   As this is the default value of the I/O mode nothing is implemented currently.
+ *   For other PCB this needs to be checked.
+ *
+ * Supported for the SIM Pads:
+ *   CC_IO
+ *   CC_CLK
+ *   CC_RST
+ *
+ *   They are usually supplied by LSIM. Handling implemented in patch_fct_vddp_sim().
+ */
+
+// CODEGEN_BEGIN(POW_ALL_VIRTUAL_DOMAINS) begin of automated generated source by tool, don't remove this line
+static pow_volt_virt_domain_info_s pow_volt_virt_domain_info[VDD_NUM_VIRT_DOMAINS] =
+{
+/* virt domain                                    phys domain                   next virt domain                        state                                   initial volt                  possible volt                           patch */
+/* POW_CONTROL_VDDP_MMC */                        { PMU_DOMAIN_LMMC1,           POW_CONTROL_VDDP_MMC_TD,                POW_CONTROL_VOLTAGE_DISABLE,            POW_CONTROL_VOLTAGE_ON,       &vddp_mmc_volt_lev[0],                  NULL                                    },
+/* POW_CONTROL_VDDP_MMC_TD */                    { PMU_DOMAIN_LMMC1,           POW_CONTROL_VDDP_MMC,                   POW_CONTROL_VOLTAGE_DISABLE,            POW_CONTROL_VOLTAGE_ON,       &vddp_mmc_td_volt_lev[0],               NULL                                    },
+/* POW_CONTROL_VDD_VEMMC */                       { PMU_DOMAIN_SD2,             POW_CONTROL_VDD_SDIO,                   POW_CONTROL_VOLTAGE_DISABLE,            POW_CONTROL_VOLTAGE_ON,       NULL,                                   NULL                                    },
+/* POW_CONTROL_VDD_SDIO */                        { PMU_DOMAIN_SD2,             POW_CONTROL_VDD_TOUCHSCREEN,            POW_CONTROL_VOLTAGE_DISABLE,            POW_CONTROL_VOLTAGE_ON,       NULL,                                   NULL                                    },
+/* POW_CONTROL_VDD_TOUCHSCREEN */                 { PMU_DOMAIN_SD2,             POW_CONTROL_VDD_EMIC_1V8_IO,            POW_CONTROL_VOLTAGE_DISABLE,            POW_CONTROL_VOLTAGE_ON,       NULL,                                   NULL                                    },
+/* POW_CONTROL_VDD_EMIC_1V8_IO */                 { PMU_DOMAIN_SD2,             POW_CONTROL_VDD_VEMMC,                  POW_CONTROL_VOLTAGE_DISABLE,            POW_CONTROL_VOLTAGE_ON,       NULL,                                   NULL                                    },
+/* POW_CONTROL_VDD_MIPI_CSI */                    { PMU_DOMAIN_LMIPI,           POW_CONTROL_VDD_MIPI_DSI,               POW_CONTROL_VOLTAGE_DISABLE,            POW_CONTROL_VOLTAGE_ON,       &vdd_mipi_csi_volt_lev[0],              NULL                                    },
+/* POW_CONTROL_VDD_MIPI_DSI */                    { PMU_DOMAIN_LMIPI,           POW_CONTROL_VDD_DIGRF1,                 POW_CONTROL_VOLTAGE_DISABLE,            POW_CONTROL_VOLTAGE_ON,       &vdd_mipi_dsi_volt_lev[0],              NULL                                    },
+/* POW_CONTROL_VDD_DIGRF1 */                      { PMU_DOMAIN_LMIPI,           POW_CONTROL_VDD_MIPI_CSI,               POW_CONTROL_VOLTAGE_DISABLE,            POW_CONTROL_VOLTAGE_ON,       &vdd_digrf1_volt_lev[0],                NULL                                    },
+/* POW_CONTROL_VDD_USB_1V1 */                     { PMU_DOMAIN_LAIF,            POW_CONTROL_VDD_EMIC_CORE,              POW_CONTROL_VOLTAGE_DISABLE,            POW_CONTROL_VOLTAGE_ON,       &vdd_usb_1v1_volt_lev[0],               NULL                                    },
+/* POW_CONTROL_VDD_EMIC_CORE */                   { PMU_DOMAIN_LAIF,            POW_CONTROL_VDD_EMIC_DLL,               POW_CONTROL_VOLTAGE_DISABLE,            POW_CONTROL_VOLTAGE_ON,       &vdd_emic_core_volt_lev[0],             NULL                                    },
+/* POW_CONTROL_VDD_EMIC_DLL */                    { PMU_DOMAIN_LAIF,            POW_CONTROL_VDD_IDI_RX,                 POW_CONTROL_VOLTAGE_DISABLE,            POW_CONTROL_VOLTAGE_ON,       &vdd_emic_dll_volt_lev[0],              NULL                                    },
+/* POW_CONTROL_VDD_IDI_RX */                      { PMU_DOMAIN_LAIF,            POW_CONTROL_VDD_USB_1V1,                POW_CONTROL_VOLTAGE_DISABLE,            POW_CONTROL_VOLTAGE_ON,       &vdd_idi_rx_volt_lev[0],                NULL                                    },
+/* POW_CONTROL_VDD_USB_3V3 */                     { PMU_DOMAIN_LUSB,            POW_CONTROL_VDD_USB_3V3,                POW_CONTROL_VOLTAGE_DISABLE,            POW_CONTROL_VOLTAGE_ON,       &vdd_usb_3v3_volt_lev[0],               NULL                                    },
+/* POW_CONTROL_VDDP_SIM */                        { PMU_DOMAIN_LSIM1,           POW_CONTROL_VDDP_SIM,                   POW_CONTROL_VOLTAGE_DISABLE,            POW_CONTROL_VOLTAGE_ON,       &vddp_sim_volt_lev[0],                  NULL                                    },
+/* POW_CONTROL_VDDP_SIM2 */                      { PMU_DOMAIN_LSIM2,           POW_CONTROL_VDDP_SIM2,                  POW_CONTROL_VOLTAGE_DISABLE,            POW_CONTROL_VOLTAGE_ON,       &vddp_sim2_volt_lev[0],                 NULL                                    },
+/* POW_CONTROL_VDD_PLL */                         { PMU_DOMAIN_LPLL,            POW_CONTROL_VDD_PLL,                    POW_CONTROL_VOLTAGE_DISABLE,            POW_CONTROL_VOLTAGE_ON,       &vdd_pll_volt_lev[0],                   NULL                                    },
+/* POW_CONTROL_VDD_IO_VOLT_TOUCH_SENSOR */       { PMU_DOMAIN_NOTCFG,           POW_CONTROL_VDD_IO_VOLT_PROXIMITY_SENSOR, POW_CONTROL_VOLTAGE_DISABLE,          POW_CONTROL_VOLTAGE_ON,       &vdd_touch_sensor_volt_lev[0],          NULL                                    },
+/* POW_CONTROL_VDD_IO_VOLT_PROXIMITY_SENSOR */    { PMU_DOMAIN_NOTCFG,           POW_CONTROL_VDD_IO_VOLT_ACCELEROMETER,    POW_CONTROL_VOLTAGE_DISABLE,          POW_CONTROL_VOLTAGE_ON,       &vdd_proximity_sensor_volt_lev[0],      NULL                                    },
+/* POW_CONTROL_VDD_IO_VOLT_ACCELEROMETER */      { PMU_DOMAIN_NOTCFG,           POW_CONTROL_VDD_IO_VOLT_MAGNETOMETER,     POW_CONTROL_VOLTAGE_DISABLE,          POW_CONTROL_VOLTAGE_ON,       &vdd_accelerometer_volt_lev[0],         NULL                                    },
+/* POW_CONTROL_VDD_IO_VOLT_MAGNETOMETER */        { PMU_DOMAIN_NOTCFG,           POW_CONTROL_VDD_IO_VOLT_GYROSCOPE,        POW_CONTROL_VOLTAGE_DISABLE,          POW_CONTROL_VOLTAGE_ON,       &vdd_magnetometer_volt_lev[0],          NULL                                    },
+/* POW_CONTROL_VDD_IO_VOLT_GYROSCOPE */           { PMU_DOMAIN_NOTCFG,           POW_CONTROL_VDD_IO_VOLT_TOUCH_SENSOR,          POW_CONTROL_VOLTAGE_DISABLE,          POW_CONTROL_VOLTAGE_ON,       &vdd_gyroscope_volt_lev[0],             NULL                                    },
+/* POW_CONTROL_VDD_CAM_PRIM_ANALOG */            { PMU_DOMAIN_LAUX1,           POW_CONTROL_VDD_CAM_SEC_ANALOG,           POW_CONTROL_VOLTAGE_DISABLE,          POW_CONTROL_VOLTAGE_ON,       &vdd_cam_prim_analog_volt_lev[0],       NULL                                    },
+/* POW_CONTROL_VDD_CAM_SEC_ANALOG */              { PMU_DOMAIN_LAUX1,           POW_CONTROL_VDD_CAM_PRIM_ANALOG,     POW_CONTROL_VOLTAGE_DISABLE,          POW_CONTROL_VOLTAGE_ON,       &vdd_cam_sec_analog_volt_lev[0],        NULL                                    },
+/* POW_CONTROL_VDD_PRIM_DISPLAY */               { PMU_DOMAIN_NOTCFG,           POW_CONTROL_VDD_TOUCH_SENSOR,           POW_CONTROL_VOLTAGE_DISABLE,            POW_CONTROL_VOLTAGE_ON,       &vdd_prim_display_volt_lev[0],          NULL                                    },
+/* POW_CONTROL_VDD_TOUCH_SENSOR */              { PMU_DOMAIN_NOTCFG,           POW_CONTROL_VDD_PRIM_DISPLAY,       POW_CONTROL_VOLTAGE_DISABLE,            POW_CONTROL_VOLTAGE_ON,       &vdd_touch_sensor_volt_lev[0],          NULL                                    },
+/* POW_CONTROL_VDD_PROXIMITY_SENSOR */            { PMU_DOMAIN_LAUX2,           POW_CONTROL_VDD_ACCELEROMETER,          POW_CONTROL_VOLTAGE_DISABLE,            POW_CONTROL_VOLTAGE_ON,       &vdd_proximity_sensor_volt_lev[0],      NULL                                    },
+/* POW_CONTROL_VDD_ACCELEROMETER */               { PMU_DOMAIN_LAUX2,           POW_CONTROL_VDD_MAGNETOMETER,           POW_CONTROL_VOLTAGE_DISABLE,            POW_CONTROL_VOLTAGE_ON,       &vdd_accelerometer_volt_lev[0],         NULL                                    },
+/* POW_CONTROL_VDD_MAGNETOMETER */               { PMU_DOMAIN_LAUX2,           POW_CONTROL_VDD_GYROSCOPE,              POW_CONTROL_VOLTAGE_DISABLE,            POW_CONTROL_VOLTAGE_ON,       &vdd_magnetometer_volt_lev[0],          NULL                                    },
+/* POW_CONTROL_VDD_GYROSCOPE */                   { PMU_DOMAIN_LAUX2,           POW_CONTROL_VDD_CAM_PRIM_IO,           POW_CONTROL_VOLTAGE_DISABLE,            POW_CONTROL_VOLTAGE_ON,       &vdd_gyroscope_volt_lev[0],             NULL                                    },
+/* POW_CONTROL_VDD_EMIC_IO */                     { PMU_DOMAIN_LMEM,            POW_CONTROL_VDD_EMIC_IO,                POW_CONTROL_VOLTAGE_DISABLE,            POW_CONTROL_VOLTAGE_ON,       &vdd_emic_io_volt_lev[0],               NULL                                    },
+/* POW_CONTROL_VDD_ABB_GNSS_TCXO_LDO */         { PMU_DOMAIN_GNSS_TCXO_LDO,   POW_CONTROL_VDD_ABB_GNSS_TCXO_LDO,      POW_CONTROL_VOLTAGE_DISABLE,            POW_CONTROL_VOLTAGE_ON,       &vdd_abb_gnss_tcxo_ldo_volt_lev[0],     NULL                                    },
+/* POW_CONTROL_VDDP_VEMMC_P */                    { PMU_DOMAIN_NOTCFG,          POW_CONTROL_VDDP_VEMMC_P,               POW_CONTROL_VOLTAGE_DISABLE,            POW_CONTROL_VOLTAGE_ON,       NULL,                                   NULL                                    },
+/* POW_CONTROL_VDD_CAM_PRIM_DIGITAL */            { PMU_DOMAIN_NOTCFG,          POW_CONTROL_VDD_CAM_PRIM_DIGITAL,       POW_CONTROL_VOLTAGE_DISABLE,            POW_CONTROL_VOLTAGE_ON,       NULL,                                   NULL                                    },
+/* POW_CONTROL_VDD_CAM_PRIM_IO */                 { PMU_DOMAIN_LAUX2,          POW_CONTROL_VDD_CAM_SEC_IO,            POW_CONTROL_VOLTAGE_DISABLE,            POW_CONTROL_VOLTAGE_ON,       &vdd_prim_sec_cam_io_volt_lev[0],        NULL                                    },
+/* POW_CONTROL_VDD_CAM_PRIM_AF */                 { PMU_DOMAIN_NOTCFG,          POW_CONTROL_VDD_CAM_PRIM_AF,            POW_CONTROL_VOLTAGE_DISABLE,            POW_CONTROL_VOLTAGE_ON,       NULL,                                   NULL                                    },
+/* POW_CONTROL_VDD_CAM_SEC_DIGITAL */             { PMU_DOMAIN_NOTCFG,          POW_CONTROL_VDD_CAM_SEC_DIGITAL,        POW_CONTROL_VOLTAGE_DISABLE,            POW_CONTROL_VOLTAGE_ON,       NULL,                                   NULL                                    },
+/* POW_CONTROL_VDD_CAM_SEC_IO */                  { PMU_DOMAIN_LAUX2,          POW_CONTROL_VDD_PROXIMITY_SENSOR,             POW_CONTROL_VOLTAGE_DISABLE,            POW_CONTROL_VOLTAGE_ON,       &vdd_prim_sec_cam_io_volt_lev[0],        NULL                                    },
+/* POW_CONTROL_VDD_CAM_SEC_AF */                  { PMU_DOMAIN_NOTCFG,          POW_CONTROL_VDD_CAM_SEC_AF,             POW_CONTROL_VOLTAGE_DISABLE,            POW_CONTROL_VOLTAGE_ON,       NULL,                                   NULL                                    },
+/* POW_CONTROL_VDD_PRIM_DISP_BACKLIGHT */         { PMU_DOMAIN_NOTCFG,          POW_CONTROL_VDD_PRIM_DISP_BACKLIGHT,    POW_CONTROL_VOLTAGE_DISABLE,            POW_CONTROL_VOLTAGE_ON,       &vdd_bl_volt_lev[0],                                   NULL                                    },
+/* POW_CONTROL_VDD_SD_CARD */                      { PMU_DOMAIN_EXT_LDO5,            POW_CONTROL_VDD_SD_CARD,             POW_CONTROL_VOLTAGE_DISABLE,            POW_CONTROL_VOLTAGE_ON,       &vdd_sd_card_volt_lev[0],                                   NULL                                      },
+/* POW_CONTROL_VDD_EMMC */                            { PMU_DOMAIN_NOTCFG,            POW_CONTROL_VDD_EMMC,                POW_CONTROL_VOLTAGE_DISABLE,            POW_CONTROL_VOLTAGE_ON,       &vdd_emmc_volt_lev[0],                                   NULL                                      },
+/* POW_CONTROL_VDD_VCPU */                            { PMU_DOMAIN_EXT_BUCK1,            POW_CONTROL_VDD_VCPU,                POW_CONTROL_VOLTAGE_DISABLE,            POW_CONTROL_VOLTAGE_DISABLE,       &vdd_ext_buck1_volt_lev[0],                                   NULL                                      },
+/* POW_CONTROL_VDD_GPU */                             { PMU_DOMAIN_EXT_BUCK2,            POW_CONTROL_VDD_GPU,                POW_CONTROL_VOLTAGE_DISABLE,            POW_CONTROL_VOLTAGE_DISABLE,       &vdd_ext_buck2_volt_lev[0],                                   NULL                                      },
+
+/* POW_CONTROL_VDD_DEPRECATED */                  { PMU_DOMAIN_NOTCFG,          POW_CONTROL_VDD_DEPRECATED,             POW_CONTROL_VOLTAGE_DISABLE,            POW_CONTROL_VOLTAGE_ON,       NULL,                                   NULL                                    },
+};
+
+// CODEGEN_END(POW_ALL_VIRTUAL_DOMAINS) end of automated generated source by tool, don't remove this line
+/*----------------------------------------------*/
+/* INTERNAL FUNCTIONS                           */
+/*----------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/*----------------------------------------------*/
+/* EXPORTED FUNCTIONS                           */
+/*----------------------------------------------*/
+
+/****************************************************************************************
+* Function:    pow_volt_get_virt_domain_info_ptr
+* Parameters:  -
+* Returns:     pointer to pow_volt_get_virt_domain_info_ptr array
+* Description: The function returns the pointer to pow_volt_get_virt_domain_info_ptr array
+****************************************************************************************/
+pow_volt_virt_domain_info_s * pow_volt_get_virt_domain_info_ptr(void)
+{
+  return &pow_volt_virt_domain_info[0];
+}
diff --git a/devices/pm/power_control/pow/src/board_sf_3gx_ext_pmic/pow_volt_pmu_cfg.c b/devices/pm/power_control/pow/src/board_sf_3gx_ext_pmic/pow_volt_pmu_cfg.c
new file mode 100644
index 0000000..ec7981b
--- /dev/null
+++ b/devices/pm/power_control/pow/src/board_sf_3gx_ext_pmic/pow_volt_pmu_cfg.c
@@ -0,0 +1,339 @@
+/* =============================================================================
+ * Copyright (C) 2013-2014 Intel Mobile Communications GmbH
+ *
+ *      Sec Class: Intel Confidential (IC)
+ *
+ * =============================================================================
+ *
+ * This document contains proprietary information belonging to IMC.
+ * Passing on and copying of this document, use and communication of
+ * its contents is not permitted without prior written authorisation.
+ *
+ * =============================================================================
+ * Revision Information :
+ *   $File name:  /mhw_drv_src/power_control/pow/src/pmu_int_agold620/pow_volt_pmu_cfg.c $
+ *
+ * =============================================================================
+ *
+ * This file contains the PMU configuration dependent implementation part of the
+ * POW voltage specific driver interface part
+ * HW set-up: AGOLD620 board
+ * ===========================================================================*/
+
+/*----------------------------------------------*/
+/* INCLUDES                                     */
+/*----------------------------------------------*/
+
+#include "pow_driverif.h"
+#include "pmu_driverif_cfg.h"
+#include "pmu_driverif.h"
+#include "pmu_internal_cfg.h"
+#include "pmu_internal.h"
+#include "pow_volt_internal.h"
+#include "pow_volt_spcu_cfg.h"
+
+//#include "pcl_driverif.h"
+
+/*----------------------------------------------*/
+/* TYPE DEFINITIONS                             */
+/*----------------------------------------------*/
+
+/*----------------------------------------------*/
+/* INTERNAL FUNCTION DECLARATIONS               */
+/*----------------------------------------------*/
+
+// CODEGEN_BEGIN(POW_DOMAIN_INFO_PATCH_FUNTIONS) begin of automated generated source by tool, don't remove this line
+// CODEGEN_END(POW_DOMAIN_INFO_PATCH_FUNTIONS) end of automated generated source by tool, don't remove this line
+/*----------------------------------------------*/
+/* VARIABLE DEFINITIONS                         */
+/*----------------------------------------------*/
+extern void pal_prh_queue_set_status_flag_normal(void);
+extern void pal_prh_i2c_callback_test(void *);
+extern void prh_patch_function(unsigned int volt, unsigned state, unsigned int pre);
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/**
+ * Contains status information and handler functions for integrated as
+ * well as external PMU domains.
+ * When the state parameter is set to POW_CONTROL_NUM_VOLTAGE_STATE it means that the
+ * PMU domain is unused and shall not be touched. But then it is not allowed to have it
+ * appear in pow_volt_virt_domain_info (file pow_volt_board_cfg.c).
+ * The array pow_volt_phys_domain_info is initialized in POW_volt_init() by the function pow_volt_init_phys_domain()
+ * according to the init values of the PMU.
+ */
+
+// CODEGEN_BEGIN(POW_PMU_NOF_DOMAINS) begin of automated generated source by tool, don't remove this line
+static pow_volt_phys_domain_info_s pow_volt_phys_domain_info[PMU_NOF_DOMAINS] =
+{
+  /* domain                             state                              voltage                       patch_fct                remark */
+  /* PMU_DOMAIN_LSIM1 */                { POW_CONTROL_VOLTAGE_DISABLE,     POW_CONTROL_VOLTAGE_ON,       NULL ,NULL},                  /**< LSIM1 power domain */
+  /* PMU_DOMAIN_LSIM2 */                { POW_CONTROL_VOLTAGE_DISABLE,     POW_CONTROL_VOLTAGE_ON,       NULL ,NULL},                  /**< LSIM2 power domain */
+  /* PMU_DOMAIN_LAUX1 */                { POW_CONTROL_VOLTAGE_DISABLE,     POW_CONTROL_VOLTAGE_ON,       NULL ,NULL},                  /**< LAUX1 power domain */
+  /* PMU_DOMAIN_LAUX2 */                { POW_CONTROL_VOLTAGE_DISABLE,     POW_CONTROL_VOLTAGE_ON,       NULL ,NULL},                  /**< LAUX2 power domain */
+  /* PMU_DOMAIN_LMMC1 */                { POW_CONTROL_VOLTAGE_DISABLE,     POW_CONTROL_VOLTAGE_ON,       NULL ,NULL},                  /**< LMMC1 power domain */
+  /* PMU_DOMAIN_LUSB */                 { POW_CONTROL_VOLTAGE_DISABLE,     POW_CONTROL_VOLTAGE_ON,       NULL ,NULL},                  /**< LUSB power domain */
+  /* PMU_DOMAIN_LPMU */                 { POW_CONTROL_VOLTAGE_DISABLE,     POW_CONTROL_VOLTAGE_ON,       NULL ,NULL},                  /**< LPMU power domain */
+  /* PMU_DOMAIN_LAIF */                 { POW_CONTROL_VOLTAGE_DISABLE,     POW_CONTROL_VOLTAGE_ON,       NULL ,NULL},                  /**< LAIF power domain */
+  /* PMU_DOMAIN_LCABB */                { POW_CONTROL_VOLTAGE_DISABLE,     POW_CONTROL_VOLTAGE_ON,       NULL,NULL },                  /**< LCABB power domain */
+  /* PMU_DOMAIN_LMEM */                 { POW_CONTROL_VOLTAGE_DISABLE,     POW_CONTROL_VOLTAGE_ON,       NULL,NULL },                  /**< LMEM power domain */
+  /* PMU_DOMAIN_LMIPI */                { POW_CONTROL_VOLTAGE_DISABLE,     POW_CONTROL_VOLTAGE_ON,       NULL,NULL },                  /**< LMIPI power domain */
+  /* PMU_DOMAIN_LPLL */                 { POW_CONTROL_VOLTAGE_DISABLE,     POW_CONTROL_VOLTAGE_ON,       NULL ,NULL},                  /**< LPLL power domain */
+  /* PMU_DOMAIN_SD1 */                  { POW_CONTROL_VOLTAGE_DISABLE,     POW_CONTROL_VOLTAGE_ON,       NULL,NULL },                  /**< SD1 power domain */
+  /* PMU_DOMAIN_SD2 */                  { POW_CONTROL_VOLTAGE_DISABLE,     POW_CONTROL_VOLTAGE_ON,       NULL,NULL },                  /**< SD2 power domain */
+  /* PMU_DOMAIN_ELDO_VMMC */            { POW_CONTROL_VOLTAGE_DISABLE,     POW_CONTROL_VOLTAGE_ON,       NULL,NULL },                  /**< EMMC power domain provided by external LDO - controlled via GPIO */
+  /* PMU_DOMAIN_GNSS_TCXO_LDO */        { POW_CONTROL_VOLTAGE_DISABLE,     POW_CONTROL_VOLTAGE_ON,       NULL,NULL },                  /**< GNSS_TCXO_LDO power domain provided by external LDO */
+  /* PMU_DOMAIN_EXT_BUCK1 */            { POW_CONTROL_VOLTAGE_DISABLE,     POW_CONTROL_VOLTAGE_ON,       NULL,NULL},                  /**< EXT_BUCK1 */
+  /* PMU_DOMAIN_EXT_BUCK2 */            { POW_CONTROL_VOLTAGE_DISABLE,     POW_CONTROL_VOLTAGE_ON,       NULL,NULL },                  /**< EXT_BUCK2 */
+  /* PMU_DOMAIN_EXT_LDO5 */            { POW_CONTROL_VOLTAGE_DISABLE,     POW_CONTROL_VOLTAGE_ON,       NULL,NULL },                  /**< EXT_LDO5 */
+  /* PMU_DOMAIN_DUMMY */                { POW_CONTROL_VOLTAGE_DISABLE,     POW_CONTROL_VOLTAGE_ON,       NULL ,NULL},                  /**< Dummy power domain */
+};
+// CODEGEN_END(POW_PMU_NOF_DOMAINS) end of automated generated source by tool, don't remove this line
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------------*/
+/**
+ * These tables are mainly interesting if you want to modify the
+ * HW controlled behavior of a specific domain. Here you can choose
+ * for example if the HW signal shall influence the enable-state or
+ * the standby-state. You could also configure to keep the domain
+ * always active by setting all three entries to enabled.
+ */
+// CODEGEN_BEGIN(STATE_MAPS_POW_PMU) begin of automated generated source by tool, don't remove this line
+/*PMU_DOMAIN_LSIM1*/
+static const ePMU_MODE_LIST_T pow_volt_map_pow_state_to_pmu_lsim1[] = {
+/*POW_CONTROL_VOLTAGE_DISABLE*/         PMU_MODE_OFF,
+/*POW_CONTROL_VOLTAGE_ENABLE*/          PMU_MODE_ON,
+/*POW_CONTROL_VOLTAGE_HW_CONTROLLED*/   PMU_MODE_IDLE_STDBY};
+
+/*PMU_DOMAIN_LSIM2*/
+static const ePMU_MODE_LIST_T pow_volt_map_pow_state_to_pmu_lsim2[] = {
+/*POW_CONTROL_VOLTAGE_DISABLE*/         PMU_MODE_OFF,
+/*POW_CONTROL_VOLTAGE_ENABLE*/          PMU_MODE_ON,
+/*POW_CONTROL_VOLTAGE_HW_CONTROLLED*/   PMU_MODE_IDLE_STDBY};
+
+/*PMU_DOMAIN_LAUX1*/
+static const ePMU_MODE_LIST_T pow_volt_map_pow_state_to_pmu_laux1[] = {
+/*POW_CONTROL_VOLTAGE_DISABLE*/         PMU_MODE_OFF,
+/*POW_CONTROL_VOLTAGE_ENABLE*/          PMU_MODE_ON,
+/*POW_CONTROL_VOLTAGE_HW_CONTROLLED*/   PMU_MODE_IDLE_STDBY};
+
+/*PMU_DOMAIN_LAUX2*/
+static const ePMU_MODE_LIST_T pow_volt_map_pow_state_to_pmu_laux2[] = {
+/*POW_CONTROL_VOLTAGE_DISABLE*/         PMU_MODE_OFF,
+/*POW_CONTROL_VOLTAGE_ENABLE*/          PMU_MODE_ON,
+/*POW_CONTROL_VOLTAGE_HW_CONTROLLED*/   PMU_MODE_IDLE_STDBY};
+
+/*PMU_DOMAIN_LMMC1*/
+static const ePMU_MODE_LIST_T pow_volt_map_pow_state_to_pmu_lmmc1[] = {
+/*POW_CONTROL_VOLTAGE_DISABLE*/         PMU_MODE_OFF,
+/*POW_CONTROL_VOLTAGE_ENABLE*/          PMU_MODE_ON,
+/*POW_CONTROL_VOLTAGE_HW_CONTROLLED*/   PMU_MODE_IDLE_STDBY};
+
+/*PMU_DOMAIN_LUSB*/
+static const ePMU_MODE_LIST_T pow_volt_map_pow_state_to_pmu_lusb[] = {
+/*POW_CONTROL_VOLTAGE_DISABLE*/         PMU_MODE_OFF,
+/*POW_CONTROL_VOLTAGE_ENABLE*/          PMU_MODE_ON,
+/*POW_CONTROL_VOLTAGE_HW_CONTROLLED*/   PMU_MODE_OFF_STDBY};
+
+/*PMU_DOMAIN_LPMU*/
+static const ePMU_MODE_LIST_T pow_volt_map_pow_state_to_pmu_lpmu[] = {
+/*POW_CONTROL_VOLTAGE_DISABLE*/         PMU_MODE_FIXED,
+/*POW_CONTROL_VOLTAGE_ENABLE*/          PMU_MODE_FIXED,
+/*POW_CONTROL_VOLTAGE_HW_CONTROLLED*/   PMU_MODE_FIXED};
+
+/*PMU_DOMAIN_LAIF*/
+static const ePMU_MODE_LIST_T pow_volt_map_pow_state_to_pmu_laif[] = {
+/*POW_CONTROL_VOLTAGE_DISABLE*/         PMU_MODE_OFF,
+/*POW_CONTROL_VOLTAGE_ENABLE*/          PMU_MODE_IDLE_STDBY,
+/*POW_CONTROL_VOLTAGE_HW_CONTROLLED*/   PMU_MODE_OFF_STDBY};
+
+/*PMU_DOMAIN_LCABB*/
+static const ePMU_MODE_LIST_T pow_volt_map_pow_state_to_pmu_lcabb[] = {
+/*POW_CONTROL_VOLTAGE_DISABLE*/         PMU_MODE_STANDBYLOWVOLTAGE,
+/*POW_CONTROL_VOLTAGE_ENABLE*/          PMU_MODE_ON,
+/*POW_CONTROL_VOLTAGE_HW_CONTROLLED*/   PMU_MODE_STANDBYHIGHVOLTAGE};
+
+/*PMU_DOMAIN_LMEM*/
+static const ePMU_MODE_LIST_T pow_volt_map_pow_state_to_pmu_lmem[] = {
+/*POW_CONTROL_VOLTAGE_DISABLE*/         PMU_MODE_FIXED,
+/*POW_CONTROL_VOLTAGE_ENABLE*/          PMU_MODE_ON,
+/*POW_CONTROL_VOLTAGE_HW_CONTROLLED*/   PMU_MODE_OFF_STDBY};
+
+/*PMU_DOMAIN_LMIPI*/
+static const ePMU_MODE_LIST_T pow_volt_map_pow_state_to_pmu_lmipi[] = {
+/*POW_CONTROL_VOLTAGE_DISABLE*/         PMU_MODE_OFF,
+/*POW_CONTROL_VOLTAGE_ENABLE*/          PMU_MODE_ON,
+/*POW_CONTROL_VOLTAGE_HW_CONTROLLED*/   PMU_MODE_OFF_STDBY};
+
+/*PMU_DOMAIN_LPLL*/
+static const ePMU_MODE_LIST_T pow_volt_map_pow_state_to_pmu_lpll[] = {
+/*POW_CONTROL_VOLTAGE_DISABLE*/         PMU_MODE_FIXED,
+/*POW_CONTROL_VOLTAGE_ENABLE*/          PMU_MODE_ON,
+/*POW_CONTROL_VOLTAGE_HW_CONTROLLED*/   PMU_MODE_OFF_STDBY};
+
+/*PMU_DOMAIN_SD1*/
+static const ePMU_MODE_LIST_T pow_volt_map_pow_state_to_pmu_sd1[] = {
+/*POW_CONTROL_VOLTAGE_DISABLE*/         PMU_MODE_FIXED,
+/*POW_CONTROL_VOLTAGE_ENABLE*/          PMU_MODE_FIXED,
+/*POW_CONTROL_VOLTAGE_HW_CONTROLLED*/   PMU_MODE_FIXED};
+
+/*PMU_DOMAIN_SD2*/
+static const ePMU_MODE_LIST_T pow_volt_map_pow_state_to_pmu_sd2[] = {
+/*POW_CONTROL_VOLTAGE_DISABLE*/         PMU_MODE_FIXED,
+/*POW_CONTROL_VOLTAGE_ENABLE*/          PMU_MODE_FIXED,
+/*POW_CONTROL_VOLTAGE_HW_CONTROLLED*/   PMU_MODE_FIXED};
+
+/*PMU_DOMAIN_ELDO_VMMC*/
+static const ePMU_MODE_LIST_T pow_volt_map_pow_state_to_pmu_eldo_vmmc[] = {
+/*POW_CONTROL_VOLTAGE_DISABLE*/         PMU_MODE_OFF,
+/*POW_CONTROL_VOLTAGE_ENABLE*/          PMU_MODE_ON,
+/*POW_CONTROL_VOLTAGE_HW_CONTROLLED*/   PMU_MODE_ON};
+
+/*PMU_DOMAIN_GNSS_TCXO_LDO*/
+static const ePMU_MODE_LIST_T pow_volt_map_pow_state_to_pmu_gnss_tcxo_ldo[] = {
+/*POW_CONTROL_VOLTAGE_DISABLE*/         PMU_MODE_OFF,
+/*POW_CONTROL_VOLTAGE_ENABLE*/          PMU_MODE_ON,
+/*POW_CONTROL_VOLTAGE_HW_CONTROLLED*/   PMU_MODE_ON};
+
+/*PMU_DOMAIN_EXT_BUCK1*/
+static const ePMU_MODE_LIST_T pow_volt_map_pow_state_to_pmu_ext_buck1[] = {
+/*POW_CONTROL_VOLTAGE_DISABLE*/         PMU_MODE_FIXED,
+/*POW_CONTROL_VOLTAGE_ENABLE*/          PMU_MODE_FIXED,
+/*POW_CONTROL_VOLTAGE_HW_CONTROLLED*/   PMU_MODE_FIXED};
+
+/*PMU_DOMAIN_EXT_BUCK2*/
+static const ePMU_MODE_LIST_T pow_volt_map_pow_state_to_pmu_ext_buck2[] = {
+/*POW_CONTROL_VOLTAGE_DISABLE*/         PMU_MODE_FIXED,
+/*POW_CONTROL_VOLTAGE_ENABLE*/          PMU_MODE_FIXED,
+/*POW_CONTROL_VOLTAGE_HW_CONTROLLED*/   PMU_MODE_FIXED};
+
+/*PMU_DOMAIN_EXT_LDO5*/
+static const ePMU_MODE_LIST_T pow_volt_map_pow_state_to_pmu_ext_ldo5[] = {
+/*POW_CONTROL_VOLTAGE_DISABLE*/         PMU_MODE_OFF,
+/*POW_CONTROL_VOLTAGE_ENABLE*/          PMU_MODE_ON,
+/*POW_CONTROL_VOLTAGE_HW_CONTROLLED*/   PMU_MODE_ON};
+
+/*PMU_DOMAIN_DUMMY*/
+static const ePMU_MODE_LIST_T pow_volt_map_pow_state_to_pmu_dummy[] = {
+/*POW_CONTROL_VOLTAGE_DISABLE*/         PMU_MODE_FIXED,
+/*POW_CONTROL_VOLTAGE_ENABLE*/          PMU_MODE_FIXED,
+/*POW_CONTROL_VOLTAGE_HW_CONTROLLED*/   PMU_MODE_FIXED};
+
+/**
+ * Collects all state_maps and makes them accessible via the
+ * PMU_DOMAIN_ID.
+ * @TODO Could be merged with pow_volt_phys_domain_info!!!
+ */
+const ePMU_MODE_LIST_T* pow_volt_map_pow_state_to_pmu[PMU_NOF_DOMAINS] = {
+/*PMU_DOMAIN_LSIM1*/                    &pow_volt_map_pow_state_to_pmu_lsim1[0],
+/*PMU_DOMAIN_LSIM2*/                    &pow_volt_map_pow_state_to_pmu_lsim2[0],
+/*PMU_DOMAIN_LAUX1*/                    &pow_volt_map_pow_state_to_pmu_laux1[0],
+/*PMU_DOMAIN_LAUX2*/                    &pow_volt_map_pow_state_to_pmu_laux2[0],
+/*PMU_DOMAIN_LMMC1*/                    &pow_volt_map_pow_state_to_pmu_lmmc1[0],
+/*PMU_DOMAIN_LUSB*/                     &pow_volt_map_pow_state_to_pmu_lusb[0],
+/*PMU_DOMAIN_LPMU*/                     &pow_volt_map_pow_state_to_pmu_lpmu[0],
+/*PMU_DOMAIN_LAIF*/                     &pow_volt_map_pow_state_to_pmu_laif[0],
+/*PMU_DOMAIN_LCABB*/                    &pow_volt_map_pow_state_to_pmu_lcabb[0],
+/*PMU_DOMAIN_LMEM*/                     &pow_volt_map_pow_state_to_pmu_lmem[0],
+/*PMU_DOMAIN_LMIPI*/                    &pow_volt_map_pow_state_to_pmu_lmipi[0],
+/*PMU_DOMAIN_LPLL*/                     &pow_volt_map_pow_state_to_pmu_lpll[0],
+/*PMU_DOMAIN_SD1*/                      &pow_volt_map_pow_state_to_pmu_sd1[0],
+/*PMU_DOMAIN_SD2*/                      &pow_volt_map_pow_state_to_pmu_sd2[0],
+/*PMU_DOMAIN_ELDO_VMMC*/                &pow_volt_map_pow_state_to_pmu_eldo_vmmc[0],
+/*PMU_DOMAIN_GNSS_TCXO_LDO*/            &pow_volt_map_pow_state_to_pmu_gnss_tcxo_ldo[0],
+/*PMU_DOMAIN_EXT_BUCK1*/                &pow_volt_map_pow_state_to_pmu_ext_buck1[0],
+/*PMU_DOMAIN_EXT_BUCK2*/                &pow_volt_map_pow_state_to_pmu_ext_buck2[0],
+/*PMU_DOMAIN_EXT_LDO5*/                 &pow_volt_map_pow_state_to_pmu_ext_ldo5[0],
+/*PMU_DOMAIN_DUMMY*/                    &pow_volt_map_pow_state_to_pmu_dummy[0],
+};
+// CODEGEN_END(STATE_MAPS_POW_PMU) end of automated generated source by tool, don't remove this line
+
+/*---------------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------------*/
+/**
+ * Maps the POW voltages onto integrated PMU voltages. Length MUST BE (POW_CONTROL_NUM_VOLTAGE+1)
+ * The one is for an end indicator used when searching from PMU voltage back to POW voltage.
+ * Mark all unused voltages with PMU_VOLTAGE_UNKNOWN !!!
+ * ALIGN WITH POW_CONTROL_VOLTAGE_T !!!
+ */
+// CODEGEN_BEGIN(POW_VOLT_MAP_POW_LEV_TO_PMU_LIST) begin of automated generated source by tool, don't remove this line
+const ePMU_VOLTAGE_LIST_T pow_volt_map_pow_lev_to_pmu_generic[POW_CONTROL_NUM_VOLTAGE+1] = {
+/* fix mapping between */
+/* POW_CONTROL_VOLTAGE_T                     ePMU_VOLTAGE_LIST_T                          remark */
+/* POW_CONTROL_VOLTAGE_ON */                 PMU_VOLTAGE_FIXED,                           /**< fixed */
+/* POW_CONTROL_VOLTAGE_0V87 */				 PMU_VOLTAGE_0V87,	
+/* POW_CONTROL_VOLTAGE_1V00 */               PMU_VOLTAGE_1V00,                            /**< 1.00 Volts */
+/* POW_CONTROL_VOLTAGE_1V02 */               PMU_VOLTAGE_1V02,                            /**< 1.02 Volts */
+/* POW_CONTROL_VOLTAGE_1V10 */               PMU_VOLTAGE_1V10,                            /**< 1.10 Volts */
+/* POW_CONTROL_VOLTAGE_1V12 */               PMU_VOLTAGE_1V12,                            /**< 1.12 Volts */
+/* POW_CONTROL_VOLTAGE_1V14 */				 PMU_VOLTAGE_1V14,	
+/* POW_CONTROL_VOLTAGE_1V16 */               PMU_VOLTAGE_1V16,                            /**< 1.16 Volts */
+/* POW_CONTROL_VOLTAGE_1V17 */               PMU_VOLTAGE_1V17,                            /**< 1.17 Volts */
+/* POW_CONTROL_VOLTAGE_1V20 */               PMU_VOLTAGE_1V20,                            /**< 1.20 Volts */
+/* POW_CONTROL_VOLTAGE_1V22 */               PMU_VOLTAGE_1V22,                            /**< 1.22 Volts */
+/* POW_CONTROL_VOLTAGE_1V226 */              PMU_VOLTAGE_1V226,                           /**< 1.226 Volts */
+/* POW_CONTROL_VOLTAGE_1V25 */               PMU_VOLTAGE_1V25,                            /**< 1.25 Volts */
+/* POW_CONTROL_VOLTAGE_1V30 */               PMU_VOLTAGE_1V30,                            /**< 1.30 Volts */
+/* POW_CONTROL_VOLTAGE_1V32 */				 PMU_VOLTAGE_1V32,	
+/* POW_CONTROL_VOLTAGE_1V8 */                PMU_VOLTAGE_1V80,                            /**< 1.80 Volts */
+/* POW_CONTROL_VOLTAGE_2V05 */               PMU_VOLTAGE_2V05,                            /**< 2.05 Volts */
+/* POW_CONTROL_VOLTAGE_2V3 */                PMU_VOLTAGE_2V30,                            /**< 2.30 Volts */
+/* POW_CONTROL_VOLTAGE_2V5 */                PMU_VOLTAGE_2V50,                            /**< 2.50 Volts */
+/* POW_CONTROL_VOLTAGE_2V8 */                PMU_VOLTAGE_2V80,                            /**< 2.80 Volts */
+/* POW_CONTROL_VOLTAGE_2V85 */               PMU_VOLTAGE_2V85,                            /**< 2.85 Volts */
+/* POW_CONTROL_VOLTAGE_2V9 */                PMU_VOLTAGE_2V90,                            /**< 2.90 Volts */
+/* POW_CONTROL_VOLTAGE_2V91 */               PMU_VOLTAGE_2V91,                            /**< 2.91 Volts */
+/* POW_CONTROL_VOLTAGE_3V00 */               PMU_VOLTAGE_3V00,                            /**< 3.00 Volts */
+/* POW_CONTROL_VOLTAGE_3V15 */                 PMU_VOLTAGE_3V15,                              /**< 3.15 Volts */
+/* POW_CONTROL_VOLTAGE_3V30 */                 PMU_VOLTAGE_3V30,                              /**< 3.30 Volts */
+/* POW_CONTROL_VOLTAGE_5V00 */                 PMU_VOLTAGE_5V00,                        /**< 5.00 Volts */
+/* POW_CONTROL_VOLTAGE_DEPRECATED_1 */       PMU_VOLTAGE_UNKNOWN,                         /**<  */
+/* End Indicator */                          PMU_VOLTAGE_UNKNOWN,                         /**< end indicator */
+};
+
+const ePMU_VOLTAGE_LIST_T* pow_volt_map_pow_lev_to_pmu[PMU_NOF_DOMAINS] = {
+/* pmu domain name                           mapping table                                remark */
+/* PMU_DOMAIN_LSIM1 */                       &pow_volt_map_pow_lev_to_pmu_generic[0],
+/* PMU_DOMAIN_LSIM2 */                       &pow_volt_map_pow_lev_to_pmu_generic[0],
+/* PMU_DOMAIN_LAUX1 */                       &pow_volt_map_pow_lev_to_pmu_generic[0],
+/* PMU_DOMAIN_LAUX2 */                       &pow_volt_map_pow_lev_to_pmu_generic[0],
+/* PMU_DOMAIN_LMMC1 */                       &pow_volt_map_pow_lev_to_pmu_generic[0],
+/* PMU_DOMAIN_LUSB */                        &pow_volt_map_pow_lev_to_pmu_generic[0],
+/* PMU_DOMAIN_LPMU */                        &pow_volt_map_pow_lev_to_pmu_generic[0],
+/* PMU_DOMAIN_LAIF */                        &pow_volt_map_pow_lev_to_pmu_generic[0],
+/* PMU_DOMAIN_LCABB */                       &pow_volt_map_pow_lev_to_pmu_generic[0],
+/* PMU_DOMAIN_LMEM */                        &pow_volt_map_pow_lev_to_pmu_generic[0],
+/* PMU_DOMAIN_LMIPI */                       &pow_volt_map_pow_lev_to_pmu_generic[0],
+/* PMU_DOMAIN_LPLL */                        &pow_volt_map_pow_lev_to_pmu_generic[0],
+/* PMU_DOMAIN_SD1 */                         &pow_volt_map_pow_lev_to_pmu_generic[0],
+/* PMU_DOMAIN_SD2 */                         &pow_volt_map_pow_lev_to_pmu_generic[0],
+/* PMU_DOMAIN_ELDO_VMMC */                   &pow_volt_map_pow_lev_to_pmu_generic[0],
+/* PMU_DOMAIN_GNSS_TCXO_LDO */               &pow_volt_map_pow_lev_to_pmu_generic[0],
+/* PMU_DOMAIN_EXT_BUCK1 */                   &pow_volt_map_pow_lev_to_pmu_generic[0],
+/* PMU_DOMAIN_EXT_BUCK2 */                   &pow_volt_map_pow_lev_to_pmu_generic[0],
+/* PMU_DOMAIN_EXT_LDO5 */                    &pow_volt_map_pow_lev_to_pmu_generic[0],
+/* PMU_DOMAIN_DUMMY */                       &pow_volt_map_pow_lev_to_pmu_generic[0],
+};
+// CODEGEN_END(POW_VOLT_MAP_POW_LEV_TO_PMU_LIST) end of automated generated source by tool, don't remove this line
+
+/*---------------------------------------------------------------------------------------------------------------*/
+
+/*----------------------------------------------*/
+/* INTERNAL FUNCTIONS                           */
+/*----------------------------------------------*/
+
+
+/*----------------------------------------------*/
+/* EXPORTED FUNCTIONS                           */
+/*----------------------------------------------*/
+
+/****************************************************************************************
+* Function:    pow_volt_get_phys_domain_info_ptr
+* Parameters:  -
+* Returns:     pointer to pow_volt_phys_domain_info array
+* Description: The function returns the pointer to pow_volt_phys_domain_info array
+****************************************************************************************/
+pow_volt_phys_domain_info_s * pow_volt_get_phys_domain_info_ptr(void)
+{
+  return &pow_volt_phys_domain_info[0];
+}
diff --git a/devices/pm/power_control/pow/src/board_sf_3gx_ext_pmic/pow_volt_spcu_cfg.h b/devices/pm/power_control/pow/src/board_sf_3gx_ext_pmic/pow_volt_spcu_cfg.h
new file mode 120000
index 0000000..157f601
--- /dev/null
+++ b/devices/pm/power_control/pow/src/board_sf_3gx_ext_pmic/pow_volt_spcu_cfg.h
@@ -0,0 +1 @@
+../board_sf_3gr_ext_pmic/pow_volt_spcu_cfg.h
\ No newline at end of file
-- 
1.9.1

